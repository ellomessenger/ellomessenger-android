/*
 * This is the source code of Telegram for Android v. 5.x.x.
 * It is licensed under GNU GPL v. 2 or later.
 * You should have received a copy of the license in this archive (see LICENSE).
 *
 * Copyright Nikolai Kudashov, 2013-2018.
 * Copyright Nikita Denin, Ello 2022-2024.
 * Copyright Shamil Afandiyev, Ello 2024.
 */
package org.telegram.ui

import android.Manifest
import android.animation.Animator
import android.animation.AnimatorListenerAdapter
import android.animation.AnimatorSet
import android.animation.ObjectAnimator
import android.animation.ValueAnimator
import android.animation.ValueAnimator.AnimatorUpdateListener
import android.annotation.SuppressLint
import android.app.Activity
import android.app.DatePickerDialog
import android.app.Dialog
import android.content.ClipData
import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.content.pm.PackageManager
import android.content.res.Configuration
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Outline
import android.graphics.Paint
import android.graphics.Paint.FontMetricsInt
import android.graphics.PorterDuff
import android.graphics.PorterDuffColorFilter
import android.graphics.Rect
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.SystemClock
import android.provider.MediaStore
import android.provider.Settings
import android.text.Html
import android.text.Layout
import android.text.Spannable
import android.text.SpannableString
import android.text.SpannableStringBuilder
import android.text.Spanned
import android.text.TextPaint
import android.text.TextUtils
import android.text.style.CharacterStyle
import android.text.style.ClickableSpan
import android.text.style.ForegroundColorSpan
import android.text.style.ImageSpan
import android.text.style.URLSpan
import android.util.Property
import android.util.SparseArray
import android.util.SparseBooleanArray
import android.util.SparseIntArray
import android.util.TypedValue
import android.view.Gravity
import android.view.HapticFeedbackConstants
import android.view.KeyEvent
import android.view.LayoutInflater
import android.view.Menu
import android.view.MotionEvent
import android.view.TextureView
import android.view.View
import android.view.View.MeasureSpec
import android.view.View.OnClickListener
import android.view.View.OnTouchListener
import android.view.ViewConfiguration
import android.view.ViewGroup
import android.view.ViewGroup.MarginLayoutParams
import android.view.ViewOutlineProvider
import android.view.ViewTreeObserver
import android.view.WindowManager
import android.view.accessibility.AccessibilityEvent
import android.view.accessibility.AccessibilityNodeInfo
import android.view.accessibility.AccessibilityNodeInfo.CollectionInfo
import android.view.animation.DecelerateInterpolator
import android.widget.EditText
import android.widget.FrameLayout
import android.widget.HorizontalScrollView
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.PopupWindow
import android.widget.Space
import android.widget.TextView
import android.widget.Toast
import androidx.annotation.MainThread
import androidx.appcompat.widget.AppCompatTextView
import androidx.collection.LongSparseArray
import androidx.core.content.ContextCompat
import androidx.core.content.FileProvider
import androidx.core.content.res.ResourcesCompat
import androidx.core.graphics.ColorUtils
import androidx.core.view.ViewCompat
import androidx.core.view.children
import androidx.exifinterface.media.ExifInterface
import androidx.recyclerview.widget.ChatListItemAnimator
import androidx.recyclerview.widget.GridLayoutManager.SpanSizeLookup
import androidx.recyclerview.widget.GridLayoutManagerFixed
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.LinearSmoothScrollerCustom
import androidx.recyclerview.widget.RecyclerView
import androidx.recyclerview.widget.RecyclerView.Recycler
import androidx.viewpager.widget.PagerAdapter
import androidx.viewpager.widget.ViewPager
import androidx.viewpager.widget.ViewPager.OnPageChangeListener
import com.google.android.exoplayer2.ui.AspectRatioFrameLayout
import com.google.gson.Gson
import com.google.zxing.common.detector.MathUtils
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.telegram.messenger.AccountInstance
import org.telegram.messenger.AndroidUtilities
import org.telegram.messenger.ApplicationLoader
import org.telegram.messenger.BuildConfig
import org.telegram.messenger.BuildVars
import org.telegram.messenger.ChatObject
import org.telegram.messenger.ChatObject.canManageCalls
import org.telegram.messenger.ChatObject.canPinMessages
import org.telegram.messenger.ChatObject.canPost
import org.telegram.messenger.ChatObject.canSendAsPeers
import org.telegram.messenger.ChatObject.canSendEmbed
import org.telegram.messenger.ChatObject.canSendMedia
import org.telegram.messenger.ChatObject.canSendMessages
import org.telegram.messenger.ChatObject.canSendStickers
import org.telegram.messenger.ChatObject.canUserDoAdminAction
import org.telegram.messenger.ChatObject.canWriteToChat
import org.telegram.messenger.ChatObject.getSendAsPeerId
import org.telegram.messenger.ChatObject.hasAdminRights
import org.telegram.messenger.ChatObject.isActionBannedByDefault
import org.telegram.messenger.ChatObject.isChannel
import org.telegram.messenger.ChatObject.isChannelAndNotMegaGroup
import org.telegram.messenger.ChatObject.isMegagroup
import org.telegram.messenger.ChatObject.isNotInChat
import org.telegram.messenger.ChatObject.isOnlineCourse
import org.telegram.messenger.ChatObject.isPaidChannel
import org.telegram.messenger.ChatObject.reactionIsAvailable
import org.telegram.messenger.ChatThemeController
import org.telegram.messenger.ContactsController.Companion.formatName
import org.telegram.messenger.DialogObject
import org.telegram.messenger.Emoji
import org.telegram.messenger.EmojiData
import org.telegram.messenger.FileLoader
import org.telegram.messenger.FileLog
import org.telegram.messenger.ForwardingMessagesParams
import org.telegram.messenger.ImageLocation
import org.telegram.messenger.ImageReceiver
import org.telegram.messenger.ImageReceiver.BitmapHolder
import org.telegram.messenger.LanguageDetector
import org.telegram.messenger.LocaleController
import org.telegram.messenger.MediaController
import org.telegram.messenger.MediaController.PhotoEntry
import org.telegram.messenger.MediaDataController
import org.telegram.messenger.MediaDataController.KeywordResult
import org.telegram.messenger.MessagesController
import org.telegram.messenger.NotificationCenter
import org.telegram.messenger.NotificationCenter.NotificationCenterDelegate
import org.telegram.messenger.NotificationCenter.PostponeNotificationCallback
import org.telegram.messenger.NotificationsController
import org.telegram.messenger.R
import org.telegram.messenger.SecretChatHelper
import org.telegram.messenger.SendMessagesHelper
import org.telegram.messenger.SendMessagesHelper.Companion.checkUpdateStickersOrder
import org.telegram.messenger.SendMessagesHelper.Companion.createVideoThumbnail
import org.telegram.messenger.SendMessagesHelper.Companion.prepareSendingAudioDocuments
import org.telegram.messenger.SendMessagesHelper.Companion.prepareSendingBotContextResult
import org.telegram.messenger.SendMessagesHelper.Companion.prepareSendingDocument
import org.telegram.messenger.SendMessagesHelper.Companion.prepareSendingDocuments
import org.telegram.messenger.SendMessagesHelper.Companion.prepareSendingMedia
import org.telegram.messenger.SendMessagesHelper.Companion.prepareSendingPhoto
import org.telegram.messenger.SendMessagesHelper.Companion.prepareSendingVideo
import org.telegram.messenger.SendMessagesHelper.SendingMediaInfo
import org.telegram.messenger.SharedConfig
import org.telegram.messenger.UserConfig
import org.telegram.messenger.UserObject.getFirstName
import org.telegram.messenger.UserObject.getUserName
import org.telegram.messenger.UserObject.isDeleted
import org.telegram.messenger.UserObject.isReplyUser
import org.telegram.messenger.UserObject.isUserSelf
import org.telegram.messenger.Utilities
import org.telegram.messenger.VideoEditedInfo
import org.telegram.messenger.browser.Browser
import org.telegram.messenger.databinding.AiBotChatTopviewFreeBalanceBinding
import org.telegram.messenger.messageobject.GroupedMessagePosition
import org.telegram.messenger.messageobject.GroupedMessages
import org.telegram.messenger.messageobject.MessageObject
import org.telegram.messenger.messageobject.SendAnimationData
import org.telegram.messenger.support.LongSparseIntArray
import org.telegram.messenger.utils.LinkClickListener
import org.telegram.messenger.utils.createCombinedChatPropertiesDrawable
import org.telegram.messenger.utils.gone
import org.telegram.messenger.utils.hasServiceMessagesOnly
import org.telegram.messenger.utils.invisible
import org.telegram.messenger.utils.vibrate
import org.telegram.messenger.utils.visible
import org.telegram.messenger.voip.VoIPService
import org.telegram.messenger.voip.VoIPService.Companion.sharedInstance
import org.telegram.tgnet.ConnectionsManager
import org.telegram.tgnet.ElloRpc
import org.telegram.tgnet.ElloRpc.RichVerifyResponse
import org.telegram.tgnet.ElloRpc.readData
import org.telegram.tgnet.ElloRpc.subscribeRequest
import org.telegram.tgnet.ElloRpc.userCheckHasDialog
import org.telegram.tgnet.TLRPC
import org.telegram.tgnet.TLRPC.BotInfo
import org.telegram.tgnet.TLRPC.BotInlineResult
import org.telegram.tgnet.TLRPC.Chat
import org.telegram.tgnet.TLRPC.ChatFull
import org.telegram.tgnet.TLRPC.EncryptedChat
import org.telegram.tgnet.TLRPC.FileLocation
import org.telegram.tgnet.TLRPC.InputStickerSet
import org.telegram.tgnet.TLRPC.KeyboardButton
import org.telegram.tgnet.TLRPC.MessageAction
import org.telegram.tgnet.TLRPC.MessageExtendedMedia
import org.telegram.tgnet.TLRPC.MessageMedia
import org.telegram.tgnet.TLRPC.MessageReplies
import org.telegram.tgnet.TLRPC.PhotoSize
import org.telegram.tgnet.TLRPC.PollResults
import org.telegram.tgnet.TLRPC.TL_attachMenuBotsBot
import org.telegram.tgnet.TLRPC.TL_biz_dataRaw
import org.telegram.tgnet.TLRPC.TL_botInlineMessageMediaAuto
import org.telegram.tgnet.TLRPC.TL_botInlineMessageMediaInvoice
import org.telegram.tgnet.TLRPC.TL_channelForbidden
import org.telegram.tgnet.TLRPC.TL_channelFull
import org.telegram.tgnet.TLRPC.TL_channels_exportMessageLink
import org.telegram.tgnet.TLRPC.TL_channels_sendAsPeers
import org.telegram.tgnet.TLRPC.TL_channels_viewSponsoredMessage
import org.telegram.tgnet.TLRPC.TL_chatFull
import org.telegram.tgnet.TLRPC.TL_chatInviteExported
import org.telegram.tgnet.TLRPC.TL_chatReactionsNone
import org.telegram.tgnet.TLRPC.TL_contacts_resolveUsername
import org.telegram.tgnet.TLRPC.TL_contacts_resolvedPeer
import org.telegram.tgnet.TLRPC.TL_decryptedMessageActionSetMessageTTL
import org.telegram.tgnet.TLRPC.TL_document
import org.telegram.tgnet.TLRPC.TL_documentEmpty
import org.telegram.tgnet.TLRPC.TL_emojiStatus
import org.telegram.tgnet.TLRPC.TL_emojiStatusUntil
import org.telegram.tgnet.TLRPC.TL_encryptedChat
import org.telegram.tgnet.TLRPC.TL_encryptedChatDiscarded
import org.telegram.tgnet.TLRPC.TL_encryptedChatRequested
import org.telegram.tgnet.TLRPC.TL_encryptedChatWaiting
import org.telegram.tgnet.TLRPC.TL_fileLocationUnavailable
import org.telegram.tgnet.TLRPC.TL_game
import org.telegram.tgnet.TLRPC.TL_groupCall
import org.telegram.tgnet.TLRPC.TL_inlineBotSwitchPM
import org.telegram.tgnet.TLRPC.TL_inputMediaPoll
import org.telegram.tgnet.TLRPC.TL_inputStickerSetID
import org.telegram.tgnet.TLRPC.TL_inputStickerSetShortName
import org.telegram.tgnet.TLRPC.TL_keyboardButtonBuy
import org.telegram.tgnet.TLRPC.TL_keyboardButtonCallback
import org.telegram.tgnet.TLRPC.TL_keyboardButtonGame
import org.telegram.tgnet.TLRPC.TL_keyboardButtonSwitchInline
import org.telegram.tgnet.TLRPC.TL_keyboardButtonUrl
import org.telegram.tgnet.TLRPC.TL_keyboardButtonUrlAuth
import org.telegram.tgnet.TLRPC.TL_keyboardButtonUserProfile
import org.telegram.tgnet.TLRPC.TL_messageActionChannelMigrateFrom
import org.telegram.tgnet.TLRPC.TL_messageActionChatAddUser
import org.telegram.tgnet.TLRPC.TL_messageActionChatCreate
import org.telegram.tgnet.TLRPC.TL_messageActionChatDeleteUser
import org.telegram.tgnet.TLRPC.TL_messageActionChatEditPhoto
import org.telegram.tgnet.TLRPC.TL_messageActionChatJoinedByRequest
import org.telegram.tgnet.TLRPC.TL_messageActionChatMigrateTo
import org.telegram.tgnet.TLRPC.TL_messageActionEmpty
import org.telegram.tgnet.TLRPC.TL_messageActionGameScore
import org.telegram.tgnet.TLRPC.TL_messageActionGeoProximityReached
import org.telegram.tgnet.TLRPC.TL_messageActionGiftPremium
import org.telegram.tgnet.TLRPC.TL_messageActionGroupCall
import org.telegram.tgnet.TLRPC.TL_messageActionGroupCallScheduled
import org.telegram.tgnet.TLRPC.TL_messageActionInviteToGroupCall
import org.telegram.tgnet.TLRPC.TL_messageActionPaymentSent
import org.telegram.tgnet.TLRPC.TL_messageActionPhoneCall
import org.telegram.tgnet.TLRPC.TL_messageActionPinMessage
import org.telegram.tgnet.TLRPC.TL_messageActionSecureValuesSent
import org.telegram.tgnet.TLRPC.TL_messageActionSetChatTheme
import org.telegram.tgnet.TLRPC.TL_messageActionSetMessagesTTL
import org.telegram.tgnet.TLRPC.TL_messageEmpty
import org.telegram.tgnet.TLRPC.TL_messageEncryptedAction
import org.telegram.tgnet.TLRPC.TL_messageMediaContact
import org.telegram.tgnet.TLRPC.TL_messageMediaGame
import org.telegram.tgnet.TLRPC.TL_messageMediaPhoto
import org.telegram.tgnet.TLRPC.TL_messageMediaPoll
import org.telegram.tgnet.TLRPC.TL_messageMediaWebPage
import org.telegram.tgnet.TLRPC.TL_messageReplies
import org.telegram.tgnet.TLRPC.TL_messages_acceptUrlAuth
import org.telegram.tgnet.TLRPC.TL_messages_discussionMessage
import org.telegram.tgnet.TLRPC.TL_messages_getAttachMenuBot
import org.telegram.tgnet.TLRPC.TL_messages_getDiscussionMessage
import org.telegram.tgnet.TLRPC.TL_messages_getHistory
import org.telegram.tgnet.TLRPC.TL_messages_getMessageEditData
import org.telegram.tgnet.TLRPC.TL_messages_getReplies
import org.telegram.tgnet.TLRPC.TL_messages_getUnreadMentions
import org.telegram.tgnet.TLRPC.TL_messages_getWebPagePreview
import org.telegram.tgnet.TLRPC.TL_messages_rateTranscribedAudio
import org.telegram.tgnet.TLRPC.TL_messages_requestUrlAuth
import org.telegram.tgnet.TLRPC.TL_messages_sendScheduledMessages
import org.telegram.tgnet.TLRPC.TL_messages_toggleBotInAttachMenu
import org.telegram.tgnet.TLRPC.TL_payments_bankCardData
import org.telegram.tgnet.TLRPC.TL_payments_getBankCardData
import org.telegram.tgnet.TLRPC.TL_payments_getPaymentReceipt
import org.telegram.tgnet.TLRPC.TL_payments_paymentReceipt
import org.telegram.tgnet.TLRPC.TL_peerChannel
import org.telegram.tgnet.TLRPC.TL_peerChat
import org.telegram.tgnet.TLRPC.TL_peerUser
import org.telegram.tgnet.TLRPC.TL_phoneCallDiscardReasonBusy
import org.telegram.tgnet.TLRPC.TL_phoneCallDiscardReasonMissed
import org.telegram.tgnet.TLRPC.TL_photoEmpty
import org.telegram.tgnet.TLRPC.TL_photoSizeEmpty
import org.telegram.tgnet.TLRPC.TL_poll
import org.telegram.tgnet.TLRPC.TL_pollAnswer
import org.telegram.tgnet.TLRPC.TL_premiumGiftOption
import org.telegram.tgnet.TLRPC.TL_replyInlineMarkup
import org.telegram.tgnet.TLRPC.TL_replyKeyboardForceReply
import org.telegram.tgnet.TLRPC.TL_updates_channelDifferenceTooLong
import org.telegram.tgnet.TLRPC.TL_urlAuthResultAccepted
import org.telegram.tgnet.TLRPC.TL_urlAuthResultDefault
import org.telegram.tgnet.TLRPC.TL_urlAuthResultRequest
import org.telegram.tgnet.TLRPC.TL_user
import org.telegram.tgnet.TLRPC.TL_webPage
import org.telegram.tgnet.TLRPC.TL_webPageEmpty
import org.telegram.tgnet.TLRPC.TL_webPagePending
import org.telegram.tgnet.TLRPC.TL_webPageUrlPending
import org.telegram.tgnet.TLRPC.Updates
import org.telegram.tgnet.TLRPC.VideoSize
import org.telegram.tgnet.TLRPC.WebPage
import org.telegram.tgnet.tlrpc.ChatInvite
import org.telegram.tgnet.tlrpc.Message
import org.telegram.tgnet.tlrpc.MessageEntity
import org.telegram.tgnet.tlrpc.ReactionCount
import org.telegram.tgnet.tlrpc.TLObject
import org.telegram.tgnet.tlrpc.TL_inputMessageEntityMentionName
import org.telegram.tgnet.tlrpc.TL_message
import org.telegram.tgnet.tlrpc.TL_messageEntityBold
import org.telegram.tgnet.tlrpc.TL_messageEntityCode
import org.telegram.tgnet.tlrpc.TL_messageEntityCustomEmoji
import org.telegram.tgnet.tlrpc.TL_messageEntityItalic
import org.telegram.tgnet.tlrpc.TL_messageEntityMentionName
import org.telegram.tgnet.tlrpc.TL_messageEntityPre
import org.telegram.tgnet.tlrpc.TL_messageEntitySpoiler
import org.telegram.tgnet.tlrpc.TL_messageEntityStrike
import org.telegram.tgnet.tlrpc.TL_messageEntityTextUrl
import org.telegram.tgnet.tlrpc.TL_messageEntityUnderline
import org.telegram.tgnet.tlrpc.TL_messageReactions
import org.telegram.tgnet.tlrpc.TL_messages_editMessage
import org.telegram.tgnet.tlrpc.TL_reactionEmoji
import org.telegram.tgnet.tlrpc.User
import org.telegram.tgnet.tlrpc.UserFull
import org.telegram.tgnet.tlrpc.messages_Messages
import org.telegram.ui.ActionBar.ActionBar
import org.telegram.ui.ActionBar.ActionBar.ActionBarMenuOnItemClick
import org.telegram.ui.ActionBar.ActionBarMenuItem
import org.telegram.ui.ActionBar.ActionBarMenuItem.ActionBarMenuItemSearchListener
import org.telegram.ui.ActionBar.ActionBarMenuSubItem
import org.telegram.ui.ActionBar.ActionBarPopupWindow
import org.telegram.ui.ActionBar.ActionBarPopupWindow.ActionBarPopupWindowLayout
import org.telegram.ui.ActionBar.AdjustPanLayoutHelper
import org.telegram.ui.ActionBar.AlertDialog
import org.telegram.ui.ActionBar.BaseFragment
import org.telegram.ui.ActionBar.BottomSheet
import org.telegram.ui.ActionBar.MessageDrawable
import org.telegram.ui.ActionBar.SimpleTextView
import org.telegram.ui.ActionBar.Theme
import org.telegram.ui.Adapters.MessagesSearchAdapter
import org.telegram.ui.Cells.BotHelpCell
import org.telegram.ui.Cells.ChatActionCell
import org.telegram.ui.Cells.ChatActionCell.ChatActionCellDelegate
import org.telegram.ui.Cells.ChatLoadingCell
import org.telegram.ui.Cells.ChatMessageCell
import org.telegram.ui.Cells.ChatMessageCellDelegate
import org.telegram.ui.Cells.ChatUnreadCell
import org.telegram.ui.Cells.CheckBoxCell
import org.telegram.ui.Cells.ContextLinkCell
import org.telegram.ui.Cells.StickerCell
import org.telegram.ui.Cells.TextSelectionHelper
import org.telegram.ui.Cells.TextSelectionHelper.ChatListTextSelectionHelper
import org.telegram.ui.Components.AlertsCreator
import org.telegram.ui.Components.AnimatedEmojiDrawable
import org.telegram.ui.Components.AnimatedEmojiSpan
import org.telegram.ui.Components.AnimatedEmojiSpan.EmojiGroupedSpans
import org.telegram.ui.Components.AnimatedFileDrawable
import org.telegram.ui.Components.AnimationProperties
import org.telegram.ui.Components.AttachBotIntroTopView
import org.telegram.ui.Components.AutoDeletePopupWrapper
import org.telegram.ui.Components.BackButtonMenu.addToPulledDialogs
import org.telegram.ui.Components.BackButtonMenu.clearPulledDialogs
import org.telegram.ui.Components.BackupImageView
import org.telegram.ui.Components.BlurBehindDrawable
import org.telegram.ui.Components.BlurredFrameLayout
import org.telegram.ui.Components.BlurredView
import org.telegram.ui.Components.Bulletin
import org.telegram.ui.Components.BulletinFactory
import org.telegram.ui.Components.BulletinFactory.FileType
import org.telegram.ui.Components.ChatActivityEnterTopView
import org.telegram.ui.Components.ChatActivityEnterTopView.EditView
import org.telegram.ui.Components.ChatActivityEnterTopView.EditViewButton
import org.telegram.ui.Components.ChatActivityEnterView
import org.telegram.ui.Components.ChatActivityEnterView.ChatActivityEnterViewDelegate
import org.telegram.ui.Components.ChatAttachAlert
import org.telegram.ui.Components.ChatAttachAlert.ChatAttachViewDelegate
import org.telegram.ui.Components.ChatAttachAlertDocumentLayout.DocumentSelectActivityDelegate
import org.telegram.ui.Components.ChatAvatarContainer
import org.telegram.ui.Components.ChatBigEmptyView
import org.telegram.ui.Components.ChatGreetingsView
import org.telegram.ui.Components.ChatNotificationsPopupWrapper
import org.telegram.ui.Components.ChatScrimPopupContainerLayout
import org.telegram.ui.Components.ChatThemeBottomSheet
import org.telegram.ui.Components.ChecksHintView
import org.telegram.ui.Components.CircularProgressDrawable
import org.telegram.ui.Components.ClippingImageView
import org.telegram.ui.Components.CounterView
import org.telegram.ui.Components.CrossfadeDrawable
import org.telegram.ui.Components.CubicBezierInterpolator
import org.telegram.ui.Components.EditTextBoldCursor
import org.telegram.ui.Components.EmbedBottomSheet
import org.telegram.ui.Components.EmojiPacksAlert
import org.telegram.ui.Components.ExtendedGridLayoutManager
import org.telegram.ui.Components.FireworksOverlay
import org.telegram.ui.Components.ForwardingPreviewView
import org.telegram.ui.Components.FragmentContextView
import org.telegram.ui.Components.GigagroupConvertAlert
import org.telegram.ui.Components.HideViewAfterAnimation
import org.telegram.ui.Components.HintView
import org.telegram.ui.Components.ImportingAlert
import org.telegram.ui.Components.InstantCameraView
import org.telegram.ui.Components.InviteMembersBottomSheet
import org.telegram.ui.Components.JoinGroupAlert
import org.telegram.ui.Components.JoinGroupAlert.Companion.showBulletin
import org.telegram.ui.Components.LayoutHelper
import org.telegram.ui.Components.LayoutHelper.createFrame
import org.telegram.ui.Components.LayoutHelper.createFrameRelatively
import org.telegram.ui.Components.LayoutHelper.createLinear
import org.telegram.ui.Components.LayoutHelper.createLinearRelatively
import org.telegram.ui.Components.LinkSpanDrawable.LinksTextView
import org.telegram.ui.Components.MentionsContainerView
import org.telegram.ui.Components.MessageContainsEmojiButton
import org.telegram.ui.Components.NumberTextView
import org.telegram.ui.Components.PhonebookShareAlert
import org.telegram.ui.Components.PinnedLineView
import org.telegram.ui.Components.PipRoundVideoView
import org.telegram.ui.Components.PollVotesAlert
import org.telegram.ui.Components.PopupSwipeBackLayout
import org.telegram.ui.Components.Premium.GiftPremiumBottomSheet.GiftTier
import org.telegram.ui.Components.Premium.PremiumFeatureBottomSheet
import org.telegram.ui.Components.Premium.PremiumPreviewBottomSheet
import org.telegram.ui.Components.RLottieImageView
import org.telegram.ui.Components.RadialProgressView
import org.telegram.ui.Components.Reactions.ReactedHeaderView
import org.telegram.ui.Components.Reactions.ReactedUsersListView
import org.telegram.ui.Components.Reactions.ReactedUsersListView.ContainerLinerLayout
import org.telegram.ui.Components.Reactions.ReactionTabHolderView
import org.telegram.ui.Components.Reactions.ReactionsContainerLayout
import org.telegram.ui.Components.Reactions.ReactionsEffectOverlay
import org.telegram.ui.Components.Reactions.VisibleReaction
import org.telegram.ui.Components.Reactions.VisibleReaction.Companion.fromEmojicon
import org.telegram.ui.Components.Reactions.VisibleReaction.Companion.fromTLReaction
import org.telegram.ui.Components.RecyclerAnimationScrollHelper
import org.telegram.ui.Components.RecyclerAnimationScrollHelper.AnimatableAdapter
import org.telegram.ui.Components.RecyclerListView
import org.telegram.ui.Components.RecyclerListView.OnItemClickListenerExtended
import org.telegram.ui.Components.RecyclerListView.OnItemLongClickListenerExtended
import org.telegram.ui.Components.RecyclerListView.OnMultiSelectionChanged
import org.telegram.ui.Components.ReportAlert
import org.telegram.ui.Components.SearchCounterView
import org.telegram.ui.Components.ShareAlert
import org.telegram.ui.Components.SharedMediaLayout
import org.telegram.ui.Components.SizeNotifierFrameLayout
import org.telegram.ui.Components.StickersAlert
import org.telegram.ui.Components.SubscribeToChannelAlert
import org.telegram.ui.Components.SuggestEmojiView
import org.telegram.ui.Components.TextSelectionHint
import org.telegram.ui.Components.TextStyleSpan
import org.telegram.ui.Components.TextStyleSpan.TextStyleRun
import org.telegram.ui.Components.TranscribeButton
import org.telegram.ui.Components.TranslateAlert
import org.telegram.ui.Components.TypefaceSpan
import org.telegram.ui.Components.URLSpanBotCommand
import org.telegram.ui.Components.URLSpanMono
import org.telegram.ui.Components.URLSpanNoUnderline
import org.telegram.ui.Components.URLSpanReplacement
import org.telegram.ui.Components.URLSpanUserMention
import org.telegram.ui.Components.UndoView
import org.telegram.ui.Components.ViewHelper
import org.telegram.ui.Components.voip.VoIPHelper.canRateCall
import org.telegram.ui.Components.voip.VoIPHelper.permissionDenied
import org.telegram.ui.Components.voip.VoIPHelper.showGroupCallAlert
import org.telegram.ui.Components.voip.VoIPHelper.showRateAlert
import org.telegram.ui.Components.voip.VoIPHelper.startCall
import org.telegram.ui.ContentPreviewViewer.ContentPreviewViewerDelegate
import org.telegram.ui.Delegates.ChatActivityMemberRequestsDelegate
import org.telegram.ui.DialogsActivity.DialogsActivityDelegate
import org.telegram.ui.LaunchActivity.Companion.getTimestampFromLink
import org.telegram.ui.PhotoAlbumPickerActivity.PhotoAlbumPickerActivityDelegate
import org.telegram.ui.PhotoViewer.EmptyPhotoViewerProvider
import org.telegram.ui.PhotoViewer.PhotoViewerProvider
import org.telegram.ui.PhotoViewer.PlaceProviderObject
import org.telegram.ui.aibot.AiSubscriptionPlansFragment
import org.telegram.ui.channel.SubscriptionResultFragment
import org.telegram.ui.group.GroupCallActivity
import org.telegram.ui.group.GroupCreateActivity.ContactsAddActivityDelegate
import org.telegram.ui.statistics.MessageStatisticActivity
import java.io.BufferedWriter
import java.io.File
import java.io.FileOutputStream
import java.io.FileWriter
import java.net.URLDecoder
import java.nio.charset.StandardCharsets
import java.util.Arrays
import java.util.Calendar
import java.util.Collections
import java.util.Locale
import java.util.concurrent.CountDownLatch
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicReference
import java.util.regex.Pattern
import kotlin.math.abs
import kotlin.math.ceil
import kotlin.math.max
import kotlin.math.min
import kotlin.math.roundToInt

@SuppressLint("NotifyDataSetChanged")
open class ChatActivity(args: Bundle?) : BaseFragment(args), NotificationCenterDelegate, DialogsActivityDelegate, LocationActivity.LocationActivityDelegate, DocumentSelectActivityDelegate {
	private val chatMessageCellsCache = mutableListOf<ChatMessageCell>()
	private val alreadyPlayedStickers = HashMap<MessageObject, Boolean>()
	private val actionModeViews = mutableListOf<View>()
	private val pinnedMessageImageView = arrayOfNulls<BackupImageView>(2)
	private val pinnedNameTextView = arrayOfNulls<TrackingWidthSimpleTextView>(2)
	private val pinnedMessageTextView = arrayOfNulls<SimpleTextView>(2)
	private val pinnedMessageButton = arrayOfNulls<PinnedMessageButton>(2)
	private val pinnedNextAnimation = arrayOfNulls<AnimatorSet>(2)
	private val pendingSendMessagesDict = SparseArray<MessageObject>()
	private val pendingSendMessages = mutableListOf<MessageObject>()
	private val animatingDocuments = HashMap<TLRPC.Document?, Int>()
	private val pollsToCheck = mutableListOf<MessageObject>()
	private val reactionsToCheck = mutableListOf<MessageObject>()
	private val extendedMediaToCheck = mutableListOf<MessageObject>()
	private val loadingPinnedMessages = SparseBooleanArray()
	private val currentPinnedMessageIndex = IntArray(1)
	private val selectedMessagesIds = arrayOf(SparseArray<MessageObject>(), SparseArray<MessageObject>())
	private val selectedMessagesCanCopyIds = arrayOf(SparseArray<MessageObject>(), SparseArray<MessageObject>())
	private val selectedMessagesCanStarIds = arrayOf(SparseArray<MessageObject>(), SparseArray<MessageObject>())
	private val waitingForLoad = mutableListOf<Int>()
	private val animateSendingViews = mutableListOf<ChatMessageCell>()
	private val messagesDict = arrayOf(SparseArray<MessageObject>(), SparseArray<MessageObject>())
	private val repliesMessagesDict = SparseArray<MessageObject>()
	private val replyMessageOwners = SparseArray<MutableList<Int>>()
	private val messagesByDays = HashMap<String, MutableList<MessageObject>>()
	private val waitingForReplies = SparseArray<MessageObject>()
	private val polls = LongSparseArray<MutableList<MessageObject>>()
	private val groupedMessagesMap = LongSparseArray<GroupedMessages>()
	private val maxMessageId = intArrayOf(Int.MAX_VALUE, Int.MAX_VALUE)
	private val minMessageId = intArrayOf(Int.MIN_VALUE, Int.MIN_VALUE)
	private val maxDate = intArrayOf(Int.MIN_VALUE, Int.MIN_VALUE)
	private val minDate = IntArray(2)
	private val endReached = BooleanArray(2)
	private val cacheEndReached = BooleanArray(2)
	private val forwardEndReached = booleanArrayOf(true, true)
	private val botInfo = LongSparseArray<BotInfo>()
	private val actionBarBackgroundPaint = Paint(Paint.ANTI_ALIAS_FLAG)
	private val chatScrollHelperCallback = ChatScrollCallback()
	var animatingMessageObjects = mutableListOf<MessageObject>()
	var openAnimationEnded = false
	var mentionContainer: MentionsContainerView? = null
	var scrimPopupWindow: ActionBarPopupWindow? = null
	var allowExpandPreviewByClick = false
	var messageEnterTransitionContainer: MessageEnterTransitionContainer? = null
	var emojiAnimationsOverlay: EmojiAnimationsOverlay? = null
	var drawingChatLisViewYoffset = 0f
	var blurredViewTopOffset = 0
	private val ioScope = CoroutineScope(Dispatchers.IO + SupervisorJob())
	private val mainScope = CoroutineScope(Dispatchers.Main + SupervisorJob())

	@JvmField
	var chatAttachAlert: ChatAttachAlert? = null

	@JvmField
	var contentView: SizeNotifierFrameLayout? = null

	@JvmField
	var fragmentOpened = false

	@JvmField
	var blurredViewBottomOffset = 0

	@JvmField
	var currentChat: Chat? = null

	@JvmField
	var currentUser: User? = null

	@JvmField
	var currentEncryptedChat: EncryptedChat? = null

	@JvmField
	var chatActivityEnterView: ChatActivityEnterView? = null

	@JvmField
	val messages = mutableListOf<MessageObject>()

	var currentUserInfo: UserFull? = null
		protected set

	protected var openKeyboardOnAttachMenuClose = false
	var currentChatInfo: ChatFull? = null
	var firstOpen = true
	var dialogFolderId = 0
	var dialogFilterId = 0
	var pulled = false
	var animateTo = false
	var updatePinnedProgressRunnable: Runnable? = null
	var bulletinDelegate: Bulletin.Delegate? = null
	var updateReactionRunnable: Runnable? = null
	private var forwardingPreviewView: ForwardingPreviewView? = null
	private var userBlocked = false
	private var chatInviterId: Long = 0
	private var closeChatDialog: Dialog? = null
	private var showCloseChatDialogLater = false
	private var progressView: FrameLayout? = null
	private var progressView2: View? = null
	private var bottomOverlay: FrameLayout? = null
	private var chatActivityEnterTopView: ChatActivityEnterTopView? = null
	private var chatActivityEnterViewAnimateFromTop = 0
	private var timeItem2: View? = null
	private var attachItem: ActionBarMenuItem? = null
	private var headerItem: ActionBarMenuItem? = null
	private var editTextItem: ActionBarMenuItem? = null
	private var searchItem: ActionBarMenuItem? = null
	private var searchIconItem: ActionBarMenuItem? = null
	private var audioCallIconItem: ActionBarMenuItem? = null
	private var searchItemVisible = false
	private var addContactItem: ActionBarMenuSubItem? = null
	private var clearHistoryItem: ActionBarMenuSubItem? = null
	private var animatingImageView: ClippingImageView? = null
	private var chatListView: RecyclerListView? = null
	private var chatListItemAnimator: ChatListItemAnimator? = null
	private var chatLayoutManager: GridLayoutManagerFixed? = null
	private var chatAdapter: ChatActivityAdapter? = null
	private var bottomOverlayChatText: TextView? = null
	private var bottomOverlayImage: ImageView? = null
	private var bottomOverlayProgress: RadialProgressView? = null
	private var bottomOverlayAnimation: AnimatorSet? = null

	// private BlurredFrameLayout bottomOverlayChat;
	private var bottomOverlayChat: FrameLayout? = null
	private var bottomMessagesActionContainer: BlurredFrameLayout? = null
	private var forwardButton: TextView? = null
	private var replyButton: TextView? = null
	private var emptyViewContainer: FrameLayout? = null
	private var greetingsViewContainer: ChatGreetingsView? = null
	private var bigEmptyView: ChatBigEmptyView? = null

	var avatarContainer: ChatAvatarContainer? = null
		private set

	private var bottomOverlayText: TextView? = null
	private var selectedMessagesCountTextView: NumberTextView? = null
	private var mentionsOnItemClickListener: RecyclerListView.OnItemClickListener? = null
	private var suggestEmojiPanel: SuggestEmojiView? = null
	private var muteItem: ActionBarMenuSubItem? = null
	private var muteItemGap: View? = null
	private var chatNotificationsPopupWrapper: ChatNotificationsPopupWrapper? = null
	private var pagedownButtonEnterProgress = 0f
	private var mentionsButtonEnterProgress = 0f
	private var reactionsMentionButtonEnterProgress = 0f
	private var pagedownButton: FrameLayout? = null
	private var pagedownButtonShowedByScroll = false
	private var pagedownButtonCounter: CounterView? = null
	private var mentiondownButton: FrameLayout? = null
	private var mentiondownButtonCounter: SimpleTextView? = null
	private var reactionsMentionCount = 0
	private var reactionsMentiondownButton: FrameLayout? = null
	private var reactionsMentiondownButtonCounter: CounterView? = null
	private var replyImageView: BackupImageView? = null

	var replyNameTextView: SimpleTextView? = null
		private set

	var replyObjectTextView: SimpleTextView? = null
		private set

	private var replyObjectHintTextView: SimpleTextView? = null
	private var showTapForForwardingOptionsHit = false
	private var tapForForwardingOptionsHitRunnable: Runnable? = null
	private var replyIconImageView: ImageView? = null
	private var replyCloseImageView: ImageView? = null
	private var mentionListAnimation: AnimatorSet? = null
	private var topChatPanelView: BlurredFrameLayout? = null
	private var reportSpamViewAnimator: AnimatorSet? = null
	private var addToContactsButton: TextView? = null
	private var botFreeBalanceView: TextView? = null
	private var botTopViewContainer: FrameLayout? = null
	private var addToContactsButtonArchive = false
	private var reportSpamButton: TextView? = null
	private var topViewSeparator1: View? = null
	private var topViewSeparator2: View? = null
	private var emojiStatusSpamHint: LinksTextView? = null
	private var chatWithAdminTextView: TextView? = null

	var fragmentContextView: FragmentContextView? = null
		private set

	private var fragmentLocationContextView: FragmentContextView? = null
	private var emptyView: TextView? = null
	private var gifHintTextView: HintView? = null
	private var emojiHintTextView: HintView? = null
	private var mediaBanTooltip: HintView? = null
	private var searchAsListHint: HintView? = null
	private var scheduledOrNoSoundHint: HintView? = null

	private val showScheduledOrNoSoundRunnable = Runnable {
		val chatActivityEnterView = chatActivityEnterView
		val parentActivity = parentActivity

		if (parentActivity == null || fragmentView == null || chatActivityEnterView == null) {
			return@Runnable
		}

		val anchor = chatActivityEnterView.getSendButton()

		if ((chatActivityEnterView.editField.text?.length ?: 0) < 5) {
			return@Runnable
		}

		SharedConfig.increaseScheduledOrNoSuoundHintShowed()

		if (scheduledOrNoSoundHint == null) {
			scheduledOrNoSoundHint = HintView(parentActivity, 4)
			scheduledOrNoSoundHint?.setShowingDuration(5000)
			scheduledOrNoSoundHint?.alpha = 0f
			scheduledOrNoSoundHint?.invisible()
			scheduledOrNoSoundHint?.setText(parentActivity.getString(R.string.ScheduledOrNoSoundHint))

			contentView?.addView(scheduledOrNoSoundHint, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.LEFT or Gravity.TOP, 10f, 0f, 10f, 0f))
		}

		scheduledOrNoSoundHint?.showForView(anchor, true)
	}

	private var searchAsListHintShown = false
	private var fwdRestrictedTopHint: HintView? = null
	private var fwdRestrictedBottomHint: HintView? = null
	private var slowModeHint: HintView? = null
	private var pollHintView: HintView? = null
	private var timerHintView: HintView? = null
	private var pollHintCell: ChatMessageCell? = null
	private var pollHintX = 0
	private var pollHintY = 0
	private var voiceHintTextView: HintView? = null
	private var noSoundHintView: HintView? = null
	private var forwardHintView: HintView? = null
	private var checksHintView: ChecksHintView? = null
	private var emojiButtonRed: View? = null
	private var pinnedMessageView: BlurredFrameLayout? = null
	private var blurredView: BlurredView? = null
	private var pinnedLineView: PinnedLineView? = null
	private var setPinnedTextTranslationX = false
	private var pinnedMessageViewAnimator: AnimatorSet? = null
	private var pinnedCounterTextView: NumberTextView? = null
	private var pinnedCounterTextViewX = 0
	private var pinnedMessageButtonShown = false
	private var closePinned: ImageView? = null
	private var pinnedProgress: RadialProgressView? = null
	private var pinnedListButton: ImageView? = null
	private var pinnedListAnimator: AnimatorSet? = null
	private var alertView: FrameLayout? = null
	private var hideAlertViewRunnable: Runnable? = null
	private var alertNameTextView: TextView? = null
	private var alertTextView: TextView? = null
	private var alertViewAnimator: AnimatorSet? = null
	private var searchContainer: FrameLayout? = null
	private var searchCalendarButton: ImageView? = null
	private var searchUserButton: ImageView? = null
	private var searchUpButton: ImageView? = null
	private var searchDownButton: ImageView? = null
	private var searchCountText: SearchCounterView? = null
	private var floatingDateView: ChatActionCell? = null
	private var infoTopView: ChatActionCell? = null
	private var hideDateDelay = 500
	private var instantCameraView: InstantCameraView? = null
	private var overlayView: View? = null
	private var currentFloatingDateOnScreen = false
	private var currentFloatingTopIsNotMessage = false
	private var floatingDateAnimation: AnimatorSet? = null
	private var scrollingFloatingDate = false
	private var scrollingChatListView = false
	private var checkTextureViewPosition = false
	private var searchingForUser = false
	private var searchingUserMessages: User? = null
	private var searchingChatMessages: Chat? = null

	var undoView: UndoView? = null
		private set

	private var topUndoView: UndoView? = null
	private var pinBulletin: Bulletin? = null
	private var showPinBulletin = false
	private var pinBullerinTag = 0
	private var unregisterFlagSecurePasscode: Runnable? = null
	private var unregisterFlagSecureNoforwards: Runnable? = null
	private var isFullyVisible = false
	private var hintMessageObject: MessageObject? = null
	private var hintMessageType = 0
	private var messagesSearchListView: RecyclerListView? = null
	private var messagesSearchAdapter: MessagesSearchAdapter? = null
	private var messagesSearchListViewAnimation: AnimatorSet? = null

	var chatMode = 0
		private set

	private var scheduledMessagesCount = -1
	private var reportType = -1
	var threadMessage: MessageObject? = null
	private var threadMessageVisible = true
	private var threadMessageObjects: List<MessageObject>? = null
	private var replyMessageHeaderObject: MessageObject? = null

	var threadId = 0
		private set

	private var replyOriginalMessageId = 0
	private var replyOriginalChat: Chat? = null
	private var isComments = false
	private var threadMessageAdded = false
	private var scrollToThreadMessage = false
	private var threadMaxInboxReadId = 0
	private var threadMaxOutboxReadId = 0
	private var replyMaxReadId = 0
	private var delayedReadRunnable: Runnable? = null
	private var threadUnreadMessagesCount = 0
	private var needAnimateToMessage: MessageObject? = null
	private var scrollToPositionOnRecreate = -1
	private var scrollToOffsetOnRecreate = 0
	private var editTextStart = 0
	private var editTextEnd = 0
	private var checkPaddingsRunnable: Runnable? = null
	private var wasManualScroll = false
	private var fixPaddingsInLayout = false
	private var globalIgnoreLayout = false
	private var topViewWasVisible = 0
	private var pinnedMessageIds = mutableListOf<Int>()
	private var pinnedMessageObjects = mutableMapOf<Int, MessageObject>()
	private var currentPinnedMessageId = 0
	private var forceNextPinnedMessageId = 0
	private var forceScrollToFirst = false
	private var loadedPinnedMessagesCount = 0
	private var totalPinnedMessagesCount = 0
	private var loadingPinnedMessagesList = false
	private var pinnedEndReached = false
	private var pagedownButtonAnimation: ValueAnimator? = null
	private var mentiondownButtonAnimation: ValueAnimator? = null
	private var reactionsMentionButtonAnimation: ValueAnimator? = null
	private var replyButtonAnimation: AnimatorSet? = null
	private var editButtonAnimation: AnimatorSet? = null
	private var forwardButtonAnimation: AnimatorSet? = null
	private var openSearchKeyboard = false
	private var waitingForReplyMessageLoad = false
	private var ignoreAttachOnPause = false
	private var allowStickersPanel = false
	private var allowContextBotPanel = false
	private var allowContextBotPanelSecond = true
	private var selectedObjectToEditCaption: MessageObject? = null
	private var selectedObject: MessageObject? = null
	private var selectedObjectGroup: GroupedMessages? = null
	private var forwardingMessages: ForwardingMessagesParams? = null
	private var forwardingMessage: MessageObject? = null
	private var forwardingMessageGroup: GroupedMessages? = null

	var replyMessage: MessageObject? = null
		private set

	private var editingMessageObjectReqId = 0
	private var editingMessageObject: MessageObject? = null
	private var paused = true
	private var pausedOnLastMessage = false
	private var wasPaused = false
	private var replyImageSize = 0
	private var replyImageCacheType = 0
	private var replyImageLocation: PhotoSize? = null
	private var replyImageThumbLocation: PhotoSize? = null
	private var replyImageLocationObject: TLObject? = null
	private var pinnedImageSize = 0
	private var pinnedImageCacheType = 0
	private var pinnedImageLocation: PhotoSize? = null
	private var pinnedImageThumbLocation: PhotoSize? = null
	private var pinnedImageLocationObject: TLObject? = null
	private var linkSearchRequestId = 0
	private var foundWebPage: WebPage? = null
	private var foundUrls: List<CharSequence>? = null
	private var pendingLinkSearchString: String? = null
	private var waitingForCharaterEnterRunnable: Runnable? = null
	private var onChatMessagesLoaded: Runnable? = null
	private var chatInvite: ChatInvite? = null
	private var chatInviteRunnable: Runnable? = null
	private var clearingHistory = false
	private var openAnimationStartTime: Long = 0
	private var scrollToTopOnResume = false
	private var forceScrollToTop = false
	private var scrollToTopUnReadOnResume = false

	var dialogId: Long = 0
		private set

	private var dialog_id_Long: Long? = null
	private var lastLoadIndex = 1
	private var hasUnfavedSelected = false
	private var cantDeleteMessagesCount = 0
	private var cantForwardMessagesCount = 0
	private var canForwardMessagesCount = 0
	private var canEditMessagesCount = 0
	private var cantSaveMessagesCount = 0
	private var canSaveMusicCount = 0
	private var canSaveDocumentsCount = 0
	private var needRemovePreviousSameChatActivity = true
	private var newUnreadMessageCount = 0
	private var prevSetUnreadCount = Int.MIN_VALUE
	private var newMentionsCount = 0
	private var hasAllMentionsLocal = false
	private var hideForwardEndReached = false
	private var loading = false
	private var firstLoading = true

	private val postponeNotificationsWhileLoadingCallback = object : PostponeNotificationCallback {
		override fun needPostpone(id: Int, currentAccount: Int, vararg args: Any?): Boolean {
			if (id == NotificationCenter.didReceiveNewMessages) {
				val did = args[0] as Long
				return firstLoading && did == dialogId
			}

			return false
		}
	}

	private var chatWasReset = false
	private var firstUnreadSent = false
	private var loadsCount = 0
	private var last_message_id = 0

	var mergeDialogId: Long = 0
		private set

	private var showScrollToMessageError = false
	private var startLoadFromMessageId = 0
	private var startLoadFromDate = 0
	private var startLoadFromMessageOffset = Int.MAX_VALUE
	private var startFromVideoTimestamp = -1
	private var startFromVideoMessageId = 0

	private val updateDeleteItemRunnable = object : Runnable {
		override fun run() {
			if (selectedObject == null || menuDeleteItem == null) {
				return
			}

			val remaining = max(0, selectedObject!!.messageOwner!!.ttl_period - (connectionsManager.currentTime - selectedObject!!.messageOwner!!.date))

			val remainingStr = if (remaining < 24 * 60 * 60) {
				AndroidUtilities.formatDuration(remaining, false)
			}
			else {
				LocaleController.formatPluralString("Days", (remaining / (24 * 60 * 60.0f)).roundToInt())
			}

			menuDeleteItem?.setSubtext(LocaleController.formatString("AutoDeleteIn", R.string.AutoDeleteIn, remainingStr))

			AndroidUtilities.runOnUIThread(this, 1000)
		}
	}

	private var needSelectFromMessageId = false
	private var returnToMessageId = 0
	private var returnToLoadIndex = 0
	private var createUnreadMessageAfterId = 0
	private var createUnreadMessageAfterIdLoading = false
	private var loadingFromOldPosition = false
	private var alertViewEnterProgress = 0f
	private var first = true
	private var first_unread_id = 0
	private var loadingForward = false
	private var unreadMessageObject: MessageObject? = null
	private var scrollToMessage: MessageObject? = null
	private var highlightMessageId = Int.MAX_VALUE
	private var scrollToMessagePosition = -10000
	private var unselectRunnable: Runnable? = null
	private var currentPicturePath: String? = null
	private var groupCall: ChatObject.Call? = null
	private var lastCallCheckFromServer = false
	private var createGroupCall = false
	private var botUser: String? = null

	var inlineReturn: Long = 0
		private set

	private var voiceChatHash: String? = null
	private var livestream = false
	private var attachMenuBotToOpen: String? = null
	private var attachMenuBotStartCommand: String? = null
	private var botButtons: MessageObject? = null
	private var botReplyButtons: MessageObject? = null
	private var botsCount = 0
	private var hasBotsCommands = false
	private var chatEnterTime: Long = 0
	private var chatLeaveTime: Long = 0
	private var locationAlertShown = false
	private var startVideoEdit: String? = null
	private var videoPlayerContainer: FrameLayout? = null
	private var drawLaterRoundProgressCell: ChatMessageCell? = null
	private var aspectRatioFrameLayout: AspectRatioFrameLayout? = null
	private val destroyTextureViewRunnable = Runnable { destroyTextureView() }
	private var videoTextureView: TextureView? = null
	private var scrollToVideo = false
	private val scrimPaint = Paint()
	private var scrimPaintAlpha = 0f
	private var scrimView: View? = null
	private var scrimViewAlpha = 1f
	private var scrimViewReaction: String? = null
	private var scrimAnimatorSet: AnimatorSet? = null
	private var scrimPopupWindowHideDimOnDismiss = true
	private var scrimPopupY = 0
	private var scrimPopupWindowItems: Array<ActionBarMenuSubItem?>? = null
	private var menuDeleteItem: ActionBarMenuSubItem? = null
	private var chatActivityDelegate: ChatActivityDelegate? = null
	private var chatScrollHelper: RecyclerAnimationScrollHelper? = null
	private var postponedScrollMinMessageId = 0
	private var postponedScrollToLastMessageQueryIndex = 0
	private var postponedScrollMessageId = 0
	private var postponedScrollIsCanceled = false

	private val textSelectionHelper = object : ChatListTextSelectionHelper() {
		override fun getParentTopPadding(): Int {
			return chatListViewPadding.toInt()
		}

		override fun getParentBottomPadding(): Int {
			return blurredViewBottomOffset
		}
	}

	private var slidingView: ChatMessageCell? = null
	private var maybeStartTrackingSlidingView = false
	private var startedTrackingSlidingView = false
	private var canShowPagedownButton = false
	private var textSelectionHint: TextSelectionHint? = null
	private var textSelectionHintWasShowed = false
	private var lastTouchY = 0f
	private var dummyMessageCell: ChatMessageCell? = null
	private var fireworksOverlay: FireworksOverlay? = null
	private var swipeBackEnabled = true
	private var waitingForSendingMessageLoad = false
	private var changeBoundAnimator: ValueAnimator? = null
	private var messageEditTextAnimator: Animator? = null
	private var distanceToPeer = 0
	private var openImport = false

	var chatListViewPadding = 0f
		private set

	private var chatListViewPaddingTopOnlyTopViews = 0f
	private var chatListViewPaddingVisibleOffset = 0

	private val photoViewerProvider = object : EmptyPhotoViewerProvider() {
		override fun getPlaceForPhoto(messageObject: MessageObject?, fileLocation: FileLocation?, index: Int, needPreview: Boolean): PlaceProviderObject? {
			return this@ChatActivity.getPlaceForPhoto(messageObject, fileLocation, needPreview, false)
		}

		override fun validateGroupId(groupId: Long): Boolean {
			val groupedMessages = groupedMessagesMap[groupId]
			return groupedMessages != null && groupedMessages.messages.size > 1
		}
	}

	private var contentPaddingTop = 0
	private var contentPanTranslation = 0f
	private var floatingDateViewOffset = 0f
	private var topChatPanelViewOffset = 0f
	private var pinnedMessageEnterOffset = 0f
	private var topViewOffset = 0f
	private var preloadedGreetingsSticker: TLRPC.Document? = null
	private var forceHistoryEmpty = false
	private var bottomPanelTranslationY = 0f
	private var bottomPanelTranslationYReverse = 0f
	private var invalidateChatListViewTopPadding = false
	private var activityResumeTime: Long = 0
	private var transitionAnimationIndex = 0
	private var scrollAnimationIndex = 0
	private var scrollCallbackAnimationIndex = 0
	private var showSearchAsIcon = false
	private var showAudioCallAsIcon = false
	private var pullingDownOffset = 0f
	private var pullingBottomOffset = 0f
	private var pullingDownDrawable: ChatPullingDownDrawable? = null
	private var pullingDownBackAnimator: Animator? = null
	private var fromPullingDownTransition = false
	private var toPullingDownTransition = false
	private var pullingDownAnimateToActivity: ChatActivity? = null
	private var pullingDownAnimateProgress = 0f
	private var fragmentTransition: AnimatorSet? = null
	private var loaderAnimationView: RLottieImageView? = null

	private val fragmentTransitionRunnable = Runnable {
		val fragmentTransition = fragmentTransition ?: return@Runnable

		if (!fragmentTransition.isRunning) {
			fragmentTransition.start()
		}
	}

	private var backToPreviousFragment: ChatActivity? = null
	private var isPauseOnThemePreview = false
	private var chatThemeBottomSheet: ChatThemeBottomSheet? = null
	private var pendingRequestsDelegate: ChatActivityMemberRequestsDelegate? = null

	var sendAsPeers: TL_channels_sendAsPeers? = null
		private set

	private var chatEmojiViewPadding = 0
	private var fixedKeyboardHeight = -1
	private var cancelFixedPositionRunnable: Runnable? = null
	private var invalidateMessagesVisiblePart = false
	private var scrollByTouch = false
	private var pinchToZoomHelper: PinchToZoomHelper? = null
	private var searchExpandAnimator: ValueAnimator? = null
	private var searchExpandProgress = 0f
	private var botContextResults: List<Any>? = null

	private val botContextProvider: PhotoViewerProvider = object : EmptyPhotoViewerProvider() {
		override fun getPlaceForPhoto(messageObject: MessageObject?, fileLocation: FileLocation?, index: Int, needPreview: Boolean): PlaceProviderObject? {
			if (index < 0 || index >= (botContextResults?.size ?: 0) || mentionContainer?.listView == null) {
				return null
			}

			val count = mentionContainer?.listView?.childCount ?: 0
			val result = botContextResults!![index]

			for (a in 0 until count) {
				var imageReceiver: ImageReceiver? = null
				val view = mentionContainer!!.listView.getChildAt(a)

				if (view is ContextLinkCell) {
					if (view.result === result) {
						imageReceiver = view.photoImage
					}
				}

				if (imageReceiver != null) {
					val coords = IntArray(2)

					view.getLocationInWindow(coords)

					val `object` = PlaceProviderObject()
					`object`.viewX = coords[0]
					`object`.viewY = coords[1]
					`object`.parentView = mentionContainer!!.listView
					`object`.imageReceiver = imageReceiver
					`object`.thumb = imageReceiver.bitmapSafe
					`object`.radius = imageReceiver.getRoundRadius()

					return `object`
				}
			}

			return null
		}

		override fun sendButtonPressed(index: Int, videoEditedInfo: VideoEditedInfo?, notify: Boolean, scheduleDate: Int, forceDocument: Boolean) {
			if (index < 0 || index >= botContextResults!!.size) {
				return
			}

			sendBotInlineResult(botContextResults!![index] as BotInlineResult, notify, scheduleDate)
		}
	}

	private var infoTopViewAnimator: Animator? = null
	private var progressDialog: AlertDialog? = null
	private var nextScrollToMessageId = 0
	private var nextScrollFromMessageId = 0
	private var nextScrollSelect = false
	private var nextScrollLoadIndex = 0
	private var nextScrollForce = false
	private var nextScrollForcePinnedMessageId = 0
	private var pinnedProgressIsShowing = false

	private val postponedScrollCancelListener = DialogInterface.OnCancelListener {
		postponedScrollIsCanceled = true
		postponedScrollMessageId = 0
		nextScrollToMessageId = 0
		forceNextPinnedMessageId = 0
		invalidateMessagesVisiblePart()
		showPinnedProgress(false)
	}

	private var sponsoredMessagesAdded = false
	private var scrimViewAlphaAnimator: ValueAnimator? = null
	private var commentLoadingGuid = 0
	private var commentMessagesLoadingGuid = 0
	private var commentRequestId = 0
	private var commentMessagesRequestId = 0
	private var commentLoadingMessageId = 0
	private var savedDiscussionMessage: TL_messages_discussionMessage? = null
	private var savedHistory: messages_Messages? = null
	private var savedNoHistory = false
	private var savedNoDiscussion = false
	private var isChatBotStarted = false
	private val showRemainingAiTextRequests = false
	private val showRemainingAiImageRequests = false
	// private var chatbotStatusIsShowing = false

	private var botHelpCell: BotHelpCell? = null
	private var showBotHelpCell = false

	fun deleteHistory(dateSelectedStart: Int, dateSelectedEnd: Int, forAll: Boolean) {
		chatAdapter?.frozenMessages?.clear()

		for (i in messages.indices) {
			val messageObject = messages[i]

			if (messageObject.messageOwner!!.date <= dateSelectedStart || messageObject.messageOwner!!.date >= dateSelectedEnd) {
				chatAdapter?.frozenMessages?.add(messageObject)
			}
		}

		chatListView?.setEmptyView(null)

		if (chatAdapter?.frozenMessages.isNullOrEmpty()) {
			showProgressView(true)
		}

		chatAdapter?.isFrozen = true
		chatAdapter?.notifyDataSetChanged(true)

		undoView?.showWithAction(dialogId, UndoView.ACTION_CLEAR_DATES, {
			messagesController.deleteMessagesRange(dialogId, if (isChannel(currentChat)) dialogId else 0, dateSelectedStart, dateSelectedEnd, forAll) {
				chatAdapter?.frozenMessages?.clear()
				chatAdapter?.isFrozen = false
				chatAdapter?.notifyDataSetChanged(true)

				showProgressView(false)
			}
		}) {
			chatAdapter?.frozenMessages?.clear()
			chatAdapter?.isFrozen = false
			chatAdapter?.notifyDataSetChanged(true)

			showProgressView(false)
		}
	}

	fun showHeaderItem(show: Boolean) {
		if (show) {
			if (chatActivityEnterView?.hasText() == true && chatActivityEnterView?.getSlowModeTimer().isNullOrEmpty()) {
				attachItem?.visible()
				headerItem?.gone()
			}
			else {
				attachItem?.gone()
				headerItem?.visible()
			}
		}
		else {
			attachItem?.gone()
			headerItem?.gone()
		}
	}

	override fun startMusicSelectActivity() {
		// unused
	}

	private fun startMultiselect(position: Int?) {
		if (position == null) {
			return
		}

		val indexOfMessage = position - chatAdapter!!.messagesStartRow

		if (indexOfMessage < 0 || indexOfMessage >= messages.size) {
			return
		}

		val messageObject = messages[indexOfMessage]
		val unselect = selectedMessagesIds[0][messageObject.id, null] == null && selectedMessagesIds[1][messageObject.id, null] == null
		val alreadySelectedMessagesIds = SparseArray<MessageObject?>()

		for (i in 0 until selectedMessagesIds[0].size()) {
			alreadySelectedMessagesIds.put(selectedMessagesIds[0].keyAt(i), selectedMessagesIds[0].valueAt(i))
		}
		for (i in 0 until selectedMessagesIds[1].size()) {
			alreadySelectedMessagesIds.put(selectedMessagesIds[1].keyAt(i), selectedMessagesIds[1].valueAt(i))
		}

		chatListView?.startMultiselect(position, false, object : OnMultiSelectionChanged {
			var limitReached = false

			override fun onSelectionChanged(position: Int, selected: Boolean, x: Float, y: Float) {
				@Suppress("NAME_SHADOWING") var selected = selected
				val i = position - chatAdapter!!.messagesStartRow

				if (unselect) {
					selected = !selected
				}

				if (i >= 0 && i < messages.size) {
					@Suppress("NAME_SHADOWING") val messageObject = messages[i]

					if (selected && (selectedMessagesIds[0].indexOfKey(messageObject.id) >= 0 || selectedMessagesIds[1].indexOfKey(messageObject.id) >= 0)) {
						return
					}

					if (!selected && selectedMessagesIds[0].indexOfKey(messageObject.id) < 0 && selectedMessagesIds[1].indexOfKey(messageObject.id) < 0) {
						return
					}

					if (messageObject.contentType == 0) {
						limitReached = selected && selectedMessagesIds[0].size() + selectedMessagesIds[1].size() >= 100

						val holder = chatListView!!.findViewHolderForAdapterPosition(position)

						if (holder != null && holder.itemView is ChatMessageCell) {
							processRowSelect(holder.itemView, false, x, y)
						}
						else {
							addToSelectedMessages(messageObject, false)
							updateActionModeTitle()
							updateVisibleRows()
						}
					}
				}
			}

			override fun canSelect(position: Int): Boolean {
				val i = position - chatAdapter!!.messagesStartRow

				if (i >= 0 && i < messages.size) {
					@Suppress("NAME_SHADOWING") val messageObject = messages[i]

					if (messageObject.contentType == 0) {
						return if (!unselect && alreadySelectedMessagesIds[messageObject.id, null] == null) {
							true
						}
						else {
							unselect && alreadySelectedMessagesIds[messageObject.id, null] != null
						}
					}
				}

				return false
			}

			override fun checkPosition(position: Int, selectionFromTop: Boolean): Int {
				val i = position - chatAdapter!!.messagesStartRow

				if (i >= 0 && i < messages.size) {
					@Suppress("NAME_SHADOWING") val messageObject = messages[i]

					if (messageObject.contentType == 0 && messageObject.hasValidGroupId()) {
						val groupedMessages = groupedMessagesMap[messageObject.groupId]

						if (groupedMessages != null) {
							val messageObject1 = groupedMessages.messages[if (selectionFromTop) 0 else groupedMessages.messages.size - 1]
							return chatAdapter!!.messagesStartRow + messages.indexOf(messageObject1)
						}
					}
				}

				return position
			}

			override fun limitReached(): Boolean {
				return limitReached
			}

			override fun getPaddings(paddings: IntArray?) {
				paddings?.set(0, chatListViewPadding.toInt())
				paddings?.set(1, blurredViewBottomOffset)
			}

			override fun scrollBy(dy: Int) {
				chatListView?.scrollBy(0, dy)
			}
		})
	}

	override fun onFragmentCreate(): Boolean {
		val arguments = arguments ?: return false

		val chatId = arguments.getLong("chat_id", 0)
		val userId = arguments.getLong("user_id", 0)
		val encId = arguments.getInt("enc_id", 0)

		dialogFolderId = arguments.getInt("dialog_folder_id", 0)
		dialogFilterId = arguments.getInt("dialog_filter_id", 0)
		chatMode = arguments.getInt("chatMode", 0)
		voiceChatHash = arguments.getString("voicechat", null)
		livestream = !TextUtils.isEmpty(arguments.getString("livestream", null))
		attachMenuBotToOpen = arguments.getString("attach_bot", null)
		attachMenuBotStartCommand = arguments.getString("attach_bot_start_command", null)
		inlineReturn = arguments.getLong("inline_return", 0)

		val inlineQuery = arguments.getString("inline_query")
		val premiumInvoiceBot = arguments.getBoolean("premium_bot", false)

		startLoadFromMessageId = arguments.getInt("message_id", 0)
		startLoadFromDate = arguments.getInt("start_from_date", 0)
		startFromVideoTimestamp = arguments.getInt("video_timestamp", -1)
		threadUnreadMessagesCount = arguments.getInt("unread_count", 0)

		if (startFromVideoTimestamp >= 0) {
			startFromVideoMessageId = startLoadFromMessageId
		}

		reportType = arguments.getInt("report", -1)
		pulled = arguments.getBoolean("pulled", false)

		val historyPreloaded = arguments.getBoolean("historyPreloaded", false)

		if (highlightMessageId != 0 && highlightMessageId != Int.MAX_VALUE) {
			startLoadFromMessageId = highlightMessageId
		}

		val migrated_to = arguments.getInt("migrated_to", 0)

		scrollToTopOnResume = arguments.getBoolean("scrollToTopOnResume", false)
		needRemovePreviousSameChatActivity = arguments.getBoolean("need_remove_previous_same_chat_activity", true)

		if (chatId != 0L) {
			currentChat = messagesController.getChat(chatId)

			if (currentChat == null) {
				val countDownLatch = CountDownLatch(1)
				val messagesStorage = messagesStorage

				messagesStorage.storageQueue.postRunnable {
					currentChat = messagesStorage.getChat(chatId)
					countDownLatch.countDown()
				}

				try {
					countDownLatch.await()
				}
				catch (e: Exception) {
					FileLog.e(e)
				}

				if (currentChat != null) {
					messagesController.putChat(currentChat, true)
				}
				else {
					return false
				}
			}

			dialogId = -chatId

			if (isChannel(currentChat)) {
				messagesController.startShortPoll(currentChat, classGuid, false)
			}
		}
		else if (userId != 0L) {
			currentUser = messagesController.getUser(userId)

			if (currentUser == null) {
				val messagesStorage = messagesStorage
				val countDownLatch = CountDownLatch(1)

				messagesStorage.storageQueue.postRunnable {
					currentUser = messagesStorage.getUser(userId)
					countDownLatch.countDown()
				}

				try {
					countDownLatch.await()
				}
				catch (e: Exception) {
					FileLog.e(e)
				}

				if (currentUser != null) {
					messagesController.putUser(currentUser, true)
				}
				else {
					return false
				}
			}

			dialogId = userId
			botUser = arguments.getString("botUser")

			if (inlineQuery != null) {
				messagesController.sendBotStart(currentUser, inlineQuery)
			}
			else if (premiumInvoiceBot && !TextUtils.isEmpty(botUser)) {
				messagesController.sendBotStart(currentUser, botUser)
				botUser = null
			}
		}
		else if (encId != 0) {
			currentEncryptedChat = messagesController.getEncryptedChat(encId)

			val messagesStorage = messagesStorage

			if (currentEncryptedChat == null) {
				val countDownLatch = CountDownLatch(1)

				messagesStorage.storageQueue.postRunnable {
					currentEncryptedChat = messagesStorage.getEncryptedChat(encId.toLong())
					countDownLatch.countDown()
				}

				try {
					countDownLatch.await()
				}
				catch (e: Exception) {
					FileLog.e(e)
				}

				if (currentEncryptedChat != null) {
					messagesController.putEncryptedChat(currentEncryptedChat, true)
				}
				else {
					return false
				}
			}

			currentUser = messagesController.getUser(currentEncryptedChat!!.user_id)

			if (currentUser == null) {
				val countDownLatch = CountDownLatch(1)

				messagesStorage.storageQueue.postRunnable {
					currentUser = messagesStorage.getUser(currentEncryptedChat!!.user_id)
					countDownLatch.countDown()
				}

				try {
					countDownLatch.await()
				}
				catch (e: Exception) {
					FileLog.e(e)
				}

				if (currentUser != null) {
					messagesController.putUser(currentUser, true)
				}
				else {
					return false
				}
			}

			dialogId = DialogObject.makeEncryptedDialogId(encId.toLong())

			maxMessageId[1] = Int.MIN_VALUE
			maxMessageId[0] = maxMessageId[1]
			minMessageId[1] = Int.MAX_VALUE
			minMessageId[0] = minMessageId[1]
		}
		else {
			return false
		}

		dialog_id_Long = dialogId

		notificationCenter.addPostponeNotificationsCallback(postponeNotificationsWhileLoadingCallback)

		if (chatMode != MODE_SCHEDULED) {
			if (threadId == 0) {
				notificationCenter.addObserver(this, NotificationCenter.screenshotTook)
				notificationCenter.addObserver(this, NotificationCenter.encryptedChatUpdated)
				notificationCenter.addObserver(this, NotificationCenter.messagesReadEncrypted)
				notificationCenter.addObserver(this, NotificationCenter.botKeyboardDidLoad)
				notificationCenter.addObserver(this, NotificationCenter.updateMentionsCount)
				notificationCenter.addObserver(this, NotificationCenter.newDraftReceived)
				notificationCenter.addObserver(this, NotificationCenter.chatOnlineCountDidLoad)
				notificationCenter.addObserver(this, NotificationCenter.peerSettingsDidLoad)
				notificationCenter.addObserver(this, NotificationCenter.didLoadPinnedMessages)
				notificationCenter.addObserver(this, NotificationCenter.commentsRead)
				notificationCenter.addObserver(this, NotificationCenter.changeRepliesCounter)
				notificationCenter.addObserver(this, NotificationCenter.messagesRead)
				notificationCenter.addObserver(this, NotificationCenter.didLoadChatInviter)
				notificationCenter.addObserver(this, NotificationCenter.groupCallUpdated)
			}
			else {
				notificationCenter.addObserver(this, NotificationCenter.threadMessagesRead)
			}

			notificationCenter.addObserver(this, NotificationCenter.removeAllMessagesFromDialog)
			notificationCenter.addObserver(this, NotificationCenter.messagesReadContent)
			notificationCenter.addObserver(this, NotificationCenter.chatSearchResultsAvailable)
			notificationCenter.addObserver(this, NotificationCenter.chatSearchResultsLoading)
			notificationCenter.addObserver(this, NotificationCenter.didUpdateMessagesViews)
			notificationCenter.addObserver(this, NotificationCenter.didUpdatePollResults)

			if (currentEncryptedChat != null) {
				notificationCenter.addObserver(this, NotificationCenter.didVerifyMessagesStickers)
			}
		}

		notificationCenter.addObserver(this, NotificationCenter.messagesDidLoad)
		notificationCenter.addObserver(this, NotificationCenter.chatIsBlocked)

		NotificationCenter.globalInstance.addObserver(this, NotificationCenter.emojiLoaded)
		NotificationCenter.globalInstance.addObserver(this, NotificationCenter.invalidateMotionBackground)

		notificationCenter.addObserver(this, NotificationCenter.didUpdateConnectionState)
		notificationCenter.addObserver(this, NotificationCenter.updateInterfaces)
		notificationCenter.addObserver(this, NotificationCenter.updateDefaultSendAsPeer)

		if (chatMode != MODE_PINNED) {
			notificationCenter.addObserver(this, NotificationCenter.didReceiveNewMessages)
		}
		if (chatMode == 0) {
			notificationCenter.addObserver(this, NotificationCenter.didLoadSponsoredMessages)
		}

		notificationCenter.addObserver(this, NotificationCenter.didLoadSendAsPeers)
		notificationCenter.addObserver(this, NotificationCenter.closeChats)
		notificationCenter.addObserver(this, NotificationCenter.messagesDeleted)
		notificationCenter.addObserver(this, NotificationCenter.historyCleared)
		notificationCenter.addObserver(this, NotificationCenter.messageReceivedByServer)
		notificationCenter.addObserver(this, NotificationCenter.messageReceivedByAck)
		notificationCenter.addObserver(this, NotificationCenter.messageSendError)
		notificationCenter.addObserver(this, NotificationCenter.chatInfoDidLoad)
		notificationCenter.addObserver(this, NotificationCenter.contactsDidLoad)
		notificationCenter.addObserver(this, NotificationCenter.messagePlayingProgressDidChanged)
		notificationCenter.addObserver(this, NotificationCenter.messagePlayingDidReset)
		notificationCenter.addObserver(this, NotificationCenter.messagePlayingGoingToStop)
		notificationCenter.addObserver(this, NotificationCenter.messagePlayingPlayStateChanged)
		notificationCenter.addObserver(this, NotificationCenter.blockedUsersDidLoad)
		notificationCenter.addObserver(this, NotificationCenter.fileNewChunkAvailable)
		notificationCenter.addObserver(this, NotificationCenter.didCreatedNewDeleteTask)
		notificationCenter.addObserver(this, NotificationCenter.messagePlayingDidStart)
		notificationCenter.addObserver(this, NotificationCenter.updateMessageMedia)
		notificationCenter.addObserver(this, NotificationCenter.voiceTranscriptionUpdate)
		notificationCenter.addObserver(this, NotificationCenter.animatedEmojiDocumentLoaded)
		notificationCenter.addObserver(this, NotificationCenter.replaceMessagesObjects)
		notificationCenter.addObserver(this, NotificationCenter.notificationsSettingsUpdated)
		notificationCenter.addObserver(this, NotificationCenter.replyMessagesDidLoad)
		notificationCenter.addObserver(this, NotificationCenter.didReceivedWebpages)
		notificationCenter.addObserver(this, NotificationCenter.didReceivedWebpagesInUpdates)
		notificationCenter.addObserver(this, NotificationCenter.botInfoDidLoad)
		notificationCenter.addObserver(this, NotificationCenter.chatInfoCantLoad)
		notificationCenter.addObserver(this, NotificationCenter.userInfoDidLoad)
		notificationCenter.addObserver(this, NotificationCenter.pinnedInfoDidLoad)

		NotificationCenter.globalInstance.addObserver(this, NotificationCenter.didSetNewWallpapper)
		NotificationCenter.globalInstance.addObserver(this, NotificationCenter.goingToPreviewTheme)

		notificationCenter.addObserver(this, NotificationCenter.channelRightsUpdated)
		notificationCenter.addObserver(this, NotificationCenter.audioRecordTooShort)
		notificationCenter.addObserver(this, NotificationCenter.didUpdateReactions)
		notificationCenter.addObserver(this, NotificationCenter.didUpdateExtendedMedia)
		notificationCenter.addObserver(this, NotificationCenter.videoLoadingStateChanged)
		notificationCenter.addObserver(this, NotificationCenter.scheduledMessagesUpdated)
		notificationCenter.addObserver(this, NotificationCenter.diceStickersDidLoad)
		notificationCenter.addObserver(this, NotificationCenter.dialogDeleted)
		notificationCenter.addObserver(this, NotificationCenter.chatAvailableReactionsUpdated)
		notificationCenter.addObserver(this, NotificationCenter.dialogsUnreadReactionsCounterChanged)
		notificationCenter.addObserver(this, NotificationCenter.groupStickersDidLoad)

		if (isAiBot()) {
			notificationCenter.addObserver(this, NotificationCenter.aiBotStarted)
			notificationCenter.addObserver(this, NotificationCenter.aiBotStopped)
			notificationCenter.addObserver(this, NotificationCenter.aiBotRequestFailed)
			notificationCenter.addObserver(this, NotificationCenter.aiSubscriptionStatusReceived)
			notificationCenter.addObserver(this, NotificationCenter.aiSubscriptionSuccess)
		}

		super.onFragmentCreate()

		if (chatMode == MODE_PINNED) {
			val messageObjects = mutableListOf<MessageObject>()
			var a = 0
			val N = pinnedMessageIds.size

			while (a < N) {
				val id = pinnedMessageIds[a]
				val `object` = pinnedMessageObjects[id]

				if (`object` != null) {
					val o = MessageObject(`object`.currentAccount, `object`.messageOwner!!, generateLayout = true, checkMediaExists = false)
					o.replyMessageObject = `object`.replyMessageObject
					o.mediaExists = `object`.mediaExists
					o.attachPathExists = `object`.attachPathExists
					messageObjects.add(o)
				}

				a++
			}

			val loadIndex = lastLoadIndex++

			waitingForLoad.add(loadIndex)

			notificationCenter.postNotificationName(NotificationCenter.messagesDidLoad, dialogId, messageObjects.size, messageObjects, false, 0, last_message_id, 0, 0, 2, true, classGuid, loadIndex, pinnedMessageIds[0], 0, MODE_PINNED)
		}
		else if (!forceHistoryEmpty) {
			loading = true
		}

		if (isThreadChat) {
			if (highlightMessageId == startLoadFromMessageId) {
				needSelectFromMessageId = true
			}
		}
		else {
			messagesController.setLastCreatedDialogId(dialogId, chatMode == MODE_SCHEDULED, true)

			if (chatMode == 0) {
				if (currentEncryptedChat == null) {
					mediaDataController.loadBotKeyboard(dialogId)
				}

				messagesController.loadPeerSettings(currentUser, currentChat)

				if (startLoadFromMessageId == 0) {
					val sharedPreferences = MessagesController.getNotificationsSettings(currentAccount)
					val messageId = sharedPreferences.getInt("diditem$dialogId", 0)

					if (messageId != 0) {
						wasManualScroll = true
						loadingFromOldPosition = true
						startLoadFromMessageOffset = sharedPreferences.getInt("diditemo$dialogId", 0)
						startLoadFromMessageId = messageId
					}
				}
				else {
					showScrollToMessageError = true
					needSelectFromMessageId = true
				}
			}
		}

		var loadInfo = false

		if (currentChat != null) {
			currentChatInfo = messagesController.getChatFull(currentChat!!.id)
			groupCall = messagesController.getGroupCall(currentChat!!.id, true)

			if (isChannel(currentChat) && !messagesController.isChannelAdminsLoaded(currentChat!!.id)) {
				messagesController.loadChannelAdmins(currentChat!!.id, true)
			}

			fillInviterId(false)

			if (chatMode != MODE_PINNED) {
				messagesStorage.loadChatInfo(currentChat!!.id, isChannel(currentChat), null, true, false)
			}

			if (chatMode == 0 && currentChatInfo != null && isChannel(currentChat) && currentChatInfo!!.migrated_from_chat_id != 0L && !isThreadChat) {
				mergeDialogId = -currentChatInfo!!.migrated_from_chat_id
				maxMessageId[1] = currentChatInfo!!.migrated_from_max_id
			}

			loadInfo = currentChatInfo == null

			checkGroupCallJoin(false)
		}
		else if (currentUser != null) {
			if (chatMode != MODE_PINNED) {
				messagesController.loadUserInfo(currentUser, true, classGuid)
			}

			loadInfo = currentUserInfo == null
		}

		if (forceHistoryEmpty) {
			endReached[1] = true
			endReached[0] = true

			forwardEndReached[1] = true
			forwardEndReached[0] = true

			firstLoading = false
		}

		if (chatMode != MODE_PINNED && !forceHistoryEmpty) {
			waitingForLoad.add(lastLoadIndex)

			if (startLoadFromDate != 0) {
				messagesController.loadMessages(dialogId, mergeDialogId, false, 30, 0, startLoadFromDate, true, 0, classGuid, 4, 0, chatMode, threadId, replyMaxReadId, lastLoadIndex++)
			}
			else if (startLoadFromMessageId != 0 && (!isThreadChat || startLoadFromMessageId == highlightMessageId)) {
				if (migrated_to != 0) {
					mergeDialogId = migrated_to.toLong()
					messagesController.loadMessages(mergeDialogId, 0, loadInfo, if (loadingFromOldPosition) 50 else if (AndroidUtilities.isTablet() || isThreadChat) 30 else 20, startLoadFromMessageId, 0, true, 0, classGuid, 3, 0, chatMode, threadId, replyMaxReadId, lastLoadIndex++)
				}
				else {
					messagesController.loadMessages(dialogId, mergeDialogId, loadInfo, if (loadingFromOldPosition) 50 else if (AndroidUtilities.isTablet() || isThreadChat) 30 else 20, startLoadFromMessageId, 0, true, 0, classGuid, 3, 0, chatMode, threadId, replyMaxReadId, lastLoadIndex++)
				}
			}
			else {
				if (historyPreloaded) {
					lastLoadIndex++
				}
				else {
					messagesController.loadMessages(dialogId, mergeDialogId, loadInfo, if (AndroidUtilities.isTablet() || isThreadChat) 30 else 20, startLoadFromMessageId, 0, true, 0, classGuid, 2, 0, chatMode, threadId, replyMaxReadId, lastLoadIndex++)
				}
			}
		}

		if (chatMode == 0 && !isThreadChat) {
			waitingForLoad.add(lastLoadIndex)
			messagesController.loadMessages(dialogId, mergeDialogId, false, 1, 0, 0, true, 0, classGuid, 2, 0, MODE_SCHEDULED, threadId, replyMaxReadId, lastLoadIndex++)
		}

		if (chatMode == 0) {
			if (userId != 0L && currentUser!!.bot) {
				mediaDataController.loadBotInfo(userId, userId, true, classGuid)
			}
			else {
				val currentChatInfo = currentChatInfo

				if (currentChatInfo is TL_chatFull) {
					for (a in currentChatInfo.participants.participants.indices) {
						val participant = currentChatInfo.participants.participants[a]
						val user = messagesController.getUser(participant.user_id)

						if (user != null && user.bot) {
							mediaDataController.loadBotInfo(user.id, -currentChatInfo.id, true, classGuid)
						}
					}
				}
			}

			if (AndroidUtilities.isTablet()) {
				notificationCenter.postNotificationName(NotificationCenter.openedChatChanged, dialogId, false)
			}

			if (currentUser != null && !isReplyUser(currentUser)) {
				userBlocked = messagesController.blockedPeers.indexOfKey(currentUser!!.id) >= 0
			}

			if (currentEncryptedChat != null && AndroidUtilities.getMyLayerVersion(currentEncryptedChat!!.layer) != SecretChatHelper.CURRENT_SECRET_CHAT_LAYER) {
				secretChatHelper.sendNotifyLayerMessage(currentEncryptedChat, null)
			}
		}

		if (currentChatInfo != null && currentChatInfo!!.linked_chat_id != 0L) {
			val chat = messagesController.getChat(currentChatInfo!!.linked_chat_id)

			if (chat != null && chat.megagroup) {
				messagesController.startShortPoll(chat, classGuid, false)
			}
		}

		if (chatInvite != null) {
			var timeout = chatInvite!!.expires - connectionsManager.currentTime

			if (timeout < 0) {
				timeout = 10
			}

			AndroidUtilities.runOnUIThread(Runnable {
				chatInviteRunnable = null

				val builder = AlertDialog.Builder(parentActivity!!)

				if (isChannel(currentChat) && !currentChat!!.megagroup) {
					builder.setMessage(context!!.getString(R.string.JoinByPeekChannelText))
					builder.setTitle(context!!.getString(R.string.JoinByPeekChannelTitle))
				}
				else {
					builder.setMessage(context!!.getString(R.string.JoinByPeekGroupText))
					builder.setTitle(context!!.getString(R.string.JoinByPeekGroupTitle))
				}

				builder.setPositiveButton(context!!.getString(R.string.JoinByPeekJoin)) { _, _ ->
					bottomOverlayChatText?.callOnClick()
				}

				builder.setNegativeButton(context!!.getString(R.string.Cancel)) { _, _ ->
					finishFragment()
				}

				showDialog(builder.create())
			}.also { chatInviteRunnable = it }, timeout * 1000L)
		}

		return true
	}

	private fun fillInviterId(load: Boolean) {
		val currentChat = currentChat
		val currentChatInfo = currentChatInfo

		if (currentChat == null || currentChatInfo == null || isNotInChat(currentChat) || currentChat.creator) {
			return
		}

		if (currentChatInfo.inviterId != 0L) {
			chatInviterId = currentChatInfo.inviterId
			return
		}

		if (currentChatInfo.participants != null) {
			if (currentChatInfo.participants.self_participant != null) {
				chatInviterId = currentChatInfo.participants.self_participant.inviter_id
				return
			}

			val selfId = userConfig.getClientUserId()
			var a = 0
			val N = currentChatInfo.participants.participants.size

			while (a < N) {
				val participant = currentChatInfo.participants.participants[a]

				if (participant.user_id == selfId) {
					chatInviterId = participant.inviter_id
					return
				}

				a++
			}
		}

		if (load && chatInviterId == 0L) {
			messagesController.checkChatInviter(currentChat.id, false)
		}
	}

	private fun hideUndoViews() {
		undoView?.hide(true, 0)
		pinBulletin?.hide(false, 0)
		topUndoView?.hide(true, 0)
	}

	private fun isAiBot(): Boolean {
		return currentUser?.bot == true && dialogId != BuildConfig.SUPPORT_BOT_ID
	}

	private fun isBot(): Boolean {
		return currentUser?.bot == true
	}

	val otherSameChatsDiff: Int
		get() {
			val parentLayout = parentLayout

			if (parentLayout?.fragmentsStack == null) {
				return 0
			}

			var cur = parentLayout.fragmentsStack.indexOf(this)

			if (cur == -1) {
				cur = parentLayout.fragmentsStack.size
			}

			var i = cur

			for (a in parentLayout.fragmentsStack.indices) {
				val fragment = parentLayout.fragmentsStack[a]

				if (fragment !== this && fragment is ChatActivity) {
					if (fragment.dialogId == dialogId) {
						i = a
						break
					}
				}
			}

			return i - cur
		}

	override fun onFragmentDestroy() {
		super.onFragmentDestroy()

		if (ioScope.isActive) {
			ioScope.cancel()
		}

		if (mainScope.isActive) {
			mainScope.cancel()
		}

		chatActivityEnterView?.onDestroy()
		avatarContainer?.onDestroy()
		mentionContainer?.adapter?.onDestroy()
		chatAttachAlert?.dismissInternal()

		notificationCenter.onAnimationFinish(transitionAnimationIndex)
		notificationCenter.onAnimationFinish(scrollAnimationIndex)
		notificationCenter.onAnimationFinish(scrollCallbackAnimationIndex)

		hideUndoViews()

		if (chatInviteRunnable != null) {
			AndroidUtilities.cancelRunOnUIThread(chatInviteRunnable)
			chatInviteRunnable = null
		}

		notificationCenter.removePostponeNotificationsCallback(postponeNotificationsWhileLoadingCallback)

		messagesController.setLastCreatedDialogId(dialogId, chatMode == MODE_SCHEDULED, false)

		notificationCenter.removeObserver(this, NotificationCenter.messagesDidLoad)
		notificationCenter.removeObserver(this, NotificationCenter.chatIsBlocked)

		NotificationCenter.globalInstance.removeObserver(this, NotificationCenter.emojiLoaded)
		NotificationCenter.globalInstance.removeObserver(this, NotificationCenter.invalidateMotionBackground)

		notificationCenter.removeObserver(this, NotificationCenter.didUpdateConnectionState)
		notificationCenter.removeObserver(this, NotificationCenter.updateInterfaces)
		notificationCenter.removeObserver(this, NotificationCenter.updateDefaultSendAsPeer)
		notificationCenter.removeObserver(this, NotificationCenter.didReceiveNewMessages)
		notificationCenter.removeObserver(this, NotificationCenter.closeChats)
		notificationCenter.removeObserver(this, NotificationCenter.messagesRead)
		notificationCenter.removeObserver(this, NotificationCenter.threadMessagesRead)
		notificationCenter.removeObserver(this, NotificationCenter.commentsRead)
		notificationCenter.removeObserver(this, NotificationCenter.changeRepliesCounter)
		notificationCenter.removeObserver(this, NotificationCenter.messagesDeleted)
		notificationCenter.removeObserver(this, NotificationCenter.historyCleared)
		notificationCenter.removeObserver(this, NotificationCenter.messageReceivedByServer)
		notificationCenter.removeObserver(this, NotificationCenter.messageReceivedByAck)
		notificationCenter.removeObserver(this, NotificationCenter.messageSendError)
		notificationCenter.removeObserver(this, NotificationCenter.chatInfoDidLoad)
		notificationCenter.removeObserver(this, NotificationCenter.didLoadChatInviter)
		notificationCenter.removeObserver(this, NotificationCenter.groupCallUpdated)
		notificationCenter.removeObserver(this, NotificationCenter.encryptedChatUpdated)
		notificationCenter.removeObserver(this, NotificationCenter.messagesReadEncrypted)
		notificationCenter.removeObserver(this, NotificationCenter.removeAllMessagesFromDialog)
		notificationCenter.removeObserver(this, NotificationCenter.contactsDidLoad)
		notificationCenter.removeObserver(this, NotificationCenter.messagePlayingProgressDidChanged)
		notificationCenter.removeObserver(this, NotificationCenter.messagePlayingDidReset)
		notificationCenter.removeObserver(this, NotificationCenter.screenshotTook)
		notificationCenter.removeObserver(this, NotificationCenter.blockedUsersDidLoad)
		notificationCenter.removeObserver(this, NotificationCenter.fileNewChunkAvailable)
		notificationCenter.removeObserver(this, NotificationCenter.didCreatedNewDeleteTask)
		notificationCenter.removeObserver(this, NotificationCenter.messagePlayingDidStart)
		notificationCenter.removeObserver(this, NotificationCenter.messagePlayingGoingToStop)
		notificationCenter.removeObserver(this, NotificationCenter.updateMessageMedia)
		notificationCenter.removeObserver(this, NotificationCenter.voiceTranscriptionUpdate)
		notificationCenter.removeObserver(this, NotificationCenter.animatedEmojiDocumentLoaded)
		notificationCenter.removeObserver(this, NotificationCenter.replaceMessagesObjects)
		notificationCenter.removeObserver(this, NotificationCenter.notificationsSettingsUpdated)
		notificationCenter.removeObserver(this, NotificationCenter.replyMessagesDidLoad)
		notificationCenter.removeObserver(this, NotificationCenter.didReceivedWebpages)
		notificationCenter.removeObserver(this, NotificationCenter.didReceivedWebpagesInUpdates)
		notificationCenter.removeObserver(this, NotificationCenter.messagesReadContent)
		notificationCenter.removeObserver(this, NotificationCenter.botInfoDidLoad)
		notificationCenter.removeObserver(this, NotificationCenter.botKeyboardDidLoad)
		notificationCenter.removeObserver(this, NotificationCenter.chatSearchResultsAvailable)
		notificationCenter.removeObserver(this, NotificationCenter.chatSearchResultsLoading)
		notificationCenter.removeObserver(this, NotificationCenter.messagePlayingPlayStateChanged)
		notificationCenter.removeObserver(this, NotificationCenter.didUpdateMessagesViews)
		notificationCenter.removeObserver(this, NotificationCenter.chatInfoCantLoad)
		notificationCenter.removeObserver(this, NotificationCenter.didLoadPinnedMessages)
		notificationCenter.removeObserver(this, NotificationCenter.peerSettingsDidLoad)
		notificationCenter.removeObserver(this, NotificationCenter.newDraftReceived)
		notificationCenter.removeObserver(this, NotificationCenter.userInfoDidLoad)
		notificationCenter.removeObserver(this, NotificationCenter.pinnedInfoDidLoad)

		NotificationCenter.globalInstance.removeObserver(this, NotificationCenter.didSetNewWallpapper)
		NotificationCenter.globalInstance.removeObserver(this, NotificationCenter.goingToPreviewTheme)

		notificationCenter.removeObserver(this, NotificationCenter.channelRightsUpdated)
		notificationCenter.removeObserver(this, NotificationCenter.updateMentionsCount)
		notificationCenter.removeObserver(this, NotificationCenter.audioRecordTooShort)
		notificationCenter.removeObserver(this, NotificationCenter.didUpdatePollResults)
		notificationCenter.removeObserver(this, NotificationCenter.didUpdateReactions)
		notificationCenter.removeObserver(this, NotificationCenter.didUpdateExtendedMedia)
		notificationCenter.removeObserver(this, NotificationCenter.chatOnlineCountDidLoad)
		notificationCenter.removeObserver(this, NotificationCenter.videoLoadingStateChanged)
		notificationCenter.removeObserver(this, NotificationCenter.scheduledMessagesUpdated)
		notificationCenter.removeObserver(this, NotificationCenter.diceStickersDidLoad)
		notificationCenter.removeObserver(this, NotificationCenter.dialogDeleted)
		notificationCenter.removeObserver(this, NotificationCenter.chatAvailableReactionsUpdated)
		notificationCenter.removeObserver(this, NotificationCenter.didLoadSponsoredMessages)
		notificationCenter.removeObserver(this, NotificationCenter.didLoadSendAsPeers)
		notificationCenter.removeObserver(this, NotificationCenter.dialogsUnreadReactionsCounterChanged)
		notificationCenter.removeObserver(this, NotificationCenter.groupStickersDidLoad)

		if (currentEncryptedChat != null) {
			notificationCenter.removeObserver(this, NotificationCenter.didVerifyMessagesStickers)
		}

		if (chatMode == 0 && AndroidUtilities.isTablet()) {
			notificationCenter.postNotificationName(NotificationCenter.openedChatChanged, dialogId, true)
		}

		if (currentUser != null) {
			MediaController.getInstance().stopMediaObserver()
		}


		unregisterFlagSecureNoforwards?.run()
		unregisterFlagSecureNoforwards = null

		unregisterFlagSecurePasscode?.run()
		unregisterFlagSecurePasscode = null

		if (currentUser != null) {
			messagesController.cancelLoadFullUser(currentUser!!.id)
		}

		chatBotController.cancelStartChatBot()

		if (isAiBot()) {
			notificationCenter.removeObserver(this, NotificationCenter.aiBotStarted)
			notificationCenter.removeObserver(this, NotificationCenter.aiBotStopped)
			notificationCenter.removeObserver(this, NotificationCenter.aiBotRequestFailed)
			notificationCenter.removeObserver(this, NotificationCenter.aiSubscriptionStatusReceived)
			notificationCenter.removeObserver(this, NotificationCenter.aiSubscriptionSuccess)
		}

		AndroidUtilities.removeAdjustResize(parentActivity, classGuid)

		chatAttachAlert?.onDestroy()

		AndroidUtilities.unlockOrientation(parentActivity)

		if (isChannel(currentChat)) {
			messagesController.startShortPoll(currentChat, classGuid, true)

			if (currentChatInfo != null && currentChatInfo!!.linked_chat_id != 0L) {
				val chat = messagesController.getChat(currentChatInfo!!.linked_chat_id)
				messagesController.startShortPoll(chat, classGuid, true)
			}
		}

		textSelectionHelper.clear()
		chatListItemAnimator?.onDestroy()
		pinchToZoomHelper?.clear()

		chatThemeBottomSheet = null

		val parentLayout = getParentLayout()

		if (parentLayout?.fragmentsStack != null) {
			clearPulledDialogs(this, parentLayout.fragmentsStack.indexOf(this) - if (replacingChatActivity) 0 else 1)
		}

		replacingChatActivity = false
	}

	override fun createView(context: Context): View? {
		actionBarBackgroundPaint.color = context.getColor(R.color.background)

		if (chatMessageCellsCache.isEmpty()) {
			for (a in 0..14) {
				chatMessageCellsCache.add(ChatMessageCell(context))
			}
		}

		for (a in 1 downTo 0) {
			selectedMessagesIds[a].clear()
			selectedMessagesCanCopyIds[a].clear()
			selectedMessagesCanStarIds[a].clear()
		}

		scheduledOrNoSoundHint = null
		infoTopView = null
		aspectRatioFrameLayout = null
		videoTextureView = null
		searchAsListHint = null
		mediaBanTooltip = null
		noSoundHintView = null
		forwardHintView = null
		checksHintView = null
		textSelectionHint = null
		emojiButtonRed = null
		gifHintTextView = null
		emojiHintTextView = null
		pollHintView = null
		timerHintView = null
		videoPlayerContainer = null
		voiceHintTextView = null
		blurredView = null
		dummyMessageCell = null
		cantDeleteMessagesCount = 0
		canEditMessagesCount = 0
		cantForwardMessagesCount = 0
		canForwardMessagesCount = 0
		cantSaveMessagesCount = 0
		canSaveMusicCount = 0
		canSaveDocumentsCount = 0
		hasOwnBackground = true


		runCatching {
			if (chatAttachAlert?.isShowing == true) {
				chatAttachAlert?.dismiss()
			}
		}

		chatAttachAlert?.onDestroy()
		chatAttachAlert = null

		Theme.createChatResources(context, false)

		actionBar?.setAddToContainer(false)

		if (inPreviewMode) {
			actionBar?.setBackButtonDrawable(null)
		}
		else {
			actionBar?.setBackButtonDrawable(ResourcesCompat.getDrawable(context.resources, R.drawable.ic_back_arrow, null))
		}

		actionBar?.setActionBarMenuOnItemClick(object : ActionBarMenuOnItemClick() {
			override fun onItemClick(id: Int) {
				when (id) {
					ActionBar.BACK_BUTTON -> {
						if (actionBar?.isActionModeShowed == true) {
							clearSelectionMode()
						}
						else {
							if (!checkRecordLocked(true)) {
								finishFragment()
							}
						}
					}

					copy -> {
						val str = SpannableStringBuilder()
						var previousUid: Long = 0

						for (a in 1 downTo 0) {
							val ids = mutableListOf<Int>()

							for (b in 0 until selectedMessagesCanCopyIds[a].size()) {
								ids.add(selectedMessagesCanCopyIds[a].keyAt(b))
							}

							if (currentEncryptedChat == null) {
								ids.sort()
							}
							else {
								ids.sortDescending()
							}

							for (b in ids.indices) {
								val messageId = ids[b]
								val messageObject = selectedMessagesCanCopyIds[a][messageId]

								if (str.isNotEmpty()) {
									str.append("\n\n")
								}

								str.append(getMessageContent(messageObject, previousUid, ids.size != 1 && (currentUser == null || !currentUser!!.self)))

								previousUid = messageObject.fromChatId
							}
						}

						if (str.isNotEmpty()) {
							AndroidUtilities.addToClipboard(str)
							undoView!!.showWithAction(0, UndoView.ACTION_TEXT_COPIED, null)
						}

						clearSelectionMode()
					}

					delete -> {
						if (parentActivity == null) {
							return
						}

						createDeleteMessagesAlert(null, null)
					}

					forward -> {
						openForward(true)
					}

					save_to -> {
						val messageObjects = mutableListOf<MessageObject>()

						for (a in 1 downTo 0) {
							for (b in 0 until selectedMessagesIds[a].size()) {
								messageObjects.add(selectedMessagesIds[a].valueAt(b))
							}

							selectedMessagesIds[a].clear()

							selectedMessagesCanCopyIds[a].clear()
							selectedMessagesCanStarIds[a].clear()
						}

						val isMusic = canSaveMusicCount > 0

						hideActionMode()
						updatePinnedMessageView(true)
						updateVisibleRows()

						MediaController.saveFilesFromMessages(parentActivity, accountInstance, messageObjects) { count ->
							if (count > 0) {
								if (parentActivity == null) {
									return@saveFilesFromMessages
								}

								BulletinFactory.of(this@ChatActivity).createDownloadBulletin(if (isMusic) FileType.AUDIOS else FileType.UNKNOWNS, count).show()
							}
						}
					}

					chat_enc_timer -> {
						val parentActivity = parentActivity
						val currentEncryptedChat = currentEncryptedChat

						if (parentActivity != null && currentEncryptedChat != null) {
							showDialog(AlertsCreator.createTTLAlert(parentActivity, currentEncryptedChat).create())
						}
					}

					clear_history, delete_chat, auto_delete_timer -> {
						val canDeleteHistory = currentChatInfo?.can_delete_channel == true

						if (id == auto_delete_timer || id == clear_history && currentEncryptedChat == null && (currentUser != null && !isUserSelf(currentUser) && !isDeleted(currentUser) || currentChatInfo != null && currentChatInfo!!.can_delete_channel)) {
							AlertsCreator.createClearDaysDialogAlert(this@ChatActivity, -1, currentUser, currentChat, canDeleteHistory) { revoke: Boolean ->
								if (revoke && (currentUser != null || canDeleteHistory)) {
									messagesStorage.getMessagesCount(dialogId) { count: Int ->
										if (count >= 50) {
											AlertsCreator.createClearOrDeleteDialogAlert(this@ChatActivity, clear = true, admin = false, second = true, chat = currentChat, user = currentUser, secret = false, checkDeleteForAll = false, canDeleteHistory = canDeleteHistory) {
												performHistoryClear(true)
											}
										}
										else {
											performHistoryClear(true)
										}
									}
								}
								else {
									performHistoryClear(revoke)
								}
							}

							return
						}
						AlertsCreator.createClearOrDeleteDialogAlert(this@ChatActivity, id == clear_history, currentChat, currentUser, currentEncryptedChat != null, true, canDeleteHistory) { param ->
							if (id == clear_history && isChannel(currentChat) && (!currentChat!!.megagroup || !TextUtils.isEmpty(currentChat!!.username))) {
								messagesController.deleteDialog(dialogId, 2, param)
							}
							else {
								if (id != clear_history) {
									notificationCenter.removeObserver(this@ChatActivity, NotificationCenter.closeChats)
									notificationCenter.postNotificationName(NotificationCenter.closeChats)

									finishFragment()

									notificationCenter.postNotificationName(NotificationCenter.needDeleteDialog, dialogId, currentUser, currentChat, param)
								}
								else {
									performHistoryClear(param)
								}
							}
						}
					}

					share_contact -> {
						val currentUser = currentUser ?: return

						if (parentActivity == null) {
							return
						}

						if (addToContactsButton?.tag != null) {
							shareMyContact(addToContactsButton!!.tag as Int, null)
						}
						else {
							val args = Bundle()
							args.putLong("user_id", currentUser.id)
							args.putBoolean("addContact", true)

							presentFragment(ContactAddActivity(args))
						}
					}

					mute -> {
						toggleMute(false)
					}

					add_shortcut -> {
						try {
							mediaDataController.installShortcut(currentUser!!.id)
						}
						catch (e: Exception) {
							FileLog.e(e)
						}
					}

					report -> {
						AlertsCreator.createReportAlert(parentActivity, dialogId, 0, this@ChatActivity, null)
					}

					star -> {
						for (a in 0..1) {
							for (b in 0 until selectedMessagesCanStarIds[a].size()) {
								val msg = selectedMessagesCanStarIds[a].valueAt(b)
								mediaDataController.addRecentSticker(MediaDataController.TYPE_FAVE, msg, msg.document!!, (System.currentTimeMillis() / 1000).toInt(), !hasUnfavedSelected)
							}
						}

						clearSelectionMode()
					}

					edit -> {
						var messageObject: MessageObject? = null

						for (a in 1 downTo 0) {
							if (messageObject == null && selectedMessagesIds[a].size() == 1) {
								val ids = mutableListOf<Int>()

								for (b in 0 until selectedMessagesIds[a].size()) {
									ids.add(selectedMessagesIds[a].keyAt(b))
								}

								messageObject = messagesDict[a][ids[0]]
							}

							selectedMessagesIds[a].clear()
							selectedMessagesCanCopyIds[a].clear()
							selectedMessagesCanStarIds[a].clear()
						}

						startEditingMessageObject(messageObject)
						hideActionMode()
						updatePinnedMessageView(true)
						updateVisibleRows()
					}

					chat_menu_attach -> {
						val attach = ActionBarMenuSubItem(context, needCheck = false, top = true, bottom = true)
						attach.setTextAndIcon(context.getString(R.string.AttachMenu), R.drawable.input_attach)

						attach.setOnClickListener {
							headerItem?.closeSubMenu()
							chatAttachAlert?.setEditingMessageObject(null)
							openAttachMenu()
						}

						headerItem?.toggleSubMenu(attach, attachItem)
					}

					bot_help -> {
						sendMessagesHelper.sendMessage("/help", dialogId, null, null, null, false, null, null, null, true, 0, null, updateStickersOrder = false, isMediaSale = false, mediaSaleHash = null)
					}

					bot_settings -> {
						sendMessagesHelper.sendMessage("/settings", dialogId, null, null, null, false, null, null, null, true, 0, null, updateStickersOrder = false, isMediaSale = false, mediaSaleHash = null)
					}

					search -> {
						openSearchWithText(null)
					}

					call, video_call -> {
						if (currentUser != null && parentActivity != null) {
							startCall(currentUser!!, id == video_call, currentUserInfo != null && currentUserInfo!!.video_calls_available, parentActivity!!, messagesController.getUserFull(currentUser!!.id), accountInstance)
						}
					}

					text_bold -> {
						chatActivityEnterView?.editField?.setSelectionOverride(editTextStart, editTextEnd)
						chatActivityEnterView?.editField?.makeSelectedBold()
					}

					text_italic -> {
						chatActivityEnterView?.editField?.setSelectionOverride(editTextStart, editTextEnd)
						chatActivityEnterView?.editField?.makeSelectedItalic()
					}

					text_spoiler -> {
						chatActivityEnterView?.editField?.setSelectionOverride(editTextStart, editTextEnd)
						chatActivityEnterView?.editField?.makeSelectedSpoiler()
					}

					text_mono -> {
						chatActivityEnterView?.editField?.setSelectionOverride(editTextStart, editTextEnd)
						chatActivityEnterView?.editField?.makeSelectedMono()
					}

					text_strike -> {
						chatActivityEnterView?.editField?.setSelectionOverride(editTextStart, editTextEnd)
						chatActivityEnterView?.editField?.makeSelectedStrike()
					}

					text_underline -> {
						chatActivityEnterView?.editField?.setSelectionOverride(editTextStart, editTextEnd)
						chatActivityEnterView?.editField?.makeSelectedUnderline()
					}

					text_link -> {
						chatActivityEnterView?.editField?.setSelectionOverride(editTextStart, editTextEnd)
						chatActivityEnterView?.editField?.makeSelectedUrl()
					}

					text_regular -> {
						chatActivityEnterView?.editField?.setSelectionOverride(editTextStart, editTextEnd)
						chatActivityEnterView?.editField?.makeSelectedRegular()
					}

					change_colors -> {
						showChatThemeBottomSheet()
					}
				}
			}
		})

		// MARK: uncomment to enable popup menu on back button
//		View backButton = actionBar.getBackButton();
//		backButton.setOnLongClickListener(e -> {
//			scrimPopupWindow = BackButtonMenu.show(this, backButton, dialog_id);
//			if (scrimPopupWindow != null) {
//				scrimPopupWindow.setOnDismissListener(() -> {
//					scrimPopupWindow = null;
//					menuDeleteItem = null;
//					scrimPopupWindowItems = null;
//					chatLayoutManager.setCanScrollVertically(true);
//					if (scrimPopupWindowHideDimOnDismiss) {
//						dimBehindView(false);
//					}
//					else {
//						scrimPopupWindowHideDimOnDismiss = true;
//					}
//					if (chatActivityEnterView != null) {
//						chatActivityEnterView.getEditField().setAllowDrawCursor(true);
//					}
//				});
//				chatListView.stopScroll();
//				chatLayoutManager.setCanScrollVertically(false);
//				dimBehindView(backButton, 0.3f);
//				hideHints(false);
//				if (topUndoView != null) {
//					topUndoView.hide(true, 1);
//				}
//				if (undoView != null) {
//					undoView.hide(true, 1);
//				}
//				if (chatActivityEnterView != null) {
//					chatActivityEnterView.getEditField().setAllowDrawCursor(false);
//				}
//				return true;
//			}
//			else {
//				return false;
//			}
//		});

		actionBar?.setInterceptTouchEventListener { _, _ ->
			if (chatThemeBottomSheet != null) {
				chatThemeBottomSheet?.close()
				return@setInterceptTouchEventListener true
			}

			false
		}

		avatarContainer?.onDestroy()

		avatarContainer = ChatAvatarContainer(context, this, currentEncryptedChat != null)
		avatarContainer?.allowShorterStatus = true
		avatarContainer?.premiumIconHidable = true

		AndroidUtilities.updateViewVisibilityAnimated(avatarContainer, true, 1f, false)

		if (inPreviewMode || inBubbleMode) {
			avatarContainer?.setOccupyStatusBar(false)
		}

		if (reportType >= 0) {
			when (reportType) {
				AlertsCreator.REPORT_TYPE_SPAM -> {
					actionBar?.setTitle(context.getString(R.string.ReportChatSpam))
				}

				AlertsCreator.REPORT_TYPE_VIOLENCE -> {
					actionBar?.setTitle(context.getString(R.string.ReportChatViolence))
				}

				AlertsCreator.REPORT_TYPE_CHILD_ABUSE -> {
					actionBar?.setTitle(context.getString(R.string.ReportChatChild))
				}

				AlertsCreator.REPORT_TYPE_PORNOGRAPHY -> {
					actionBar?.setTitle(context.getString(R.string.ReportChatPornography))
				}

				AlertsCreator.REPORT_TYPE_ILLEGAL_DRUGS -> {
					actionBar?.setTitle(context.getString(R.string.ReportChatIllegalDrugs))
				}

				AlertsCreator.REPORT_TYPE_PERSONAL_DETAILS -> {
					actionBar?.setTitle(context.getString(R.string.ReportChatPersonalDetails))
				}
			}

			actionBar?.setSubtitle(context.getString(R.string.ReportSelectMessages))
		}
		else if (startLoadFromDate != 0) {
			val date = startLoadFromDate

			actionBar?.setOnClickListener {
				jumpToDate(date)
			}

			actionBar?.setTitle(LocaleController.formatDateChat(startLoadFromDate.toLong(), false))
			actionBar?.setSubtitle(context.getString(R.string.Loading))

			val gh1 = TL_messages_getHistory()
			gh1.peer = messagesController.getInputPeer(dialogId)
			gh1.offset_date = startLoadFromDate
			gh1.limit = 1
			gh1.add_offset = -1

			val req = connectionsManager.sendRequest(gh1) { response, _ ->
				if (response is messages_Messages) {
					val l: List<Message> = response.messages

					if (l.isNotEmpty()) {
						val gh2 = TL_messages_getHistory()
						gh2.peer = messagesController.getInputPeer(dialogId)
						gh2.offset_date = startLoadFromDate + 60 * 60 * 24
						gh2.limit = 1

						connectionsManager.sendRequest(gh2) { response1, _ ->
							if (response1 is messages_Messages) {
								val l2: List<Message> = response1.messages

								val count = if (l2.isNotEmpty()) {
									response.offset_id_offset - response1.offset_id_offset
								}
								else {
									response.offset_id_offset
								}

								AndroidUtilities.runOnUIThread {
									if (count != 0) {
										actionBar?.setSubtitle(LocaleController.formatPluralString("messages", count))
									}
									else {
										actionBar?.setSubtitle(context.getString(R.string.NoMessagesForThisDay))
									}
								}
							}
						}
					}
					else {
						AndroidUtilities.runOnUIThread {
							actionBar?.setSubtitle(context.getString(R.string.NoMessagesForThisDay))
						}
					}
				}
			}

			connectionsManager.bindRequestToGuid(req, classGuid)
		}
		else {
			actionBar?.addView(avatarContainer, 0, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT.toFloat(), Gravity.TOP or Gravity.LEFT, (if (!inPreviewMode) 56 else if (chatMode == MODE_PINNED) 10 else 0).toFloat(), 0f, 40f, 0f))
		}

		val menu = actionBar!!.createMenu()

		if (currentEncryptedChat == null && chatMode == 0 && reportType < 0) {
			searchIconItem = menu.addItem(search, R.drawable.ic_search_menu)
			searchIconItem?.contentDescription = context.getString(R.string.Search)

			searchItem = menu.addItem(0, R.drawable.ic_search_menu).setIsSearchField(true).setActionBarMenuItemSearchListener(object : ActionBarMenuItemSearchListener() {
				var searchWas = false

				override fun canCollapseSearch(): Boolean {
					if (messagesSearchListView?.tag != null) {
						showMessagesSearchListView(false)
						return false
					}

					return true
				}

				override fun onSearchCollapse() {
					searchCalendarButton?.visible()
					searchUserButton?.visible()

					if (searchingForUser) {
						mentionContainer?.adapter?.searchUsernameOrHashtag(null, 0, null, usernameOnly = false, forSearch = true)
						searchingForUser = false
					}

					mentionContainer?.isReversed = false
					mentionContainer?.adapter?.setSearchingMentions(false)

					searchingUserMessages = null
					searchingChatMessages = null

					searchItem?.setSearchFieldHint(context.getString(R.string.Search))
					searchItem?.setSearchFieldCaption(null)

					AndroidUtilities.updateViewVisibilityAnimated(avatarContainer, true, 0.95f, true)

					if (editTextItem != null && editTextItem!!.tag != null) {
						headerItem?.gone()
						editTextItem?.visible()
						attachItem?.gone()

						if (showSearchAsIcon) {
							searchIconItem?.gone()
						}

						if (showAudioCallAsIcon) {
							audioCallIconItem?.gone()
						}
					}
					else if (chatActivityEnterView!!.hasText() && TextUtils.isEmpty(chatActivityEnterView!!.getSlowModeTimer()) && (currentChat == null || canSendMessages(currentChat))) {
						headerItem?.gone()
						editTextItem?.gone()
						attachItem?.visible()

						if (showSearchAsIcon) {
							searchIconItem?.gone()
						}

						if (showAudioCallAsIcon) {
							audioCallIconItem?.gone()
						}
					}
					else {
						headerItem?.visible()

						if (showAudioCallAsIcon) {
							audioCallIconItem?.visible()
						}

						if (showSearchAsIcon) {
							searchIconItem?.visible()
						}

						editTextItem?.gone()
						attachItem?.gone()
					}

					if (threadId == 0 && !isReplyUser(currentUser) || threadMessage != null && threadMessage!!.repliesCount == 0) {
						searchItem?.gone()
					}

					searchItemVisible = false

					mediaDataController.clearFoundMessageObjects()

					messagesSearchAdapter?.notifyDataSetChanged()

					removeSelectedMessageHighlight()
					updateBottomOverlay()
					updatePinnedMessageView(true)
					updateVisibleRows()
				}

				override fun onSearchExpand() {
					if (threadId != 0 || isReplyUser(currentUser)) {
						openSearchWithText(null)
					}

					if (!openSearchKeyboard) {
						return
					}

					saveKeyboardPositionBeforeTransition()
					AndroidUtilities.requestAdjustResize(parentActivity, classGuid)

					AndroidUtilities.runOnUIThread({
						searchWas = false
						searchItem?.searchField?.requestFocus()
						AndroidUtilities.showKeyboard(searchItem?.searchField)
						removeKeyboardPositionBeforeTransition()
					}, 500)
				}

				override fun onSearchPressed(editText: EditText) {
					searchWas = true
					updateSearchButtons(0, 0, -1)
					mediaDataController.searchMessagesInChat(editText.text.toString(), dialogId, mergeDialogId, classGuid, 0, threadId, searchingUserMessages, searchingChatMessages)
				}

				override fun onTextChanged(editText: EditText) {
					showMessagesSearchListView(false)

					if (searchingForUser) {
						mentionContainer?.adapter?.searchUsernameOrHashtag("@" + editText.text.toString(), 0, messages, usernameOnly = true, forSearch = true)
					}
					else if (searchingUserMessages == null && searchingChatMessages == null && searchUserButton != null && TextUtils.equals(editText.text, context.getString(R.string.SearchFrom))) {
						searchUserButton?.callOnClick()
					}
				}

				override fun onCaptionCleared() {
					if (searchingUserMessages != null || searchingChatMessages != null) {
						searchUserButton?.callOnClick()
					}
					else {
						if (searchingForUser) {
							mentionContainer?.adapter?.searchUsernameOrHashtag(null, 0, null, usernameOnly = false, forSearch = true)
							searchingForUser = false
							searchItem?.setSearchFieldText("", true)
						}

						searchItem?.setSearchFieldHint(context.getString(R.string.Search))

						searchCalendarButton?.visible()
						searchUserButton?.visible()

						searchingUserMessages = null
						searchingChatMessages = null
					}
				}

				override fun forceShowClear(): Boolean {
					return searchingForUser
				}
			})

			searchItem?.setSearchFieldHint(context.getString(R.string.Search))

			if (threadId == 0 && !isReplyUser(currentUser) || threadMessage?.repliesCount == 0) {
				searchItem?.gone()
			}

			searchItemVisible = false
		}

		editTextItem = menu.addItem(0, R.drawable.overflow_menu)
		editTextItem?.contentDescription = context.getString(R.string.AccDescrMoreOptions)
		editTextItem?.tag = null
		editTextItem?.gone()
		editTextItem?.addSubItem(text_spoiler, context.getString(R.string.Spoiler))

		var stringBuilder = SpannableStringBuilder(context.getString(R.string.Bold))
		stringBuilder.setSpan(TypefaceSpan(Theme.TYPEFACE_BOLD), 0, stringBuilder.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

		editTextItem?.addSubItem(text_bold, stringBuilder)

		stringBuilder = SpannableStringBuilder(context.getString(R.string.Italic))
		stringBuilder.setSpan(TypefaceSpan(Theme.TYPEFACE_ITALIC), 0, stringBuilder.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

		editTextItem?.addSubItem(text_italic, stringBuilder)

		stringBuilder = SpannableStringBuilder(context.getString(R.string.Mono))
		stringBuilder.setSpan(TypefaceSpan(Theme.TYPEFACE_MONOSPACE), 0, stringBuilder.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

		editTextItem?.addSubItem(text_mono, stringBuilder)

		if (currentEncryptedChat == null || AndroidUtilities.getPeerLayerVersion(currentEncryptedChat!!.layer) >= 101) {
			stringBuilder = SpannableStringBuilder(context.getString(R.string.Strike))

			var run = TextStyleRun()
			run.styleFlags = run.styleFlags or TextStyleSpan.FLAG_STYLE_STRIKE

			stringBuilder.setSpan(TextStyleSpan(run), 0, stringBuilder.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

			editTextItem?.addSubItem(text_strike, stringBuilder)

			stringBuilder = SpannableStringBuilder(context.getString(R.string.Underline))

			run = TextStyleRun()
			run.styleFlags = run.styleFlags or TextStyleSpan.FLAG_STYLE_UNDERLINE

			stringBuilder.setSpan(TextStyleSpan(run), 0, stringBuilder.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

			editTextItem?.addSubItem(text_underline, stringBuilder)
		}

		editTextItem?.addSubItem(text_link, context.getString(R.string.CreateLink))
		editTextItem?.addSubItem(text_regular, context.getString(R.string.Regular))

		if (chatMode == 0 && threadId == 0 && !isReplyUser(currentUser) && reportType < 0) {
			var userFull: UserFull? = null

			if (currentUser != null && !currentUser!!.self && currentUser!!.id != 333000L && currentUser!!.id != 777000L && currentUser!!.id != 42777L) {
				audioCallIconItem = menu.addItem(call, R.drawable.chat_calls_voice)
				audioCallIconItem?.contentDescription = context.getString(R.string.Call)

				userFull = messagesController.getUserFull(currentUser!!.id)

				if (userFull != null && userFull.phone_calls_available) {
					showAudioCallAsIcon = !inPreviewMode
					audioCallIconItem?.visible()
				}
				else {
					showAudioCallAsIcon = false
					audioCallIconItem?.gone()
				}

				avatarContainer?.setTitleExpand(showAudioCallAsIcon)
			}

			if (currentUser?.id != 333000L && currentUser?.id != 777000L && currentUser?.id != 42777L) {
				val headerItem = menu.addItem(0, R.drawable.overflow_menu).also {
					this@ChatActivity.headerItem = it
				}

				headerItem.contentDescription = context.getString(R.string.AccDescrMoreOptions)

				if (currentUser?.self != true) {
					chatNotificationsPopupWrapper = ChatNotificationsPopupWrapper(context, currentAccount, headerItem.getPopupLayout()!!.swipeBack, false, object : ChatNotificationsPopupWrapper.Callback {
						override fun dismiss() {
							headerItem.toggleSubMenu()
						}

						override fun toggleSound() {
							val preferences = MessagesController.getNotificationsSettings(currentAccount)
							val enabled = !preferences.getBoolean("sound_enabled_$dialogId", true)

							preferences.edit().putBoolean("sound_enabled_$dialogId", enabled).commit()

							if (BulletinFactory.canShowBulletin(this@ChatActivity)) {
								BulletinFactory.createSoundEnabledBulletin(this@ChatActivity, if (enabled) NotificationsController.SETTING_SOUND_ON else NotificationsController.SETTING_SOUND_OFF).show()
							}

							updateTitleIcons()
						}

						override fun muteFor(timeInSeconds: Int) {
							if (timeInSeconds == 0) {
								if (messagesController.isDialogMuted(dialogId)) {
									this@ChatActivity.toggleMute(true)
								}

								if (BulletinFactory.canShowBulletin(this@ChatActivity)) {
									BulletinFactory.createMuteBulletin(this@ChatActivity, NotificationsController.SETTING_MUTE_UNMUTE, timeInSeconds).show()
								}
							}
							else {
								notificationsController.muteUntil(dialogId, timeInSeconds)

								if (BulletinFactory.canShowBulletin(this@ChatActivity)) {
									BulletinFactory.createMuteBulletin(this@ChatActivity, NotificationsController.SETTING_MUTE_CUSTOM, timeInSeconds).show()
								}
							}
						}

						override fun showCustomize() {
							if (dialogId != 0L) {
								if (currentUser != null) {
									messagesController.putUser(currentUser, true)
								}

								val args = Bundle()
								args.putLong("dialog_id", dialogId)

								presentFragment(ProfileNotificationsActivity(args))
							}
						}

						override fun toggleMute() {
							this@ChatActivity.toggleMute(true)
							BulletinFactory.createMuteBulletin(this@ChatActivity, messagesController.isDialogMuted(dialogId)).show()
						}
					})

					muteItem = headerItem.addSwipeBackItem(R.drawable.msg_mute, null, null, chatNotificationsPopupWrapper!!.windowLayout)

					muteItem?.setOnClickListener {
						val muted = MessagesController.getInstance(currentAccount).isDialogMuted(dialogId)

						if (muted) {
							updateTitleIcons(true)

							AndroidUtilities.runOnUIThread({
								toggleMute(true)
							}, 150)

							headerItem.toggleSubMenu()

							BulletinFactory.createMuteBulletin(this@ChatActivity, false).show()
						}
						else {
							muteItem?.openSwipeBack()
						}
					}

					muteItemGap = headerItem.addColoredGap()
				}

				if (currentUser != null && currentUser?.self != true) {
					headerItem.addSubItem(call, R.drawable.msg_callback, context.getString(R.string.Call))

					// MARK: uncomment to enable video calls
					// headerItem.addSubItem(video_call, R.drawable.msg_videocall, getContext().getString(R.string.VideoCall));

					if (userFull != null && userFull.phone_calls_available) {
						headerItem.showSubItem(call)

						// MARK: uncomment to enable video calls
//					if (userFull.video_calls_available) {
//						headerItem.showSubItem(video_call);
//					}
//					else {
						headerItem.hideSubItem(video_call)
						//					}
					}
					else {
						headerItem.hideSubItem(call)
						headerItem.hideSubItem(video_call)
					}
				}

				if (searchItem != null) {
					headerItem.addSubItem(search, R.drawable.ic_search_menu, context.getString(R.string.Search))
				}

				if (currentChat != null && currentChat?.creator != true && !hasAdminRights(currentChat)) {
					headerItem.addSubItem(report, R.drawable.ic_error, context.getString(R.string.ReportChat))
				}

				if (currentUser != null && currentUser?.self != true) {
					addContactItem = headerItem.addSubItem(share_contact, R.drawable.msg_addcontact, "")
				}
				if (currentEncryptedChat != null) {
					timeItem2 = headerItem.addSubItem(chat_enc_timer, R.drawable.msg_autodelete, context.getString(R.string.SetTimer))
				}

				if (!isBot() && currentUser?.id != 333000L && currentUser?.id != 777000L && currentUser?.id != 42777L) {
					if (!isChannel(currentChat)) { // MARK: remove this check to enable clearing history for all channel types
						clearHistoryItem = headerItem.addSubItem(clear_history, R.drawable.msg_clear, context.getString(R.string.ClearHistory))
					}
				}

				if (isChannel(currentChat) && currentChat?.creator != true) {
					if (!isNotInChat(currentChat)) {
						val leaveItem = if (currentChat?.megagroup == true) {
							headerItem.addSubItem(delete_chat, R.drawable.msg_leave, context.getString(R.string.LeaveMegaMenu))
						}
						else {
							headerItem.addSubItem(delete_chat, R.drawable.msg_leave, context.getString(R.string.LeaveChannelMenu))
						}

						leaveItem.setColors(ResourcesCompat.getColor(context.resources, R.color.purple, null), ResourcesCompat.getColor(context.resources, R.color.purple, null))
					}
				}
				else if (!isChannel(currentChat)) {
					if (currentChat != null) {
						val leaveItem = headerItem.addSubItem(delete_chat, R.drawable.msg_leave, context.getString(R.string.DeleteAndExit))
						leaveItem.setColors(ResourcesCompat.getColor(context.resources, R.color.purple, null), ResourcesCompat.getColor(context.resources, R.color.purple, null))
					}
					else if (currentUser?.self != true && !isBot() && currentUser?.id != 333000L && currentUser?.id != 777000L && currentUser?.id != 42777L) {
						val deleteItem = headerItem.addSubItem(delete_chat, R.drawable.msg_delete, context.getString(R.string.DeleteChatUser))
						deleteItem.setColors(ResourcesCompat.getColor(context.resources, R.color.dark, null), ResourcesCompat.getColor(context.resources, R.color.purple, null))
					}
				}

				if (currentUser?.self == true) {
					headerItem.addSubItem(add_shortcut, R.drawable.msg_home, context.getString(R.string.AddShortcut))
				}

				if (currentEncryptedChat == null && currentUser?.bot == true) {
					headerItem.addSubItem(bot_settings, R.drawable.msg_settings_old, context.getString(R.string.BotSettings))
					headerItem.addSubItem(bot_help, R.drawable.msg_help, context.getString(R.string.BotHelp))

					updateBotButtons()
				}
			}
		}

		menu.visibility = if (inMenuMode) View.GONE else View.VISIBLE

		updateTitle(false)

		avatarContainer?.updateOnlineCount()
		avatarContainer?.updateSubtitle()

		updateTitleIcons()

		if (chatMode == 0 && !isThreadChat && reportType < 0) {
			attachItem = menu.addItem(chat_menu_attach, R.drawable.overflow_menu).setOverrideMenuClick(true).setAllowCloseAnimation(false)
			attachItem?.contentDescription = context.getString(R.string.AccDescrMoreOptions)
			attachItem?.visibility = View.GONE
		}

		actionModeViews.clear()

		if (inPreviewMode) {
			headerItem?.alpha = 0.0f
			attachItem?.alpha = 0.0f
		}

		val actionMode = actionBar!!.createActionMode()

		selectedMessagesCountTextView = NumberTextView(actionMode.context)
		selectedMessagesCountTextView?.setTextSize(18)
		selectedMessagesCountTextView?.setTypeface(Theme.TYPEFACE_BOLD)
		selectedMessagesCountTextView?.setTextColor(context.getColor(R.color.text))

		actionMode.addView(selectedMessagesCountTextView, createLinear(0, LayoutHelper.MATCH_PARENT, 1.0f, 65, 0, 0, 0))

		selectedMessagesCountTextView?.setOnTouchListener { _, _ -> true }

		if (currentEncryptedChat == null) {
			actionModeViews.add(actionMode.addItemWithWidth(save_to, R.drawable.msg_download, AndroidUtilities.dp(54f), context.getString(R.string.SaveToMusic)))
			actionModeViews.add(actionMode.addItemWithWidth(edit, R.drawable.msg_edit, AndroidUtilities.dp(54f), context.getString(R.string.Edit)))
			actionModeViews.add(actionMode.addItemWithWidth(star, R.drawable.msg_fave, AndroidUtilities.dp(54f), context.getString(R.string.AddToFavorites)))
			actionModeViews.add(actionMode.addItemWithWidth(copy, R.drawable.msg_copy, AndroidUtilities.dp(54f), context.getString(R.string.Copy)))

			if (!messagesController.isChatNoForwards(currentChat)) {
				actionModeViews.add(actionMode.addItemWithWidth(forward, R.drawable.msg_forward, AndroidUtilities.dp(54f), context.getString(R.string.Forward)))
			}

			val deleteItem = actionMode.addItemWithWidth(delete, R.drawable.msg_delete, AndroidUtilities.dp(54f), context.getString(R.string.Delete))
			deleteItem.setIconColor(ResourcesCompat.getColor(context.resources, R.color.purple, null))

			actionModeViews.add(deleteItem)
		}
		else {
			actionModeViews.add(actionMode.addItemWithWidth(edit, R.drawable.msg_edit, AndroidUtilities.dp(54f), context.getString(R.string.Edit)))
			actionModeViews.add(actionMode.addItemWithWidth(star, R.drawable.msg_fave, AndroidUtilities.dp(54f), context.getString(R.string.AddToFavorites)))
			actionModeViews.add(actionMode.addItemWithWidth(copy, R.drawable.msg_copy, AndroidUtilities.dp(54f), context.getString(R.string.Copy)))

			val deleteItem = actionMode.addItemWithWidth(delete, R.drawable.msg_delete, AndroidUtilities.dp(54f), context.getString(R.string.Delete))
			deleteItem.setIconColor(ResourcesCompat.getColor(context.resources, R.color.purple, null))

			actionModeViews.add(deleteItem)
		}

		val editItem = actionMode.getItem(edit)

		if (editItem != null) {
			editItem.visibility = if (canEditMessagesCount == 1 && selectedMessagesIds[0].size() + selectedMessagesIds[1].size() == 1) View.VISIBLE else View.GONE
		}

		val copyItem = actionMode.getItem(copy)

		if (copyItem != null) {
			copyItem.visibility = if (!messagesController.isChatNoForwards(currentChat) && selectedMessagesCanCopyIds[0].size() + selectedMessagesCanCopyIds[1].size() != 0) View.VISIBLE else View.GONE
		}

		val starItem = actionMode.getItem(star)

		if (starItem != null) {
			starItem.visibility = if (selectedMessagesCanStarIds[0].size() + selectedMessagesCanStarIds[1].size() != 0) View.VISIBLE else View.GONE
		}

		val deleteItem = actionMode.getItem(delete)

		if (deleteItem != null) {
			deleteItem.visibility = if (cantDeleteMessagesCount == 0) View.VISIBLE else View.GONE
		}

		checkActionBarMenu(false)

		fragmentView = object : SizeNotifierFrameLayout(context, parentLayout) {
			val drawTimeAfter = mutableListOf<ChatMessageCell>()
			val drawNamesAfter = mutableListOf<ChatMessageCell>()
			val drawCaptionAfter = mutableListOf<ChatMessageCell>()
			var inputFieldHeight = 0
			var lastHeight = 0
			var lastWidth = 0
			var backgroundPaint: Paint? = null
			var aBackgroundColor = 0

			private var x = 0f
			private var y = 0f
			private var pressTime: Long = 0

			init {
				adjustPanLayoutHelper = object : AdjustPanLayoutHelper(this) {
					override fun onTransitionStart(keyboardVisible: Boolean, contentHeight: Int) {
						wasManualScroll = true
						chatActivityEnterView?.onAdjustPanTransitionStart(keyboardVisible, contentHeight)
						mentionContainer?.onPanTransitionStart()
						mediaBanTooltip?.hide(false)
					}

					override fun onTransitionEnd() {
						chatActivityEnterView?.onAdjustPanTransitionEnd()
						mentionContainer?.onPanTransitionEnd()
					}

					override fun onPanTranslationUpdate(y: Float, progress: Float, keyboardVisible: Boolean) {
						if (getParentLayout() != null && getParentLayout()!!.isPreviewOpenAnimationInProgress) {
							return
						}

						contentPanTranslation = y

						if (chatAttachAlert?.isShowing == true) {
							setNonNoveTranslation(y)
						}
						else {
							actionBar?.translationY = y
							emptyViewContainer?.translationY = y / 2
							progressView?.translationY = y / 2
							contentView?.setBackgroundTranslation(y.toInt())
							instantCameraView?.onPanTranslationUpdate(y)
							blurredView?.drawable?.onPanTranslationUpdate(y)
							setFragmentPanTranslationOffset(y.toInt())
							invalidateChatListViewTopPadding()
							invalidateMessagesVisiblePart()
						}

						chatListView?.invalidate()

						updateBulletinLayout()

						chatActivityEnterView?.onAdjustPanTransitionUpdate(y)
						mentionContainer?.onPanTransitionUpdate(y)
					}

					override fun heightAnimationEnabled(): Boolean {
						val actionBarLayout = getParentLayout()

						if (inPreviewMode || inBubbleMode || AndroidUtilities.isInMultiwindow || actionBarLayout == null || fixedKeyboardHeight > 0) {
							return false
						}

						if (System.currentTimeMillis() - activityResumeTime < 250) {
							return false
						}

						return if (this@ChatActivity === actionBarLayout.lastFragment && actionBarLayout.isTransitionAnimationInProgress || actionBarLayout.isPreviewOpenAnimationInProgress || isPaused || !openAnimationEnded || chatAttachAlert?.isShowing == true) {
							false
						}
						else {
							chatActivityEnterView?.trendingStickersAlert == null || chatActivityEnterView?.trendingStickersAlert?.isShowing == false
						}
					}

					override fun startOffset(): Int {
						val keyboardSize = getKeyboardHeight()

						return if (keyboardSize <= AndroidUtilities.dp(20f) && chatActivityEnterView?.isPopupShowing == true) {
							chatActivityEnterView?.emojiPadding ?: 0
						}
						else {
							0
						}
					}
				}
			}

			override fun drawList(blurCanvas: Canvas, top: Boolean) {
				val clipTop: Float = chatListViewPadding - chatListViewPaddingVisibleOffset - AndroidUtilities.dp(4f)

				for (i in 0 until chatListView!!.childCount) {
					val child = chatListView!!.getChildAt(i)

					if (top && child.y > clipTop + AndroidUtilities.dp(40f)) {
						continue
					}

					if (!top && child.y + child.measuredHeight < AndroidUtilities.dp(203f)) {
						continue
					}

					blurCanvas.save()

					if (top) {
						blurCanvas.translate(chatListView!!.x + child.x, chatListView!!.y + child.y - contentPanTranslation)
					}
					else {
						blurCanvas.translate(chatListView!!.x + child.x, chatListView!!.top + child.y)
					}

					if (child is ChatMessageCell) {
						child.drawForBlur = true

						if (child.drawBackgroundInParent()) {
							child.drawBackgroundInternal(blurCanvas, true)
						}

						child.draw(blurCanvas)

						if (child.hasOutboundContent()) {
							child.drawOutboundContent(blurCanvas)
						}

						child.drawForBlur = false
					}
					else {
						child.draw(blurCanvas)
					}

					blurCanvas.restore()
				}
			}

			override fun getScrollOffset(): Int {
				return chatListView?.computeVerticalScrollOffset() ?: 0
			}

			override fun getBottomOffset(): Float {
				return chatListView?.bottom?.toFloat() ?: 0f
			}

			override fun getListTranslationY(): Float {
				return chatListView?.translationY ?: 0f
			}

			override fun onAttachedToWindow() {
				super.onAttachedToWindow()

				adjustPanLayoutHelper?.onAttach()
				chatActivityEnterView?.adjustPanLayoutHelper = adjustPanLayoutHelper

				val messageObject = MediaController.getInstance().playingMessageObject

				if (messageObject != null && (messageObject.isRoundVideo || messageObject.isVideo) && messageObject.eventId == 0L && messageObject.dialogId == dialogId) {
					MediaController.getInstance().setTextureView(createTextureView(false), aspectRatioFrameLayout, videoPlayerContainer, true)
				}

				pullingDownDrawable?.onAttach()
				emojiAnimationsOverlay?.onAttachedToWindow()
			}

			override fun onDetachedFromWindow() {
				super.onDetachedFromWindow()
				adjustPanLayoutHelper?.onDetach()

				pullingDownDrawable?.onDetach()
				pullingDownDrawable = null

				emojiAnimationsOverlay?.onDetachedFromWindow()

				AndroidUtilities.runOnUIThread {
					ReactionsEffectOverlay.removeCurrent(true)
				}
			}

			override fun dispatchTouchEvent(ev: MotionEvent): Boolean {
				val expandY = if (AndroidUtilities.isInMultiwindow || isInBubbleMode) {
					if (chatActivityEnterView!!.emojiView != null) chatActivityEnterView!!.emojiView!!.y else chatActivityEnterView!!.y
				}
				else {
					chatActivityEnterView!!.y
				}

				if (scrimView != null || chatActivityEnterView != null && chatActivityEnterView!!.isStickersExpanded && ev.y < expandY) {
					return false
				}

				lastTouchY = ev.y

				val selectionOverlay = textSelectionHelper.getOverlayView(context)

				ev.offsetLocation(-selectionOverlay.x, -selectionOverlay.y)

				if (textSelectionHelper.isSelectionMode && textSelectionHelper.getOverlayView(context).onTouchEvent(ev)) {
					return true
				}
				else {
					ev.offsetLocation(selectionOverlay.x, selectionOverlay.y)
				}

				if (selectionOverlay.checkOnTap(ev)) {
					ev.action = MotionEvent.ACTION_CANCEL
				}

				if (ev.action == MotionEvent.ACTION_DOWN && textSelectionHelper.isSelectionMode && (ev.y < chatListView!!.top || ev.y > chatListView!!.bottom)) {
					ev.offsetLocation(-selectionOverlay.x, -selectionOverlay.y)

					return if (textSelectionHelper.getOverlayView(context).onTouchEvent(ev)) {
						ev.offsetLocation(selectionOverlay.x, selectionOverlay.y)
						super.dispatchTouchEvent(ev)
					}
					else {
						true
					}
				}

				if (pinchToZoomHelper!!.isInOverlayMode) {
					return pinchToZoomHelper!!.onTouchEvent(ev)
				}

				if (AvatarPreviewer.hasVisibleInstance()) {
					AvatarPreviewer.getInstance().onTouchEvent(ev)
					return true
				}

				var r = false

				if (isInPreviewMode && allowExpandPreviewByClick) {
					if (ev.action == MotionEvent.ACTION_DOWN) {
						var pressedOnPageDownButtons = false
						val off = IntArray(2)

						getLocationInWindow(off)

						val pos = IntArray(2)

						if (pagedownButton != null) {
							pagedownButton?.getLocationInWindow(pos)

							AndroidUtilities.rectTmp2.set(pos[0] - off[0], pos[1] - off[1], pos[0] - off[0] + pagedownButton!!.measuredWidth, pos[1] - off[1] + pagedownButton!!.measuredHeight)

							if (AndroidUtilities.rectTmp2.contains(ev.x.toInt(), ev.y.toInt())) {
								pressedOnPageDownButtons = true
							}
						}

						if (!pressedOnPageDownButtons && mentiondownButton != null) {
							mentiondownButton?.getLocationInWindow(pos)

							AndroidUtilities.rectTmp2.set(pos[0] - off[0], pos[1] - off[1], pos[0] - off[0] + mentiondownButton!!.measuredWidth, pos[1] - off[1] + mentiondownButton!!.measuredHeight)

							if (AndroidUtilities.rectTmp2.contains(ev.x.toInt(), ev.y.toInt())) {
								pressedOnPageDownButtons = true
							}
						}

						if (!pressedOnPageDownButtons) {
							x = ev.x
							y = ev.y
							pressTime = SystemClock.elapsedRealtime()
							r = true
						}
						else {
							pressTime = -1
						}
					}
					else if (ev.action == MotionEvent.ACTION_UP) {
						if (MathUtils.distance(x, y, ev.x, ev.y) < AndroidUtilities.dp(6f) && SystemClock.elapsedRealtime() - pressTime <= ViewConfiguration.getTapTimeout()) {
							parentLayout?.expandPreviewFragment()
							ev.action = MotionEvent.ACTION_CANCEL
						}

						pressTime = -1
					}
					else if (ev.action == MotionEvent.ACTION_CANCEL) {
						pressTime = -1
					}
				}

				return super.dispatchTouchEvent(ev) || r
			}

			override fun onDraw(canvas: Canvas) {
				if (getTag(BlurBehindDrawable.TAG_DRAWING_AS_BACKGROUND) != null) {
					return
				}

				if (getTag(BlurBehindDrawable.TAG_DRAWING_AS_BACKGROUND) == null && (instantCameraView!!.blurFullyDrawing() || blurredView?.fullyDrawing() == true && blurredView?.tag != null)) {
					return
				}

				super.onDraw(canvas)
			}

			override fun drawChild(canvas: Canvas, child: View, drawingTime: Long): Boolean {
				if ((scrimView != null || messageEnterTransitionContainer?.isRunning == true) && (child === pagedownButton || child === mentiondownButton || child === floatingDateView || child === fireworksOverlay || child === reactionsMentiondownButton || child === gifHintTextView || child === emojiHintTextView || child === undoView || child === topUndoView)) {
					return false
				}

				if (child === fragmentContextView && fragmentContextView?.isCallStyle == true) {
					return true
				}

				if (child === undoView && PhotoViewer.getInstance().isVisible) {
					return true
				}

				if (toPullingDownTransition && child === chatListView) {
					return true
				}

				if (getTag(BlurBehindDrawable.TAG_DRAWING_AS_BACKGROUND) != null) {
					val needBlur = if (getTag(BlurBehindDrawable.TAG_DRAWING_AS_BACKGROUND) as Int == BlurBehindDrawable.STATIC_CONTENT) {
						child === actionBar || child === fragmentContextView || child === pinnedMessageView
					}
					else {
						child === chatListView || child === chatActivityEnterView || chatActivityEnterView!!.isPopupView(child)
					}

					if (!needBlur) {
						return false
					}
				}
				else if (getTag(BlurBehindDrawable.TAG_DRAWING_AS_BACKGROUND) == null && (instantCameraView!!.blurFullyDrawing() || blurredView?.fullyDrawing() == true && blurredView?.tag != null)) {
					val needBlur = child === actionBar || child === chatListView || child === pinnedMessageView || child === fragmentContextView

					if (needBlur) {
						return false
					}
				}

				val result: Boolean
				val messageObject = MediaController.getInstance().playingMessageObject
				var isRoundVideo = false

				val isVideo = messageObject != null && messageObject.eventId == 0L && (messageObject.isRoundVideo.also {
					isRoundVideo = it
				} || messageObject.isVideo)

				if (child === videoPlayerContainer) {
					canvas.save()

					var transitionOffset = 0f

					if (pullingDownAnimateProgress != 0f) {
						transitionOffset = (chatListView!!.measuredHeight - pullingDownOffset) * pullingDownAnimateProgress
					}

					canvas.translate(0f, -pullingDownOffset - transitionOffset)

					if (messageObject != null && messageObject.type == MessageObject.TYPE_ROUND_VIDEO) {
						if (Theme.chat_roundVideoShadow != null && aspectRatioFrameLayout!!.isDrawingReady) {
							val x = child.getX().toInt() - AndroidUtilities.dp(3f)
							val y = child.getY().toInt() - AndroidUtilities.dp(2f)

							canvas.save()
							canvas.scale(videoPlayerContainer?.scaleX ?: 1f, videoPlayerContainer?.scaleY ?: 1f, child.getX(), child.getY())

							Theme.chat_roundVideoShadow.alpha = 255
							Theme.chat_roundVideoShadow.setBounds(x, y, x + AndroidUtilities.roundPlayingMessageSize + AndroidUtilities.dp(6f), y + AndroidUtilities.roundPlayingMessageSize + AndroidUtilities.dp(6f))
							Theme.chat_roundVideoShadow.draw(canvas)

							canvas.restore()
						}

						result = super.drawChild(canvas, child, drawingTime)
					}
					else {
						if (child.getTag() == null) {
							val oldTranslation = child.getTranslationY()

							child.setTranslationY(-AndroidUtilities.dp(1000f).toFloat())

							result = super.drawChild(canvas, child, drawingTime)

							child.setTranslationY(oldTranslation)
						}
						else {
							result = false
						}
					}

					canvas.restore()
				}
				else {
					result = super.drawChild(canvas, child, drawingTime)
					if (isVideo && child === chatListView && messageObject!!.type != 5 && videoPlayerContainer?.tag != null) {

						canvas.save()

						var transitionOffset = 0f

						if (pullingDownAnimateProgress != 0f) {
							transitionOffset = (chatListView!!.measuredHeight - pullingDownOffset) * pullingDownAnimateProgress
						}

						canvas.translate(0f, -pullingDownOffset - transitionOffset + pullingBottomOffset)

						super.drawChild(canvas, videoPlayerContainer, drawingTime)

						if (drawLaterRoundProgressCell != null) {
							canvas.save()
							canvas.translate(drawLaterRoundProgressCell!!.x, drawLaterRoundProgressCell!!.top + chatListView!!.y)

							if (isRoundVideo) {
								drawLaterRoundProgressCell?.drawRoundProgress(canvas)
								invalidate()
								drawLaterRoundProgressCell?.invalidate()
							}
							else {
								drawLaterRoundProgressCell?.drawOverlays(canvas)

								if (drawLaterRoundProgressCell?.needDrawTime() == true) {
									drawLaterRoundProgressCell?.drawTime(canvas, drawLaterRoundProgressCell!!.alpha, true)
								}
							}

							canvas.restore()
						}

						canvas.restore()
					}
				}

				if (child === actionBar && parentLayout != null) {
					parentLayout?.drawHeaderShadow(canvas, if (actionBar!!.visibility == VISIBLE) actionBar!!.translationY.toInt() + actionBar!!.measuredHeight + (if (inPreviewMode) AndroidUtilities.statusBarHeight else 0) else 0)
				}

				return result
			}

			override fun isActionBarVisible(): Boolean {
				return actionBar?.visibility == VISIBLE
			}

			private fun drawChildElement(canvas: Canvas, listTop: Float, cell: ChatMessageCell?, type: Int) {
				val chatListView = chatListView ?: return
				@Suppress("NAME_SHADOWING") val cell = cell ?: return

				canvas.save()

				val canvasOffsetX = (chatListView.left + cell.left).toFloat()
				val canvasOffsetY = chatListView.y + cell.y
				val alpha = if (cell.shouldDrawAlphaLayer()) cell.alpha else 1f

				canvas.clipRect(chatListView.left.toFloat(), listTop, chatListView.right.toFloat(), chatListView.y + chatListView.measuredHeight - blurredViewBottomOffset)
				canvas.translate(canvasOffsetX, canvasOffsetY)

				cell.setInvalidatesParent(true)

				when (type) {
					0 -> {
						cell.drawTime(canvas, alpha, true)
					}

					1 -> {
						cell.drawNamesLayout(canvas, alpha)
					}

					else -> {
						cell.drawCaptionLayout(canvas, cell.currentPosition != null && cell.currentPosition!!.flags and MessageObject.POSITION_FLAG_LEFT == 0, alpha)
					}
				}

				cell.setInvalidatesParent(false)

				canvas.restore()
			}

			override fun dispatchDraw(canvas: Canvas) {
				chatActivityEnterView?.checkAnimation()

				updateChatListViewTopPadding()

				if (invalidateMessagesVisiblePart || chatListItemAnimator?.isRunning == true) {
					invalidateMessagesVisiblePart = false
					updateMessagesVisiblePart(false)
				}

				updateTextureViewPosition(false)
				updatePagedownButtonsPosition()

				super.dispatchDraw(canvas)

				val fragmentContextView = fragmentContextView

				if (fragmentContextView != null && fragmentContextView.isCallStyle) {
					val blurredView = blurredView
					val alpha = if (blurredView != null && blurredView.visibility == VISIBLE) 1f - blurredView.alpha else 1f

					if (alpha > 0) {
						if (alpha == 1f) {
							canvas.save()
						}
						else {
							canvas.saveLayerAlpha(fragmentContextView.x, fragmentContextView.y - AndroidUtilities.dp(30f), fragmentContextView.x + fragmentContextView.measuredWidth, fragmentContextView.y + fragmentContextView.measuredHeight, (255 * alpha).toInt())
						}

						canvas.translate(fragmentContextView.x, fragmentContextView.y)

						fragmentContextView.setDrawOverlay(true)
						fragmentContextView.draw(canvas)
						fragmentContextView.setDrawOverlay(false)

						canvas.restore()
					}
				}

				chatActivityEnterView?.let { chatActivityEnterView ->
					if (chatActivityEnterView.panelAnimationInProgress() && chatActivityEnterView.emojiPadding < bottomPanelTranslationY) {
						val color = context.getColor(R.color.light_background)

						if (backgroundPaint == null) {
							backgroundPaint = Paint()
						}

						if (aBackgroundColor != color) {
							backgroundPaint?.color = color.also { aBackgroundColor = it }
						}

						val offset = (bottomPanelTranslationY - chatActivityEnterView.emojiPadding).toInt() + 3
						canvas.drawRect(0f, (measuredHeight - offset).toFloat(), measuredWidth.toFloat(), measuredHeight.toFloat(), backgroundPaint!!)
						setFragmentPanTranslationOffset(chatActivityEnterView.emojiPadding)
					}
				}

				var a = 0
				val N = animateSendingViews.size

				while (a < N) {
					val cell = animateSendingViews[a]
					val data = cell.getMessageObject()?.sendAnimationData

					if (data != null) {
						canvas.save()

						val imageReceiver = cell.photoImage

						canvas.translate(data.currentX, data.currentY)
						canvas.scale(data.currentScale, data.currentScale)
						canvas.translate(-imageReceiver.centerX, -imageReceiver.centerY)

						cell.timeAlpha = data.timeAlpha

						animateSendingViews[a].draw(canvas)

						canvas.restore()
					}

					a++
				}

				if (scrimViewReaction == null || scrimView == null) {
					scrimPaint.alpha = (255 * scrimPaintAlpha * if (scrimView != null) scrimViewAlpha else 1f).toInt()
					canvas.drawRect(0f, 0f, measuredWidth.toFloat(), measuredHeight.toFloat(), scrimPaint)
				}

				val scrimView = scrimView

				if (scrimView != null) {
					if (scrimView === reactionsMentiondownButton || scrimView === mentiondownButton) {
						if (scrimViewAlpha < 1f) {
							scrimPaint.alpha = (255 * scrimPaintAlpha * (1f - scrimViewAlpha)).toInt()
							canvas.drawRect(0f, 0f, measuredWidth.toFloat(), measuredHeight.toFloat(), scrimPaint)
						}
					}
					else if (scrimView is ImageView) {
						val c = canvas.save()

						if (scrimViewAlpha < 1f) {
							canvas.saveLayerAlpha(scrimView.getLeft().toFloat(), scrimView.getTop().toFloat(), scrimView.getRight().toFloat(), scrimView.getBottom().toFloat(), (255 * scrimViewAlpha).toInt())
						}

						canvas.translate(scrimView.getLeft().toFloat(), scrimView.getTop().toFloat())

						if (scrimView === actionBar!!.backButton) {
							val r = max(scrimView.getMeasuredWidth(), scrimView.getMeasuredHeight()) / 2
							canvas.drawCircle(r.toFloat(), r.toFloat(), r * 0.7f, actionBarBackgroundPaint)
						}

						scrimView.draw(canvas)

						canvas.restoreToCount(c)

						if (scrimViewAlpha < 1f) {
							scrimPaint.alpha = (255 * scrimPaintAlpha * (1f - scrimViewAlpha)).toInt()
							canvas.drawRect(0f, 0f, measuredWidth.toFloat(), measuredHeight.toFloat(), scrimPaint)
						}
					}
					else {
						val listTop: Float = chatListView!!.y + chatListViewPadding - chatListViewPaddingVisibleOffset - AndroidUtilities.dp(4f)

						val scrimGroup = if (scrimView is ChatMessageCell) {
							scrimView.currentMessagesGroup
						}
						else {
							null
						}

						var groupedBackgroundWasDraw = false
						val count = chatListView!!.childCount

						for (num in 0 until count) {
							val child = chatListView!!.getChildAt(num)
							var group: GroupedMessages?
							var position: GroupedMessagePosition?
							var cell: ChatMessageCell?

							if (child is ChatMessageCell) {
								cell = child
								group = cell.currentMessagesGroup
								position = cell.currentPosition
							}
							else {
								position = null
								group = null
								cell = null
							}

							if (child !== scrimView && (scrimGroup == null || scrimGroup != group) || child.alpha == 0f) {
								continue
							}

							if (!groupedBackgroundWasDraw && cell != null && scrimGroup != null && scrimGroup.transitionParams.cell != null) {
								val x = scrimGroup.transitionParams.cell!!.getNonAnimationTranslationX(true)
								val l = scrimGroup.transitionParams.left + x + scrimGroup.transitionParams.offsetLeft
								var t = scrimGroup.transitionParams.top + scrimGroup.transitionParams.offsetTop
								val r = scrimGroup.transitionParams.right + x + scrimGroup.transitionParams.offsetRight
								var b = scrimGroup.transitionParams.bottom + scrimGroup.transitionParams.offsetBottom

								if (!scrimGroup.transitionParams.backgroundChangeBounds) {
									t += scrimGroup.transitionParams.cell!!.translationY
									b += scrimGroup.transitionParams.cell!!.translationY
								}

								if (t < chatListViewPadding - chatListViewPaddingVisibleOffset - AndroidUtilities.dp(20f)) {
									t = chatListViewPadding - chatListViewPaddingVisibleOffset - AndroidUtilities.dp(20f)
								}

								if (b > chatListView!!.measuredHeight + AndroidUtilities.dp(20f)) {
									b = (chatListView!!.measuredHeight + AndroidUtilities.dp(20f)).toFloat()
								}

								var selected = true
								@Suppress("NAME_SHADOWING") var a = 0
								@Suppress("NAME_SHADOWING") val N = scrimGroup.messages.size

								while (a < N) {
									val `object` = scrimGroup.messages[a]
									val index = if (`object`.dialogId == dialogId) 0 else 1

									if (selectedMessagesIds[index].indexOfKey(`object`.id) < 0) {
										selected = false
										break
									}

									a++
								}

								canvas.save()
								canvas.clipRect(0f, listTop + (mentionContainer?.clipTop() ?: 0f), measuredWidth.toFloat(), chatListView!!.y + chatListView!!.measuredHeight - blurredViewBottomOffset - (mentionContainer?.clipBottom() ?: 0f))
								canvas.translate(0f, chatListView!!.y)

								scrimGroup.transitionParams.cell!!.drawBackground(canvas, l.toInt(), t.toInt(), r.toInt(), b.toInt(), scrimGroup.transitionParams.pinnedTop, scrimGroup.transitionParams.pinnedBottom, selected, contentView!!.keyboardHeight)

								canvas.restore()

								groupedBackgroundWasDraw = true
							}

							if (cell != null && cell.photoImage.isAnimationRunning) {
								invalidate()
							}

							var viewClipLeft = chatListView!!.left.toFloat()
							var viewClipTop = listTop
							var viewClipRight = chatListView!!.right.toFloat()
							var viewClipBottom = chatListView!!.y + chatListView!!.measuredHeight - blurredViewBottomOffset

							if (mentionContainer != null) {
								viewClipTop += mentionContainer!!.clipTop()
								viewClipBottom -= mentionContainer!!.clipBottom()
							}

							if (cell == null || !cell.transitionParams.animateBackgroundBoundsInner) {
								viewClipLeft = max(viewClipLeft, chatListView!!.left + child.x)
								viewClipTop = max(viewClipTop, chatListView!!.top + child.y)
								viewClipRight = min(viewClipRight, chatListView!!.left + child.x + child.measuredWidth)
								viewClipBottom = min(viewClipBottom, chatListView!!.y + child.y + child.measuredHeight)
							}

							if (viewClipTop < viewClipBottom) {
								if (child.alpha != 1f) {
									canvas.saveLayerAlpha(viewClipLeft, viewClipTop, viewClipRight, viewClipBottom, (255 * child.alpha).toInt())
								}
								else {
									canvas.save()
								}

								if (cell != null) {
									cell.setInvalidatesParent(true)
									cell.setScrimReaction(scrimViewReaction)
								}

								canvas.clipRect(viewClipLeft, viewClipTop, viewClipRight, viewClipBottom)
								canvas.translate(chatListView!!.left + child.x, chatListView!!.y + child.y)

								if (cell != null && scrimGroup == null && cell.drawBackgroundInParent()) {
									cell.drawBackgroundInternal(canvas, true)
								}

								child.draw(canvas)

								if (cell != null && cell.hasOutboundContent()) {
									cell.drawOutboundContent(canvas)
								}

								canvas.restore()

								if (cell != null) {
									cell.setInvalidatesParent(false)
									cell.setScrimReaction(null)
								}
							}

							if (position != null || cell != null && cell.transitionParams.animateBackgroundBoundsInner) {
								if (position == null || position.last || position.minX.toInt() == 0 && position.minY.toInt() == 0) {
									if (position == null || position.last) {
										if (cell != null) {
											drawTimeAfter.add(cell)
										}
									}

									if (position == null || position.minX.toInt() == 0 && position.minY.toInt() == 0 && cell!!.hasNameLayout()) {
										if (cell != null) {
											drawNamesAfter.add(cell)
										}
									}
								}

								if (position == null || position.flags and MessageObject.POSITION_FLAG_BOTTOM != 0) {
									if (cell != null) {
										drawCaptionAfter.add(cell)
									}
								}
							}

							if (scrimViewReaction != null && cell != null) {
								scrimPaint.alpha = (255 * scrimPaintAlpha * scrimViewAlpha).toInt()

								canvas.drawRect(0f, 0f, measuredWidth.toFloat(), measuredHeight.toFloat(), scrimPaint)

								if (viewClipTop < viewClipBottom) {
									val alpha = child.alpha * scrimViewAlpha

									if (alpha < 1f) {
										canvas.saveLayerAlpha(viewClipLeft, viewClipTop, viewClipRight, viewClipBottom, (255 * alpha).toInt())
									}
									else {
										canvas.save()
									}

									canvas.clipRect(viewClipLeft, viewClipTop, viewClipRight, viewClipBottom)
									canvas.translate(chatListView!!.left + child.x, chatListView!!.y + child.y)

									cell.drawScrimReaction(canvas, scrimViewReaction)

									canvas.restore()
								}
							}
						}

						var size = drawTimeAfter.size

						if (size > 0) {
							for (@Suppress("NAME_SHADOWING") a in 0 until size) {
								drawChildElement(canvas, listTop, drawTimeAfter[a], 0)
							}

							drawTimeAfter.clear()
						}

						size = drawNamesAfter.size

						if (size > 0) {
							for (@Suppress("NAME_SHADOWING") a in 0 until size) {
								drawChildElement(canvas, listTop, drawNamesAfter[a], 1)
							}

							drawNamesAfter.clear()
						}

						size = drawCaptionAfter.size

						if (size > 0) {
							for (@Suppress("NAME_SHADOWING") a in 0 until size) {
								val cell = drawCaptionAfter[a]

								if (cell.currentPosition == null && !cell.transitionParams.animateBackgroundBoundsInner) {
									continue
								}

								drawChildElement(canvas, listTop, cell, 2)
							}

							drawCaptionAfter.clear()
						}
					}

					if (scrimViewReaction == null && scrimViewAlpha < 1f) {
						scrimPaint.alpha = (255 * scrimPaintAlpha * (1f - scrimViewAlpha)).toInt()
						canvas.drawRect(0f, 0f, measuredWidth.toFloat(), measuredHeight.toFloat(), scrimPaint)
					}
				}

				if (scrimView != null || messageEnterTransitionContainer!!.isRunning) {
					if (mentionContainer?.visibility != VISIBLE) {
						if (pagedownButton?.tag != null) {
							super.drawChild(canvas, pagedownButton, SystemClock.uptimeMillis())
						}

						if (mentiondownButton?.tag != null) {
							super.drawChild(canvas, mentiondownButton, SystemClock.uptimeMillis())
						}

						if (reactionsMentiondownButton?.tag != null) {
							super.drawChild(canvas, reactionsMentiondownButton, SystemClock.uptimeMillis())
						}
					}

					if (floatingDateView?.tag != null) {
						super.drawChild(canvas, floatingDateView, SystemClock.uptimeMillis())
					}

					if (fireworksOverlay != null) {
						super.drawChild(canvas, fireworksOverlay, SystemClock.uptimeMillis())
					}

					if (gifHintTextView != null) {
						super.drawChild(canvas, gifHintTextView, SystemClock.uptimeMillis())
					}

					if (emojiHintTextView != null) {
						super.drawChild(canvas, emojiHintTextView, SystemClock.uptimeMillis())
					}

					if (undoView?.visibility == VISIBLE) {
						super.drawChild(canvas, undoView, SystemClock.uptimeMillis())
					}

					if (topUndoView?.visibility == VISIBLE) {
						super.drawChild(canvas, topUndoView, SystemClock.uptimeMillis())
					}
				}

				if (fixedKeyboardHeight > 0 && keyboardHeight < AndroidUtilities.dp(20f)) {
					val color = context.getColor(R.color.background)

					if (backgroundPaint == null) {
						backgroundPaint = Paint()
					}

					if (aBackgroundColor != color) {
						backgroundPaint?.color = color.also { aBackgroundColor = it }
					}

					canvas.drawRect(0f, (measuredHeight - fixedKeyboardHeight).toFloat(), measuredWidth.toFloat(), measuredHeight.toFloat(), backgroundPaint!!)
				}

				if (pullingDownDrawable != null && pullingDownDrawable!!.needDrawBottomPanel()) {
					var top: Int
					val bottom: Int

					if (chatActivityEnterView?.visibility == VISIBLE) {
						top = chatActivityEnterView!!.top + AndroidUtilities.dp2(2f)
						bottom = chatActivityEnterView!!.bottom
					}
					else {
						top = bottomOverlayChat!!.top + AndroidUtilities.dp2(2f)
						bottom = bottomOverlayChat!!.bottom
					}

					top -= ((if (pullingDownAnimateToActivity == null) 0f else pullingDownAnimateToActivity!!.pullingBottomOffset) * pullingDownAnimateProgress).toInt()

					pullingDownDrawable?.drawBottomPanel(canvas, top, bottom, measuredWidth)
				}

				if (pullingDownAnimateToActivity != null) {
					canvas.saveLayerAlpha(0f, 0f, measuredWidth.toFloat(), measuredHeight.toFloat(), (255 * pullingDownAnimateProgress).toInt())
					pullingDownAnimateToActivity?.fragmentView?.draw(canvas)
					canvas.restore()
				}

				emojiAnimationsOverlay?.draw(canvas)
			}

			override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
				val widthSize = MeasureSpec.getSize(widthMeasureSpec)
				val allHeight = MeasureSpec.getSize(heightMeasureSpec)
				var heightSize = allHeight

				if (lastWidth != widthSize) {
					globalIgnoreLayout = true
					lastWidth = widthMeasureSpec

					showSearchAsIcon = if (!inPreviewMode && currentUser != null && currentUser!!.self) {
						val textView = avatarContainer!!.titleTextView
						val textWidth = textView.paint.measureText(textView.getText(), 0, textView.getText().length).toInt()

						if (widthSize - AndroidUtilities.dp((96 + 56).toFloat()) > textWidth + AndroidUtilities.dp(10f)) {
							!showAudioCallAsIcon
						}
						else {
							false
						}
					}
					else {
						false
					}

					if (showSearchAsIcon || showAudioCallAsIcon) {
						(avatarContainer?.layoutParams as? MarginLayoutParams)?.rightMargin = AndroidUtilities.dp(96f)
					}
					else {
						(avatarContainer?.layoutParams as? MarginLayoutParams)?.rightMargin = AndroidUtilities.dp(40f)
					}

					if (showSearchAsIcon) {
						if (actionBar?.isSearchFieldVisible == false) {
							searchIconItem?.visible()
						}

						headerItem?.hideSubItem(search)
					}
					else {
						headerItem?.showSubItem(search)
						searchIconItem?.gone()
					}

					if (!actionBar!!.isSearchFieldVisible) {
						audioCallIconItem?.visibility = if (showAudioCallAsIcon && !showSearchAsIcon) VISIBLE else GONE
					}

					if (headerItem != null) {
						val userInfo = currentUserInfo

						if (showAudioCallAsIcon) {
							headerItem?.hideSubItem(call)
						}
						else if (userInfo != null && userInfo.phone_calls_available) {
							headerItem?.showSubItem(call)
						}
					}

					globalIgnoreLayout = false
				}

				setMeasuredDimension(widthSize, heightSize)

				heightSize -= paddingTop

				measureChildWithMargins(actionBar, widthMeasureSpec, 0, heightMeasureSpec, 0)

				val actionBarHeight = actionBar!!.measuredHeight

				if (actionBar?.visibility == VISIBLE) {
					heightSize -= actionBarHeight
				}

				val keyboardHeightOld = keyboardHeight + chatEmojiViewPadding
				val keyboardVisibleOld = keyboardHeight + chatEmojiViewPadding >= AndroidUtilities.dp(20f)

				if (lastHeight != allHeight) {
					measureKeyboardHeight()
				}

				val keyboardSize = getKeyboardHeight()

				chatEmojiViewPadding = if (fixedKeyboardHeight > 0 && keyboardSize <= AndroidUtilities.dp(20f)) {
					fixedKeyboardHeight
				}
				else {
					if (keyboardSize <= AndroidUtilities.dp(20f)) {
						if (chatActivityEnterView!!.isPopupShowing) chatActivityEnterView!!.emojiPadding else 0
					}
					else {
						0
					}
				}

				setEmojiKeyboardHeight(chatEmojiViewPadding)

				val keyboardVisible = keyboardHeight + chatEmojiViewPadding >= AndroidUtilities.dp(20f)
				var waitingChatListItemAnimator = false

				if (MediaController.getInstance().playingMessageObject != null && MediaController.getInstance().playingMessageObject!!.isRoundVideo && keyboardVisibleOld != keyboardVisible) {
					for (i in 0 until chatListView!!.childCount) {
						val child = chatListView!!.getChildAt(i)

						if (child is ChatMessageCell) {
							val messageObject = child.getMessageObject()

							if (messageObject!!.isRoundVideo && MediaController.getInstance().isPlayingMessage(messageObject)) {
								val p = chatListView!!.getChildAdapterPosition(child)

								if (p >= 0) {
									chatLayoutManager?.scrollToPositionWithOffset(p, ((chatListView!!.measuredHeight - chatListViewPadding - blurredViewBottomOffset + (keyboardHeight + chatEmojiViewPadding - keyboardHeightOld) - if (keyboardVisible) AndroidUtilities.roundMessageSize else AndroidUtilities.roundPlayingMessageSize) / 2).toInt(), false)
									chatAdapter?.notifyItemChanged(p)
									adjustPanLayoutHelper?.delayAnimation()
									waitingChatListItemAnimator = true
									break
								}
							}
						}
					}
				}

				if (!waitingChatListItemAnimator) {
					chatActivityEnterView?.runEmojiPanelAnimation()
				}

				val childCount = childCount

				measureChildWithMargins(chatActivityEnterView, widthMeasureSpec, 0, heightMeasureSpec, 0)

				val listViewTopHeight: Int

				if (inPreviewMode) {
					inputFieldHeight = 0
					listViewTopHeight = 0
				}
				else {
					inputFieldHeight = chatActivityEnterView!!.measuredHeight
					listViewTopHeight = AndroidUtilities.dp(49f)
				}

				blurredViewTopOffset = 0
				blurredViewBottomOffset = 0

				if (SharedConfig.chatBlurEnabled()) {
					blurredViewTopOffset = actionBarHeight
					blurredViewBottomOffset = AndroidUtilities.dp(203f)
				}

				for (i in 0 until childCount) {
					val child = getChildAt(i)

					if (child == null || child.visibility == GONE || child === chatActivityEnterView || child === actionBar) {
						continue
					}

					if (child === backgroundView) {
						val contentWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY)
						val contentHeightSpec = MeasureSpec.makeMeasureSpec(allHeight, MeasureSpec.EXACTLY)
						child.measure(contentWidthSpec, contentHeightSpec)
					}
					else if (child === blurredView) {
						var h = allHeight

						if (keyboardSize > AndroidUtilities.dp(20f) && layoutParams.height < 0) {
							h += keyboardSize
						}

						val contentWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY)
						val contentHeightSpec = MeasureSpec.makeMeasureSpec(h, MeasureSpec.EXACTLY)

						child.measure(contentWidthSpec, contentHeightSpec)
					}
					else if (child === chatListView) {
						val contentWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY)
						var h = heightSize - listViewTopHeight - (if (inPreviewMode) AndroidUtilities.statusBarHeight else 0) + blurredViewTopOffset + blurredViewBottomOffset

						if (keyboardSize > AndroidUtilities.dp(20f) && layoutParams.height < 0) {
							h += keyboardSize
						}

						val contentHeightSpec = MeasureSpec.makeMeasureSpec(max(AndroidUtilities.dp(10f), h), MeasureSpec.EXACTLY)

						child.measure(contentWidthSpec, contentHeightSpec)
					}
					else if (child === progressView) {
						val contentWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY)
						val contentHeightSpec = MeasureSpec.makeMeasureSpec(max(AndroidUtilities.dp(10f), heightSize - inputFieldHeight - (if (inPreviewMode) AndroidUtilities.statusBarHeight else 0) + AndroidUtilities.dp((2 + if (chatActivityEnterView!!.isTopViewVisible) 48 else 0).toFloat())), MeasureSpec.EXACTLY)

						child.measure(contentWidthSpec, contentHeightSpec)
					}
					else if (child === instantCameraView || child === overlayView) {
						val contentWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY)
						val contentHeightSpec = MeasureSpec.makeMeasureSpec(allHeight - inputFieldHeight - chatEmojiViewPadding + AndroidUtilities.dp(3f), MeasureSpec.EXACTLY)

						child.measure(contentWidthSpec, contentHeightSpec)
					}
					else if (child === emptyViewContainer) {
						val contentWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY)
						val contentHeightSpec = MeasureSpec.makeMeasureSpec(heightSize, MeasureSpec.EXACTLY)

						child.measure(contentWidthSpec, contentHeightSpec)
					}
					else if (child === messagesSearchListView) {
						val contentWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY)
						val contentHeightSpec = MeasureSpec.makeMeasureSpec(allHeight - actionBarHeight - AndroidUtilities.dp(48f), MeasureSpec.EXACTLY)

						child.measure(contentWidthSpec, contentHeightSpec)
					}
					else if (chatActivityEnterView!!.isPopupView(child)) {
						if (inBubbleMode) {
							child.measure(MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(heightSize - inputFieldHeight + actionBarHeight + paddingTop, MeasureSpec.EXACTLY))
						}
						else if (AndroidUtilities.isInMultiwindow) {
							if (AndroidUtilities.isTablet()) {
								child.measure(MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(min(AndroidUtilities.dp(320f), heightSize - inputFieldHeight + actionBarHeight - AndroidUtilities.statusBarHeight + paddingTop), MeasureSpec.EXACTLY))
							}
							else {
								child.measure(MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(heightSize - inputFieldHeight + actionBarHeight - AndroidUtilities.statusBarHeight + paddingTop, MeasureSpec.EXACTLY))
							}
						}
						else {
							child.measure(MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.layoutParams.height, MeasureSpec.EXACTLY))
						}
					}
					else if (child === mentionContainer) {
						val layoutParams = mentionContainer!!.layoutParams as LayoutParams

						if (mentionContainer!!.adapter.isBannedInline) {
							child.measure(MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(heightSize, MeasureSpec.AT_MOST))
						}
						else {
							val height: Int

							mentionContainer?.setIgnoreLayout(true)

							val layoutManager = mentionContainer!!.currentLayoutManager

							if (layoutManager is ExtendedGridLayoutManager) {
								val size = layoutManager.getRowsCount(widthSize)
								var maxHeight = size * 102

								if (mentionContainer!!.adapter.isBotContext) {
									if (mentionContainer!!.adapter.botContextSwitch != null) {
										maxHeight += 34
									}
								}

								height = heightSize - chatActivityEnterView!!.measuredHeight + if (maxHeight != 0) AndroidUtilities.dp(2f) else 0
							}
							else {
								var size = mentionContainer!!.adapter.lastItemCount
								var maxHeight = 0

								if (mentionContainer!!.adapter.isBotContext) {
									if (mentionContainer!!.adapter.botContextSwitch != null) {
										maxHeight += 36
										size -= 1
									}

									maxHeight += size * 68
								}
								else {
									maxHeight += size * 36
								}

								height = heightSize - chatActivityEnterView!!.measuredHeight + if (maxHeight != 0) AndroidUtilities.dp(2f) else 0
							}

							layoutParams.height = height
							layoutParams.topMargin = 0
							mentionContainer!!.setIgnoreLayout(false)

							child.measure(MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(layoutParams.height, MeasureSpec.EXACTLY))
						}

						mentionContainer!!.translationY = chatActivityEnterView!!.animatedTop.toFloat()
					}
					else if (child === textSelectionHelper.getOverlayView(context)) {
						val contentWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY)
						var h = heightSize + blurredViewTopOffset

						if (keyboardSize > AndroidUtilities.dp(20f) && layoutParams.height < 0) {
							h += keyboardSize
							textSelectionHelper.setKeyboardSize(keyboardSize)
						}
						else {
							textSelectionHelper.setKeyboardSize(0)
						}

						child.measure(contentWidthSpec, MeasureSpec.makeMeasureSpec(h, MeasureSpec.EXACTLY))
					}
					else if (child === forwardingPreviewView) {
						val contentWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY)
						var h = allHeight - AndroidUtilities.statusBarHeight

						if (keyboardSize > AndroidUtilities.dp(20f) && layoutParams.height < 0) {
							h += keyboardSize
						}

						val contentHeightSpec = MeasureSpec.makeMeasureSpec(h, MeasureSpec.EXACTLY)

						child.measure(contentWidthSpec, contentHeightSpec)
					}
					else {
						measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0)
					}
				}

				if (fixPaddingsInLayout) {
					globalIgnoreLayout = true

					invalidateChatListViewTopPadding()
					invalidateMessagesVisiblePart()

					fixPaddingsInLayout = false

					chatListView?.measure(MeasureSpec.makeMeasureSpec(chatListView!!.measuredWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(chatListView!!.measuredHeight, MeasureSpec.EXACTLY))

					globalIgnoreLayout = false
				}

				if (scrollToPositionOnRecreate != -1) {
					val scrollTo = scrollToPositionOnRecreate

					AndroidUtilities.runOnUIThread {
						chatLayoutManager?.scrollToPositionWithOffset(scrollTo, scrollToOffsetOnRecreate)
					}

					scrollToPositionOnRecreate = -1
				}

				updateBulletinLayout()

				lastHeight = allHeight
			}

			override fun requestLayout() {
				if (globalIgnoreLayout) {
					return
				}

				super.requestLayout()
			}

			override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {
				val count = childCount
				val keyboardSize = getKeyboardHeight()

				val paddingBottom = if (fixedKeyboardHeight > 0 && keyboardSize <= AndroidUtilities.dp(20f)) {
					fixedKeyboardHeight
				}
				else {
					if (keyboardSize <= AndroidUtilities.dp(20f) && !AndroidUtilities.isInMultiwindow && !inBubbleMode) chatActivityEnterView!!.emojiPadding else 0
				}

				if (!SharedConfig.smoothKeyboard) {
					setBottomClip(paddingBottom)
				}

				for (i in 0 until count) {
					val child = getChildAt(i)

					if (child == null || child.visibility == GONE) {
						continue
					}

					val lp = child.layoutParams as LayoutParams
					val width = child.measuredWidth
					val height = child.measuredHeight
					var childLeft: Int
					var childTop: Int
					var gravity = lp.gravity

					if (gravity == -1) {
						gravity = Gravity.TOP or Gravity.LEFT
					}

					val absoluteGravity = gravity and Gravity.HORIZONTAL_GRAVITY_MASK
					val verticalGravity = gravity and Gravity.VERTICAL_GRAVITY_MASK

					childLeft = when (absoluteGravity and Gravity.HORIZONTAL_GRAVITY_MASK) {
						Gravity.CENTER_HORIZONTAL -> (r - l - width) / 2 + lp.leftMargin - lp.rightMargin
						Gravity.RIGHT -> r - width - lp.rightMargin
						Gravity.LEFT -> lp.leftMargin
						else -> lp.leftMargin
					}

					when (verticalGravity) {
						Gravity.TOP -> {
							childTop = lp.topMargin + paddingTop

							if (child !== actionBar && actionBar!!.visibility == VISIBLE) {
								childTop += actionBar!!.measuredHeight

								if (inPreviewMode) {
									childTop += AndroidUtilities.statusBarHeight
								}
							}
						}

						Gravity.CENTER_VERTICAL -> {
							childTop = (b - paddingBottom - t - height) / 2 + lp.topMargin - lp.bottomMargin
						}

						Gravity.BOTTOM -> {
							childTop = b - paddingBottom - t - height - lp.bottomMargin
						}

						else -> {
							childTop = lp.topMargin
						}
					}

					if (child === blurredView || child === backgroundView) {
						childTop = 0
					}
					else if (child is HintView || child is ChecksHintView) {
						childTop = 0
					}
					else if (child === mentionContainer) {
						childTop -= chatActivityEnterView!!.measuredHeight - AndroidUtilities.dp(2f)
						mentionContainer!!.translationY = chatActivityEnterView!!.animatedTop.toFloat()
					}
					else if (child === pagedownButton || child === mentiondownButton || child === reactionsMentiondownButton) {
						if (!inPreviewMode) {
							childTop -= chatActivityEnterView!!.measuredHeight
						}
					}
					else if (child === emptyViewContainer) {
						childTop -= inputFieldHeight / 2 - if (actionBar!!.visibility == VISIBLE) actionBar!!.measuredHeight / 2 else 0
					}
					else if (chatActivityEnterView!!.isPopupView(child)) {
						childTop = if (AndroidUtilities.isInMultiwindow || inBubbleMode) {
							chatActivityEnterView!!.top - child.measuredHeight + AndroidUtilities.dp(1f)
						}
						else {
							chatActivityEnterView!!.bottom
						}
					}
					else if (child === gifHintTextView || child === voiceHintTextView || child === mediaBanTooltip || child === emojiHintTextView) {
						childTop -= inputFieldHeight
					}
					else if (child === chatListView || child === floatingDateView || child === infoTopView) {
						childTop -= blurredViewTopOffset

						if (!inPreviewMode) {
							childTop -= inputFieldHeight - AndroidUtilities.dp(51f)
						}

						childTop -= paddingBottom

						if (keyboardSize > AndroidUtilities.dp(20f) && layoutParams.height < 0) {
							childTop -= keyboardSize
						}
					}
					else if (child === progressView) {
						if (chatActivityEnterView!!.isTopViewVisible) {
							childTop -= AndroidUtilities.dp(48f)
						}
					}
					else if (child === actionBar) {
						if (inPreviewMode) {
							childTop += AndroidUtilities.statusBarHeight
						}

						childTop -= paddingTop
					}
					else if (child === videoPlayerContainer) {
						childTop = actionBar!!.measuredHeight
						childTop -= paddingBottom

						if (keyboardSize > AndroidUtilities.dp(20f) && layoutParams.height < 0) {
							childTop -= keyboardSize
						}
					}
					else if (child === instantCameraView || child === overlayView || child === animatingImageView) {
						childTop = 0
					}
					else if (child === textSelectionHelper.getOverlayView(context)) {
						childTop -= paddingBottom

						if (keyboardSize > AndroidUtilities.dp(20f) && layoutParams.height < 0) {
							childTop -= keyboardSize
						}

						childTop -= blurredViewTopOffset
					}
					else if (chatActivityEnterView != null && child === chatActivityEnterView!!.botCommandsMenuContainer) {
						childTop -= inputFieldHeight
					}
					else if (child === forwardingPreviewView) {
						childTop = AndroidUtilities.statusBarHeight
					}

					child.layout(childLeft, childTop, childLeft + width, childTop + height)
				}

				invalidateChatListViewTopPadding()
				invalidateMessagesVisiblePart()
				updateTextureViewPosition(false)

				if (!scrollingChatListView) {
					checkAutoDownloadMessages(false)
				}

				notifyHeightChanged()
			}

			private fun setNonNoveTranslation(y: Float) {
				contentView?.translationY = y
				actionBar?.translationY = 0f
				emptyViewContainer?.translationY = 0f
				progressView?.translationY = 0f
				contentPanTranslation = 0f
				contentView?.setBackgroundTranslation(0)
				instantCameraView?.onPanTranslationUpdate(0f)
				blurredView?.drawable?.onPanTranslationUpdate(0f)
				setFragmentPanTranslationOffset(0)
				invalidateChatListViewTopPadding()
			}

			override fun setPadding(left: Int, top: Int, right: Int, bottom: Int) {
				contentPaddingTop = top
				invalidateChatListViewTopPadding()
				invalidateMessagesVisiblePart()
			}

			override fun dispatchKeyEvent(event: KeyEvent): Boolean {
				if (event.keyCode == KeyEvent.KEYCODE_BACK && event.action == 1 && forwardingPreviewView?.isShowing == true) {
					forwardingPreviewView?.dismiss(true)
					return true
				}

				return super.dispatchKeyEvent(event)
			}
		}

		contentView = fragmentView as? SizeNotifierFrameLayout
		contentView?.needBlur = true
		contentView?.needBlurBottom = true

		if (inBubbleMode) {
			contentView?.setOccupyStatusBar(false)
		}

		// contentView.setBackgroundImage(Theme.getCachedWallpaper(), Theme.isWallpaperMotion());
		when (dialogId) {
			BuildConfig.PHOENIX_BOT_ID -> contentView?.background = ResourcesCompat.getDrawable(context.resources, R.drawable.chat_ai_phoenix_background, null)

			BuildConfig.BUSINESS_BOT_ID -> contentView?.background = ResourcesCompat.getDrawable(context.resources, R.drawable.chat_ai_business_background, null)

			BuildConfig.CANCER_BOT_ID -> contentView?.background = ResourcesCompat.getDrawable(context.resources, R.drawable.chat_ai_cancer_background, null)

			else -> contentView?.setBackgroundImage(ResourcesCompat.getDrawable(context.resources, R.drawable.chat_background, null), false)
		}

		emptyViewContainer = FrameLayout(context)
		emptyViewContainer?.invisible()

		contentView?.addView(emptyViewContainer, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER))

		emptyViewContainer?.setOnTouchListener { _, _ -> true }

		val distance = getArguments()!!.getInt("nearby_distance", -1)

		if ((distance >= 0 || preloadedGreetingsSticker != null) && currentUser != null && !userBlocked) {
			greetingsViewContainer = ChatGreetingsView(context, currentUser!!, distance, currentAccount, preloadedGreetingsSticker)

			greetingsViewContainer?.setListener { sticker ->
				animatingDocuments[sticker] = 0
				SendMessagesHelper.getInstance(currentAccount).sendSticker(sticker, null, dialogId, null, null, null, null, true, 0, false)
			}

			val paint = Paint()
			paint.color = ResourcesCompat.getColor(context.resources, R.color.service_message_background, null)

			greetingsViewContainer?.background = Theme.createServiceDrawable(AndroidUtilities.dp(14f), greetingsViewContainer, contentView, paint)

			emptyViewContainer?.addView(greetingsViewContainer, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.CENTER_VERTICAL, 68f, 0f, 68f, 0f))
		}
		else if (currentEncryptedChat == null) {
			if (!isThreadChat && chatMode == 0 && (currentUser != null && currentUser!!.self || currentChat != null && currentChat!!.creator && !isChannelAndNotMegaGroup(currentChat))) {
				bigEmptyView = ChatBigEmptyView(context, contentView, if (currentChat != null) ChatBigEmptyView.EMPTY_VIEW_TYPE_GROUP else ChatBigEmptyView.EMPTY_VIEW_TYPE_SAVED)
				emptyViewContainer?.addView(bigEmptyView, FrameLayout.LayoutParams(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER))

				if (currentChat != null) {
					bigEmptyView?.setStatusText(AndroidUtilities.replaceTags(context.getString(R.string.GroupEmptyTitle1)))
				}
			}
			else {
				var emptyMessage: String? = null

				if (isThreadChat) {
					emptyMessage = if (isComments) {
						context.getString(R.string.NoComments)
					}
					else {
						context.getString(R.string.NoReplies)
					}
				}
				else if (chatMode == MODE_SCHEDULED) {
					emptyMessage = context.getString(R.string.NoScheduledMessages)
				}
				else if (currentUser != null && currentUser!!.id != 777000L && currentUser!!.id != 429000L && currentUser!!.id != 4244000L && MessagesController.isSupportUser(currentUser)) {
					emptyMessage = context.getString(R.string.GotAQuestion)
				}
				else if (currentUser == null || currentUser!!.self || currentUser!!.deleted || userBlocked) {
					emptyMessage = context.getString(R.string.NoMessages)
				}

				if (emptyMessage == null) {
					greetingsViewContainer = ChatGreetingsView(context, currentUser!!, distance, currentAccount, preloadedGreetingsSticker)

					greetingsViewContainer?.setListener { sticker ->
						animatingDocuments[sticker] = 0
						SendMessagesHelper.getInstance(currentAccount).sendSticker(sticker, null, dialogId, null, null, null, null, true, 0, false)
					}

					val paint = Paint()

					when (dialogId) {
						BuildConfig.AI_BOT_ID -> {
							greetingsViewContainer?.background = ResourcesCompat.getDrawable(context.resources, R.drawable.ai_bot_greetings_background, null)
						}

						BuildConfig.SUPPORT_BOT_ID -> {
							greetingsViewContainer?.background = ResourcesCompat.getDrawable(context.resources, R.drawable.ai_bot_greetings_background, null)
						}

						BuildConfig.PHOENIX_BOT_ID -> {
							greetingsViewContainer?.background = ResourcesCompat.getDrawable(context.resources, R.drawable.ai_bot_greetings_background, null)
						}

						BuildConfig.BUSINESS_BOT_ID -> {
							showBotHelpCell = true
						}

						BuildConfig.CANCER_BOT_ID -> {
							showBotHelpCell = true
						}

						else -> {
							if (isAiBot()) {
								showBotHelpCell = true
							}
							else {
								paint.color = ResourcesCompat.getColor(context.resources, R.color.service_message_background, null)
								greetingsViewContainer?.background = Theme.createServiceDrawable(AndroidUtilities.dp(14f), greetingsViewContainer, contentView, paint)
							}
						}
					}

					emptyViewContainer?.addView(greetingsViewContainer, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.CENTER_VERTICAL, 68f, 0f, 68f, 0f))
				}
				else {
					emptyView = TextView(context)
					emptyView?.text = emptyMessage
					emptyView?.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14f)
					emptyView?.gravity = Gravity.CENTER
					emptyView?.setTextColor(context.getColor(R.color.text))

					val paint = Paint()
					paint.color = ResourcesCompat.getColor(context.resources, R.color.service_message_background, null)

					emptyView?.background = Theme.createServiceDrawable(AndroidUtilities.dp(6f), emptyView, contentView, paint)
					emptyView?.setTypeface(Theme.TYPEFACE_BOLD)
					emptyView?.setPadding(AndroidUtilities.dp(10f), AndroidUtilities.dp(2f), AndroidUtilities.dp(10f), AndroidUtilities.dp(3f))

					emptyViewContainer?.addView(emptyView, FrameLayout.LayoutParams(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER))
				}
			}
		}
		else {
			bigEmptyView = ChatBigEmptyView(context, contentView, ChatBigEmptyView.EMPTY_VIEW_TYPE_SECRET)

			if (currentEncryptedChat?.admin_id == userConfig.getClientUserId()) {
				bigEmptyView?.setStatusText(LocaleController.formatString("EncryptedPlaceholderTitleOutgoing", R.string.EncryptedPlaceholderTitleOutgoing, getFirstName(currentUser)))
			}
			else {
				bigEmptyView?.setStatusText(LocaleController.formatString("EncryptedPlaceholderTitleIncoming", R.string.EncryptedPlaceholderTitleIncoming, getFirstName(currentUser)))
			}

			emptyViewContainer?.addView(bigEmptyView, FrameLayout.LayoutParams(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER))
		}

		val oldMessage = if (chatActivityEnterView != null) {
			chatActivityEnterView?.onDestroy()

			if (!chatActivityEnterView!!.isEditingMessage) {
				chatActivityEnterView?.fieldText
			}
			else {
				null
			}
		}
		else {
			null
		}

		mentionContainer?.adapter?.onDestroy()

		chatListView = object : RecyclerListView(context) {
			private val drawTimeAfter = mutableListOf<ChatMessageCell>()
			private val drawNamesAfter = mutableListOf<ChatMessageCell>()
			private val drawCaptionAfter = mutableListOf<ChatMessageCell>()
			private val drawingGroups = mutableListOf<GroupedMessages>()

			var lastH = 0

			private var lastWidth = 0
			private val slideAnimationInProgress = false
			private var startedTrackingX = 0
			private var startedTrackingY = 0
			private var startedTrackingPointerId = 0
			private var lastTrackingAnimationTime: Long = 0
			private var trackAnimationProgress = 0f
			private var endTrackingX = 0f
			private var wasTrackingVibrate = false
			private var replyButtonProgress = 0f
			private var lastReplyButtonAnimationTime: Long = 0
			private var ignoreLayout = false
			private var invalidated = false

			override fun requestLayout() {
				if (ignoreLayout) {
					return
				}

				super.requestLayout()
			}

			override fun setTranslationY(translationY: Float) {
				if (translationY != getTranslationY()) {
					super.setTranslationY(translationY)

					if (chatActivityEnterView?.panelAnimationInProgress() == true) {
						emptyViewContainer?.translationY = translationY / 2f
					}
					else {
						emptyViewContainer?.translationY = translationY / 1.7f
					}

					chatActivityEnterView?.botCommandsMenuContainer?.translationY = translationY

					invalidateChatListViewTopPadding()
					invalidateMessagesVisiblePart()
				}
			}

			override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {
				super.onLayout(changed, l, t, r, b)

				if (lastWidth != r - l) {
					lastWidth = r - l
					hideHints(false)
				}

				val height = measuredHeight

				if (lastH != height) {
					ignoreLayout = true

					chatListItemAnimator?.endAnimations()

					chatScrollHelper?.cancel()
					ignoreLayout = false
					lastH = height
				}

				forceScrollToTop = false

				if (textSelectionHelper.isSelectionMode) {
					textSelectionHelper.invalidate()
				}
			}

			private fun setGroupTranslationX(view: ChatMessageCell, dx: Float) {
				val group = view.currentMessagesGroup ?: return
				val count = childCount

				for (a in 0 until count) {
					val child = getChildAt(a)

					if (child === view || child !is ChatMessageCell) {
						continue
					}

					if (child.currentMessagesGroup == group) {
						child.setSlidingOffset(dx)
						child.invalidate()
					}
				}

				invalidate()
			}

			override fun requestChildRectangleOnScreen(child: View, rect: Rect, immediate: Boolean): Boolean {
				return if (scrimPopupWindow != null) {
					false
				}
				else {
					super.requestChildRectangleOnScreen(child, rect, immediate)
				}
			}

			override fun onInterceptTouchEvent(e: MotionEvent): Boolean {
				textSelectionHelper.checkSelectionCancel(e)

				if (isFastScrollAnimationRunning) {
					return false
				}

				val result = super.onInterceptTouchEvent(e)

				if (actionBar!!.isActionModeShowed || reportType >= 0) {
					return result
				}

				processTouchEvent(e)

				return result
			}

			override fun setItemAnimator(animator: ItemAnimator?) {
				if (isFastScrollAnimationRunning) {
					return
				}

				super.setItemAnimator(animator)
			}

			private fun drawReplyButton(canvas: Canvas) {
				if (slidingView == null) {
					return
				}

				val translationX = slidingView!!.getNonAnimationTranslationX(false)
				val newTime = System.currentTimeMillis()
				val dt = min(17, newTime - lastReplyButtonAnimationTime)

				lastReplyButtonAnimationTime = newTime

				var showing: Boolean

				if ((translationX <= -AndroidUtilities.dp(50f)).also { showing = it }) {
					if (replyButtonProgress < 1.0f) {
						replyButtonProgress += dt / 180.0f

						if (replyButtonProgress > 1.0f) {
							replyButtonProgress = 1.0f
						}
						else {
							invalidate()
						}
					}
				}
				else {
					if (replyButtonProgress > 0.0f) {
						replyButtonProgress -= dt / 180.0f

						if (replyButtonProgress < 0.0f) {
							replyButtonProgress = 0f
						}
						else {
							invalidate()
						}
					}
				}

				val alpha: Int
				val alpha2: Int
				val chatActionBackgroundPaint = getThemedPaint(Theme.key_paint_chatActionBackground)
				val oldAlpha = chatActionBackgroundPaint.alpha
				val scale: Float

				if (showing) {
					scale = if (replyButtonProgress <= 0.8f) {
						1.2f * (replyButtonProgress / 0.8f)
					}
					else {
						1.2f - 0.2f * ((replyButtonProgress - 0.8f) / 0.2f)
					}

					alpha = min(255f, 255 * (replyButtonProgress / 0.8f)).toInt()
					alpha2 = min(oldAlpha.toFloat(), oldAlpha * (replyButtonProgress / 0.8f)).toInt()
				}
				else {
					scale = replyButtonProgress
					alpha = min(255f, 255 * replyButtonProgress).toInt()
					alpha2 = min(oldAlpha.toFloat(), oldAlpha * replyButtonProgress).toInt()
				}

				chatActionBackgroundPaint.alpha = alpha2

				val x = measuredWidth + slidingView!!.getNonAnimationTranslationX(false) / 2
				val y = (slidingView!!.top + slidingView!!.measuredHeight / 2).toFloat()

				AndroidUtilities.rectTmp.set((x - AndroidUtilities.dp(16f) * scale).toInt().toFloat(), (y - AndroidUtilities.dp(16f) * scale).toInt().toFloat(), (x + AndroidUtilities.dp(16f) * scale).toInt().toFloat(), (y + AndroidUtilities.dp(16f) * scale).toInt().toFloat())

				Theme.applyServiceShaderMatrix(measuredWidth, AndroidUtilities.displaySize.y, 0f, getY() + AndroidUtilities.rectTmp.top)

				canvas.drawRoundRect(AndroidUtilities.rectTmp, AndroidUtilities.dp(16f).toFloat(), AndroidUtilities.dp(16f).toFloat(), chatActionBackgroundPaint)

				chatActionBackgroundPaint.alpha = oldAlpha

				val replyIconDrawable = ResourcesCompat.getDrawable(context.resources, R.drawable.fast_reply, null)!!.mutate()
				replyIconDrawable.alpha = alpha
				replyIconDrawable.setBounds((x - AndroidUtilities.dp(7f) * scale).toInt(), (y - AndroidUtilities.dp(6f) * scale).toInt(), (x + AndroidUtilities.dp(7f) * scale).toInt(), (y + AndroidUtilities.dp(5f) * scale).toInt())
				replyIconDrawable.draw(canvas)
				replyIconDrawable.alpha = 255
			}

			private fun processTouchEvent(e: MotionEvent?) {
				if (e != null) {
					wasManualScroll = true
				}

				if (e != null && e.action == MotionEvent.ACTION_DOWN && !startedTrackingSlidingView && !maybeStartTrackingSlidingView && slidingView == null && !inPreviewMode) {
					val view = pressedChildView

					if (view is ChatMessageCell) {
						slidingView?.setSlidingOffset(0f)

						slidingView = view

						val message = slidingView?.getMessageObject()

						if (chatMode != 0 || threadMessageObjects?.contains(message) == true || getMessageType(message) == 1 && (message?.dialogId == mergeDialogId || message?.needDrawBluredPreview() == true) || currentEncryptedChat == null && message!!.id < 0 || bottomOverlayChat?.visibility == VISIBLE || currentChat != null && (isNotInChat(currentChat) && !isThreadChat || isChannel(currentChat) && !canPost(currentChat) && !currentChat!!.megagroup || !canSendMessages(currentChat)) || textSelectionHelper.isSelectionMode) {
							slidingView?.setSlidingOffset(0f)
							slidingView = null
							return
						}

						startedTrackingPointerId = e.getPointerId(0)
						maybeStartTrackingSlidingView = true
						startedTrackingX = e.x.toInt()
						startedTrackingY = e.y.toInt()
					}
				}
				else if (slidingView != null && e != null && e.action == MotionEvent.ACTION_MOVE && e.getPointerId(0) == startedTrackingPointerId) {
					val dx = max(AndroidUtilities.dp(-80f), min(0, (e.x - startedTrackingX).toInt()))
					val dy = abs(e.y.toInt() - startedTrackingY)

					if (scrollState == SCROLL_STATE_IDLE && maybeStartTrackingSlidingView && !startedTrackingSlidingView && dx <= -AndroidUtilities.getPixelsInCM(0.4f, true) && abs(dx) / 3 > dy) {
						val event = MotionEvent.obtain(0, 0, MotionEvent.ACTION_CANCEL, 0f, 0f, 0)

						slidingView?.onTouchEvent(event)

						super.onInterceptTouchEvent(event)

						event.recycle()

						chatLayoutManager?.setCanScrollVertically(false)

						maybeStartTrackingSlidingView = false
						startedTrackingSlidingView = true
						startedTrackingX = e.x.toInt()

						parent?.requestDisallowInterceptTouchEvent(true)
					}
					else if (startedTrackingSlidingView) {
						if (abs(dx) >= AndroidUtilities.dp(50f)) {
							if (!wasTrackingVibrate) {
								runCatching {
									performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP, HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING)
								}

								wasTrackingVibrate = true
							}
						}
						else {
							wasTrackingVibrate = false
						}

						slidingView?.setSlidingOffset(dx.toFloat())

						val messageObject = slidingView?.getMessageObject()

						if (messageObject?.isRoundVideo == true || messageObject?.isVideo == true) {
							updateTextureViewPosition(false)
						}

						setGroupTranslationX(slidingView!!, dx.toFloat())
						invalidate()
					}
				}
				else if (slidingView != null && (e == null || e.getPointerId(0) == startedTrackingPointerId && (e.action == MotionEvent.ACTION_CANCEL || e.action == MotionEvent.ACTION_UP || e.action == MotionEvent.ACTION_POINTER_UP))) {
					if (e != null && e.action != MotionEvent.ACTION_CANCEL && abs(slidingView!!.getNonAnimationTranslationX(false)) >= AndroidUtilities.dp(50f)) {
						showFieldPanelForReply(slidingView!!.getMessageObject())
					}

					endTrackingX = slidingView!!.slidingOffsetX

					if (endTrackingX == 0f) {
						slidingView = null
					}

					lastTrackingAnimationTime = System.currentTimeMillis()
					trackAnimationProgress = 0.0f

					invalidate()

					maybeStartTrackingSlidingView = false
					startedTrackingSlidingView = false

					chatLayoutManager?.setCanScrollVertically(true)
				}
			}

			override fun onTouchEvent(e: MotionEvent): Boolean {
				textSelectionHelper.checkSelectionCancel(e)

				if (e.action == MotionEvent.ACTION_DOWN) {
					scrollByTouch = true
				}

				if (pullingDownOffset != 0f && (e.action == MotionEvent.ACTION_UP || e.action == MotionEvent.ACTION_CANCEL)) {
					val progress = min(1f, pullingDownOffset / AndroidUtilities.dp(110f))

					if (e.action == MotionEvent.ACTION_UP && progress == 1f && pullingDownDrawable != null && !pullingDownDrawable!!.emptyStub) {
						if (pullingDownDrawable!!.animationIsRunning()) {
							val animator = ValueAnimator.ofFloat(pullingDownOffset, pullingDownOffset + AndroidUtilities.dp(8f))

							pullingDownBackAnimator = animator

							animator.addUpdateListener {
								pullingDownOffset = it.animatedValue as Float
								chatListView?.invalidate()
							}

							animator.duration = 200
							animator.interpolator = CubicBezierInterpolator.DEFAULT
							animator.start()

							pullingDownDrawable?.runOnAnimationFinish {
								animateToNextChat()
							}
						}
						else {
							animateToNextChat()
						}
					}
					else {
						if (pullingDownDrawable != null && pullingDownDrawable!!.emptyStub && System.currentTimeMillis() - pullingDownDrawable!!.lastShowingReleaseTime < 500 && pullingDownDrawable!!.animateSwipeToRelease) {
							val animatorSet = AnimatorSet()

							pullingDownBackAnimator = animatorSet

							pullingDownDrawable?.showBottomPanel(false)

							val animator = ValueAnimator.ofFloat(pullingDownOffset, AndroidUtilities.dp(111f).toFloat())

							animator.addUpdateListener {
								pullingDownOffset = it.animatedValue as Float
								chatListView?.invalidate()
							}

							animator.duration = 400
							animator.interpolator = CubicBezierInterpolator.DEFAULT

							val animator2 = ValueAnimator.ofFloat(AndroidUtilities.dp(111f).toFloat(), 0f)

							animator2.addUpdateListener {
								pullingDownOffset = it.animatedValue as Float
								chatListView?.invalidate()
							}

							animator2.startDelay = 600
							animator2.duration = ChatListItemAnimator.DEFAULT_DURATION
							animator2.interpolator = ChatListItemAnimator.DEFAULT_INTERPOLATOR

							animatorSet.playSequentially(animator, animator2)
							animatorSet.start()
						}
						else {
							val animator = ValueAnimator.ofFloat(pullingDownOffset, 0f)

							pullingDownBackAnimator = animator

							pullingDownDrawable?.showBottomPanel(false)

							animator.addUpdateListener {
								pullingDownOffset = it.animatedValue as Float
								chatListView?.invalidate()
							}

							animator.duration = ChatListItemAnimator.DEFAULT_DURATION
							animator.interpolator = ChatListItemAnimator.DEFAULT_INTERPOLATOR
							animator.start()
						}
					}
				}

				if (isFastScrollAnimationRunning) {
					return false
				}

				val result = super.onTouchEvent(e)

				if (actionBar!!.isActionModeShowed || reportType >= 0) {
					return result
				}

				processTouchEvent(e)

				return startedTrackingSlidingView || result
			}

			override fun requestDisallowInterceptTouchEvent(disallowIntercept: Boolean) {
				super.requestDisallowInterceptTouchEvent(disallowIntercept)

				if (slidingView != null) {
					processTouchEvent(null)
				}
			}

			override fun onChildPressed(child: View?, x: Float, y: Float, pressed: Boolean) {
				super.onChildPressed(child, x, y, pressed)

				if (child is ChatMessageCell) {
					val `object` = child.getMessageObject()

					if (`object`?.isMusic == true || `object`?.isDocument() == true) {
						return
					}

					val groupedMessages = child.currentMessagesGroup

					if (groupedMessages != null) {
						val count = childCount

						for (a in 0 until count) {
							val item = getChildAt(a)

							if (item === child || item !is ChatMessageCell) {
								continue
							}

							if (item.currentMessagesGroup == groupedMessages) {
								item.isPressed = pressed
							}
						}
					}
				}
			}

			override fun onDraw(c: Canvas) {
				super.onDraw(c)

				if (slidingView != null) {
					var translationX = slidingView!!.slidingOffsetX

					if (!maybeStartTrackingSlidingView && !startedTrackingSlidingView && endTrackingX != 0f && translationX != 0f) {
						val newTime = System.currentTimeMillis()
						val dt = newTime - lastTrackingAnimationTime

						trackAnimationProgress += dt / 180.0f

						if (trackAnimationProgress > 1.0f) {
							trackAnimationProgress = 1.0f
						}

						lastTrackingAnimationTime = newTime

						translationX = endTrackingX * (1.0f - AndroidUtilities.decelerateInterpolator.getInterpolation(trackAnimationProgress))

						if (translationX == 0f) {
							endTrackingX = 0f
						}

						setGroupTranslationX(slidingView!!, translationX)

						slidingView?.setSlidingOffset(translationX)

						val messageObject = slidingView!!.getMessageObject()

						if (messageObject!!.isRoundVideo || messageObject.isVideo) {
							updateTextureViewPosition(false)
						}

						if (trackAnimationProgress == 1f || trackAnimationProgress == 0f) {
							slidingView?.setSlidingOffset(0f)
							slidingView = null
						}

						invalidate()
					}

					drawReplyButton(c)
				}

				if (pullingDownOffset != 0f && !isInPreviewMode) {
					c.save()

					var transitionOffset = 0f

					if (pullingDownAnimateProgress != 0f) {
						transitionOffset = (chatListView!!.measuredHeight - pullingDownOffset + (pullingDownAnimateToActivity?.pullingBottomOffset ?: 0f)) * pullingDownAnimateProgress
					}

					c.translate(0f, measuredHeight - blurredViewBottomOffset - transitionOffset)

					if (pullingDownDrawable == null) {
						pullingDownDrawable = ChatPullingDownDrawable(currentAccount, fragmentView, dialogId, dialogFolderId, dialogFilterId)
						pullingDownDrawable?.onAttach()
					}

					pullingDownDrawable?.setWidth(measuredWidth)

					val progress = min(1f, pullingDownOffset / AndroidUtilities.dp(110f))

					pullingDownDrawable?.draw(c, chatListView!!, progress, 1f - pullingDownAnimateProgress)

					c.restore()

					if (pullingDownAnimateToActivity != null) {
						c.saveLayerAlpha(0f, 0f, pullingDownAnimateToActivity!!.chatListView!!.measuredWidth.toFloat(), pullingDownAnimateToActivity!!.chatListView!!.measuredHeight.toFloat(), (255 * pullingDownAnimateProgress).toInt())
						c.translate(0f, measuredHeight - pullingDownOffset - transitionOffset)

						pullingDownAnimateToActivity?.chatListView?.draw(c)

						c.restore()
					}
				}
				else {
					pullingDownDrawable?.reset()
				}
			}

			override fun dispatchDraw(canvas: Canvas) {
				drawLaterRoundProgressCell = null
				invalidated = false

				canvas.save()

				if (fragmentTransition == null || fromPullingDownTransition && !toPullingDownTransition) {
					canvas.clipRect(0f, chatListViewPadding - chatListViewPaddingVisibleOffset - AndroidUtilities.dp(4f), measuredWidth.toFloat(), (measuredHeight - blurredViewBottomOffset).toFloat())
				}

				selectorRect.setEmpty()

				if (pullingDownOffset != 0f) {
					canvas.save()

					var transitionOffset = 0f

					if (pullingDownAnimateProgress != 0f) {
						transitionOffset = (chatListView!!.measuredHeight - pullingDownOffset) * pullingDownAnimateProgress
					}
					canvas.translate(0f, -pullingDownOffset - transitionOffset.also {
						drawingChatLisViewYoffset = it
					})

					drawChatBackgroundElements(canvas)

					super.dispatchDraw(canvas)

					drawChatForegroundElements(canvas)

					canvas.restore()
				}
				else {
					drawChatBackgroundElements(canvas)

					super.dispatchDraw(canvas)

					drawChatForegroundElements(canvas)
				}

				canvas.restore()
			}

			private fun drawChatForegroundElements(canvas: Canvas) {
				var size = drawTimeAfter.size

				if (size > 0) {
					for (a in 0 until size) {
						val cell = drawTimeAfter[a]
						canvas.save()
						canvas.translate(cell.left + cell.getNonAnimationTranslationX(false), cell.y)
						cell.drawTime(canvas, if (cell.shouldDrawAlphaLayer()) cell.alpha else 1f, true)
						canvas.restore()
					}

					drawTimeAfter.clear()
				}

				size = drawNamesAfter.size

				if (size > 0) {
					for (a in 0 until size) {
						val cell = drawNamesAfter[a]
						val canvasOffsetX = cell.left + cell.getNonAnimationTranslationX(false)
						val canvasOffsetY = cell.y
						val alpha = if (cell.shouldDrawAlphaLayer()) cell.alpha else 1f

						canvas.save()
						canvas.translate(canvasOffsetX, canvasOffsetY)

						cell.setInvalidatesParent(true)
						cell.drawNamesLayout(canvas, alpha)
						cell.setInvalidatesParent(false)

						canvas.restore()
					}

					drawNamesAfter.clear()
				}

				size = drawCaptionAfter.size

				if (size > 0) {
					for (a in 0 until size) {
						val cell = drawCaptionAfter[a]
						var selectionOnly = false

						if (cell.currentPosition != null) {
							selectionOnly = cell.currentPosition!!.flags and MessageObject.POSITION_FLAG_LEFT == 0
						}

						val alpha = if (cell.shouldDrawAlphaLayer()) cell.alpha else 1f
						val canvasOffsetX = cell.left + cell.getNonAnimationTranslationX(false)
						val canvasOffsetY = cell.y

						canvas.save()

						val groupedMessages = cell.currentMessagesGroup

						if (groupedMessages != null && groupedMessages.transitionParams.backgroundChangeBounds) {
							val x = cell.getNonAnimationTranslationX(true)
							val l = groupedMessages.transitionParams.left + x + groupedMessages.transitionParams.offsetLeft
							var t = groupedMessages.transitionParams.top + groupedMessages.transitionParams.offsetTop
							val r = groupedMessages.transitionParams.right + x + groupedMessages.transitionParams.offsetRight
							var b = groupedMessages.transitionParams.bottom + groupedMessages.transitionParams.offsetBottom

							if (!groupedMessages.transitionParams.backgroundChangeBounds) {
								t += cell.translationY
								b += cell.translationY
							}

							canvas.clipRect(l + AndroidUtilities.dp(8f), t + AndroidUtilities.dp(8f), r - AndroidUtilities.dp(8f), b - AndroidUtilities.dp(8f))
						}

						if (cell.transitionParams.wasDraw) {
							canvas.translate(canvasOffsetX, canvasOffsetY)
							cell.setInvalidatesParent(true)
							cell.drawCaptionLayout(canvas, selectionOnly, alpha)
							cell.setInvalidatesParent(false)
							canvas.restore()
						}
					}

					drawCaptionAfter.clear()
				}
			}

			private fun drawChatBackgroundElements(canvas: Canvas) {
				val count = childCount
				var lastDrawnGroup: GroupedMessages? = null

				for (a in 0 until count) {
					val child = getChildAt(a)

					if (chatAdapter!!.isBot && child is BotHelpCell) {
						val top: Float = (measuredHeight - chatListViewPadding - blurredViewBottomOffset) / 2 - child.getMeasuredHeight() / 2 + chatListViewPadding

						if (!child.animating() && !chatListView!!.isFastScrollAnimationRunning) {
							if (child.getTop() > top) {
								child.setTranslationY(top - child.getTop())
							}
							else {
								child.setTranslationY(0f)
							}
						}

						break
					}
					else if (child is ChatMessageCell) {
						val group = child.currentMessagesGroup

						if (group == null || group != lastDrawnGroup) {
							lastDrawnGroup = group

							val position = child.currentPosition
							val backgroundDrawable = child.backgroundDrawable

							if ((backgroundDrawable.isAnimationInProgress || child.isDrawingSelectionBackground()) && (position == null || position.flags and MessageObject.POSITION_FLAG_RIGHT != 0)) {
								if (child.isHighlighted() || child.isHighlightedAnimated) {
									if (position == null) {
										val backgroundPaint = Paint(Paint.ANTI_ALIAS_FLAG)

										backgroundPaint.color = context.getColor(R.color.transparent_background)

										val viewTop = ((if (isKeyboardVisible) chatListView!!.top else actionBar!!.measuredHeight) - contentView!!.backgroundTranslationY).toFloat()
										val backgroundHeight = contentView!!.backgroundSizeY

										Theme.applyServiceShaderMatrix(measuredWidth, backgroundHeight, child.x, viewTop)

										canvas.save()
										canvas.translate(0f, child.translationY)

										val wasAlpha = backgroundPaint.alpha

										backgroundPaint.alpha = (wasAlpha * child.getHighlightAlpha() * child.alpha).toInt()

										canvas.drawRect(0f, child.top.toFloat(), measuredWidth.toFloat(), child.bottom.toFloat(), backgroundPaint)

										backgroundPaint.alpha = wasAlpha

										canvas.restore()
									}
								}
								else {
									var y = child.y.toInt()

									var height: Int

									canvas.save()

									if (position == null) {
										height = child.measuredHeight
									}
									else {
										height = y + child.measuredHeight

										var time: Long = 0
										var touchX = 0f
										var touchY = 0f

										for (i in 0 until count) {
											val inner = getChildAt(i)

											if (inner is ChatMessageCell) {
												val innerGroup = inner.currentMessagesGroup

												if (innerGroup == group) {
													val drawable = inner.backgroundDrawable

													y = min(y, inner.y.toInt())

													height = max(height, inner.y.toInt() + inner.measuredHeight)

													val touchTime = drawable.lastTouchTime

													if (touchTime > time) {
														touchX = drawable.touchX + inner.x
														touchY = drawable.touchY + inner.y
														time = touchTime
													}
												}
											}
										}

										backgroundDrawable.setTouchCoordsOverride(touchX, touchY - y)

										height -= y
									}

									canvas.clipRect(0, y, measuredWidth, y + height)

									backgroundDrawable.setCustomPaint(null)
									backgroundDrawable.setColor(context.getColor(R.color.transparent_background))
									backgroundDrawable.setBounds(0, y, measuredWidth, y + height)
									backgroundDrawable.draw(canvas)

									canvas.restore()
								}
							}
						}

						if (scrimView !== child && group == null && child.drawBackgroundInParent()) {
							canvas.save()
							canvas.translate(child.x, child.y)

							if (child.scaleX != 1f) {
								canvas.scale(child.scaleX, child.scaleY, child.pivotX, (child.height shr 1).toFloat())
							}

							child.drawBackgroundInternal(canvas, true)

							canvas.restore()
						}
					}
					else if (child is ChatActionCell) {
						if (child.hasGradientService()) {
							canvas.save()
							canvas.translate(child.x, child.y)
							canvas.scale(child.scaleX, child.scaleY, child.measuredWidth / 2f, child.measuredHeight / 2f)

							child.drawBackground(canvas, true)

							canvas.restore()
						}
					}
				}

				val scrimGroup: GroupedMessages? = (scrimView as? ChatMessageCell)?.currentMessagesGroup

				for (k in 0..2) {
					drawingGroups.clear()

					if (k == 2 && !chatListView!!.isFastScrollAnimationRunning) {
						continue
					}

					for (i in 0 until count) {
						val child = chatListView!!.getChildAt(i)

						if (child is ChatMessageCell) {
							if (child.getY() > chatListView!!.height || child.getY() + child.getHeight() < 0) {
								continue
							}

							val group = child.currentMessagesGroup

							if (group == null || k == 0 && group.messages.size == 1 || k == 1 && !group.transitionParams.drawBackgroundForDeletedItems) {
								continue
							}

							if (k == 0 && child.getMessageObject()!!.deleted || k == 1 && !child.getMessageObject()!!.deleted) {
								continue
							}

							if (k == 2 && !child.willRemovedAfterAnimation() || k != 2 && child.willRemovedAfterAnimation()) {
								continue
							}

							if (!drawingGroups.contains(group)) {
								group.transitionParams.left = 0
								group.transitionParams.top = 0
								group.transitionParams.right = 0
								group.transitionParams.bottom = 0
								group.transitionParams.pinnedBottom = false
								group.transitionParams.pinnedTop = false
								group.transitionParams.cell = child

								drawingGroups.add(group)
							}

							group.transitionParams.pinnedTop = child.isPinnedTop
							group.transitionParams.pinnedBottom = child.isPinnedBottom

							val left = child.left + child.getBackgroundDrawableLeft()
							val right = child.left + child.getBackgroundDrawableRight()
							var top = child.top + child.getBackgroundDrawableTop()
							var bottom = child.top + child.getBackgroundDrawableBottom()

							if (child.currentPosition!!.flags and MessageObject.POSITION_FLAG_TOP == 0) {
								top -= AndroidUtilities.dp(10f)
							}

							if (child.currentPosition!!.flags and MessageObject.POSITION_FLAG_BOTTOM == 0) {
								bottom += AndroidUtilities.dp(10f)
							}

							if (child.willRemovedAfterAnimation()) {
								group.transitionParams.cell = child
							}

							if (group.transitionParams.top == 0 || top < group.transitionParams.top) {
								group.transitionParams.top = top
							}

							if (group.transitionParams.bottom == 0 || bottom > group.transitionParams.bottom) {
								group.transitionParams.bottom = bottom
							}

							if (group.transitionParams.left == 0 || left < group.transitionParams.left) {
								group.transitionParams.left = left
							}

							if (group.transitionParams.right == 0 || right > group.transitionParams.right) {
								group.transitionParams.right = right
							}
						}
					}

					for (i in drawingGroups.indices) {
						val group = drawingGroups[i]

						if (group == scrimGroup) {
							continue
						}

						val x = group.transitionParams.cell!!.getNonAnimationTranslationX(true)
						val l = group.transitionParams.left + x + group.transitionParams.offsetLeft
						var t = group.transitionParams.top + group.transitionParams.offsetTop
						val r = group.transitionParams.right + x + group.transitionParams.offsetRight
						var b = group.transitionParams.bottom + group.transitionParams.offsetBottom

						if (!group.transitionParams.backgroundChangeBounds) {
							t += group.transitionParams.cell!!.translationY
							b += group.transitionParams.cell!!.translationY
						}

						if (t < chatListViewPadding - chatListViewPaddingVisibleOffset - AndroidUtilities.dp(20f)) {
							t = chatListViewPadding - chatListViewPaddingVisibleOffset - AndroidUtilities.dp(20f)
						}

						if (b > chatListView!!.measuredHeight + AndroidUtilities.dp(20f)) {
							b = (chatListView!!.measuredHeight + AndroidUtilities.dp(20f)).toFloat()
						}

						val useScale = group.transitionParams.cell!!.scaleX != 1f || group.transitionParams.cell!!.scaleY != 1f

						if (useScale) {
							canvas.save()
							canvas.scale(group.transitionParams.cell!!.scaleX, group.transitionParams.cell!!.scaleY, l + (r - l) / 2, t + (b - t) / 2)
						}

						var selected = true
						var a = 0
						val N = group.messages.size

						while (a < N) {
							val `object` = group.messages[a]
							val index = if (`object`.dialogId == dialogId) 0 else 1

							if (selectedMessagesIds[index].indexOfKey(`object`.id) < 0) {
								selected = false
								break
							}

							a++
						}

						group.transitionParams.cell!!.drawBackground(canvas, l.toInt(), t.toInt(), r.toInt(), b.toInt(), group.transitionParams.pinnedTop, group.transitionParams.pinnedBottom, selected, contentView!!.keyboardHeight)
						group.transitionParams.cell = null
						group.transitionParams.drawCaptionLayout = group.hasCaption

						if (useScale) {
							canvas.restore()

							for (ii in 0 until count) {
								val child = chatListView!!.getChildAt(ii)

								if (child is ChatMessageCell && child.currentMessagesGroup == group) {
									val left = child.left
									val top = child.top

									child.setPivotX(l - left + (r - l) / 2)
									child.setPivotY(t - top + (b - t) / 2)
								}
							}
						}
					}
				}
			}

			override fun drawChild(canvas: Canvas, child: View, drawingTime: Long): Boolean {
				var clipLeft = 0
				var clipBottom = 0
				var skipDraw = child === scrimView
				var cell: ChatMessageCell?
				val clipTop: Float = chatListViewPadding - chatListViewPaddingVisibleOffset - AndroidUtilities.dp(4f)

				if (child.y > measuredHeight || child.y + child.measuredHeight < clipTop) {
					skipDraw = true
				}

				val group: GroupedMessages?

				if (child is ChatMessageCell) {
					cell = child

					if (animateSendingViews.contains(cell)) {
						skipDraw = true
					}

					val position = child.currentPosition
					group = child.currentMessagesGroup

					if (position != null) {
						if (position.pw != position.spanSize && position.spanSize == 1000 && position.siblingHeights == null && group?.hasSibling == true) {
							clipLeft = child.getBackgroundDrawableLeft()
						}
						else if (position.siblingHeights != null) {
							clipBottom = child.getBottom() - AndroidUtilities.dp((1 + if (child.isPinnedBottom) 1 else 0).toFloat())
						}
					}

					if (child.needDelayRoundProgressDraw()) {
						drawLaterRoundProgressCell = child
					}

					if (!skipDraw && scrimView is ChatMessageCell) {
						val cell2 = scrimView as ChatMessageCell

						if (cell2.currentMessagesGroup != null && cell2.currentMessagesGroup == group) {
							skipDraw = true
						}
					}

					if (skipDraw) {
						child.photoImage.skipDraw()
					}
				}
				else {
					cell = null
					group = null
				}

				if (clipLeft != 0 || clipBottom != 0) {
					canvas.save()
				}

				val result: Boolean

				if (!skipDraw) {
					val clipToGroupBounds = group?.transitionParams?.backgroundChangeBounds == true
					@Suppress("NAME_SHADOWING") val cell = cell

					if (clipToGroupBounds) {
						canvas.save()

						if (cell != null && group != null) {
							val x = cell.getNonAnimationTranslationX(true)
							val l = group.transitionParams.left + x + group.transitionParams.offsetLeft
							val t = group.transitionParams.top + group.transitionParams.offsetTop
							val r = group.transitionParams.right + x + group.transitionParams.offsetRight
							val b = group.transitionParams.bottom + group.transitionParams.offsetBottom

							canvas.clipRect(l + AndroidUtilities.dp(4f), t + AndroidUtilities.dp(4f), r - AndroidUtilities.dp(4f), b - AndroidUtilities.dp(4f))
						}
					}

					if (cell != null && clipToGroupBounds) {
						cell.clipToGroupBounds = true

						result = super.drawChild(canvas, child, drawingTime)

						cell.clipToGroupBounds = false
					}
					else {
						result = super.drawChild(canvas, child, drawingTime)
					}

					if (clipToGroupBounds) {
						canvas.restore()
					}

					cell?.let {
						if (it.hasOutboundContent()) {
							canvas.save()
							canvas.translate(it.x, it.y)

							it.drawOutboundContent(canvas)

							canvas.restore()
						}
					}
				}
				else {
					result = false
				}

				if (clipLeft != 0 || clipBottom != 0) {
					canvas.restore()
				}

				if (child.translationY != 0f) {
					canvas.save()
					canvas.translate(0f, child.translationY)
				}

				cell?.drawCheckBox(canvas)

				if (child.translationY != 0f) {
					canvas.restore()
				}

				if (child.translationY != 0f) {
					canvas.save()
					canvas.translate(0f, child.translationY)
				}

				if (cell != null) {
					val message = cell?.getMessageObject()
					val position = cell?.currentPosition

					if (!skipDraw) {
						if (position != null || cell!!.transitionParams.animateBackgroundBoundsInner) {
							if (position == null || position.last || position.minX.toInt() == 0 && position.minY.toInt() == 0) {
								if (position == null || position.last) {
									drawTimeAfter.add(cell!!)
								}

								if ((position == null || position.minX.toInt() == 0 && position.minY.toInt() == 0) && cell!!.hasNameLayout()) {
									drawNamesAfter.add(cell!!)
								}
							}

							if (position != null || cell!!.transitionParams.transformGroupToSingleMessage || cell!!.transitionParams.animateBackgroundBoundsInner) {
								if (position == null || position.flags and MessageObject.POSITION_FLAG_BOTTOM != 0) {
									drawCaptionAfter.add(cell!!)
								}
							}
						}

						val videoPlayerContainer = videoPlayerContainer

						if (videoPlayerContainer != null && (message?.isRoundVideo == true || message?.isVideo == true) && MediaController.getInstance().isPlayingMessage(message)) {
							val imageReceiver = cell!!.photoImage
							val newX = imageReceiver.imageX + cell!!.x
							val newY = cell!!.y + imageReceiver.imageY + chatListView!!.y - videoPlayerContainer.top

							if (videoPlayerContainer.translationX != newX || videoPlayerContainer.translationY != newY) {
								videoPlayerContainer.translationX = newX
								videoPlayerContainer.translationY = newY

								fragmentView?.invalidate()

								videoPlayerContainer.invalidate()
							}
						}
					}

					val imageReceiver = cell?.getAvatarImage()

					if (imageReceiver != null) {
						val groupedMessages = getValidGroupedMessage(message)

						if (cell?.getMessageObject()?.deleted == true) {
							if (child.translationY != 0f) {
								canvas.restore()
							}

							imageReceiver.setVisible(value = false, invalidate = false)

							return result
						}

						val replaceAnimation = chatListView!!.isFastScrollAnimationRunning || groupedMessages != null && groupedMessages.transitionParams.backgroundChangeBounds
						var top = if (replaceAnimation) child.top else child.y.toInt()

						if (cell!!.drawPinnedBottom()) {
							var p: Int

							if (cell!!.willRemovedAfterAnimation()) {
								p = chatScrollHelper?.positionToOldView?.indexOfValue(child) ?: -1

								if (p >= 0) {
									p = chatScrollHelper?.positionToOldView?.keyAt(p) ?: -1
								}
							}
							else {
								val holder = chatListView!!.getChildViewHolder(child)
								p = holder.adapterPosition
							}

							if (p >= 0) {
								var nextPosition: Int

								if (groupedMessages != null && position != null) {
									val idx = groupedMessages.posArray.indexOf(position)
									val size = groupedMessages.posArray.size

									if (position.flags and MessageObject.POSITION_FLAG_BOTTOM != 0) {
										nextPosition = p - size + idx
									}
									else {
										nextPosition = p - 1

										for (a in idx + 1 until size) {
											if (groupedMessages.posArray[a].minY > position.maxY) {
												break
											}
											else {
												nextPosition--
											}
										}
									}
								}
								else {
									nextPosition = p - 1
								}

								if (cell?.willRemovedAfterAnimation() == true) {
									val view = chatScrollHelper?.positionToOldView?.get(nextPosition)

									if (view != null) {
										if (child.translationY != 0f) {
											canvas.restore()
										}

										imageReceiver.setVisible(value = false, invalidate = false)

										return result
									}
								}
								else {
									val holder = chatListView?.findViewHolderForAdapterPosition(nextPosition)

									if (holder != null) {
										if (child.translationY != 0f) {
											canvas.restore()
										}

										imageReceiver.setVisible(value = false, invalidate = false)

										return result
									}
								}
							}
						}

						val tx = cell!!.slidingOffsetX + cell!!.getCheckBoxTranslation()
						var y: Int = ((if (replaceAnimation) child.top else child.y.toInt()) + cell!!.layoutHeight + cell!!.transitionParams.deltaBottom).toInt()
						val maxY = chatListView!!.measuredHeight - chatListView!!.paddingBottom

						if (cell!!.isPlayingRound() || cell!!.transitionParams.animatePlayingRound) {
							if (cell!!.transitionParams.animatePlayingRound) {
								var progressLocal = cell!!.transitionParams.animateChangeProgress

								if (!cell!!.isPlayingRound()) {
									progressLocal = 1f - progressLocal
								}

								val fromY = y
								val toY = min(y, maxY)

								y = (fromY * progressLocal + toY * (1f - progressLocal)).toInt()
							}
						}
						else {
							if (y > maxY) {
								y = maxY
							}
						}

						if (!replaceAnimation && child.translationY != 0f) {
							canvas.restore()
						}

						if (cell!!.drawPinnedTop()) {
							var p: Int

							if (cell!!.willRemovedAfterAnimation()) {
								p = chatScrollHelper!!.positionToOldView.indexOfValue(child)

								if (p >= 0) {
									p = chatScrollHelper!!.positionToOldView.keyAt(p)
								}
							}
							else {
								val holder = chatListView!!.getChildViewHolder(child)
								p = holder.adapterPosition
							}

							if (p >= 0) {
								var tries = 0

								while (true) {
									if (tries >= 20) {
										break
									}

									tries++

									var prevPosition: Int

									if (groupedMessages != null && position != null) {
										val idx = groupedMessages.posArray.indexOf(position)

										if (idx < 0) {
											break
										}

										if (position.flags and MessageObject.POSITION_FLAG_TOP != 0) {
											prevPosition = p + idx + 1
										}
										else {
											prevPosition = p + 1

											for (a in idx - 1 downTo 0) {
												if (groupedMessages.posArray[a].maxY < position.minY) {
													break
												}
												else {
													prevPosition++
												}
											}
										}
									}
									else {
										prevPosition = p + 1
									}

									if (cell!!.willRemovedAfterAnimation()) {
										val view = chatScrollHelper?.positionToOldView?.get(prevPosition)

										if (view != null) {
											top = view.top

											if (view is ChatMessageCell) {
												cell = view

												p = if (!cell!!.drawPinnedTop()) {
													break
												}
												else {
													prevPosition
												}
											}
											else {
												break
											}
										}
										else {
											break
										}
									}
									else {
										val holder = chatListView?.findViewHolderForAdapterPosition(prevPosition)

										if (holder != null) {
											top = holder.itemView.top

											if (holder.itemView is ChatMessageCell) {
												cell = holder.itemView

												p = if (!cell!!.drawPinnedTop()) {
													break
												}
												else {
													prevPosition
												}
											}
											else {
												break
											}
										}
										else {
											break
										}
									}
								}
							}
						}

						if (y - AndroidUtilities.dp(48f) < top) {
							y = top + AndroidUtilities.dp(48f)
						}

						if (!cell!!.drawPinnedBottom()) {
							val cellBottom = if (replaceAnimation) cell!!.bottom else (cell!!.y + cell!!.measuredHeight + cell!!.transitionParams.deltaBottom).toInt()

							if (y > cellBottom) {
								y = cellBottom
							}
						}

						canvas.save()

						if (tx != 0f) {
							canvas.translate(tx, 0f)
						}

						if (cell?.currentMessagesGroup?.transitionParams?.backgroundChangeBounds == true) {
							y -= cell!!.translationY.toInt()
						}

						imageReceiver.imageY = (y - AndroidUtilities.dp(44f)).toFloat()

						if (cell!!.shouldDrawAlphaLayer()) {
							imageReceiver.alpha = cell!!.alpha
							canvas.scale(cell!!.scaleX, cell!!.scaleY, cell!!.x + cell!!.pivotX, cell!!.y + (cell!!.height shr 1))
						}
						else {
							imageReceiver.alpha = 1f
						}

						imageReceiver.setVisible(value = true, invalidate = false)
						imageReceiver.draw(canvas)

						canvas.restore()

						if (!replaceAnimation && child.translationY != 0f) {
							canvas.save()
						}
					}
				}

				if (child.translationY != 0f) {
					canvas.restore()
				}

				return result
			}

			override fun onInitializeAccessibilityNodeInfo(info: AccessibilityNodeInfo) {
				if (currentEncryptedChat != null) {
					return
				}

				super.onInitializeAccessibilityNodeInfo(info)

				val collection = info.collectionInfo

				if (collection != null) {
					info.collectionInfo = CollectionInfo.obtain(collection.rowCount, 1, false)
				}
			}

			override fun createAccessibilityNodeInfo(): AccessibilityNodeInfo? {
				return if (currentEncryptedChat != null) {
					null
				}
				else {
					super.createAccessibilityNodeInfo()
				}
			}

			override fun invalidate() {
				if (invalidated && slidingView == null) {
					return
				}

				invalidated = true

				super.invalidate()

				contentView?.invalidateBlur()
			}
		}

		if (currentEncryptedChat != null) {
			chatListView?.importantForAccessibility = View.IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS
		}

		chatListView?.setAccessibilityEnabled(false)
		chatListView?.isNestedScrollingEnabled = false
		chatListView?.setInstantClick(true)
		chatListView?.setDisableHighlightState(true)
		chatListView?.tag = 1
		chatListView?.isVerticalScrollBarEnabled = !SharedConfig.chatBlurEnabled()
		chatListView?.adapter = ChatActivityAdapter(context).also { chatAdapter = it }
		chatListView?.clipToPadding = false
		chatListView?.setAnimateEmptyView(true, 1)
		chatListView?.scrollBarStyle = View.SCROLLBARS_OUTSIDE_OVERLAY

		chatListViewPadding = 0f

		invalidateChatListViewTopPadding()

		if (MessagesController.getGlobalMainSettings().getBoolean("view_animations", true)) {
			chatListItemAnimator = object : ChatListItemAnimator(this@ChatActivity, chatListView!!) {
				var finishRunnable: Runnable? = null

				override fun checkIsRunning() {
					if (scrollAnimationIndex == -1) {
						scrollAnimationIndex = notificationCenter.setAnimationInProgress(scrollAnimationIndex, allowedNotificationsDuringChatListAnimations, false)
					}
				}

				override fun onAnimationStart() {
					scrollAnimationIndex = notificationCenter.setAnimationInProgress(scrollAnimationIndex, allowedNotificationsDuringChatListAnimations, false)

					if (finishRunnable != null) {
						AndroidUtilities.cancelRunOnUIThread(finishRunnable)
						finishRunnable = null
					}

					chatActivityEnterView?.adjustPanLayoutHelper?.runDelayedAnimation()
					chatActivityEnterView?.runEmojiPanelAnimation()
				}

				override fun onAllAnimationsDone() {
					super.onAllAnimationsDone()

					if (finishRunnable != null) {
						AndroidUtilities.cancelRunOnUIThread(finishRunnable)
						finishRunnable = null
					}

					AndroidUtilities.runOnUIThread(Runnable {
						finishRunnable = null

						if (scrollAnimationIndex != -1) {
							notificationCenter.onAnimationFinish(scrollAnimationIndex)
							scrollAnimationIndex = -1
						}
					}.also { finishRunnable = it })
				}

				override fun endAnimations() {
					super.endAnimations()

					if (finishRunnable != null) {
						AndroidUtilities.cancelRunOnUIThread(finishRunnable)
					}

					AndroidUtilities.runOnUIThread(Runnable {
						finishRunnable = null

						if (scrollAnimationIndex != -1) {
							notificationCenter.onAnimationFinish(scrollAnimationIndex)
							scrollAnimationIndex = -1
						}
					}.also { finishRunnable = it })
				}
			}
		}

		chatLayoutManager = object : GridLayoutManagerFixed(context, 1000, VERTICAL, true) {
			var computingScroll = false

			override fun getStarForFixGap(): Int {
				var padding = chatListViewPadding.toInt()

				if (isThreadChat && pinnedMessageView != null && pinnedMessageView!!.visibility == View.VISIBLE) {
					padding -= max(0f, AndroidUtilities.dp(48f) + pinnedMessageEnterOffset).toInt()
				}

				return padding
			}

			override fun getParentStart(): Int {
				return if (computingScroll) {
					chatListViewPadding.toInt()
				}
				else {
					0
				}
			}

			override fun getStartAfterPadding(): Int {
				return if (computingScroll) {
					chatListViewPadding.toInt()
				}
				else {
					super.getStartAfterPadding()
				}
			}

			override fun getTotalSpace(): Int {
				return if (computingScroll) {
					(height - chatListViewPadding - paddingBottom).toInt()
				}
				else {
					super.getTotalSpace()
				}
			}

			override fun computeVerticalScrollExtent(state: RecyclerView.State): Int {
				computingScroll = true
				val r = super.computeVerticalScrollExtent(state)
				computingScroll = false
				return r
			}

			override fun computeVerticalScrollOffset(state: RecyclerView.State): Int {
				computingScroll = true
				val r = super.computeVerticalScrollOffset(state)
				computingScroll = false
				return r
			}

			override fun computeVerticalScrollRange(state: RecyclerView.State): Int {
				computingScroll = true
				val r = super.computeVerticalScrollRange(state)
				computingScroll = false
				return r
			}

			override fun scrollToPositionWithOffset(position: Int, offset: Int, bottom: Boolean) {
				@Suppress("NAME_SHADOWING") var offset = offset

				if (!bottom) {
					offset = (offset - paddingTop + chatListViewPadding).toInt()
				}

				super.scrollToPositionWithOffset(position, offset, bottom)
			}

			override fun supportsPredictiveItemAnimations(): Boolean {
				return true
			}

			override fun smoothScrollToPosition(recyclerView: RecyclerView, state: RecyclerView.State, position: Int) {
				scrollByTouch = false
				val linearSmoothScroller = LinearSmoothScrollerCustom(recyclerView.context, LinearSmoothScrollerCustom.POSITION_MIDDLE)
				linearSmoothScroller.targetPosition = position
				startSmoothScroll(linearSmoothScroller)
			}

			override fun shouldLayoutChildFromOppositeSide(child: View): Boolean {
				return if (child is ChatMessageCell) {
					child.getMessageObject()?.isOutOwner != true
				}
				else {
					false
				}
			}

			override fun hasSiblingChild(position: Int): Boolean {
				if (position >= chatAdapter!!.messagesStartRow && position < chatAdapter!!.messagesEndRow) {
					val index = position - chatAdapter!!.messagesStartRow

					if (index >= 0 && index < messages.size) {
						val message = messages[index]
						val group = getValidGroupedMessage(message)

						if (group != null) {
							val pos = group.positions[message]

							if (pos!!.minX == pos.maxX || pos.minY != pos.maxY || pos.minY.toInt() == 0) {
								return false
							}

							val count = group.posArray.size

							for (a in 0 until count) {
								val p = group.posArray[a]

								if (p == pos) {
									continue
								}

								if (p.minY <= pos.minY && p.maxY >= pos.minY) {
									return true
								}
							}
						}
					}
				}

				return false
			}

			override fun onLayoutChildren(recycler: Recycler, state: RecyclerView.State) {
				if (BuildConfig.DEBUG_PRIVATE_VERSION) {
					super.onLayoutChildren(recycler, state)
				}
				else {
					try {
						super.onLayoutChildren(recycler, state)
					}
					catch (e: Exception) {
						FileLog.e(e)

						AndroidUtilities.runOnUIThread {
							chatAdapter?.notifyDataSetChanged(false)
						}
					}
				}
			}

			override fun scrollVerticallyBy(dy: Int, recycler: Recycler, state: RecyclerView.State): Int {
				@Suppress("NAME_SHADOWING") var dy = dy

				if (dy < 0 && pullingDownOffset != 0f) {
					pullingDownOffset += dy.toFloat()

					if (pullingDownOffset < 0) {
						dy = pullingDownOffset.toInt()
						pullingDownOffset = 0f
						chatListView?.invalidate()
					}
					else {
						dy = 0
					}
				}

				val n = chatListView?.childCount ?: 0
				var scrolled = 0
				var foundTopView = false

				for (i in 0 until n) {
					val child = chatListView?.getChildAt(i) ?: continue
					var padding: Float = chatListViewPadding

					if (isThreadChat && pinnedMessageView != null && pinnedMessageView!!.visibility == View.VISIBLE) {
						padding -= max(0f, AndroidUtilities.dp(48f) + pinnedMessageEnterOffset)
					}

					if (chatListView?.getChildAdapterPosition(child) == (chatAdapter?.itemCount ?: -1) - 1) {
						var dyLocal = dy

						if (child.top - dy > padding) {
							dyLocal = (child.top - padding).toInt()
						}

						scrolled = super.scrollVerticallyBy(dyLocal, recycler, state)
						foundTopView = true

						break
					}
				}

				if (!foundTopView) {
					scrolled = super.scrollVerticallyBy(dy, recycler, state)
				}

				if (dy > 0 && scrolled == 0 && isChannel(currentChat) && !currentChat!!.megagroup && chatListView?.scrollState == RecyclerView.SCROLL_STATE_DRAGGING && chatListView?.isFastScrollAnimationRunning != true && chatListView?.isMultiselect != true && reportType < 0) {
					if (pullingDownOffset == 0f) {
						pullingDownDrawable?.updateDialog()
					}

					pullingDownBackAnimator?.removeAllListeners()
					pullingDownBackAnimator?.cancel()

					val k = if (pullingDownOffset < AndroidUtilities.dp(110f)) {
						val progress = pullingDownOffset / AndroidUtilities.dp(110f)
						0.65f * (1f - progress) + 0.45f * progress
					}
					else if (pullingDownOffset < AndroidUtilities.dp(160f)) {
						val progress = (pullingDownOffset - AndroidUtilities.dp(110f)) / AndroidUtilities.dp(50f)
						0.45f * (1f - progress) + 0.05f * progress
					}
					else {
						0.05f
					}

					pullingDownOffset += dy * k

					ReactionsEffectOverlay.onScrolled((dy * k).toInt())

					chatListView?.invalidate()
				}

				if (pullingDownOffset == 0f) {
					chatListView?.overScrollMode = View.OVER_SCROLL_ALWAYS
				}
				else {
					chatListView?.overScrollMode = View.OVER_SCROLL_NEVER
				}


				pullingDownDrawable?.showBottomPanel(pullingDownOffset > 0 && chatListView?.scrollState == RecyclerView.SCROLL_STATE_DRAGGING)

				return scrolled
			}
		}

		chatLayoutManager?.spanSizeLookup = object : SpanSizeLookup() {
			override fun getSpanSize(position: Int): Int {
				if (position >= chatAdapter!!.messagesStartRow && position < chatAdapter!!.messagesEndRow) {
					val idx = position - chatAdapter!!.messagesStartRow

					if (idx >= 0 && idx < messages.size) {
						val message = messages[idx]
						val groupedMessages = getValidGroupedMessage(message)

						if (groupedMessages != null) {
							return groupedMessages.positions[message]?.spanSize ?: 1000
						}
					}
				}

				return 1000
			}
		}

		chatListView?.layoutManager = chatLayoutManager

		chatListView?.addItemDecoration(object : RecyclerView.ItemDecoration() {
			override fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State) {
				outRect.bottom = 0

				if (view is ChatMessageCell) {
					val group = view.currentMessagesGroup

					if (group != null) {
						val position = view.currentPosition

						if (position?.siblingHeights != null) {
							val maxHeight = max(AndroidUtilities.displaySize.x, AndroidUtilities.displaySize.y) * 0.5f
							var h = view.getExtraInsetHeight()

							for (a in position.siblingHeights!!.indices) {
								h += ceil((maxHeight * position.siblingHeights!![a]).toDouble()).toInt()
							}

							h += (position.maxY - position.minY) * (7 * AndroidUtilities.density).roundToInt()

							val count = group.posArray.size

							for (a in 0 until count) {
								val pos = group.posArray[a]

								if (pos.minY != position.minY || pos.minX == position.minX && pos.maxX == position.maxX && pos.minY == position.minY && pos.maxY == position.maxY) {
									continue
								}

								if (pos.minY == position.minY) {
									h -= ceil((maxHeight * pos.ph).toDouble()).toInt() - AndroidUtilities.dp(4f)
									break
								}
							}

							outRect.bottom = -h
						}
					}
				}
			}
		})

		contentView?.addView(chatListView, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT.toFloat()))

		chatListView?.setOnItemLongClickListener(onItemLongClickListener)
		chatListView?.setOnItemClickListener(onItemClickListener)

		chatListView?.addOnScrollListener(object : RecyclerView.OnScrollListener() {
			private val scrollValue = AndroidUtilities.dp(100f)
			private var totalDy = 0f
			private var scrollUp = false

			override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) {
				if (newState == RecyclerView.SCROLL_STATE_IDLE) {
					if (pollHintCell != null) {
						pollHintView?.showForMessageCell(pollHintCell, -1, pollHintX, pollHintY, true)
						pollHintCell = null
					}

					scrollingFloatingDate = false
					scrollingChatListView = false
					checkTextureViewPosition = false

					hideFloatingDateView(true)

					checkAutoDownloadMessages(scrollUp)

					if (SharedConfig.getDevicePerformanceClass() == SharedConfig.PERFORMANCE_CLASS_LOW) {
						NotificationCenter.globalInstance.postNotificationName(NotificationCenter.startAllHeavyOperations, 512)
					}

					NotificationCenter.globalInstance.postNotificationName(NotificationCenter.startSpoilers)

					chatListView?.overScrollMode = RecyclerView.OVER_SCROLL_ALWAYS

					textSelectionHelper.stopScrolling()

					updateVisibleRows()

					scrollByTouch = false
				}
				else {
					if (newState == RecyclerView.SCROLL_STATE_SETTLING) {
						wasManualScroll = true
						scrollingChatListView = true
					}
					else if (newState == RecyclerView.SCROLL_STATE_DRAGGING) {
						pollHintCell = null
						wasManualScroll = true
						scrollingFloatingDate = true
						checkTextureViewPosition = true
						scrollingChatListView = true
					}

					if (SharedConfig.getDevicePerformanceClass() == SharedConfig.PERFORMANCE_CLASS_LOW) {
						NotificationCenter.globalInstance.postNotificationName(NotificationCenter.stopAllHeavyOperations, 512)
					}

					NotificationCenter.globalInstance.postNotificationName(NotificationCenter.stopSpoilers)
				}
			}

			override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
				chatListView?.invalidate()

				scrollUp = dy < 0

				val firstVisibleItem = chatLayoutManager!!.findFirstVisibleItemPosition()

				if (dy != 0 && scrollByTouch && recyclerView.scrollState == RecyclerView.SCROLL_STATE_SETTLING || recyclerView.scrollState == RecyclerView.SCROLL_STATE_DRAGGING) {
					if (forceNextPinnedMessageId != 0) {
						if (!scrollUp || forceScrollToFirst) {
							forceNextPinnedMessageId = 0
						}
						else if (chatListView?.isFastScrollAnimationRunning != true && firstVisibleItem != RecyclerView.NO_POSITION) {
							val lastVisibleItem = chatLayoutManager!!.findLastVisibleItemPosition()
							var messageObject: MessageObject? = null
							var foundForceNextPinnedView = false

							for (i in lastVisibleItem downTo firstVisibleItem) {
								val view = chatLayoutManager?.findViewByPosition(i)

								if (view is ChatMessageCell) {
									messageObject = view.getMessageObject()
								}
								else if (view is ChatActionCell) {
									messageObject = view.messageObject
								}

								if (messageObject != null) {
									if (forceNextPinnedMessageId == messageObject?.id) {
										foundForceNextPinnedView = true
										break
									}
								}
							}

							if (!foundForceNextPinnedView && messageObject != null && messageObject!!.id < forceNextPinnedMessageId) {
								forceNextPinnedMessageId = 0
							}
						}
					}
				}

				if (recyclerView.scrollState == RecyclerView.SCROLL_STATE_DRAGGING) {
					forceScrollToFirst = false

					if (!wasManualScroll && dy != 0) {
						wasManualScroll = true
					}
				}

				if (dy != 0) {
					hideHints(true)
				}

				if (dy != 0 && scrollingFloatingDate && !currentFloatingTopIsNotMessage) {
					if (highlightMessageId != Int.MAX_VALUE) {
						removeSelectedMessageHighlight()
						updateVisibleRows()
					}

					showFloatingDateView(true)
				}

				checkScrollForLoad(true)

				if (firstVisibleItem != RecyclerView.NO_POSITION) {
					if (firstVisibleItem == 0 && forwardEndReached[0]) {
						if (dy >= 0) {
							canShowPagedownButton = false
							updatePagedownButtonVisibility(true)
						}
					}
					else {
						if (dy > 0) {
							if (pagedownButton?.tag == null) {
								totalDy += dy.toFloat()

								if (totalDy > scrollValue) {
									totalDy = 0f
									canShowPagedownButton = true
									updatePagedownButtonVisibility(true)
									pagedownButtonShowedByScroll = true
								}
							}
						}
						else {
							if (pagedownButtonShowedByScroll && pagedownButton?.tag != null) {
								totalDy += dy.toFloat()

								if (totalDy < -scrollValue) {
									canShowPagedownButton = false
									updatePagedownButtonVisibility(true)
									totalDy = 0f
								}
							}
						}
					}
				}

				invalidateMessagesVisiblePart()
				textSelectionHelper.onParentScrolled()
				emojiAnimationsOverlay?.onScrolled(dy)
				ReactionsEffectOverlay.onScrolled(dy)
			}
		})

		animatingImageView = ClippingImageView(context)
		animatingImageView?.gone()

		contentView?.addView(animatingImageView, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT.toFloat()))

		progressView = FrameLayout(context)
		progressView?.invisible()

		contentView?.addView(progressView, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.TOP or Gravity.LEFT))

		progressView2 = View(context)
		progressView2?.background = Theme.createServiceDrawable(AndroidUtilities.dp(18f), progressView2, contentView, Paint())

		progressView?.addView(progressView2, createFrame(36, 36, Gravity.CENTER))

		loaderAnimationView = RLottieImageView(context)
		loaderAnimationView?.setAutoRepeat(true)
		loaderAnimationView?.setAnimation(R.raw.ello_loader, 28, 28)

		progressView?.addView(loaderAnimationView, createFrame(32, 32, Gravity.CENTER))

		floatingDateView = object : ChatActionCell(context, false) {
			override fun setTranslationY(translationY: Float) {
				if (getTranslationY() != translationY) {
					invalidate()
				}

				super.setTranslationY(translationY)
			}

			override fun onInterceptTouchEvent(ev: MotionEvent): Boolean {
				return if (alpha == 0f || actionBar!!.isActionModeShowed || reportType >= 0) {
					false
				}
				else {
					super.onInterceptTouchEvent(ev)
				}
			}

			override fun onTouchEvent(event: MotionEvent): Boolean {
				return if (alpha == 0f || actionBar!!.isActionModeShowed || reportType >= 0) {
					false
				}
				else {
					super.onTouchEvent(event)
				}
			}

			override fun onDraw(canvas: Canvas) {
				val clipTop = (chatListView?.y ?: 0f) + chatListViewPadding - y - AndroidUtilities.dp(4f).toFloat()

				if (clipTop > 0) {
					if (clipTop < measuredHeight) {
						canvas.save()
						canvas.clipRect(0f, clipTop, measuredWidth.toFloat(), measuredHeight.toFloat())
						super.onDraw(canvas)
						canvas.restore()
					}
				}
				else {
					super.onDraw(canvas)
				}
			}
		}

		floatingDateView?.setCustomDate((System.currentTimeMillis() / 1000).toInt(), scheduled = false, inLayout = false)
		floatingDateView?.alpha = 0.0f
		floatingDateView?.importantForAccessibility = View.IMPORTANT_FOR_ACCESSIBILITY_NO
		floatingDateView?.setInvalidateColors(true)

		contentView?.addView(floatingDateView, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.TOP or Gravity.CENTER_HORIZONTAL, 0f, 4f, 0f, 0f))

		floatingDateView?.setOnClickListener {
			if (floatingDateView?.alpha == 0f || actionBar?.isActionModeShowed == true || reportType >= 0) {
				return@setOnClickListener
			}

			val calendar = Calendar.getInstance()
			calendar.timeInMillis = (floatingDateView?.customDate?.toLong() ?: 0L) * 1000

			val year = calendar[Calendar.YEAR]
			val monthOfYear = calendar[Calendar.MONTH]
			val dayOfMonth = calendar[Calendar.DAY_OF_MONTH]

			calendar.clear()
			calendar[year, monthOfYear] = dayOfMonth

			jumpToDate((calendar.time.time / 1000).toInt())
		}

		if (currentChat != null) {
			pendingRequestsDelegate = ChatActivityMemberRequestsDelegate(this, currentChat) { invalidateChatListViewTopPadding() }
			pendingRequestsDelegate?.setChatInfo(currentChatInfo, false)

			contentView?.addView(pendingRequestsDelegate!!.view, ViewGroup.LayoutParams.MATCH_PARENT, pendingRequestsDelegate!!.viewHeight)
		}

		if (currentEncryptedChat == null) {
			pinnedMessageView = object : BlurredFrameLayout(context, contentView) {
				var lastY = 0f
				var startY = 0f

				init {
					setOnLongClickListener {
						if (AndroidUtilities.isTablet() || isThreadChat) {
							return@setOnLongClickListener false
						}

						startY = lastY

						openPinnedMessagesList(true)

						true
					}
				}

				override fun onTouchEvent(event: MotionEvent): Boolean {
					lastY = event.y

					if (event.action == MotionEvent.ACTION_UP) {
						finishPreviewFragment()
					}
					else if (event.action == MotionEvent.ACTION_MOVE) {
						val dy = startY - lastY

						movePreviewFragment(dy)

						if (dy < 0) {
							startY = lastY
						}
					}

					return super.onTouchEvent(event)
				}

				override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
					super.onMeasure(widthMeasureSpec, heightMeasureSpec)

					if (setPinnedTextTranslationX) {
						for (animatorSet in pinnedNextAnimation) {
							animatorSet?.start()
						}

						setPinnedTextTranslationX = false
					}
				}

				override fun drawChild(canvas: Canvas, child: View, drawingTime: Long): Boolean {
					if (child === pinnedLineView) {
						canvas.save()
						canvas.clipRect(0, 0, measuredWidth, AndroidUtilities.dp(48f))
					}

					val result: Boolean

					if (child === pinnedMessageTextView[0] || child === pinnedMessageTextView[1]) {
						canvas.save()
						canvas.clipRect(0, 0, measuredWidth - AndroidUtilities.dp(38f), measuredHeight)
						result = super.drawChild(canvas, child, drawingTime)
						canvas.restore()
					}
					else {
						result = super.drawChild(canvas, child, drawingTime)

						if (child === pinnedLineView) {
							canvas.restore()
						}
					}

					return result
				}
			}

			pinnedMessageView?.tag = 1

			pinnedMessageEnterOffset = -AndroidUtilities.dp(50f).toFloat()

			pinnedMessageView?.gone()
			pinnedMessageView?.setBackgroundResource(R.drawable.blockpanel)
			pinnedMessageView?.setBackgroundResource(R.color.background)
			pinnedMessageView?.backgroundPaddingBottom = AndroidUtilities.dp(2f)

			contentView?.addView(pinnedMessageView, createFrame(LayoutHelper.MATCH_PARENT, 50, Gravity.TOP or Gravity.LEFT))

			pinnedMessageView?.setOnClickListener {
				wasManualScroll = true

				if (isThreadChat) {
					scrollToMessageId(threadId, 0, true, 0, true, 0)
				}
				else if (currentPinnedMessageId != 0) {
					val currentPinned = currentPinnedMessageId
					var forceNextPinnedMessageId = 0

					if (pinnedMessageIds.isNotEmpty()) {
						if (currentPinned == pinnedMessageIds[pinnedMessageIds.size - 1]) {
							forceNextPinnedMessageId = pinnedMessageIds[0] + 1
							forceScrollToFirst = true
						}
						else {
							forceNextPinnedMessageId = currentPinned - 1
							forceScrollToFirst = false
						}
					}

					this.forceNextPinnedMessageId = forceNextPinnedMessageId

					if (!forceScrollToFirst) {
						forceNextPinnedMessageId = -forceNextPinnedMessageId
					}

					scrollToMessageId(currentPinned, 0, true, 0, true, forceNextPinnedMessageId)

					updateMessagesVisiblePart(false)
				}
			}

			pinnedMessageView?.isEnabled = !isInPreviewMode

			val selector = View(context)

			selector.background = Theme.getSelectorDrawable(false)

			pinnedMessageView?.addView(selector, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT.toFloat(), Gravity.LEFT or Gravity.TOP, 0f, 0f, 0f, 2f))

			pinnedLineView = PinnedLineView(context)

			pinnedMessageView?.addView(pinnedLineView, createFrame(2, 48f, Gravity.LEFT or Gravity.TOP, 8f, 0f, 0f, 0f))

			pinnedCounterTextView = NumberTextView(context)
			pinnedCounterTextView?.setAddNumber()
			pinnedCounterTextView?.setTextSize(14)
			pinnedCounterTextView?.setTextColor(ResourcesCompat.getColor(context.resources, R.color.brand, null))
			pinnedCounterTextView?.setTypeface(Theme.TYPEFACE_BOLD)

			pinnedMessageView?.addView(pinnedCounterTextView, createFrame(LayoutHelper.MATCH_PARENT, 18f, Gravity.TOP or Gravity.LEFT, 18f, 7f, 44f, 0f))

			for (a in 0..1) {
				pinnedNameTextView[a] = TrackingWidthSimpleTextView(context)
				pinnedNameTextView[a]?.setTextSize(14)
				pinnedNameTextView[a]?.textColor = context.getColor(R.color.brand)
				pinnedNameTextView[a]?.setTypeface(Theme.TYPEFACE_BOLD)

				pinnedMessageView?.addView(pinnedNameTextView[a], createFrame(LayoutHelper.MATCH_PARENT, 18f, Gravity.TOP or Gravity.LEFT, 18f, 7.3f, 44f, 0f))

				pinnedMessageTextView[a] = object : SimpleTextView(context) {
					override fun setTranslationY(translationY: Float) {
						super.setTranslationY(translationY)

						if (this == pinnedMessageTextView[0] && pinnedNextAnimation[1] != null) {
							if (forceScrollToFirst && translationY < 0) {
								pinnedLineView?.translationY = translationY / 2
							}
							else {
								pinnedLineView?.translationY = 0f
							}
						}
					}
				}

				pinnedMessageTextView[a]?.setTextSize(14)
				pinnedMessageTextView[a]?.textColor = context.getColor(R.color.text)

				pinnedMessageView?.addView(pinnedMessageTextView[a], createFrame(LayoutHelper.MATCH_PARENT, 18f, Gravity.TOP or Gravity.LEFT, 18f, 25.3f, 44f, 0f))

				pinnedMessageButton[a] = PinnedMessageButton(context)

				pinnedMessageView?.addView(pinnedMessageButton[a], createFrame(LayoutHelper.WRAP_CONTENT, 28f, Gravity.TOP or Gravity.RIGHT, 0f, 10f, 14f, 0f))

				pinnedMessageImageView[a] = BackupImageView(context)
				pinnedMessageImageView[a]?.setRoundRadius(AndroidUtilities.dp(2f))

				pinnedMessageView?.addView(pinnedMessageImageView[a], createFrame(32, 32f, Gravity.TOP or Gravity.LEFT, 17f, 8f, 0f, 0f))

				if (a == 1) {
					pinnedNameTextView[a]?.invisible()
					pinnedMessageButton[a]?.invisible()
					pinnedMessageTextView[a]?.invisible()
					pinnedMessageImageView[a]?.invisible()
				}
			}

			pinnedListButton = ImageView(context)
			pinnedListButton?.setImageResource(R.drawable.msg_pinnedlist)
			pinnedListButton?.colorFilter = PorterDuffColorFilter(context.getColor(R.color.brand), PorterDuff.Mode.SRC_IN)
			pinnedListButton?.scaleType = ImageView.ScaleType.CENTER
			pinnedListButton?.contentDescription = context.getString(R.string.AccPinnedMessagesList)
			pinnedListButton?.invisible()
			pinnedListButton?.alpha = 0.0f
			pinnedListButton?.scaleX = 0.4f
			pinnedListButton?.scaleY = 0.4f
			pinnedListButton?.background = Theme.createSelectorDrawable(context.getColor(R.color.light_background))

			pinnedMessageView?.addView(pinnedListButton, createFrame(36, 48f, Gravity.RIGHT or Gravity.TOP, 0f, 0f, 7f, 0f))

			pinnedListButton?.setOnClickListener {
				openPinnedMessagesList(false)
			}

			closePinned = ImageView(context)
			closePinned?.setImageResource(R.drawable.miniplayer_close)
			closePinned?.colorFilter = PorterDuffColorFilter(context.getColor(R.color.brand), PorterDuff.Mode.SRC_IN)
			closePinned?.scaleType = ImageView.ScaleType.CENTER
			closePinned?.contentDescription = context.getString(R.string.Close)

			pinnedProgress = RadialProgressView(context)
			pinnedProgress?.gone()
			pinnedProgress?.setSize(AndroidUtilities.dp(16f))
			pinnedProgress?.setStrokeWidth(2f)

			pinnedMessageView?.addView(pinnedProgress, createFrame(36, 48f, Gravity.RIGHT or Gravity.TOP, 0f, 0f, 2f, 0f))

			if (threadId != 0) {
				closePinned?.gone()
			}

			closePinned?.background = Theme.createSelectorDrawable(context.getColor(R.color.light_background), 1, AndroidUtilities.dp(14f))

			pinnedMessageView?.addView(closePinned, createFrame(36, 48f, Gravity.RIGHT or Gravity.TOP, 0f, 0f, 2f, 0f))

			closePinned?.setOnClickListener {
				if (parentActivity == null) {
					return@setOnClickListener
				}

				val allowPin = if (currentChat != null) {
					canPinMessages(currentChat)
				}
				else if (currentEncryptedChat == null) {
					currentUserInfo?.can_pin_message == true
				}
				else {
					false
				}

				if (allowPin) {
					val builder = AlertDialog.Builder(parentActivity!!)
					builder.setTitle(context.getString(R.string.UnpinMessageAlertTitle))
					builder.setMessage(context.getString(R.string.UnpinMessageAlert))

					builder.setPositiveButton(context.getString(R.string.UnpinMessage)) { _, _ ->
						var messageObject = pinnedMessageObjects[currentPinnedMessageId]

						if (messageObject == null) {
							messageObject = messagesDict[0][currentPinnedMessageId]
						}

						unpinMessage(messageObject)
					}

					builder.setNegativeButton(context.getString(R.string.Cancel), null)

					showDialog(builder.create())
				}
				else if (pinnedMessageIds.isNotEmpty()) {
					val preferences = MessagesController.getNotificationsSettings(currentAccount)
					preferences.edit().putInt("pin_$dialogId", pinnedMessageIds[0]).commit()
					updatePinnedMessageView(true)
				}
			}
		}

		topChatPanelView = object : BlurredFrameLayout(context, contentView) {
			private var ignoreLayout = false

			override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
				var width = MeasureSpec.getSize(widthMeasureSpec)

				if (addToContactsButton != null && addToContactsButton!!.visibility == VISIBLE && reportSpamButton != null && reportSpamButton!!.visibility == VISIBLE) {
					width = (width - AndroidUtilities.dp(31f)) / 2
				}

				ignoreLayout = true

				if (reportSpamButton != null && reportSpamButton!!.visibility == VISIBLE) {
					val layoutParams = reportSpamButton!!.layoutParams as LayoutParams
					layoutParams.width = width

					if (addToContactsButton != null && addToContactsButton!!.visibility == VISIBLE) {
						reportSpamButton!!.setPadding(AndroidUtilities.dp(4f), 0, AndroidUtilities.dp(4f), 0)
						layoutParams.leftMargin = width
						layoutParams.width -= AndroidUtilities.dp(15f)
					}
					else {
						reportSpamButton!!.setPadding(AndroidUtilities.dp(48f), 0, AndroidUtilities.dp(48f), 0)
						layoutParams.leftMargin = 0
					}
				}

				if (addToContactsButton != null && addToContactsButton!!.visibility == VISIBLE) {
					val layoutParams = addToContactsButton!!.layoutParams as LayoutParams
					layoutParams.width = width

					if (reportSpamButton != null && reportSpamButton!!.visibility == VISIBLE) {
						addToContactsButton!!.setPadding(AndroidUtilities.dp(11f), 0, AndroidUtilities.dp(4f), 0)
					}
					else {
						addToContactsButton!!.setPadding(AndroidUtilities.dp(48f), 0, AndroidUtilities.dp(48f), 0)
						layoutParams.leftMargin = 0
					}
				}

				ignoreLayout = false

				super.onMeasure(widthMeasureSpec, heightMeasureSpec)
			}

			override fun requestLayout() {
				if (ignoreLayout) {
					return
				}

				super.requestLayout()
			}
		}

		topChatPanelView?.setBackgroundColor(context.getColor(R.color.background))
		topChatPanelView?.backgroundPaddingBottom = AndroidUtilities.dp(2f)
		topChatPanelView?.tag = 1

		topChatPanelViewOffset = -AndroidUtilities.dp(50f).toFloat()

		invalidateChatListViewTopPadding()

		topChatPanelView?.isClickable = true
		topChatPanelView?.gone()
		topChatPanelView?.setBackgroundResource(R.drawable.blockpanel)
		topChatPanelView?.background?.colorFilter = PorterDuffColorFilter(context.getColor(R.color.background), PorterDuff.Mode.MULTIPLY)

		contentView?.addView(topChatPanelView, createFrame(LayoutHelper.MATCH_PARENT, 50, Gravity.TOP or Gravity.LEFT))

		reportSpamButton = TextView(context)
		reportSpamButton?.setTextColor(context.getColor(R.color.purple))
		reportSpamButton?.background = Theme.createSelectorDrawable(context.getColor(R.color.purple) and 0x19ffffff, 3)
		reportSpamButton?.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14f)
		reportSpamButton?.typeface = Theme.TYPEFACE_BOLD
		reportSpamButton?.isSingleLine = true
		reportSpamButton?.maxLines = 1
		reportSpamButton?.gravity = Gravity.CENTER

		topChatPanelView?.addView(reportSpamButton, createFrame(LayoutHelper.MATCH_PARENT, 48f, Gravity.LEFT or Gravity.TOP, 0f, 0f, 0f, 1f))

		reportSpamButton?.setOnClickListener {
			AlertsCreator.showBlockReportSpamAlert(this@ChatActivity, dialogId, currentUser, currentChat, currentEncryptedChat, reportSpamButton!!.getTag(R.id.object_tag) != null, currentChatInfo) {
				if (it == 0) {
					updateTopPanel(true)
				}
				else {
					finishFragment()
				}
			}
		}

		emojiStatusSpamHint = object : LinksTextView(context) {
			var lastLayout: Layout? = null
			var stack: EmojiGroupedSpans? = null
			var colorFilter: PorterDuffColorFilter? = null
			var lastColor = 0

			override fun onDetachedFromWindow() {
				super.onDetachedFromWindow()
				AnimatedEmojiSpan.release(stack)
				lastLayout = null
			}

			override fun dispatchDraw(canvas: Canvas) {
				super.dispatchDraw(canvas)

				if (lastLayout !== layout) {
					stack = AnimatedEmojiSpan.update(AnimatedEmojiDrawable.CACHE_TYPE_EMOJI_STATUS, this, stack, layout.also { lastLayout = it })
				}

				val color = context.getColor(R.color.brand)

				if (lastColor != color || colorFilter == null) {
					colorFilter = PorterDuffColorFilter(color, PorterDuff.Mode.MULTIPLY)
					lastColor = color
				}

				AnimatedEmojiSpan.drawAnimatedEmojis(canvas, layout, stack, 0f, null, 0f, 0f, 0f, 1f, colorFilter)
			}
		}

		emojiStatusSpamHint?.setTextColor(context.getColor(R.color.text))
		emojiStatusSpamHint?.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13.3f)
		emojiStatusSpamHint?.gravity = Gravity.CENTER
		emojiStatusSpamHint?.gone()
		emojiStatusSpamHint?.setLinkTextColor(context.getColor(R.color.brand))

		topChatPanelView?.addView(emojiStatusSpamHint, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.LEFT or Gravity.TOP, 25f, 56f, 25f, 1f))

		topViewSeparator1 = View(context)
		topViewSeparator1?.gone()
		topViewSeparator1?.setBackgroundColor(context.getColor(R.color.divider))
		topViewSeparator1?.alpha = .5f

		topChatPanelView?.addView(topViewSeparator1, createFrame(LayoutHelper.MATCH_PARENT, 1f / AndroidUtilities.density, Gravity.LEFT or Gravity.BOTTOM, 0f, 0f, 0f, 2f))

		topViewSeparator2 = View(context)
		topViewSeparator2?.gone()
		topViewSeparator2?.setBackgroundColor(context.getColor(R.color.divider))

		topChatPanelView?.addView(topViewSeparator2, createFrame(LayoutHelper.MATCH_PARENT, 1f / AndroidUtilities.density, Gravity.LEFT or Gravity.TOP, 10f, 50f, 10f, 1f))

		if (isAiBot()) {
			val botBalanceBinding = AiBotChatTopviewFreeBalanceBinding.inflate(LayoutInflater.from(getContext()))

			botTopViewContainer = botBalanceBinding.root
			botTopViewContainer?.gone()

			botFreeBalanceView = botBalanceBinding.text

			topChatPanelView?.addView(botTopViewContainer, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT.toFloat()))
		}

		addToContactsButton = TextView(context)
		addToContactsButton?.setTextColor(context.getColor(R.color.brand))
		addToContactsButton?.gone()
		addToContactsButton?.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14f)
		addToContactsButton?.typeface = Theme.TYPEFACE_BOLD
		addToContactsButton?.isSingleLine = true
		addToContactsButton?.maxLines = 1
		addToContactsButton?.setPadding(AndroidUtilities.dp(4f), 0, AndroidUtilities.dp(4f), 0)
		addToContactsButton?.gravity = Gravity.CENTER
		addToContactsButton?.background = Theme.createSelectorDrawable(context.getColor(R.color.brand) and 0x19ffffff, 3)

		topChatPanelView?.addView(addToContactsButton, createFrame(LayoutHelper.MATCH_PARENT, 48f, Gravity.LEFT or Gravity.TOP, 0f, 0f, 0f, 1f))

		addToContactsButton?.setOnClickListener {
			if (addToContactsButtonArchive) {
				messagesController.addDialogToFolder(dialogId, 0, 0, 0)
				undoView?.showWithAction(dialogId, UndoView.ACTION_CHAT_UNARCHIVED, null)

				val preferences = MessagesController.getNotificationsSettings(currentAccount)

				val editor = preferences.edit()
				editor.putBoolean("dialog_bar_archived$dialogId", false)
				editor.putBoolean("dialog_bar_block$dialogId", false)
				editor.putBoolean("dialog_bar_report$dialogId", false)
				editor.commit()

				updateTopPanel(false)

				notificationsController.clearDialogNotificationsSettings(dialogId)
			}
			else if (addToContactsButton?.tag as? Int == 4) {
				if (currentChatInfo?.participants != null) {
					val users = LongSparseArray<TLObject?>()

					for (a in currentChatInfo!!.participants.participants.indices) {
						users.put(currentChatInfo!!.participants.participants[a].user_id, null)
					}

					val chatId = currentChatInfo!!.id
					val bottomSheet = InviteMembersBottomSheet(context, currentAccount, users, currentChatInfo!!.id, this@ChatActivity, null)

					bottomSheet.setDelegate(object : ContactsAddActivityDelegate {
						override fun needAddBot(user: User) {
							// unused
						}

						override fun didSelectUsers(users: List<User>, fwdCount: Int) {
							var a = 0
							val N = users.size

							while (a < N) {
								val user = users[a]
								messagesController.addUserToChat(chatId, user, fwdCount, null, this@ChatActivity, null)
								a++
							}

							messagesController.hidePeerSettingsBar(dialogId, currentUser, currentChat)

							updateTopPanel(true)
							updateInfoTopView(true)
						}
					})

					bottomSheet.show()
				}
			}
			else if (addToContactsButton?.tag != null) {
				shareMyContact(1, null)
			}
			else {
				val args = Bundle()
				args.putLong("user_id", currentUser!!.id)
				args.putBoolean("addContact", true)

				val activity = ContactAddActivity(args)

				activity.setDelegate {
					undoView?.showWithAction(dialogId, UndoView.ACTION_CONTACT_ADDED, currentUser)
				}

				presentFragment(activity)
			}
		}

		if (!isBot()) {
			val closeReportSpam = ImageView(context)
			closeReportSpam.setImageResource(R.drawable.miniplayer_close)
			closeReportSpam.contentDescription = context.getString(R.string.Close)
			closeReportSpam.background = Theme.AdaptiveRipple.circle(context.getColor(R.color.light_background))
			closeReportSpam.colorFilter = PorterDuffColorFilter(context.getColor(R.color.brand), PorterDuff.Mode.SRC_IN)
			closeReportSpam.scaleType = ImageView.ScaleType.CENTER

			topChatPanelView?.addView(closeReportSpam, createFrame(36, 36f, Gravity.RIGHT or Gravity.TOP, 0f, 6f, 2f, 0f))

			closeReportSpam.setOnClickListener {
				var did = dialogId

				if (currentEncryptedChat != null) {
					did = currentUser?.id ?: 0
				}

				messagesController.hidePeerSettingsBar(did, currentUser, currentChat)

				updateTopPanel(true)
				updateInfoTopView(true)
			}
		}

		alertView = FrameLayout(context)
		alertView?.tag = 1
		alertView?.gone()
		alertView?.setBackgroundResource(R.drawable.blockpanel)
		alertView?.background?.colorFilter = PorterDuffColorFilter(context.getColor(R.color.background), PorterDuff.Mode.MULTIPLY)

		contentView?.addView(alertView, createFrame(LayoutHelper.MATCH_PARENT, 50, Gravity.TOP or Gravity.LEFT))

		alertNameTextView = TextView(context)
		alertNameTextView?.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14f)
		alertNameTextView?.setTextColor(context.getColor(R.color.text))
		alertNameTextView?.typeface = Theme.TYPEFACE_BOLD
		alertNameTextView?.isSingleLine = true
		alertNameTextView?.ellipsize = TextUtils.TruncateAt.END
		alertNameTextView?.maxLines = 1

		alertView?.addView(alertNameTextView, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.TOP or Gravity.LEFT, 8f, 5f, 8f, 0f))

		alertTextView = TextView(context)
		alertTextView?.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14f)
		alertTextView?.setTextColor(context.getColor(R.color.text))
		alertTextView?.isSingleLine = true
		alertTextView?.ellipsize = TextUtils.TruncateAt.END
		alertTextView?.maxLines = 1

		alertView?.addView(alertTextView, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.TOP or Gravity.LEFT, 8f, 23f, 8f, 0f))

		pagedownButton = FrameLayout(context)
		pagedownButton?.invisible()

		contentView?.addView(pagedownButton, createFrame(66, 61f, Gravity.RIGHT or Gravity.BOTTOM, 0f, 0f, -3f, 20f))

		pagedownButton?.setOnClickListener {
			wasManualScroll = true

			textSelectionHelper.cancelTextSelectionRunnable()

			if (createUnreadMessageAfterId != 0) {
				scrollToMessageId(createUnreadMessageAfterId, 0, false, returnToLoadIndex, true, 0)
			}
			else if (returnToMessageId > 0) {
				scrollToMessageId(returnToMessageId, 0, true, returnToLoadIndex, true, 0)
			}
			else {
				scrollToLastMessage(false)

				if (pinnedMessageIds.isNotEmpty()) {
					forceScrollToFirst = true
					forceNextPinnedMessageId = pinnedMessageIds[0]
				}
			}
		}

		mentiondownButton = FrameLayout(context)
		mentiondownButton?.invisible()

		contentView?.addView(mentiondownButton, createFrame(46, 61f, Gravity.RIGHT or Gravity.BOTTOM, 0f, 0f, 7f, 5f))

		mentiondownButton?.setOnClickListener(object : View.OnClickListener {
			private fun loadLastUnreadMention() {
				wasManualScroll = true

				if (hasAllMentionsLocal) {
					messagesStorage.getUnreadMention(dialogId) {
						if (it == 0) {
							hasAllMentionsLocal = false
							loadLastUnreadMention()
						}
						else {
							scrollToMessageId(it, 0, false, 0, true, 0)
						}
					}
				}
				else {
					val messagesStorage = messagesStorage

					val req = TL_messages_getUnreadMentions()
					req.peer = messagesController.getInputPeer(dialogId)
					req.limit = 1
					req.add_offset = newMentionsCount - 1

					connectionsManager.sendRequest(req) { response, error ->
						AndroidUtilities.runOnUIThread {
							val res = response as messages_Messages?

							if (error != null || res?.messages.isNullOrEmpty()) {
								newMentionsCount = res?.count ?: 0

								messagesStorage.resetMentionsCount(dialogId, newMentionsCount)

								if (newMentionsCount == 0) {
									hasAllMentionsLocal = true
									showMentionDownButton(show = false, animated = true)
								}
								else {
									mentiondownButtonCounter!!.setText(String.format(Locale.getDefault(), "%d", newMentionsCount))
									loadLastUnreadMention()
								}
							}
							else {
								val id = res?.messages?.get(0)?.id ?: return@runOnUIThread
								val `object` = messagesDict[0][id]

								messagesStorage.markMessageAsMention(dialogId, id)

								if (`object` != null) {
									`object`.messageOwner?.media_unread = true
									`object`.messageOwner?.mentioned = true
								}

								scrollToMessageId(id, 0, false, 0, true, 0)
							}
						}
					}
				}
			}

			override fun onClick(view: View) {
				loadLastUnreadMention()
			}
		})

		mentiondownButton?.setOnLongClickListener {
			scrimPopupWindow = ReadAllMentionsMenu.show(ReadAllMentionsMenu.TYPE_MENTIONS, parentActivity, contentView, it, resourceProvider) {
				for (a in messages.indices) {
					val messageObject = messages[a]

					if (messageObject.messageOwner?.mentioned == true && !messageObject.isContentUnread) {
						messageObject.setContentIsRead()
					}
				}

				newMentionsCount = 0

				messagesController.markMentionsAsRead(dialogId)

				hasAllMentionsLocal = true

				showMentionDownButton(show = false, animated = true)

				scrimPopupWindow?.dismiss()
			}

			dimBehindView(mentiondownButton, true)

			scrimPopupWindow?.setOnDismissListener {
				scrimPopupWindow = null
				menuDeleteItem = null
				scrimPopupWindowItems = null
				chatLayoutManager?.setCanScrollVertically(true)
				dimBehindView(false)
				chatActivityEnterView?.editField?.setAllowDrawCursor(true)
			}

			it.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS, HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING)

			true
		}

		updateMessageListAccessibilityVisibility()

		reactionsMentiondownButton = FrameLayout(context)

		contentView?.addView(reactionsMentiondownButton, createFrame(46, 61f, Gravity.RIGHT or Gravity.BOTTOM, 0f, 0f, 7f, 5f))

		mentionContainer = object : MentionsContainerView(context, dialogId, threadId, this@ChatActivity) {
			override fun canOpen(): Boolean {
				return bottomOverlay?.visibility != VISIBLE || searchingForUser
			}

			override fun onOpen() {
				if (allowStickersPanel && (!adapter.isBotContext || allowContextBotPanel || allowContextBotPanelSecond)) {
					if (currentEncryptedChat != null && adapter.isBotContext) {
						val preferences = MessagesController.getGlobalMainSettings()

						if (!preferences.getBoolean("secretbot", false)) {
							val builder = AlertDialog.Builder(parentActivity!!)
							builder.setTitle(getContext().getString(R.string.AppName))
							builder.setMessage(getContext().getString(R.string.SecretChatContextBotAlert))
							builder.setPositiveButton(getContext().getString(R.string.OK), null)

							showDialog(builder.create())

							preferences.edit().putBoolean("secretbot", true).commit()
						}
					}
				}

				updateMessageListAccessibilityVisibility()
			}

			override fun onClose() {
				updateMessageListAccessibilityVisibility()
			}

			override fun onContextSearch(searching: Boolean) {
				chatActivityEnterView?.setCaption(adapter.botCaption)
				chatActivityEnterView?.showContextProgress(searching)
			}

			override fun onContextClick(result: BotInlineResult) {
				if (parentActivity == null || result.content == null) {
					return
				}

				if (result.type == "video" || result.type == "web_player_video") {
					val size = MessageObject.getInlineResultWidthAndHeight(result)
					EmbedBottomSheet.show(this@ChatActivity, null, botContextProvider, if (result.title != null) result.title else "", result.description, result.content.url, result.content.url, size[0], size[1], isKeyboardVisible)
				}
				else {
					processExternalUrl(0, result.content.url, false)
				}
			}
		}

		contentView?.addView(mentionContainer, createFrame(LayoutHelper.MATCH_PARENT, 110, Gravity.LEFT or Gravity.BOTTOM))

		val contentPreviewViewerDelegate: ContentPreviewViewerDelegate = object : ContentPreviewViewerDelegate {
			override fun sendSticker(sticker: TLRPC.Document, query: String, parent: Any, notify: Boolean, scheduleDate: Int) {
				chatActivityEnterView?.onStickerSelected(sticker, query, parent, null, true, notify, scheduleDate)
			}

			override fun needSend(): Boolean {
				return true
			}

			override fun canSchedule(): Boolean {
				return canScheduleMessage()
			}

			override fun isInScheduleMode(): Boolean {
				return chatMode == MODE_SCHEDULED
			}

			override fun openSet(set: InputStickerSet?, clearsInputField: Boolean) {
				if (set == null) {
					return
				}

				val parentActivity = parentActivity ?: return

				val inputStickerSet = TL_inputStickerSetID()
				inputStickerSet.access_hash = set.access_hash
				inputStickerSet.id = set.id

				val alert = StickersAlert(parentActivity, this@ChatActivity, inputStickerSet, null, chatActivityEnterView)

				alert.setCalcMandatoryInsets(isKeyboardVisible)
				alert.isClearsInputField = clearsInputField
				showDialog(alert)
			}

			override fun getDialogId(): Long {
				return this@ChatActivity.dialogId
			}
		}

		mentionContainer?.listView?.setOnTouchListener { _, event ->
			mentionContainer?.let { mentionContainer ->
				ContentPreviewViewer.getInstance().onTouch(event, mentionContainer.listView, 0, mentionsOnItemClickListener, if (mentionContainer.adapter.isStickers()) contentPreviewViewerDelegate else null)
			} ?: false
		}

		if (!isChannel(currentChat) || currentChat!!.megagroup) {
			mentionContainer?.adapter?.setBotInfo(botInfo)
		}

		mentionContainer?.adapter?.setParentFragment(this)
		mentionContainer?.adapter?.setChatInfo(currentChatInfo)
		mentionContainer?.adapter?.setNeedUsernames(currentChat != null)
		mentionContainer?.adapter?.setNeedBotContext(true)
		mentionContainer?.adapter?.setBotsCount(if (currentChat != null) botsCount else 1)

		mentionContainer?.listView?.setOnItemClickListener(RecyclerListView.OnItemClickListener { view, position ->
			val mentionContainer = mentionContainer ?: return@OnItemClickListener
			@Suppress("NAME_SHADOWING") var position = position

			if (position == 0 || mentionContainer.adapter.isBannedInline) {
				return@OnItemClickListener
			}

			position--

			val `object` = mentionContainer.adapter.getItem(position)
			val start = mentionContainer.adapter.resultStartPosition
			val len = mentionContainer.adapter.resultLength

			if (`object` is TL_document) {
				if (chatMode == 0 && checkSlowMode(view)) {
					return@OnItemClickListener
				}

				var sendAnimationData: SendAnimationData? = null

				if (view is StickerCell) {
					sendAnimationData = view.sendAnimationData
				}

				val parent = mentionContainer.adapter.getItemParent(position)
				val query = MessageObject.findAnimatedEmojiEmoticon(`object`)

				if (chatMode == MODE_SCHEDULED) {
					AlertsCreator.createScheduleDatePickerDialog(parentActivity, dialogId) { notify, scheduleDate ->
						SendMessagesHelper.getInstance(currentAccount).sendSticker(`object`, query, dialogId, replyMessage, threadMessage, parent, null, notify, scheduleDate, false)
					}
				}
				else {
					sendMessagesHelper.sendSticker(`object`, query, dialogId, replyMessage, threadMessage, parent, sendAnimationData, true, 0, false)
				}

				hideFieldPanel(false)

				chatActivityEnterView?.addStickerToRecent(`object`)
				chatActivityEnterView?.fieldText = ""
			}
			else if (`object` is Chat) {
				if (searchingForUser && searchContainer?.visibility == View.VISIBLE) {
					searchUserMessages(null, `object`)
				}
				else {
					if (`object`.username != null) {
						chatActivityEnterView?.replaceWithText(start, len, "@" + `object`.username + " ", false)
					}
				}
			}
			else if (`object` is User) {
				if (searchingForUser && searchContainer?.visibility == View.VISIBLE) {
					searchUserMessages(`object`, null)
				}
				else {
					if (`object`.username != null) {
						chatActivityEnterView?.replaceWithText(start, len, "@" + `object`.username + " ", false)
					}
					else {
						val name = getFirstName(`object`, false)

						val spannable: Spannable = SpannableString("$name ")
						spannable.setSpan(URLSpanUserMention("" + `object`.id, 3), 0, spannable.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

						chatActivityEnterView?.replaceWithText(start, len, spannable, false)
					}
				}
			}
			else if (`object` is String) {
				if (mentionContainer.adapter.isBotCommands) {
					if (chatMode == MODE_SCHEDULED) {
						AlertsCreator.createScheduleDatePickerDialog(parentActivity, dialogId) { notify, scheduleDate ->
							sendMessagesHelper.sendMessage(`object` as String?, dialogId, replyMessage, threadMessage, null, false, null, null, null, notify, scheduleDate, null, updateStickersOrder = false, isMediaSale = false, mediaSaleHash = null)
							chatActivityEnterView?.fieldText = ""
							hideFieldPanel(false)
						}
					}
					else {
						if (checkSlowMode(view)) {
							return@OnItemClickListener
						}

						sendMessagesHelper.sendMessage(`object` as String?, dialogId, replyMessage, threadMessage, null, false, null, null, null, true, 0, null, updateStickersOrder = false, isMediaSale = false, mediaSaleHash = null)
						chatActivityEnterView?.fieldText = ""
						hideFieldPanel(false)
					}
				}
				else {
					chatActivityEnterView?.replaceWithText(start, len, "$`object` ", false)
				}
			}
			else if (`object` is BotInlineResult) {
				if (chatActivityEnterView?.fieldText == null || chatMode != MODE_SCHEDULED && checkSlowMode(view)) {
					return@OnItemClickListener
				}

				if (currentEncryptedChat != null) {
					var error = 0

					if (`object`.send_message is TL_botInlineMessageMediaAuto && "game" == `object`.type) {
						error = 1
					}
					else if (`object`.send_message is TL_botInlineMessageMediaInvoice) {
						error = 2
					}

					if (error != 0) {
						val builder = AlertDialog.Builder(parentActivity!!)
						builder.setTitle(context.getString(R.string.SendMessageTitle))

						if (error == 1) {
							builder.setMessage(context.getString(R.string.GameCantSendSecretChat))
						}
						else {
							builder.setMessage(context.getString(R.string.InvoiceCantSendSecretChat))
						}

						builder.setNegativeButton(context.getString(R.string.OK), null)

						showDialog(builder.create())

						return@OnItemClickListener
					}
				}

				if (/* || result.content_url != null*/ `object`.type == "photo" && (`object`.photo != null || `object`.content != null) || `object`.type == "gif" && (`object`.document != null || `object`.content != null) || `object`.type == "video" && `object`.document != null) {
					val arrayList: ArrayList<Any>

					botContextResults = ArrayList<Any>(mentionContainer.adapter.searchResultBotContext ?: arrayListOf()).also {
						arrayList = it
					}

					with(PhotoViewer.getInstance()) {
						setParentActivity(this@ChatActivity)
						openPhotoForSelect(arrayList, mentionContainer.adapter.getItemPosition(position), 3, false, botContextProvider, this@ChatActivity, false)
					}
				}
				else {
					if (chatMode == MODE_SCHEDULED) {
						AlertsCreator.createScheduleDatePickerDialog(parentActivity, dialogId) { notify, scheduleDate ->
							sendBotInlineResult(`object`, notify, scheduleDate)
						}
					}
					else {
						sendBotInlineResult(`object`, true, 0)
					}
				}
			}
			else if (`object` is TL_inlineBotSwitchPM) {
				processInlineBotContextPM(`object` as TL_inlineBotSwitchPM?)
			}
			else if (`object` is KeywordResult) {
				val code = `object`.emoji

				chatActivityEnterView?.addEmojiToRecent(code)

				if (code != null && code.startsWith("animated_")) {
					try {
						val documentId = code.substring(9).toLong()
						val document = AnimatedEmojiDrawable.findDocument(currentAccount, documentId)
						val emoji = SpannableString(MessageObject.findAnimatedEmojiEmoticon(document))

						val span = if (document != null) {
							AnimatedEmojiSpan(document, chatActivityEnterView?.editField?.paint?.fontMetricsInt)
						}
						else {
							AnimatedEmojiSpan(documentId, chatActivityEnterView?.editField?.paint?.fontMetricsInt)
						}

						emoji.setSpan(span, 0, emoji.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

						chatActivityEnterView?.replaceWithText(start, len, emoji, false)
					}
					catch (ignore: Exception) {
						chatActivityEnterView?.replaceWithText(start, len, code, true)
					}
				}
				else {
					chatActivityEnterView?.replaceWithText(start, len, code, true)
				}

				mentionContainer.updateVisibility(false)
			}
		}.also { mentionsOnItemClickListener = it })

		mentionContainer?.listView?.setOnItemLongClickListener { _, position ->
			val mentionContainer = mentionContainer ?: return@setOnItemLongClickListener false

			if (!mentionContainer.adapter.isLongClickEnabled) {
				return@setOnItemLongClickListener false
			}

			val parentActivity = parentActivity ?: return@setOnItemLongClickListener false

			val `object` = mentionContainer.adapter.getItem(position)

			if (`object` is String) {
				if (mentionContainer.adapter.isBotCommands) {
					if (URLSpanBotCommand.enabled) {
						chatActivityEnterView?.fieldText = ""
						chatActivityEnterView?.setCommand(null, `object` as String?, true, currentChat?.megagroup == true)

						return@setOnItemLongClickListener true
					}

					return@setOnItemLongClickListener false
				}
				else {
					val builder = AlertDialog.Builder(parentActivity)
					builder.setTitle(context.getString(R.string.AppName))
					builder.setMessage(context.getString(R.string.ClearSearch))

					builder.setPositiveButton(context.getString(R.string.ClearButton).uppercase(Locale.getDefault())) { _, _ ->
						mentionContainer.adapter.clearRecentHashtags()
					}

					builder.setNegativeButton(context.getString(R.string.Cancel), null)

					showDialog(builder.create())

					return@setOnItemLongClickListener true
				}
			}

			false
		}

		val pageDownButtonImage = ImageView(context)
		pageDownButtonImage.setImageResource(R.drawable.arrow_bottom)
		pageDownButtonImage.scaleType = ImageView.ScaleType.CENTER
		pageDownButtonImage.colorFilter = PorterDuffColorFilter(ResourcesCompat.getColor(context.resources, R.color.scroll_to_bottom_indicator, null), PorterDuff.Mode.SRC_IN)
		pageDownButtonImage.setPadding(0, AndroidUtilities.dp(2f), 0, 0)

		pageDownButtonImage.outlineProvider = object : ViewOutlineProvider() {
			override fun getOutline(view: View, outline: Outline) {
				outline.setOval(0, 0, AndroidUtilities.dp(32f), AndroidUtilities.dp(32f))
			}
		}

		var drawable = Theme.createSimpleSelectorCircleDrawable(AndroidUtilities.dp(13f), context.getColor(R.color.white), context.getColor(R.color.brand))

		pageDownButtonImage.background = drawable

		pagedownButton?.addView(pageDownButtonImage, createFrame(32, 32, Gravity.CENTER_HORIZONTAL or Gravity.BOTTOM))
		pagedownButton?.contentDescription = context.getString(R.string.AccDescrPageDown)

		pagedownButtonCounter = object : CounterView(context) {
			override fun invalidate() {
				if (isInOutAnimation) {
					contentView?.invalidate()
				}

				super.invalidate()
			}
		}

		pagedownButtonCounter?.setReverse(true)

		pagedownButton?.addView(pagedownButtonCounter, createFrame(LayoutHelper.MATCH_PARENT, 28f, Gravity.TOP or Gravity.LEFT, 0f, 12f, 0f, 0f))

		val mentionDownButtonImage = ImageView(context)
		mentionDownButtonImage.setImageResource(R.drawable.mentionbutton)
		mentionDownButtonImage.scaleType = ImageView.ScaleType.CENTER
		mentionDownButtonImage.colorFilter = PorterDuffColorFilter(context.getColor(R.color.white), PorterDuff.Mode.MULTIPLY)
		mentionDownButtonImage.setPadding(0, AndroidUtilities.dp(2f), 0, 0)

		pageDownButtonImage.outlineProvider = object : ViewOutlineProvider() {
			override fun getOutline(view: View, outline: Outline) {
				outline.setOval(0, 0, AndroidUtilities.dp(42f), AndroidUtilities.dp(42f))
			}
		}

		drawable = Theme.createSimpleSelectorCircleDrawable(AndroidUtilities.dp(42f), context.getColor(R.color.white), context.getColor(R.color.brand))

		mentionDownButtonImage.background = drawable

		mentiondownButton?.addView(mentionDownButtonImage, createFrame(46, 46, Gravity.LEFT or Gravity.BOTTOM))

		mentiondownButtonCounter = SimpleTextView(context)
		mentiondownButtonCounter?.invisible()
		mentiondownButtonCounter?.setTypeface(Theme.TYPEFACE_BOLD)
		mentiondownButtonCounter?.setTextSize(13)
		mentiondownButtonCounter?.textColor = context.getColor(R.color.white)
		mentiondownButtonCounter?.setGravity(Gravity.CENTER)
		mentiondownButtonCounter?.background = Theme.createRoundRectDrawable(AndroidUtilities.dp(11.5f), context.getColor(R.color.brand))
		mentiondownButtonCounter?.setMinWidth(AndroidUtilities.dp(23f))
		mentiondownButtonCounter?.setPadding(AndroidUtilities.dp(8f), AndroidUtilities.dp(1f), AndroidUtilities.dp(8f), 0)

		mentiondownButton?.addView(mentiondownButtonCounter, createFrame(LayoutHelper.WRAP_CONTENT, 23, Gravity.TOP or Gravity.CENTER_HORIZONTAL))
		mentiondownButton?.contentDescription = context.getString(R.string.AccDescrMentionDown)

		reactionsMentiondownButton?.setOnClickListener {
			wasManualScroll = true

			messagesController.getNextReactionMention(dialogId, reactionsMentionCount) { messageId ->
				if (messageId == 0) {
					reactionsMentionCount = 0
					updateReactionsMentionButton(true)
					messagesController.markReactionsAsRead(dialogId)
				}
				else {
					updateReactionsMentionButton(true)
					scrollToMessageId(messageId, 0, false, 0, true, 0)
				}
			}
		}

		reactionsMentiondownButton?.setOnLongClickListener {
			scrimPopupWindow = ReadAllMentionsMenu.show(ReadAllMentionsMenu.TYPE_REACTIONS, parentActivity, contentView, it, resourceProvider) {
				messages.forEach { msg ->
					msg.markReactionsAsRead()
				}

				reactionsMentionCount = 0

				updateReactionsMentionButton(true)

				messagesController.markReactionsAsRead(dialogId)

				scrimPopupWindow?.dismiss()
			}

			dimBehindView(reactionsMentiondownButton, true)

			scrimPopupWindow?.setOnDismissListener {
				scrimPopupWindow = null
				menuDeleteItem = null
				scrimPopupWindowItems = null
				chatLayoutManager?.setCanScrollVertically(true)
				dimBehindView(false)
				chatActivityEnterView?.editField?.setAllowDrawCursor(true)
			}

			it.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS, HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING)

			false
		}

		reactionsMentiondownButton?.invisible()

		val reactionsMentiondownButtonImage = ImageView(context)
		reactionsMentiondownButtonImage.setImageResource(R.drawable.reactionbutton)
		reactionsMentiondownButtonImage.scaleType = ImageView.ScaleType.CENTER
		reactionsMentiondownButtonImage.colorFilter = PorterDuffColorFilter(context.getColor(R.color.white), PorterDuff.Mode.MULTIPLY)

		reactionsMentiondownButtonImage.outlineProvider = object : ViewOutlineProvider() {
			override fun getOutline(view: View, outline: Outline) {
				outline.setOval(0, 0, AndroidUtilities.dp(42f), AndroidUtilities.dp(42f))
			}
		}

		drawable = Theme.createSimpleSelectorCircleDrawable(AndroidUtilities.dp(42f), context.getColor(R.color.white), context.getColor(R.color.brand))

		reactionsMentiondownButtonImage.background = drawable

		reactionsMentiondownButton?.addView(reactionsMentiondownButtonImage, createFrame(46, 46, Gravity.LEFT or Gravity.BOTTOM))

		reactionsMentiondownButtonCounter = CounterView(context)

		reactionsMentiondownButton?.addView(reactionsMentiondownButtonCounter, createFrame(LayoutHelper.MATCH_PARENT, 28, Gravity.TOP or Gravity.LEFT))
		reactionsMentiondownButton?.contentDescription = context.getString(R.string.AccDescrReactionMentionDown)

		fragmentLocationContextView = FragmentContextView(context, this@ChatActivity, true)

		fragmentContextView = object : FragmentContextView(context, this@ChatActivity, false) {
			override fun playbackSpeedChanged(value: Float) {
				if (abs(value - 1.0f) < 0.001f || abs(value - 1.8f) < 0.001f) {
					undoView?.showWithAction(0, if (abs(value - 1.0f) > 0.001f) UndoView.ACTION_PLAYBACK_SPEED_ENABLED else UndoView.ACTION_PLAYBACK_SPEED_DISABLED, value, null, null)
				}
			}
		}

		contentView?.addView(fragmentLocationContextView, createFrame(LayoutHelper.MATCH_PARENT, 38f, Gravity.TOP or Gravity.LEFT, 0f, -36f, 0f, 0f))
		contentView?.addView(fragmentContextView, createFrame(LayoutHelper.MATCH_PARENT, 38f, Gravity.TOP or Gravity.LEFT, 0f, -36f, 0f, 0f))

		fragmentContextView?.setAdditionalContextView(fragmentLocationContextView)

		fragmentLocationContextView?.setAdditionalContextView(fragmentContextView)

		fragmentContextView?.isEnabled = !inPreviewMode

		fragmentLocationContextView?.isEnabled = !inPreviewMode

		if (chatMode != 0) {
			fragmentContextView?.setSupportsCalls(false)
		}

		messagesSearchListView = RecyclerListView(context)
		messagesSearchListView?.setBackgroundResource(R.color.background)

		val messagesSearchLayoutManager = LinearLayoutManager(context)
		messagesSearchLayoutManager.orientation = LinearLayoutManager.VERTICAL

		messagesSearchListView?.layoutManager = messagesSearchLayoutManager
		messagesSearchListView?.gone()
		messagesSearchListView?.alpha = 0.0f
		messagesSearchListView?.adapter = MessagesSearchAdapter(context).also { messagesSearchAdapter = it }

		contentView?.addView(messagesSearchListView, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT.toFloat(), Gravity.LEFT or Gravity.TOP, 0f, 0f, 0f, 48f))

		messagesSearchListView?.setOnItemClickListener { _, position ->
			mediaDataController.jumpToSearchedMessage(classGuid, position)
			showMessagesSearchListView(false)
		}

		messagesSearchListView?.addOnScrollListener(object : RecyclerView.OnScrollListener() {
			override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
				val lastVisibleItem = messagesSearchLayoutManager.findLastVisibleItemPosition()
				val visibleItemCount = if (lastVisibleItem == RecyclerView.NO_POSITION) 0 else lastVisibleItem

				if (visibleItemCount > 0 && lastVisibleItem > messagesSearchLayoutManager.itemCount - 5) {
					mediaDataController.loadMoreSearchMessages()
				}
			}
		})

		topUndoView = object : UndoView(context, this, true) {
			override fun didPressUrl(span: CharacterStyle) {
				didPressMessageUrl(span, false, null, null)
			}

			override fun showWithAction(did: Long, action: Int, infoObject: Any, infoObject2: Any, actionRunnable: Runnable, cancelRunnable: Runnable) {
				setAdditionalTranslationY((if (fragmentContextView != null && fragmentContextView?.isCallTypeVisible == true) AndroidUtilities.dp(fragmentContextView?.styleHeight?.toFloat() ?: 0f) else 0).toFloat())
				super.showWithAction(did, action, infoObject, infoObject2, actionRunnable, cancelRunnable)
			}
		}

		contentView?.addView(topUndoView, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.TOP or Gravity.LEFT, 8f, 8f, 8f, 0f))
		contentView?.addView(actionBar)

		overlayView = View(context)

		overlayView?.setOnTouchListener { _, event ->
			if (event.action == MotionEvent.ACTION_DOWN) {
				checkRecordLocked(false)
			}

			overlayView?.parent?.requestDisallowInterceptTouchEvent(true)

			true
		}

		contentView?.addView(overlayView, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.LEFT or Gravity.TOP))

		overlayView?.gone()

		contentView?.clipChildren = false

		instantCameraView = InstantCameraView(context, this, null)

		contentView?.addView(instantCameraView, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.LEFT or Gravity.TOP))

		bottomMessagesActionContainer = BlurredFrameLayout(context, contentView)
		bottomMessagesActionContainer?.setBackgroundColor(ResourcesCompat.getColor(context.resources, R.color.background, null))
		bottomMessagesActionContainer?.drawBlur = false
		bottomMessagesActionContainer?.isTopView = false
		bottomMessagesActionContainer?.invisible()
		bottomMessagesActionContainer?.setWillNotDraw(false)
		bottomMessagesActionContainer?.setPadding(0, AndroidUtilities.dp(2f), 0, 0)

		contentView?.addView(bottomMessagesActionContainer, createFrame(LayoutHelper.MATCH_PARENT, 51, Gravity.BOTTOM))

		bottomMessagesActionContainer?.setOnTouchListener { _, _ -> true }

		chatActivityEnterView = object : ChatActivityEnterView(parentActivity!!, contentView, this@ChatActivity, true, isAiBot()) {
			var lastContentViewHeight = 0
			var messageEditTextPredrawHeigth = 0
			var messageEditTextPredrawScrollY = 0

			override fun onInterceptTouchEvent(ev: MotionEvent): Boolean {
				return if (alpha != 1.0f) {
					false
				}
				else {
					super.onInterceptTouchEvent(ev)
				}
			}

			override fun onTouchEvent(event: MotionEvent): Boolean {
				return if (alpha != 1.0f) {
					false
				}
				else {
					super.onTouchEvent(event)
				}
			}

			override fun dispatchTouchEvent(ev: MotionEvent): Boolean {
				return if (alpha != 1.0f) {
					false
				}
				else {
					super.dispatchTouchEvent(ev)
				}
			}

			override fun panelAnimationEnabled(): Boolean {
				return openAnimationEnded
			}

			override fun checkAnimation() {
				if (actionBar?.isActionModeShowed == true || reportType >= 0) {
					messageEditTextAnimator?.cancel()
					changeBoundAnimator?.cancel()
					chatActivityEnterViewAnimateFromTop = 0
					shouldAnimateEditTextWithBounds = false
				}
				else {
					val t = backgroundTop

					if (chatActivityEnterViewAnimateFromTop != 0 && t != chatActivityEnterViewAnimateFromTop && lastContentViewHeight == contentView!!.measuredHeight) {
						val dy = animatedTop + chatActivityEnterViewAnimateFromTop - t

						animatedTop = dy

						changeBoundAnimator?.removeAllListeners()
						changeBoundAnimator?.cancel()

						chatListView?.translationY = dy.toFloat()

						if (topView?.visibility == VISIBLE) {
							topView?.translationY = animatedTop + (1f - topViewEnterProgress) * topView!!.layoutParams.height
							topLineView?.translationY = animatedTop.toFloat()
						}

						mentionContainer?.translationY = dy.toFloat()

						changeBoundAnimator = ValueAnimator.ofFloat(dy.toFloat(), 0f)

						changeBoundAnimator?.addUpdateListener {
							val top = it.animatedValue as Float
							animatedTop = top.toInt()

							if (topView?.visibility == VISIBLE) {
								topView?.translationY = top + (1f - topViewEnterProgress) * topView!!.layoutParams.height
								topLineView?.translationY = top
							}
							else {
								mentionContainer?.translationY = top
								chatListView?.translationY = top
								invalidateChatListViewTopPadding()
								invalidateMessagesVisiblePart()
							}

							invalidate()
						}

						changeBoundAnimator?.addListener(object : AnimatorListenerAdapter() {
							override fun onAnimationEnd(animation: Animator) {
								animatedTop = 0

								if (topView?.visibility == VISIBLE) {
									topView?.translationY = animatedTop + (1f - topViewEnterProgress) * topView!!.layoutParams.height
									topLineView?.translationY = animatedTop.toFloat()
								}
								else {
									chatListView?.translationY = 0f
									mentionContainer?.translationY = 0f
								}

								changeBoundAnimator = null
							}
						})

						changeBoundAnimator?.duration = ChatListItemAnimator.DEFAULT_DURATION
						changeBoundAnimator?.interpolator = ChatListItemAnimator.DEFAULT_INTERPOLATOR

						if (!waitingForSendingMessageLoad) {
							changeBoundAnimator?.start()
						}

						invalidateChatListViewTopPadding()
						invalidateMessagesVisiblePart()

						chatActivityEnterViewAnimateFromTop = 0
					}
					else if (lastContentViewHeight != contentView!!.measuredHeight) {
						chatActivityEnterViewAnimateFromTop = 0
					}

					if (shouldAnimateEditTextWithBounds) {
						val dy = (messageEditTextPredrawHeigth - editField.measuredHeight + (messageEditTextPredrawScrollY - editField.scrollY)).toFloat()

						editField.offsetY -= dy

						val a = ValueAnimator.ofFloat(editField.offsetY, 0f)

						a.addUpdateListener {
							editField.offsetY = it.animatedValue as Float
						}

						messageEditTextAnimator?.cancel()
						messageEditTextAnimator = a

						a.duration = ChatListItemAnimator.DEFAULT_DURATION
						// a.setStartDelay(chatActivityEnterViewAnimateBeforeSending ? 20 : 0);
						a.interpolator = ChatListItemAnimator.DEFAULT_INTERPOLATOR
						a.start()

						shouldAnimateEditTextWithBounds = false
					}

					lastContentViewHeight = contentView!!.measuredHeight
				}
			}

			override fun onLineCountChanged(oldLineCount: Int, newLineCount: Int) {
				if (chatActivityEnterView != null) {
					shouldAnimateEditTextWithBounds = true
					messageEditTextPredrawHeigth = editField.measuredHeight
					messageEditTextPredrawScrollY = editField.scrollY
					contentView?.invalidate()
					chatActivityEnterViewAnimateFromTop = chatActivityEnterView!!.backgroundTop
				}
			}
		}

		chatActivityEnterView?.setDelegate(object : ChatActivityEnterViewDelegate {
			var lastSize = 0
			var isEditTextItemVisibilitySuppressed = false

			override fun onBotCommandSelected(command: String) {
				updateChatBotTopPanel()
			}

			override val contentViewHeight: Int
				get() = contentView?.height ?: 0

			override fun measureKeyboardHeight(): Int {
				return contentView?.measureKeyboardHeight() ?: 0
			}

			override fun onMessageSend(message: CharSequence?, notify: Boolean, scheduleDate: Int) {
				if (chatListItemAnimator != null) {
					chatActivityEnterViewAnimateFromTop = chatActivityEnterView?.backgroundTop ?: 0
				}

				mentionContainer?.adapter?.addHashtagsFromMessage(message)

				if (scheduleDate != 0) {
					if (scheduledMessagesCount == -1) {
						scheduledMessagesCount = 0
					}

					if (message != null) {
						scheduledMessagesCount++
					}

					scheduledMessagesCount += forwardingMessages?.messages?.size ?: 0

					updateScheduledInterface(false)
				}

				hideFieldPanel(notify, scheduleDate, true)

				chatActivityEnterView?.emojiView?.onMessageSend()
			}

			override fun onEditTextScroll() {
				suggestEmojiPanel?.forceClose()
			}

			override fun onContextMenuOpen() {
				suggestEmojiPanel?.forceClose()
			}

			override fun onContextMenuClose() {
				suggestEmojiPanel?.fireUpdate()
			}

			override fun onSwitchRecordMode(video: Boolean) {
				showVoiceHint(false, video)
			}

			override fun onPreAudioVideoRecord() {
				showVoiceHint(hide = true, video = false)
			}

			override fun onUpdateSlowModeButton(button: View?, show: Boolean, time: CharSequence?) {
				showSlowModeHint(button, show, time)

				if (headerItem != null && headerItem?.visibility != View.VISIBLE) {
					headerItem?.visible()
					attachItem?.gone()
				}
			}

			override fun onTextSelectionChanged(start: Int, end: Int) {
				val editTextItem = editTextItem ?: return

				suggestEmojiPanel?.onTextSelectionChanged(start, end)

				if (end - start > 0) {
					if (editTextItem.tag == null) {
						editTextItem.tag = 1

						if (editTextItem.visibility != View.VISIBLE) {
							if (chatMode == 0 && threadId == 0 && !isReplyUser(currentUser) && reportType < 0) {
								editTextItem.visible()
								headerItem?.gone()
								attachItem?.gone()
							}
							else {
								val valueAnimator = ValueAnimator.ofFloat(AndroidUtilities.dp(48f).toFloat(), 0f)
								valueAnimator.duration = 220
								valueAnimator.interpolator = CubicBezierInterpolator.DEFAULT

								valueAnimator.addListener(object : AnimatorListenerAdapter() {
									override fun onAnimationStart(animation: Animator) {
										actionBar?.setMenuOffsetSuppressed(true)
										editTextItem.visible()
										menu.translateXItems(AndroidUtilities.dp(48f).toFloat())
									}

									override fun onAnimationEnd(animation: Animator) {
										actionBar?.setMenuOffsetSuppressed(false)
									}
								})

								valueAnimator.addUpdateListener {
									menu.translateXItems(it.animatedValue as Float)
								}

								valueAnimator.start()
							}
						}
					}

					editTextStart = start
					editTextEnd = end
				}
				else {
					if (editTextItem.tag != null) {
						editTextItem.tag = null

						if (editTextItem.visibility != View.GONE) {
							if (chatMode == 0 && threadId == 0 && !isReplyUser(currentUser) && reportType < 0) {
								editTextItem.gone()

								if (chatActivityEnterView?.hasText() == true && chatActivityEnterView?.getSlowModeTimer().isNullOrEmpty()) {
									headerItem?.gone()
									attachItem?.visible()
								}
								else {
									headerItem?.visible()
									attachItem?.gone()
								}
							}
							else {
								val valueAnimator = ValueAnimator.ofFloat(0f, AndroidUtilities.dp(48f).toFloat())
								valueAnimator.duration = 220
								valueAnimator.interpolator = CubicBezierInterpolator.DEFAULT

								valueAnimator.addListener(object : AnimatorListenerAdapter() {
									override fun onAnimationStart(animation: Animator) {
										actionBar?.setMenuOffsetSuppressed(true)
										isEditTextItemVisibilitySuppressed = true
									}

									override fun onAnimationEnd(animation: Animator) {
										editTextItem.visibility = View.GONE
										menu.translateXItems(0f)
										actionBar?.setMenuOffsetSuppressed(false)
										isEditTextItemVisibilitySuppressed = false
									}
								})

								valueAnimator.addUpdateListener {
									menu.translateXItems(it.animatedValue as Float)
								}

								valueAnimator.start()
							}
						}
					}
				}
			}

			override fun onTextChanged(text: CharSequence?, bigChange: Boolean) {
				MediaController.getInstance().setInputFieldHasText(!text.isNullOrEmpty() || chatActivityEnterView?.isEditingMessage == true)

				mentionContainer?.adapter?.searchUsernameOrHashtag(text, chatActivityEnterView?.cursorPosition ?: 0, messages, usernameOnly = false, forSearch = false)

				if (waitingForCharaterEnterRunnable != null) {
					AndroidUtilities.cancelRunOnUIThread(waitingForCharaterEnterRunnable)
					waitingForCharaterEnterRunnable = null
				}

				if ((currentChat == null || canSendEmbed(currentChat)) && chatActivityEnterView?.isMessageWebPageSearchEnabled == true && (chatActivityEnterView?.isEditingMessage != true || chatActivityEnterView?.isEditingCaption != true)) {
					if (bigChange) {
						searchLinks(text, true)
					}
					else {
						waitingForCharaterEnterRunnable = object : Runnable {
							override fun run() {
								if (this == waitingForCharaterEnterRunnable) {
									searchLinks(text, false)
									waitingForCharaterEnterRunnable = null
								}
							}
						}

						AndroidUtilities.runOnUIThread(waitingForCharaterEnterRunnable, (if (AndroidUtilities.WEB_URL == null) 3000L else 1000L))
					}
				}

				emojiAnimationsOverlay?.cancelAllAnimations()

				ReactionsEffectOverlay.dismissAll()
			}

			override fun onTextSpansChanged(text: CharSequence?) {
				searchLinks(text, true)
			}

			override fun needSendTyping() {
				messagesController.sendTyping(dialogId, threadId, 0, classGuid)
			}

			override fun onAttachButtonHidden() {
				if (actionBar?.isSearchFieldVisible == true) {
					return
				}

				if (!isEditTextItemVisibilitySuppressed) {
					editTextItem?.gone()
				}

				if (chatActivityEnterView?.getSlowModeTimer().isNullOrEmpty()) {
					headerItem?.gone()
					attachItem?.visible()
				}
			}

			override fun onAttachButtonShow() {
				if (actionBar?.isSearchFieldVisible == true) {
					return
				}

				headerItem?.visible()

				if (!isEditTextItemVisibilitySuppressed) {
					editTextItem?.gone()
				}

				attachItem?.gone()
			}

			override fun onMessageEditEnd(loading: Boolean) {
				if (chatListItemAnimator != null) {
					chatActivityEnterViewAnimateFromTop = chatActivityEnterView?.backgroundTop ?: 0
				}

				if (!loading) {
					mentionContainer?.adapter?.setNeedBotContext(true)

					if (editingMessageObject != null) {
						AndroidUtilities.runOnUIThread({ hideFieldPanel(true) }, 30)
					}

					var waitingForKeyboard = false

					if (chatActivityEnterView?.isPopupShowing == true) {
						chatActivityEnterView?.setFieldFocused()
						waitingForKeyboard = true
					}

					chatActivityEnterView?.setAllowStickersAndGifs(needAnimatedEmoji = true, needStickers = true, needGifs = true, waitingForKeyboardOpen = waitingForKeyboard)

					if (editingMessageObjectReqId != 0) {
						connectionsManager.cancelRequest(editingMessageObjectReqId, true)
						editingMessageObjectReqId = 0
					}

					updatePinnedMessageView(true)
					updateBottomOverlay()
					updateVisibleRows()
				}
			}

			override fun onWindowSizeChanged(size: Int) {
				if (size < AndroidUtilities.dp(72f) + ActionBar.getCurrentActionBarHeight()) {
					allowStickersPanel = false
					if (suggestEmojiPanel?.visibility == View.VISIBLE) {
						suggestEmojiPanel?.invisible()
					}
				}
				else {
					allowStickersPanel = true

					if (suggestEmojiPanel?.visibility == View.INVISIBLE) {
						suggestEmojiPanel?.visible()
					}
				}

				allowContextBotPanel = chatActivityEnterView?.isPopupShowing != true
				// checkContextBotPanel()

				val size2 = size + if (chatActivityEnterView?.isPopupShowing == true) 1 shl 16 else 0

				if (lastSize != size2) {
					chatActivityEnterViewAnimateFromTop = 0
				}

				lastSize = size2
			}

			override fun onStickersTab(opened: Boolean) {
				emojiButtonRed?.gone()
				allowContextBotPanelSecond = !opened
				// checkContextBotPanel()
			}

			override fun didPressAttachButton() {
				chatAttachAlert?.setEditingMessageObject(null)
				openAttachMenu()
			}

			override fun needStartRecordVideo(state: Int, notify: Boolean, scheduleDate: Int) {
				if (instantCameraView != null) {
					when (state) {
						0 -> {
							instantCameraView?.showCamera()
							chatListView?.stopScroll()
							chatAdapter?.updateRowsSafe()
						}

						1, 3, 4 -> {
							instantCameraView?.send(state, notify, scheduleDate)
						}

						2, 5 -> {
							instantCameraView?.cancel(state == 2)
						}
					}
				}
			}

			override fun needChangeVideoPreviewState(state: Int, seekProgress: Float) {
				instantCameraView?.changeVideoPreviewState(state, seekProgress)
			}

			override fun needStartRecordAudio(state: Int) {
				val visibility = if (state == 0) View.GONE else View.VISIBLE

				if (overlayView?.visibility != visibility) {
					overlayView?.visibility = visibility
				}
			}

			override fun needShowMediaBanHint() {
				showMediaBannedHint()
			}

			override fun onStickersExpandedChange() {
				checkRaiseSensors()

				if (chatActivityEnterView?.isStickersExpanded == true) {
					AndroidUtilities.setAdjustResizeToNothing(parentActivity, classGuid)

					if (Bulletin.visibleBulletin?.isShowing == true) {
						Bulletin.visibleBulletin?.hide()
					}
				}
				else {
					AndroidUtilities.requestAdjustResize(parentActivity, classGuid)
				}

				mentionContainer?.animate()?.alpha(if (chatActivityEnterView?.isStickersExpanded == true) 0f else 1f)?.setInterpolator(CubicBezierInterpolator.DEFAULT)?.start()


				suggestEmojiPanel?.visible()

				suggestEmojiPanel?.animate()?.alpha(if (chatActivityEnterView?.isStickersExpanded == true) 0f else 1f)?.setInterpolator(CubicBezierInterpolator.DEFAULT)?.withEndAction {
					if (chatActivityEnterView?.isStickersExpanded == true) {
						suggestEmojiPanel?.gone()
					}
				}?.start()
			}

			override fun scrollToSendingMessage() {
				val id = sendMessagesHelper.getSendingMessageId(dialogId)

				if (id != 0) {
					scrollToMessageId(id, 0, true, 0, true, 0)
				}
			}

			override fun hasScheduledMessages(): Boolean {
				return scheduledMessagesCount > 0 && chatMode == 0
			}

			override fun onSendLongClick() {
				scheduledOrNoSoundHint?.hide()
			}

			override fun openScheduledMessages() {
				this@ChatActivity.openScheduledMessages()
			}

			override fun onAudioVideoInterfaceUpdated() {
				updatePagedownButtonVisibility(true)
			}

			override fun bottomPanelTranslationYChanged(translation: Float) {
				@Suppress("NAME_SHADOWING") var translation = translation

				if (translation != 0f) {
					wasManualScroll = true
				}

				bottomPanelTranslationY = if (chatActivityEnterView?.panelAnimationInProgress() == true) ((chatActivityEnterView?.emojiPadding?.toFloat() ?: 0f) - translation) else 0f
				bottomPanelTranslationYReverse = if (chatActivityEnterView?.panelAnimationInProgress() == true) translation else 0f

				chatActivityEnterView?.translationY = translation
				mentionContainer?.translationY = translation

				contentView?.setEmojiOffset(chatActivityEnterView?.panelAnimationInProgress() == true, bottomPanelTranslationY)

				translation += chatActivityEnterView?.topViewTranslation ?: 0f

				mentionContainer?.translationY = translation
				chatListView?.translationY = translation
				invalidateChatListViewTopPadding()
				invalidateMessagesVisiblePart()
				updateTextureViewPosition(false)
				contentView?.invalidate()
				updateBulletinLayout()
			}

			override fun prepareMessageSending() {
				waitingForSendingMessageLoad = true
			}

			override fun onTrendingStickersShowed(show: Boolean) {
				if (show) {
					AndroidUtilities.setAdjustResizeToNothing(parentActivity, classGuid)
					fragmentView?.requestLayout()
				}
				else {
					AndroidUtilities.requestAdjustResize(parentActivity, classGuid)
				}
			}

			override fun hasForwardingMessages(): Boolean {
				return !forwardingMessages?.messages.isNullOrEmpty()
			}
		})

		chatActivityEnterView?.setDialogId(dialogId, currentAccount)

		currentChatInfo?.let {
			chatActivityEnterView?.setChatInfo(it)
		}

		chatActivityEnterView?.id = id_chat_compose_panel
		chatActivityEnterView?.setBotsCount(botsCount, hasBotsCommands, false)
		chatActivityEnterView?.updateBotWebView(false)
		chatActivityEnterView?.minimumHeight = AndroidUtilities.dp(ChatActivityEnterView.height.toFloat())
		chatActivityEnterView?.setAllowStickersAndGifs(needAnimatedEmoji = false, needStickers = false, needGifs = false)
		// chatActivityEnterView.setAllowStickersAndGifs(true, true, currentEncryptedChat == null || AndroidUtilities.getPeerLayerVersion(currentEncryptedChat.layer) >= 46);

		if (inPreviewMode) {
			chatActivityEnterView?.invisible()
		}

		if (!isChannel(currentChat) || currentChat?.megagroup == true) {
			chatActivityEnterView?.setBotInfo(botInfo, false)
		}

		contentView?.addView(chatActivityEnterView, contentView!!.childCount - 1, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT or Gravity.BOTTOM))

		chatActivityEnterView?.checkChannelRights()

		chatActivityEnterTopView = object : ChatActivityEnterTopView(context) {
			override fun setTranslationY(translationY: Float) {
				super.setTranslationY(translationY)
				chatActivityEnterView?.invalidate()

				if (visibility != GONE) {
					hideHints(true)
					chatListView?.translationY = translationY
					progressView?.translationY = translationY
					invalidateChatListViewTopPadding()
					invalidateMessagesVisiblePart()
					fragmentView?.invalidate()
				}
			}

			override fun hasOverlappingRendering(): Boolean {
				return false
			}

			override fun setVisibility(visibility: Int) {
				super.setVisibility(visibility)

				if (visibility == GONE) {
					chatListView?.translationY = 0f
					progressView?.translationY = 0f
				}
			}
		}

		chatActivityEnterView?.addTopView(chatActivityEnterTopView, null, ChatActivityEnterTopView.height)

		val replyLayout = FrameLayout(context)
		// chatActivityEnterTopView.addReplyView(replyLayout, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.NO_GRAVITY, 0, 0, 52, 0));

		chatActivityEnterTopView?.addReplyView(replyLayout, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT.toFloat(), Gravity.NO_GRAVITY, 0f, 0f, 52f, 0f))

		replyLayout.setOnClickListener {
			if (!forwardingMessages?.messages.isNullOrEmpty()) {
				SharedConfig.forwardingOptionsHintHintShowed()
				openForwardingPreview()
			}
			else if (replyMessage != null && (!isThreadChat || replyMessage!!.id != threadId)) {
				scrollToMessageId(replyMessage!!.id, 0, true, 0, true, 0)
			}
			else if (editingMessageObject != null) {
				if (editingMessageObject!!.canEditMedia() && editingMessageObjectReqId == 0) {
					if (chatAttachAlert == null) {
						createChatAttachView()
					}

					chatAttachAlert?.setEditingMessageObject(editingMessageObject)

					openAttachMenu()
				}
				else {
					scrollToMessageId(editingMessageObject!!.id, 0, true, 0, true, 0)
				}
			}
		}

		replyIconImageView = ImageView(context)
		replyIconImageView?.colorFilter = PorterDuffColorFilter(ResourcesCompat.getColor(context.resources, R.color.brand, null), PorterDuff.Mode.SRC_IN)
		replyIconImageView?.scaleType = ImageView.ScaleType.CENTER

		replyLayout.addView(replyIconImageView, createFrame(56, 46, Gravity.CENTER_VERTICAL or Gravity.LEFT))

		val verticalLine = View(context)
		verticalLine.setBackgroundResource(R.color.brand)

		replyLayout.addView(verticalLine, createFrame(2, 46f, Gravity.CENTER_VERTICAL or Gravity.LEFT, 56f, 0f, 0f, 0f))

		replyCloseImageView = ImageView(context)
		replyCloseImageView?.colorFilter = PorterDuffColorFilter(ResourcesCompat.getColor(context.resources, R.color.brand, null), PorterDuff.Mode.SRC_IN)
		replyCloseImageView?.setImageResource(R.drawable.close_circle)
		replyCloseImageView?.scaleType = ImageView.ScaleType.CENTER
		replyCloseImageView?.background = Theme.createSelectorDrawable(context.getColor(R.color.brand) and 0x19ffffff, 1, AndroidUtilities.dp(18f))

		chatActivityEnterTopView?.addView(replyCloseImageView, createFrame(52, 46f, Gravity.RIGHT or Gravity.CENTER_VERTICAL, 0f, 0f, 0f, 0f))

		replyCloseImageView?.setOnClickListener {
			if (forwardingMessages?.messages.isNullOrEmpty()) {
				showFieldPanel(false, null, null, null, foundWebPage, true, 0, cancel = true, animated = true)
			}
			else {
				openAnotherForward()
			}
		}

		replyNameTextView = SimpleTextView(context)
		replyNameTextView?.setTextSize(16)
		replyNameTextView?.textColor = ResourcesCompat.getColor(context.resources, R.color.brand, null)
		replyNameTextView?.setTypeface(Theme.TYPEFACE_BOLD)

		replyLayout.addView(replyNameTextView, createFrame(LayoutHelper.MATCH_PARENT, 24f, Gravity.TOP or Gravity.LEFT, 74f, 11f, 0f, 0f))

		replyObjectTextView = SimpleTextView(context)
		replyObjectTextView?.setTextSize(14)
		replyObjectTextView?.textColor = ResourcesCompat.getColor(context.resources, R.color.dark_gray, null)

		replyLayout.addView(replyObjectTextView, createFrame(LayoutHelper.MATCH_PARENT, 20f, Gravity.TOP or Gravity.LEFT, 74f, 32f, 0f, 0f))

		replyObjectHintTextView = SimpleTextView(context)
		replyObjectHintTextView?.setTextSize(14)
		replyObjectHintTextView?.textColor = context.getColor(R.color.dark_gray)
		replyObjectHintTextView?.setText(context.getString(R.string.TapForForwardingOptions))
		replyObjectHintTextView?.alpha = 0f

		replyLayout.addView(replyObjectHintTextView, createFrame(LayoutHelper.MATCH_PARENT, 20f, Gravity.TOP or Gravity.LEFT, 74f, 32f, 0f, 0f))

		replyImageView = BackupImageView(context)
		replyImageView?.setRoundRadius(AndroidUtilities.dp(2f))

		replyLayout.addView(replyImageView, createFrame(46, 46f, Gravity.CENTER_VERTICAL or Gravity.LEFT, 74f, 0f, 0f, 0f))

		suggestEmojiPanel = SuggestEmojiView(context, currentAccount, chatActivityEnterView, null)

		contentView?.addView(suggestEmojiPanel, createFrame(LayoutHelper.MATCH_PARENT, 160f, Gravity.LEFT or Gravity.BOTTOM, 0f, 0f, 0f, 0f))

		val editView = EditView(context)
		editView.isMotionEventSplittingEnabled = false
		editView.orientation = LinearLayout.HORIZONTAL

		editView.setOnClickListener {
			editingMessageObject?.let { msg ->
				scrollToMessageId(msg.id, 0, true, 0, true, 0)
			}
		}

		chatActivityEnterTopView?.addEditView(editView, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT.toFloat(), Gravity.NO_GRAVITY, 0f, 0f, 48f, 0f))

		for (i in 0..1) {
			val firstButton = i == 0

			val button = object : EditViewButton(context) {
				override fun setEditButton(editButton: Boolean) {
					super.setEditButton(editButton)

					if (firstButton) {
						textView.maxWidth = if (editButton) AndroidUtilities.dp(116f) else Int.MAX_VALUE
					}
				}

				override fun updateColors() {
					val leftInset = if (firstButton) AndroidUtilities.dp(14f) else 0
					background = Theme.createCircleSelectorDrawable(context.getColor(R.color.brand) and 0x19ffffff, leftInset, 0)
					imageView.colorFilter = PorterDuffColorFilter(context.getColor(R.color.brand), PorterDuff.Mode.MULTIPLY)
					textView.setTextColor(context.getColor(R.color.brand))
				}
			}

			button.orientation = LinearLayout.HORIZONTAL

			ViewHelper.setPadding(button, 10f, 0f, 10f, 0f)

			editView.addButton(button, createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT))

			val imageView = ImageView(context)
			imageView.scaleType = ImageView.ScaleType.CENTER
			imageView.setImageResource(if (firstButton) R.drawable.msg_photoeditor else R.drawable.msg_replace)

			button.addImageView(imageView, createLinear(24, LayoutHelper.MATCH_PARENT))
			button.addView(Space(context), createLinear(10, LayoutHelper.MATCH_PARENT))

			val textView = TextView(context)
			textView.maxLines = 1
			textView.isSingleLine = true
			textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14f)
			textView.typeface = Theme.TYPEFACE_BOLD
			textView.gravity = Gravity.LEFT or Gravity.CENTER_VERTICAL
			textView.ellipsize = TextUtils.TruncateAt.END

			button.addTextView(textView, createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT))
			button.updateColors()

			button.setOnClickListener {
				if (editingMessageObject?.canEditMedia() != true || editingMessageObjectReqId != 0) {
					return@setOnClickListener
				}

				if (button.isEditButton) {
					openEditingMessageInPhotoEditor()
				}
				else {
					replyLayout.callOnClick()
				}
			}
		}

		searchContainer = object : FrameLayout(context) {
			override fun measureChildWithMargins(child: View, parentWidthMeasureSpec: Int, widthUsed: Int, parentHeightMeasureSpec: Int, heightUsed: Int) {
				if (child === searchCountText) {
					var leftMargin = 14

					if (searchCalendarButton != null && searchCalendarButton?.visibility != GONE) {
						leftMargin += 48
					}
					if (searchUserButton != null && searchUserButton?.visibility != GONE) {
						leftMargin += 48
					}

					(child.getLayoutParams() as? MarginLayoutParams)?.leftMargin = AndroidUtilities.dp(leftMargin.toFloat())
				}

				super.measureChildWithMargins(child, parentWidthMeasureSpec, widthUsed, parentHeightMeasureSpec, heightUsed)
			}
		}

		searchContainer?.setWillNotDraw(false)
		searchContainer?.visibility = View.INVISIBLE
		// searchContainer?.setPadding(0, AndroidUtilities.dp(3), 0, 0)
		searchContainer?.clipToPadding = false
		searchContainer?.setBackgroundResource(R.color.background)

		val searchAsListTogglerView = View(context)

		searchAsListTogglerView.setOnTouchListener { _, _ ->
			mediaDataController.foundMessageObjects.size <= 1
		}

		searchAsListTogglerView.background = Theme.getSelectorDrawable(context.getColor(R.color.brand), false)

		searchAsListTogglerView.setOnClickListener {
			if (mediaDataController.foundMessageObjects.size > 1) {
				searchAsListHint?.hide()
				toggleMessagesSearchListView()

				if (!SharedConfig.searchMessagesAsListUsed) {
					SharedConfig.setSearchMessagesAsListUsed(true)
				}
			}
		}

		val paddingTop = Theme.chat_composeShadowDrawable.intrinsicHeight / AndroidUtilities.density - 3f

		searchContainer?.addView(searchAsListTogglerView, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT.toFloat(), Gravity.NO_GRAVITY, 0f, paddingTop, 0f, 0f))

		searchUpButton = ImageView(context)
		searchUpButton?.scaleType = ImageView.ScaleType.CENTER
		searchUpButton?.setImageResource(R.drawable.msg_go_up)
		searchUpButton?.colorFilter = PorterDuffColorFilter(context.getColor(R.color.brand), PorterDuff.Mode.MULTIPLY)
		searchUpButton?.background = Theme.createSelectorDrawable(context.getColor(R.color.light_background), 1)

		searchContainer?.addView(searchUpButton, createFrame(48, 48f, Gravity.RIGHT or Gravity.TOP, 0f, 0f, 48f, 0f))

		searchUpButton?.setOnClickListener {
			mediaDataController.searchMessagesInChat(null, dialogId, mergeDialogId, classGuid, 1, threadId, searchingUserMessages, searchingChatMessages)

			showMessagesSearchListView(false)

			if (!SharedConfig.searchMessagesAsListUsed && SharedConfig.searchMessagesAsListHintShows < 3 && !searchAsListHintShown && Math.random() <= 0.25) {
				showSearchAsListHint()
				searchAsListHintShown = true
				SharedConfig.increaseSearchAsListHintShows()
			}
		}

		searchUpButton?.contentDescription = context.getString(R.string.AccDescrSearchNext)

		searchDownButton = ImageView(context)
		searchDownButton?.scaleType = ImageView.ScaleType.CENTER
		searchDownButton?.setImageResource(R.drawable.msg_go_down)
		searchDownButton?.colorFilter = PorterDuffColorFilter(context.getColor(R.color.brand), PorterDuff.Mode.MULTIPLY)
		searchDownButton?.background = Theme.createSelectorDrawable(context.getColor(R.color.light_background), 1)

		searchContainer?.addView(searchDownButton, createFrame(48, 48f, Gravity.RIGHT or Gravity.TOP, 0f, 0f, 0f, 0f))

		searchDownButton?.setOnClickListener {
			mediaDataController.searchMessagesInChat(null, dialogId, mergeDialogId, classGuid, 2, threadId, searchingUserMessages, searchingChatMessages)
			showMessagesSearchListView(false)
		}

		searchDownButton?.contentDescription = context.getString(R.string.AccDescrSearchPrev)

		if (currentChat != null && (!isChannel(currentChat) || currentChat!!.megagroup)) {
			searchUserButton = ImageView(context)
			searchUserButton?.scaleType = ImageView.ScaleType.CENTER
			searchUserButton?.setImageResource(R.drawable.msg_usersearch)
			searchUserButton?.colorFilter = PorterDuffColorFilter(context.getColor(R.color.brand), PorterDuff.Mode.MULTIPLY)
			searchUserButton?.background = Theme.createSelectorDrawable(context.getColor(R.color.light_background), 1)

			searchContainer?.addView(searchUserButton, createFrame(48, 48f, Gravity.LEFT or Gravity.TOP, 48f, 0f, 0f, 0f))

			searchUserButton?.setOnClickListener {
				mentionContainer?.isReversed = true
				mentionContainer?.adapter?.setSearchingMentions(true)

				searchCalendarButton?.gone()
				searchUserButton?.gone()

				searchingForUser = true
				searchingUserMessages = null
				searchingChatMessages = null

				searchItem?.setSearchFieldHint(context.getString(R.string.SearchMembers))
				searchItem?.setSearchFieldCaption(context.getString(R.string.SearchFrom))

				AndroidUtilities.showKeyboard(searchItem?.searchField)

				searchItem?.clearSearchText()
			}

			searchUserButton?.contentDescription = context.getString(R.string.AccDescrSearchByUser)
		}

		searchCalendarButton = ImageView(context)
		searchCalendarButton?.scaleType = ImageView.ScaleType.CENTER
		searchCalendarButton?.setImageResource(R.drawable.msg_calendar)
		searchCalendarButton?.colorFilter = PorterDuffColorFilter(context.getColor(R.color.brand), PorterDuff.Mode.MULTIPLY)
		searchCalendarButton?.background = Theme.createSelectorDrawable(context.getColor(R.color.light_background), 1)

		searchContainer?.addView(searchCalendarButton, createFrame(48, 48, Gravity.LEFT or Gravity.TOP))

		searchCalendarButton?.setOnClickListener {
			val parentActivity = parentActivity ?: return@setOnClickListener
			AndroidUtilities.hideKeyboard(searchItem?.searchField)

			AlertsCreator.createCalendarPickerDialog(parentActivity, 1375315200000L, { date -> jumpToDate(date) }, null)?.create()?.let { alert ->
				showDialog(alert)
			}
		}

		searchCalendarButton?.contentDescription = context.getString(R.string.JumpToDate)

		searchCountText = SearchCounterView(context, null)
		searchCountText?.setGravity(Gravity.LEFT)

		searchContainer?.addView(searchCountText, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.CENTER_VERTICAL, 0f, 0f, 108f, 0f))

		bottomOverlay = FrameLayout(context)
		bottomOverlay?.setBackgroundResource(R.color.background)
		bottomOverlay?.setWillNotDraw(false)
		bottomOverlay?.invisible()
		bottomOverlay?.isFocusable = true
		bottomOverlay?.isFocusableInTouchMode = true
		bottomOverlay?.isClickable = true
		bottomOverlay?.outlineProvider = ViewOutlineProvider.BOUNDS
		bottomOverlay?.clipToOutline = false

		ViewCompat.setElevation(bottomOverlay!!, AndroidUtilities.dp(4f).toFloat())

		contentView?.addView(bottomOverlay, createFrame(LayoutHelper.MATCH_PARENT, ChatActivityEnterView.height + 2, Gravity.BOTTOM))

		bottomOverlayText = TextView(context)
		bottomOverlayText?.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14f)
		bottomOverlayText?.gravity = Gravity.CENTER
		bottomOverlayText?.maxLines = 2
		bottomOverlayText?.ellipsize = TextUtils.TruncateAt.END
		bottomOverlayText?.setLineSpacing(AndroidUtilities.dp(2f).toFloat(), 1f)
		bottomOverlayText?.setTextColor(context.getColor(R.color.brand))

		bottomOverlay?.addView(bottomOverlayText, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.CENTER, 14f, 0f, 14f, 0f))

		bottomOverlayChat = FrameLayout(context)
		bottomOverlayChat?.setBackgroundResource(if (currentUser != null && currentUser!!.bot) R.color.brand else R.color.background)
		bottomOverlayChat?.setWillNotDraw(false)
		bottomOverlayChat?.visibility = View.INVISIBLE
		bottomOverlayChat?.clipChildren = false

		ViewCompat.setElevation(bottomOverlayChat!!, AndroidUtilities.dp(4f).toFloat())

		contentView?.addView(bottomOverlayChat, createFrame(LayoutHelper.MATCH_PARENT, ChatActivityEnterView.height + 2, Gravity.BOTTOM))

		bottomOverlayChatText = TextView(context)
		bottomOverlayChatText?.letterSpacing = 0.12f
		bottomOverlayChatText?.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14f)

		if (currentUser != null && currentUser!!.bot) {
			bottomOverlayChatText?.setTextColor(context.getColor(R.color.white))
			bottomOverlayChatText?.setBackgroundResource(R.color.brand)
		}
		else {
			bottomOverlayChatText?.setTextColor(context.resources.getColorStateList(R.color.chat_actions_text_color, null))
			bottomOverlayChatText?.setBackgroundResource(R.color.background)
		}

		bottomOverlayChatText?.foreground = Theme.createSimpleSelectorRoundRectDrawable(AndroidUtilities.dp(6f), Color.TRANSPARENT, ColorUtils.setAlphaComponent(ResourcesCompat.getColor(context.resources, R.color.brand, null), (255 * 0.3f).toInt()))
		bottomOverlayChatText?.compoundDrawablePadding = AndroidUtilities.dp(8f)
		bottomOverlayChatText?.gravity = Gravity.CENTER_VERTICAL

		bottomOverlayChat?.addView(bottomOverlayChatText, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.CENTER, 0f, 0f, 0f, 0f))

		bottomOverlayChatText?.setOnClickListener {
			if (pullingDownOffset != 0f) {
				return@setOnClickListener
			}

			val parentActivity = parentActivity ?: return@setOnClickListener

			if (reportType >= 0) {
				showDialog(object : ReportAlert(parentActivity, reportType) {
					override fun onSend(type: Int, message: String?) {
						val ids = mutableListOf<Int>()

						for (b in 0 until selectedMessagesIds[0].size()) {
							ids.add(selectedMessagesIds[0].keyAt(b))
						}

						val peer = if (currentUser != null) MessagesController.getInputPeer(currentUser!!) else MessagesController.getInputPeer(currentChat)

						AlertsCreator.sendReport(peer, reportType, message, ids)

						finishFragment()

						chatActivityDelegate?.onReport()
					}
				})
			}
			else if (chatMode == MODE_PINNED) {
				finishFragment()
				chatActivityDelegate?.onUnpin(true, bottomOverlayChatText!!.tag == null)
			}
			else if (currentUser != null && userBlocked) {
				if (currentUser!!.bot) {
					val botUserLast = botUser
					botUser = null
					messagesController.unblockPeer(currentUser!!.id)

					if (!botUserLast.isNullOrEmpty()) {
						messagesController.sendBotStart(currentUser, botUserLast)
					}
					else {
						sendMessagesHelper.sendMessage("/start", dialogId, null, null, null, false, null, null, null, true, 0, null, updateStickersOrder = false, isMediaSale = false, mediaSaleHash = null)
					}
				}
				else {
					val builder = AlertDialog.Builder(parentActivity)
					builder.setMessage(context.getString(R.string.AreYouSureUnblockContact))

					builder.setPositiveButton(context.getString(R.string.OK)) { _, _ ->
						messagesController.unblockPeer(currentUser!!.id)
					}

					builder.setTitle(context.getString(R.string.AppName))
					builder.setNegativeButton(context.getString(R.string.Cancel), null)

					showDialog(builder.create())
				}
			}
			else if (isReplyUser(currentUser)) {
				toggleMute(true)
			}
			else if (currentUser != null && currentUser!!.bot && botUser != null) {
				if (!botUser.isNullOrEmpty()) {
					messagesController.sendBotStart(currentUser, botUser)
				}
				else {
					sendMessagesHelper.sendMessage("/start", dialogId, null, null, null, false, null, null, null, true, 0, null, updateStickersOrder = false, isMediaSale = false, mediaSaleHash = null)
				}

				botUser = null

				showBotHelpCell = true
				emptyViewContainer?.gone()

				updateBottomOverlay()
			}
			else {
				if (isChannel(currentChat) && currentChat !is TL_channelForbidden) {
					if (isNotInChat(currentChat)) {
						if (currentChat!!.join_request) {
							showBottomOverlayProgress(show = true, animated = true)

							MessagesController.getInstance(currentAccount).addUserToChat(currentChat!!.id, UserConfig.getInstance(currentAccount).getCurrentUser(), 0, null, null, true, {
								waitingForLoad.add(lastLoadIndex)
								messagesController.loadMessages(dialogId, mergeDialogId, true, if (AndroidUtilities.isTablet() || isThreadChat) 30 else 20, startLoadFromMessageId, 0, false, 0, classGuid, 2, 0, chatMode, threadId, replyMaxReadId, lastLoadIndex++)
								showBottomOverlayProgress(show = false, animated = true)
							}) { err ->
								val preferences = MessagesController.getNotificationsSettings(currentAccount)
								preferences.edit().putLong("dialog_join_requested_time_$dialogId", System.currentTimeMillis()).commit()

								if (err != null && "INVITE_REQUEST_SENT" == err.text) {
									showBulletin(context, this, isChannel(currentChat) && !currentChat!!.megagroup)
								}

								showBottomOverlayProgress(show = false, animated = true)

								false
							}
						}
						else {
							if (chatInviteRunnable != null) {
								AndroidUtilities.cancelRunOnUIThread(chatInviteRunnable)
								chatInviteRunnable = null
							}

							showBottomOverlayProgress(show = true, animated = true)

							messagesController.addUserToChat(currentChat!!.id, userConfig.getCurrentUser(), 0, null, this@ChatActivity, null)
							NotificationCenter.globalInstance.postNotificationName(NotificationCenter.closeSearchByActiveAction)

							if (hasReportSpam() && reportSpamButton?.getTag(R.id.object_tag) != null) {
								val preferences = MessagesController.getNotificationsSettings(currentAccount)
								preferences.edit().putInt("dialog_bar_vis3$dialogId", 3).commit()
								notificationCenter.postNotificationName(NotificationCenter.peerSettingsDidLoad, dialogId)
							}
						}
					}
					else {
						toggleMute(true)
					}
				}
				else {
					val canDeleteHistory = currentChatInfo?.can_delete_channel == true

					AlertsCreator.createClearOrDeleteDialogAlert(this@ChatActivity, false, currentChat, currentUser, currentEncryptedChat != null, true, canDeleteHistory) {
						notificationCenter.removeObserver(this@ChatActivity, NotificationCenter.closeChats)
						notificationCenter.postNotificationName(NotificationCenter.closeChats)

						finishFragment()

						notificationCenter.postNotificationName(NotificationCenter.needDeleteDialog, dialogId, currentUser, currentChat, it)
					}
				}
			}
		}

		bottomOverlayProgress = RadialProgressView(context)
		bottomOverlayProgress?.setSize(AndroidUtilities.dp(22f))
		bottomOverlayProgress?.setProgressColor(context.getColor(R.color.dark_gray))
		bottomOverlayProgress?.invisible()
		bottomOverlayProgress?.scaleX = 0.1f
		bottomOverlayProgress?.scaleY = 0.1f
		bottomOverlayProgress?.alpha = 1.0f

		bottomOverlayChat?.addView(bottomOverlayProgress, createFrame(30, 30, Gravity.CENTER))

		val color = context.getColor(R.color.brand)

		bottomOverlayImage = ImageView(context)
		bottomOverlayImage?.setImageResource(R.drawable.msg_help)
		bottomOverlayImage?.colorFilter = PorterDuffColorFilter(color, PorterDuff.Mode.MULTIPLY)
		bottomOverlayImage?.scaleType = ImageView.ScaleType.CENTER
		bottomOverlayImage?.background = Theme.createSelectorDrawable(Color.argb(24, Color.red(color), Color.green(color), Color.blue(color)), 1)

		bottomOverlayChat?.addView(bottomOverlayImage, createFrame(48, 48f, Gravity.RIGHT or Gravity.TOP, 3f, 1.5f, 0f, 0f))

		bottomOverlayImage?.contentDescription = context.getString(R.string.SettingsHelp)

		bottomOverlayImage?.setOnClickListener {
			undoView?.showWithAction(dialogId, UndoView.ACTION_TEXT_INFO, context.getString(R.string.BroadcastGroupInfo))
		}

		replyButton = TextView(context)
		replyButton?.text = context.getString(R.string.Reply)
		replyButton?.gravity = Gravity.CENTER_VERTICAL
		replyButton?.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15f)
		replyButton?.setPadding(AndroidUtilities.dp(14f), 0, AndroidUtilities.dp(21f), 0)
		replyButton?.background = Theme.createSelectorDrawable(context.getColor(R.color.light_background), 3)
		replyButton?.setTextColor(ResourcesCompat.getColor(context.resources, R.color.text, null))
		replyButton?.compoundDrawablePadding = AndroidUtilities.dp(20f)
		replyButton?.typeface = Theme.TYPEFACE_BOLD

		var image = ResourcesCompat.getDrawable(context.resources, R.drawable.msg_reply, null)?.mutate()
		image?.colorFilter = PorterDuffColorFilter(context.getColor(R.color.text), PorterDuff.Mode.SRC_IN)

		replyButton?.setCompoundDrawablesWithIntrinsicBounds(image, null, null, null)

		replyButton?.setOnClickListener {
			var messageObject: MessageObject? = null

			for (a in 1 downTo 0) {
				if (messageObject == null && selectedMessagesIds[a].size() != 0) {
					messageObject = messagesDict[a][selectedMessagesIds[a].keyAt(0)]
				}

				selectedMessagesIds[a].clear()
				selectedMessagesCanCopyIds[a].clear()
				selectedMessagesCanStarIds[a].clear()
			}

			hideActionMode()

			if (messageObject != null && (messageObject!!.messageOwner!!.id > 0 || messageObject!!.messageOwner!!.id < 0 && currentEncryptedChat != null)) {
				showFieldPanelForReply(messageObject)
			}

			updatePinnedMessageView(true)
			updateVisibleRows()
		}

		bottomMessagesActionContainer?.addView(replyButton, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, Gravity.LEFT or Gravity.TOP))

		forwardButton = TextView(context)
		forwardButton?.text = context.getString(R.string.Forward)
		forwardButton?.gravity = Gravity.CENTER_VERTICAL
		forwardButton?.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15f)
		forwardButton?.setPadding(AndroidUtilities.dp(21f), 0, AndroidUtilities.dp(21f), 0)
		forwardButton?.compoundDrawablePadding = AndroidUtilities.dp(20f)
		forwardButton?.background = Theme.createSelectorDrawable(context.getColor(R.color.light_background), 3)
		forwardButton?.setTextColor(ResourcesCompat.getColor(context.resources, R.color.text, null))
		forwardButton?.typeface = Theme.TYPEFACE_BOLD

		image = ResourcesCompat.getDrawable(context.resources, R.drawable.msg_forward, null)?.mutate()
		image?.colorFilter = PorterDuffColorFilter(ResourcesCompat.getColor(context.resources, R.color.text, null), PorterDuff.Mode.SRC_IN)

		forwardButton?.setCompoundDrawablesWithIntrinsicBounds(image, null, null, null)

		forwardButton?.setOnClickListener {
			openForward(false)
		}

		bottomMessagesActionContainer?.addView(forwardButton, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, Gravity.RIGHT or Gravity.TOP))

		contentView?.addView(searchContainer, createFrame(LayoutHelper.MATCH_PARENT, 51, Gravity.BOTTOM))
		contentView?.addView(MessageEnterTransitionContainer(contentView, currentAccount).also { messageEnterTransitionContainer = it })

		undoView = UndoView(context, this, false)
		undoView?.setAdditionalTranslationY(AndroidUtilities.dp(51f).toFloat())

		contentView?.addView(undoView, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.BOTTOM or Gravity.LEFT, 8f, 0f, 8f, 8f))

		if (currentChat != null) {
			slowModeHint = HintView(parentActivity, 2)
			slowModeHint?.alpha = 0.0f
			slowModeHint?.invisible()

			contentView?.addView(slowModeHint, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.LEFT or Gravity.TOP, 19f, 0f, 19f, 0f))
		}

		chatAdapter?.updateRowsSafe()

		if (loading && messages.isEmpty()) {
			showProgressView(chatAdapter!!.botInfoRow < 0)
			chatListView?.setEmptyView(null)
		}
		else {
			showProgressView(false)
			chatListView?.setEmptyView(emptyViewContainer)
		}

		checkBotKeyboard()
		updateBottomOverlay()
		updateSecretStatus()
		updateTopPanel(false)
		updatePinnedMessageView(false)
		updateInfoTopView(false)

		chatScrollHelper = RecyclerAnimationScrollHelper(chatListView, chatLayoutManager)

		chatScrollHelper?.setScrollListener {
			invalidateMessagesVisiblePart()
		}
		chatScrollHelper?.setAnimationCallback(chatScrollHelperCallback)

		if (currentEncryptedChat != null && (SharedConfig.passcodeHash.isNullOrEmpty() || SharedConfig.allowScreenCapture)) {
			unregisterFlagSecurePasscode = AndroidUtilities.registerFlagSecure(parentActivity!!.window)
		}

		if (messagesController.isChatNoForwards(currentChat)) {
			unregisterFlagSecureNoforwards = AndroidUtilities.registerFlagSecure(parentActivity!!.window)
		}

		if (oldMessage != null) {
			chatActivityEnterView?.fieldText = oldMessage
		}

		fixLayoutInternal()

		textSelectionHelper.setCallback(object : TextSelectionHelper.Callback() {
			override fun onStateChanged(isSelected: Boolean) {
				swipeBackEnabled = !isSelected

				if (isSelected) {
					slidingView?.setSlidingOffset(0f)
					slidingView = null

					maybeStartTrackingSlidingView = false
					startedTrackingSlidingView = false

					textSelectionHint?.hide()
				}

				updatePagedownButtonVisibility(true)
			}

			override fun onTextCopied() {
				if (actionBar?.isActionModeShowed == true) {
					clearSelectionMode()
				}

				undoView?.showWithAction(0, UndoView.ACTION_TEXT_COPIED, null)
			}
		})

		val textSelectionHelperOverlayView = textSelectionHelper.getOverlayView(context)

		(textSelectionHelperOverlayView.parent as? ViewGroup)?.removeView(textSelectionHelperOverlayView)

		contentView?.addView(textSelectionHelperOverlayView)

		fireworksOverlay = FireworksOverlay(context)

		contentView?.addView(fireworksOverlay, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT.toFloat()))

		textSelectionHelper.setParentView(chatListView)

		val searchFromUserId = getArguments()!!.getInt("search_from_user_id", 0).toLong()
		val searchFromChatId = getArguments()!!.getInt("search_from_chat_id", 0).toLong()

		if (searchFromUserId != 0L) {
			val user = messagesController.getUser(searchFromUserId)

			if (user != null) {
				openSearchWithText("")
				searchUserButton?.callOnClick()
				searchUserMessages(user, null)
			}
		}
		else if (searchFromChatId != 0L) {
			val chat = messagesController.getChat(searchFromChatId)

			if (chat != null) {
				openSearchWithText("")
				searchUserButton?.callOnClick()
				searchUserMessages(null, chat)
			}
		}

		if (replyMessage != null) {
			chatActivityEnterView?.setReplyingMessageObject(replyMessage)
		}

		val decorView = parentActivity?.window?.decorView as? ViewGroup

		pinchToZoomHelper = object : PinchToZoomHelper(decorView, contentView) {
			override fun drawOverlays(canvas: Canvas, alpha: Float, parentOffsetX: Float, parentOffsetY: Float, clipTop: Float, clipBottom: Float) {
				if (alpha > 0) {
					val view = child

					if (view is ChatMessageCell) {
						val top = max(clipTop, parentOffsetY).toInt()
						val bottom = min(clipBottom, parentOffsetY + view.measuredHeight).toInt()

						AndroidUtilities.rectTmp.set(parentOffsetX, top.toFloat(), parentOffsetX + view.measuredWidth, bottom.toFloat())

						canvas.saveLayerAlpha(AndroidUtilities.rectTmp, (255 * alpha).toInt())
						canvas.translate(parentOffsetX, parentOffsetY)

						view.drawFromPinchToZoom = true
						view.drawOverlays(canvas)

						if (view.shouldDrawTimeOnMedia() && view.currentMessagesGroup == null) {
							view.drawTime(canvas, 1f, false)
						}

						view.drawFromPinchToZoom = false

						canvas.restore()
					}
				}
			}
		}

		pinchToZoomHelper?.setCallback(object : PinchToZoomHelper.Callback {
			override fun getCurrentTextureView(): TextureView? {
				return videoTextureView
			}

			override fun onZoomStarted(messageObject: MessageObject?) {
				chatListView?.cancelClickRunnables(true)
				chatListView?.stopScroll()

				if (MediaController.getInstance().isPlayingMessage(messageObject)) {
					contentView?.removeView(videoPlayerContainer)
					videoPlayerContainer = null
					videoTextureView = null
					aspectRatioFrameLayout = null
				}

				val chatListView = chatListView ?: return

				for (i in 0 until chatListView.childCount) {
					if (chatListView.getChildAt(i) is ChatMessageCell) {
						val cell = chatListView.getChildAt(i) as ChatMessageCell

						if (cell.getMessageObject()?.id == messageObject?.id) {
							cell.photoImage.setVisible(value = false, invalidate = true)
						}
					}
				}
			}

			override fun onZoomFinished(messageObject: MessageObject?) {
				if (messageObject == null) {
					return
				}

				val chatListView = chatListView ?: return

				if (MediaController.getInstance().isPlayingMessage(messageObject)) {
					for (i in 0 until chatListView.childCount) {
						if (chatListView.getChildAt(i) is ChatMessageCell) {
							val cell = chatListView.getChildAt(i) as ChatMessageCell

							if (cell.getMessageObject()?.id == messageObject.id) {
								val animation = cell.photoImage.animation

								if (animation?.isRunning == true) {
									animation.stop()
								}

								if (animation != null) {
									val bitmap = animation.animatedBitmap

									if (bitmap != null) {
										try {
											val src = pinchToZoomHelper?.getVideoBitmap(bitmap.width, bitmap.height)

											if (src != null) {
												val canvas = Canvas(bitmap)
												canvas.drawBitmap(src, 0f, 0f, null)
												src.recycle()
											}
										}
										catch (e: Throwable) {
											FileLog.e(e)
										}
									}
								}
							}
						}
					}

					createTextureView(true)

					MediaController.getInstance().setTextureView(videoTextureView, aspectRatioFrameLayout, videoPlayerContainer, true)
				}

				chatListView.invalidate()
			}
		})

		pinchToZoomHelper?.setClipBoundsListener {
			it[1] = ((chatListView?.bottom ?: 0) - blurredViewBottomOffset).toFloat()
			it[0] = (chatListView?.top ?: 0) + chatListViewPadding - AndroidUtilities.dp(4f)
		}

		emojiAnimationsOverlay = object : EmojiAnimationsOverlay(this@ChatActivity, contentView, chatListView, currentAccount, dialogId, threadId) {
			override fun onAllEffectsEnd() {
				updateMessagesVisiblePart(false)
			}
		}

		actionBar?.setDrawBlurBackground(contentView)

		val dialog = messagesController.dialogs_dict[dialogId]

		if (dialog != null) {
			reactionsMentionCount = dialog.unread_reactions_count
			updateReactionsMentionButton(false)
		}

		if (isAiBot()) {
			startAiBot()
		}

		return fragmentView
	}

	private suspend fun checkAdultSubscription(currentChat: Chat) {
		if (currentChat.creator) {
			return
		}

		if (!currentChat.adult) {
			return
		}

		withContext(mainScope.coroutineContext) {
			bottomOverlayChatText?.isEnabled = false
		}

		delay(500)

		mainScope.launch {
			showSubscribeBottomSheet(currentChat)
		}
	}

	private suspend fun checkSubscription(currentChat: Chat) {
		if (currentChat.creator || hasAdminRights(currentChat)) {
			return
		}

		if (!isPaidChannel(currentChat)) {
			return
		}

		if (!currentChat.left) {
			return
		}

		withContext(mainScope.coroutineContext) {
			bottomOverlayChatText?.isEnabled = false
		}

		val currentSubscriptions = (connectionsManager.performRequest(ElloRpc.getSubscriptionsRequest(subscriptionType = ElloRpc.SubscriptionType.ACTIVE_CHANNELS)) as? TL_biz_dataRaw)?.readData<ElloRpc.Subscriptions>()

		if (currentSubscriptions?.items?.find { it.channelId == currentChat.id && it.isActive } != null) {
			withContext(mainScope.coroutineContext) {
				bottomOverlayChatText?.isEnabled = true
			}

			return
		}

		delay(100)

		mainScope.launch {
			showSubscribeBottomSheet(currentChat)
		}
	}

	@MainThread
	private fun showSubscribeBottomSheet(currentChat: Chat) {
		val context = context ?: return
		val subscriptionView: View?
		val showingDialog = visibleDialog?.window?.findViewById<View>(R.id.subscribe_dialog_parent_view).also { subscriptionView = it } != null

		val alert = SubscribeToChannelAlert(context = context, currentChat = currentChat, currentChatInfo = currentChatInfo, subscriptionView = subscriptionView, linkClickListener = object : LinkClickListener {
			override fun onClick(route: String) {
				openUrl(route)
			}

			override fun onLongClick(route: String) {
				val builder = BottomSheet.Builder(parentActivity)
				builder.setTitle(route)

				builder.setItems(arrayOf<CharSequence>(context.getString(R.string.Open), context.getString(R.string.Copy))) { _, which ->
					if (which == 0) {
						openUrl(route)
					}
					else if (which == 1) {
						AndroidUtilities.addToClipboard(route)

						if (AndroidUtilities.shouldShowClipboardToast()) {
							if (route.startsWith("@")) {
								BulletinFactory.of(this@ChatActivity).createSimpleBulletin(R.raw.copy, context.getString(R.string.UsernameCopied)).show()
							}
							else if (route.startsWith("#") || route.startsWith("$")) {
								BulletinFactory.of(this@ChatActivity).createSimpleBulletin(R.raw.copy, context.getString(R.string.HashtagCopied)).show()
							}
							else {
								BulletinFactory.of(this@ChatActivity).createSimpleBulletin(R.raw.copy, context.getString(R.string.LinkCopied)).show()
							}
						}
					}
				}
				builder.show()
			}
		}, subscribeClickListener = object : OnClickListener {
			override fun onClick(v: View) {
				if (!isPaidChannel(currentChat)) {
					bottomOverlayChatText?.performClick()

					visibleDialog?.setOnDismissListener(null)
					visibleDialog?.dismiss()

					return
				}

				ioScope.launch {
					val request = subscribeRequest(currentChat.id)
					val resp = connectionsManager.performRequest(request)
					val error = resp as? TLRPC.TL_error

					mainScope.launch {
						visibleDialog?.setOnDismissListener {
							val args = Bundle()
							args.putBoolean(SubscriptionResultFragment.SUCCESS, error == null)

							val originalError = error?.text?.lowercase()

							if (originalError?.contains("enough") == true && originalError.contains("money")) {
								args.putString(SubscriptionResultFragment.DESCRIPTION, v.context.getString(R.string.insufficient_funds_message))
								args.putInt(SubscriptionResultFragment.IMAGE_RES_ID, R.drawable.panda_payment_error)
								args.putBoolean(SubscriptionResultFragment.SHOW_TOPUP, true)
							}
							else {
								args.putInt(SubscriptionResultFragment.IMAGE_RES_ID, if (error == null) R.drawable.panda_success else R.drawable.panda_error)

								if (isOnlineCourse(currentChat)) {
									args.putString(SubscriptionResultFragment.DESCRIPTION, if (error == null) v.context.getString(R.string.online_course_success) else (error.text ?: ""))
								}
								else {
									args.putString(SubscriptionResultFragment.DESCRIPTION, if (error == null) v.context.getString(R.string.subscription_success) else (error.text ?: ""))
								}
							}

							presentFragment(SubscriptionResultFragment(args), true)
						}

						visibleDialog?.dismiss()
					}
				}
			}
		})

		if (!showingDialog) {
			val builder = BottomSheet.Builder(context)
			builder.setApplyTopPadding(true)
			builder.customView = alert.view

			val dialog = builder.create()
			dialog.setCanDismissWithSwipe(false)

			alert.setCloseButtonClickListener {
				dialog.dismiss()
			}

			showDialog(dialog) {
				finishFragment()
			}
		}
	}

	private fun openUrl(url: String) {
		if (url.startsWith("@")) {
			messagesController.openByUserName(url.substring(1), this, 0)
		}
		else if (url.startsWith("#")) {
			val fragment = DialogsActivity(null)
			fragment.setSearchString(url)

			presentFragment(fragment)
		}
		else if (url.startsWith("/")) {
			if (parentLayout!!.fragmentsStack.size > 1) {
				val previousFragment = parentLayout?.fragmentsStack?.getOrNull((parentLayout?.fragmentsStack?.size ?: 0) - 2)

				if (previousFragment is ChatActivity) {
					finishFragment()
					previousFragment.chatActivityEnterView?.setCommand(null, url, longPress = false, username = false)
				}
			}
		}
		else {
			Browser.openUrl(parentActivity, url)
		}
	}

	private fun playReactionAnimation(messageId: Int) {
		if (fragmentView == null) {
			return
		}

		val cell = findMessageCell(messageId, false) ?: return

		val reaction = cell.getMessageObject()!!.randomUnreadReaction

		if (reaction != null && cell.reactionsLayoutInBubble.hasUnreadReactions) {
			ReactionsEffectOverlay.show(this@ChatActivity, null, cell, null, 0f, 0f, fromTLReaction(reaction.reaction), currentAccount, if (reaction.big) ReactionsEffectOverlay.LONG_ANIMATION else ReactionsEffectOverlay.SHORT_ANIMATION)
			ReactionsEffectOverlay.startAnimation()
		}

		cell.markReactionsAsRead()
	}

	private fun dimBehindView(view: View?, enable: Boolean) {
		scrimView = view
		dimBehindView(if (enable) 0.01f else 0f, view !== reactionsMentiondownButton && view !== mentiondownButton)
	}

//	private fun dimBehindView(view: View, value: Float) {
//		scrimView = view
//		dimBehindView(value, view !== reactionsMentiondownButton && view !== mentiondownButton)
//	}

	fun dimBehindView(enable: Boolean) {
		dimBehindView(if (enable) 0.01f else 0f, true)
	}

	private fun dimBehindView(value: Float, hidePagedownButtons: Boolean) {
		val enable = value > 0

		if (scrimView is ChatMessageCell) {
			val cell = scrimView as ChatMessageCell
			cell.setInvalidatesParent(enable)

			if (enable) {
				restartSticker(cell)
			}
		}

		contentView?.invalidate()
		chatListView?.invalidate()

		scrimAnimatorSet?.removeAllListeners()
		scrimAnimatorSet?.cancel()

		scrimAnimatorSet = AnimatorSet()

		val animators = mutableListOf<Animator>()
		var scrimPaintAlphaAnimator: ValueAnimator

		if (enable) {
			scrimViewAlpha = 1f
			scrimViewAlphaAnimator?.cancel()
			animators.add(ValueAnimator.ofFloat(0f, value).also { scrimPaintAlphaAnimator = it })
		}
		else {
			animators.add(ValueAnimator.ofFloat(scrimPaintAlpha, 0f).also { scrimPaintAlphaAnimator = it })
		}

		scrimPaintAlphaAnimator.addUpdateListener {
			scrimPaintAlpha = it.animatedValue as Float
			fragmentView?.invalidate()
		}

		if (!enable || hidePagedownButtons) {
			if (pagedownButton != null) {
				animators.add(ObjectAnimator.ofFloat(pagedownButton, View.ALPHA, (if (enable) 0f else 1f)))
			}

			if (mentiondownButton != null) {
				animators.add(ObjectAnimator.ofFloat(mentiondownButton, View.ALPHA, (if (enable) 0f else 1f)))
			}

			if (reactionsMentiondownButton != null) {
				animators.add(ObjectAnimator.ofFloat(reactionsMentiondownButton, View.ALPHA, (if (enable) 0f else 1f)))
			}
		}

		scrimAnimatorSet?.playTogether(animators)
		scrimAnimatorSet?.duration = (if (enable) 150 else 220).toLong()

		scrimAnimatorSet?.addListener(object : AnimatorListenerAdapter() {
			override fun onAnimationEnd(animation: Animator) {
				if (!enable) {
					scrimView = null
					scrimViewReaction = null
					contentView?.invalidate()
					chatListView?.invalidate()
				}
			}
		})

		if (scrimViewAlpha <= 0f) {
			scrimView = null
		}

		scrimAnimatorSet?.start()
	}

	private fun updatePagedownButtonsPosition() {
		val baseTranslationY = (chatActivityEnterView?.animatedTop ?: 0) + (chatActivityEnterView?.translationY ?: 0f) + if (chatActivityEnterTopView?.visibility == View.VISIBLE) (chatActivityEnterTopView?.translationY ?: 0f) else 0f

		pagedownButton?.translationY = baseTranslationY + AndroidUtilities.dp(100f) * (1f - pagedownButtonEnterProgress)
		mentiondownButton?.translationY = baseTranslationY + AndroidUtilities.dp(100f) * (1f - mentionsButtonEnterProgress) - AndroidUtilities.dp(72f) * pagedownButtonEnterProgress * mentionsButtonEnterProgress
		reactionsMentiondownButton?.translationY = baseTranslationY + AndroidUtilities.dp(100f) * (1f - reactionsMentionButtonEnterProgress) - ((AndroidUtilities.dp(50f) + AndroidUtilities.dp(22f) * pagedownButtonCounter!!.enterProgress) * pagedownButtonEnterProgress + AndroidUtilities.dp(72f) * mentionsButtonEnterProgress) * reactionsMentionButtonEnterProgress
		suggestEmojiPanel?.translationY = baseTranslationY
	}

	private fun updateReactionsMentionButton(animated: Boolean) {
		val reactionsMentiondownButtonCounter = reactionsMentiondownButtonCounter ?: return
		val reactionsMentiondownButton = reactionsMentiondownButton ?: return

		if (parentActivity == null) {
			return
		}

		val visible = reactionsMentionCount > 0 && chatMode == 0

		reactionsMentiondownButtonCounter.setCount(reactionsMentionCount, animated)

		if (visible && reactionsMentiondownButton.tag == null) {
			reactionsMentiondownButton.tag = 1

			reactionsMentionButtonAnimation?.removeAllListeners()
			reactionsMentionButtonAnimation?.cancel()
			reactionsMentionButtonAnimation = null

			if (animated) {
				reactionsMentiondownButton.visible()

				reactionsMentionButtonAnimation = ValueAnimator.ofFloat(reactionsMentionButtonEnterProgress, 1f)

				reactionsMentionButtonAnimation?.addUpdateListener {
					reactionsMentionButtonEnterProgress = it.animatedValue as Float
					contentView?.invalidate()
				}

				reactionsMentionButtonAnimation?.addListener(object : AnimatorListenerAdapter() {
					override fun onAnimationEnd(animation: Animator) {
						reactionsMentionButtonEnterProgress = 1f
						contentView?.invalidate()
					}
				})

				reactionsMentionButtonAnimation?.duration = 200
				reactionsMentionButtonAnimation?.start()
			}
			else {
				reactionsMentiondownButton.visible()
				reactionsMentionButtonEnterProgress = 1f
				contentView?.invalidate()
			}
		}
		else if (!visible && reactionsMentiondownButton.tag != null) {
			reactionsMentiondownButton.tag = null

			reactionsMentionButtonAnimation?.removeAllListeners()
			reactionsMentionButtonAnimation?.cancel()
			reactionsMentionButtonAnimation = null

			if (animated) {
				reactionsMentiondownButton.visible()

				reactionsMentionButtonAnimation = ValueAnimator.ofFloat(reactionsMentionButtonEnterProgress, 0f)

				reactionsMentionButtonAnimation?.addUpdateListener {
					reactionsMentionButtonEnterProgress = it.animatedValue as Float
					contentView?.invalidate()
				}

				reactionsMentionButtonAnimation?.addListener(object : AnimatorListenerAdapter() {
					override fun onAnimationEnd(animation: Animator) {
						reactionsMentiondownButton.invisible()
						reactionsMentionButtonEnterProgress = 0f
						contentView?.invalidate()
					}
				})

				reactionsMentionButtonAnimation?.duration = 200
				reactionsMentionButtonAnimation?.start()
			}
			else {
				reactionsMentiondownButton.invisible()
				reactionsMentionButtonEnterProgress = 0f
				contentView?.invalidate()
			}
		}
	}

	private fun openForwardingPreview() {
		val keyboardVisible = chatActivityEnterView?.isKeyboardVisible ?: false
		val context = context ?: return

		forwardingPreviewView = object : ForwardingPreviewView(context, forwardingMessages, currentUser, currentChat, currentAccount) {
			override fun onDismiss(canShowKeyboard: Boolean) {
				checkShowBlur()

				if (forwardingMessages != null) {
					val selectedMessage = mutableListOf<MessageObject>()
					forwardingMessages?.getSelectedMessages(selectedMessage)
					showFieldPanelForForward(true, selectedMessage)
				}

				if (keyboardVisible && canShowKeyboard) {
					AndroidUtilities.runOnUIThread({
						chatActivityEnterView?.openKeyboard()
					}, 50)
				}

				AndroidUtilities.requestAdjustResize(parentActivity, classGuid)
			}

			override fun selectAnotherChat() {
				super.selectAnotherChat()

				dismiss(false)

				if (forwardingMessages != null) {
					var hasPoll = 0
					var hasInvoice = false
					var a = 0
					val N = forwardingMessages?.messages?.size ?: 0

					while (a < N) {
						val messageObject = forwardingMessages?.messages?.get(a)

						if (messageObject == null) {
							a++
							continue
						}

						if (messageObject.isPoll) {
							if (hasPoll != 2) {
								hasPoll = if (messageObject.isPublicPoll) 2 else 1
							}
						}
						else if (messageObject.isInvoice) {
							hasInvoice = true
						}

						selectedMessagesIds[0].put(messageObject.id, messageObject)

						a++
					}

					val args = Bundle()
					args.putBoolean("onlySelect", true)
					args.putInt("dialogsType", 3)
					args.putInt("hasPoll", hasPoll)
					args.putBoolean("hasInvoice", hasInvoice)
					args.putInt("messagesCount", N)

					val fragment = DialogsActivity(args)
					fragment.setDelegate(this@ChatActivity)

					presentFragment(fragment)
				}
			}

			override fun didSendPressed() {
				super.didSendPressed()
				dismiss(true)
				chatActivityEnterView?.getSendButton()?.callOnClick()
			}
		}

		val defPeer = currentChatInfo?.default_send_as ?: sendAsPeers?.peers?.firstOrNull()?.peer

//		if (defPeer == null && !sendAsPeers?.peers.isNullOrEmpty()) {
//			defPeer = sendAsPeers!!.peers[0].peer
//		}

		forwardingPreviewView?.setSendAsPeer(defPeer)

		checkShowBlur()

		contentView?.addView(forwardingPreviewView)

		if (keyboardVisible) {
			chatActivityEnterView?.showEmojiView()
			openKeyboardOnAttachMenuClose = true
		}

		AndroidUtilities.setAdjustResizeToNothing(parentActivity, classGuid)

		fragmentView?.requestLayout()
	}

	private fun animateToNextChat() {
		val pullingDownDrawable = pullingDownDrawable ?: return

		addToPulledDialogsMyself()

		val nextChat = pullingDownDrawable.nextChat

		if (nextChat != null) {
			addToPulledDialogs(nextChat, pullingDownDrawable.nextDialogId, pullingDownDrawable.dialogFolderId, pullingDownDrawable.dialogFilterId)
		}

		val bundle = Bundle()
		bundle.putLong("chat_id", pullingDownDrawable.chatId)
		bundle.putInt("dialog_folder_id", pullingDownDrawable.dialogFolderId)
		bundle.putInt("dialog_filter_id", pullingDownDrawable.dialogFilterId)
		bundle.putBoolean("pulled", true)

		val sharedPreferences = MessagesController.getNotificationsSettings(currentAccount)
		sharedPreferences.edit().remove("diditem" + pullingDownDrawable.nextDialogId).commit()

		val chatActivity = ChatActivity(bundle)
		chatActivity.setPullingDownTransition(true)

		replacingChatActivity = true

		presentFragment(chatActivity, true)
	}

	private fun addToPulledDialogsMyself() {
		val stackIndex = getParentLayout()?.fragmentsStack?.indexOf(this) ?: return
		addToPulledDialogs(this, stackIndex, currentChat, currentUser, dialogId, dialogFilterId, dialogFolderId)
	}

	private fun addToPulledDialogs(chat: Chat, dialogId: Long, folderId: Int, filterId: Int) {
		val stackIndex = getParentLayout()?.fragmentsStack?.indexOf(this) ?: return
		addToPulledDialogs(this, stackIndex, chat, null, dialogId, folderId, filterId)
	}

	private fun setPullingDownTransition(fromPullingDownTransition: Boolean) {
		this.fromPullingDownTransition = fromPullingDownTransition
	}

	private fun updateBulletinLayout() {
		val bulletin = Bulletin.visibleBulletin

		if (bulletin != null && bulletinDelegate != null) {
			bulletin.updatePosition()
		}
	}

	private fun searchUserMessages(user: User?, chat: Chat?) {
		val context = context ?: return

		searchingUserMessages = user
		searchingChatMessages = chat

		if (searchItem == null || mentionContainer == null || searchingUserMessages == null && searchingChatMessages == null) {
			return
		}

		var name: String?

		if (searchingUserMessages != null) {
			name = searchingUserMessages?.first_name

			if (name.isNullOrEmpty()) {
				name = searchingUserMessages?.last_name
			}
		}
		else {
			name = searchingChatMessages?.title
		}

		if (name == null) {
			return
		}

		if (name.length > 10) {
			name = name.substring(0, 10)
		}

		searchingForUser = false

		val from = context.getString(R.string.SearchFrom)
		val spannable: Spannable = SpannableString("$from $name")

		spannable.setSpan(ForegroundColorSpan(context.getColor(R.color.dark_gray)), from.length + 1, spannable.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

		searchItem?.setSearchFieldCaption(spannable)

		mentionContainer?.adapter?.searchUsernameOrHashtag(null, 0, null, usernameOnly = false, forSearch = true)

		searchItem?.setSearchFieldHint(null)
		searchItem?.clearSearchText()

		mediaDataController.searchMessagesInChat("", dialogId, mergeDialogId, classGuid, 0, threadId, searchingUserMessages, searchingChatMessages)
	}

	private fun updateInfoTopView(animated: Boolean) {
		val contentView = contentView ?: return

		val preferences = MessagesController.getNotificationsSettings(currentAccount)

		distanceToPeer = preferences.getInt("dialog_bar_distance$dialogId", -1)

		var text: CharSequence? = null
		var onClickListener: View.OnClickListener? = null

		if (distanceToPeer >= 0 && currentUser != null) {
			text = LocaleController.formatString("ChatDistanceToPeer", R.string.ChatDistanceToPeer, currentUser!!.first_name, LocaleController.formatDistance(distanceToPeer.toFloat(), 0))

			onClickListener = View.OnClickListener {
				presentFragment(PeopleNearbyActivity())
			}
		}
		else if (currentChat != null && chatInviterId != 0L) {
			val show = preferences.getInt("dialog_bar_vis3$dialogId", 0) == 2
			val showReport = preferences.getBoolean("dialog_bar_report$dialogId", false)
			val showBlock = preferences.getBoolean("dialog_bar_block$dialogId", false)

			if (show && (showReport || showBlock)) {
				val user = messagesController.getUser(chatInviterId)

				if (user != null) {
					text = if (isChannel(currentChat) && !currentChat!!.megagroup) contentView.context.getString(R.string.ActionUserInvitedToChannel) else contentView.context.getString(R.string.ActionUserInvitedToGroup)
					text = MessageObject.replaceWithLink(text, "un1", user)

					onClickListener = View.OnClickListener {
						// MARK: open profile
						val args = Bundle()
						args.putLong("user_id", chatInviterId)
						presentFragment(ProfileActivity(args))
					}
				}
			}
			else {
				hideInfoView()
			}
		}

		if (text != null) {
			infoTopViewAnimator?.cancel()

			if (infoTopView == null) {
				infoTopView = ChatActionCell(contentView.context, false)
				infoTopView?.setCustomText(text)
				infoTopView?.setInvalidateColors(true)
				infoTopView?.setOnClickListener(onClickListener)

				contentView.addView(infoTopView, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.TOP or Gravity.CENTER_HORIZONTAL, 0f, 0f, 0f, 0f))
			}

			if (animated) {
				if (infoTopView?.tag == null) {
					val a = ValueAnimator.ofFloat(0f, 1f)

					infoTopView?.tag = 1
					infoTopView?.alpha = 0f

					val distanceTopViewFinal = infoTopView

					a.addUpdateListener {
						val alpha = it.animatedValue as Float
						topViewOffset = alpha * AndroidUtilities.dp(30f)
						invalidateChatListViewTopPadding()
						distanceTopViewFinal?.alpha = alpha
					}

					a.addListener(object : AnimatorListenerAdapter() {
						override fun onAnimationEnd(animation: Animator) {
							topViewOffset = AndroidUtilities.dp(30f).toFloat()
							invalidateChatListViewTopPadding()
						}
					})

					a.duration = 150

					infoTopViewAnimator = a

					a.start()
				}
			}
			else {
				infoTopView?.tag = 1
				topViewOffset = AndroidUtilities.dp(30f).toFloat()
				invalidateChatListViewTopPadding()
			}
		}
	}

	private fun openAnotherForward() {
		val parentActivity = parentActivity ?: return
		val fwdMessages = forwardingMessages?.messages ?: return
		var lastPeerId: Long = 0
		var dialogId: Long = 0
		var a = 0
		val N = fwdMessages.size

		while (a < N) {
			val message = fwdMessages[a]

			if (lastPeerId == 0L) {
				dialogId = message.dialogId
				lastPeerId = message.fromChatId
			}
			else if (lastPeerId != message.fromChatId) {
				break
			}

			a++
		}

		val builder = AlertDialog.Builder(parentActivity)
		builder.setButtonsVertical(true)

		val message = if (dialogId > 0) {
			val user = messagesController.getUser(dialogId) ?: return
			LocaleController.formatString("CancelForwardPrivate", R.string.CancelForwardPrivate, LocaleController.formatPluralString("MessagesBold", fwdMessages.size), formatName(user.first_name, user.last_name))
		}
		else {
			val chat = messagesController.getChat(-dialogId) ?: return
			LocaleController.formatString("CancelForwardChat", R.string.CancelForwardChat, LocaleController.formatPluralString("MessagesBold", fwdMessages.size), chat.title ?: "")
		}

		builder.setMessage(AndroidUtilities.replaceTags(message))
		builder.setTitle(LocaleController.formatPluralString("messages", fwdMessages.size))

		builder.setPositiveButton(parentActivity.getString(R.string.CancelForwarding)) { _, _ ->
			forwardingMessages = null
			showFieldPanel(false, null, null, null, foundWebPage, true, 0, cancel = true, animated = true)
		}

		builder.setNegativeButton(parentActivity.getString(R.string.ShowForwardingOptions)) { _, _ ->
			openForwardingPreview()
		}

		val dialog = builder.create()

		showDialog(dialog)

		val button = dialog.getButton(DialogInterface.BUTTON_POSITIVE) as? TextView

		button?.setTextColor(parentActivity.getColor(R.color.purple))
	}

	private fun openPinnedMessagesList(preview: Boolean) {
		if (parentActivity == null || parentLayout == null || parentLayout?.lastFragment !== this || pinnedMessageIds.isEmpty()) {
			return
		}

		val bundle = Bundle()

		if (currentChat != null) {
			bundle.putLong("chat_id", currentChat!!.id)
		}
		else {
			bundle.putLong("user_id", currentUser!!.id)
		}

		bundle.putInt("chatMode", MODE_PINNED)

		val fragment = ChatActivity(bundle)
		fragment.pinnedMessageIds = pinnedMessageIds.toMutableList()
		fragment.pinnedMessageObjects = pinnedMessageObjects.toMutableMap()

		var a = 0
		val N = pinnedMessageIds.size

		while (a < N) {
			val id = pinnedMessageIds[a]
			var `object` = pinnedMessageObjects[id]
			val object2 = messagesDict[0][id]

			if (`object` == null) {
				`object` = object2
			}
			else if (object2 != null) {
				`object`.mediaExists = object2.mediaExists
				`object`.attachPathExists = object2.attachPathExists
			}

			if (`object` != null) {
				fragment.pinnedMessageObjects[id] = `object`
			}

			a++
		}

		fragment.loadedPinnedMessagesCount = loadedPinnedMessagesCount
		fragment.totalPinnedMessagesCount = totalPinnedMessagesCount
		fragment.pinnedEndReached = pinnedEndReached
		fragment.currentUserInfo = currentUserInfo
		fragment.currentChatInfo = currentChatInfo

		fragment.chatActivityDelegate = object : ChatActivityDelegate {
			override fun openReplyMessage(mid: Int) {
				scrollToMessageId(mid, 0, true, 0, true, 0)
			}

			override fun openSearch(text: String?) {
				openSearchWithText(text)
			}

			override fun onUnpin(all: Boolean, hide: Boolean) {
				if (all) {
					val ids = pinnedMessageIds.toList()
					val objects = pinnedMessageObjects.values.toList()

					if (hide) {
						val preferences = MessagesController.getNotificationsSettings(currentAccount)
						preferences.edit().putInt("pin_$dialogId", pinnedMessageIds[0]).commit()
						updatePinnedMessageView(true)
					}
					else {
						notificationCenter.postNotificationName(NotificationCenter.didLoadPinnedMessages, dialogId, ids, false, null, null, 0, 0, true)
					}

					pinBulletin?.hide()

					showPinBulletin = true

					val tag = ++pinBullerinTag
					val oldTotalPinnedCount: Int = pinnedMessagesCount

					pinBulletin = BulletinFactory.createUnpinAllMessagesBulletin(this@ChatActivity, oldTotalPinnedCount, hide, {
						if (hide) {
							val preferences = MessagesController.getNotificationsSettings(currentAccount)
							preferences.edit().remove("pin_$dialogId").commit()
							updatePinnedMessageView(true)
						}
						else {
							notificationCenter.postNotificationName(NotificationCenter.didLoadPinnedMessages, dialogId, ids, true, objects, null, 0, oldTotalPinnedCount, pinnedEndReached)
						}

						if (tag == pinBullerinTag) {
							pinBulletin = null
						}
					}) {
						if (!hide) {
							messagesController.unpinAllMessages(currentChat, currentUser)
						}
						if (tag == pinBullerinTag) {
							pinBulletin = null
						}
					}
				}
				else {
					var messageObject = pinnedMessageObjects[currentPinnedMessageId]

					if (messageObject == null) {
						messageObject = messagesDict[0][currentPinnedMessageId]
					}

					unpinMessage(messageObject)
				}
			}
		}

		if (preview) {
			presentFragmentAsPreview(fragment)
			checkShowBlur()
		}
		else {
			presentFragment(fragment, false)
		}
	}

	private fun checkShowBlur() {
		val show = parentLayout != null && parentLayout!!.isInPreviewMode && !inPreviewMode || forwardingPreviewView != null && forwardingPreviewView!!.isShowing

		if (show && (blurredView == null || blurredView!!.tag == null)) {
			if (blurredView == null) {
				blurredView = object : BlurredView(fragmentView!!.context, fragmentView!!) {
					override fun setAlpha(alpha: Float) {
						super.setAlpha(alpha)
						fragmentView?.invalidate()
					}

					override fun setVisibility(visibility: Int) {
						super.setVisibility(visibility)
						fragmentView?.invalidate()
					}
				}

				contentView?.addView(blurredView, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT.toFloat()))
			}
			else {
				val idx = contentView!!.indexOfChild(blurredView)

				if (idx != contentView!!.childCount - 1) {
					contentView?.removeView(blurredView)
					contentView?.addView(blurredView)
				}

				blurredView?.update()
				blurredView?.visible()
			}

			blurredView?.alpha = 0.0f
			blurredView?.animate()?.setListener(null)?.cancel()

			blurredView?.animate()?.alpha(1f)?.setListener(object : AnimatorListenerAdapter() {
				override fun onAnimationEnd(animation: Animator) {
					super.onAnimationEnd(animation)
					chatListView?.invalidate()
					fragmentView?.invalidate()
				}
			})?.start()

			blurredView?.tag = 1
		}
		else if (!show && blurredView?.tag != null) {
			blurredView?.animate()?.setListener(null)?.cancel()
			blurredView?.animate()?.setListener(HideViewAfterAnimation(blurredView!!))?.alpha(0f)?.start()
			blurredView?.tag = null

			chatListView?.invalidate()
			fragmentView?.invalidate()
		}
	}

	override fun getPreviewHeight(): Int {
		return if (chatMode == MODE_PINNED && messages.size == 2) {
			getHeightForMessage(messages[0]) + AndroidUtilities.dp(80f) + ActionBar.getCurrentActionBarHeight()
		}
		else {
			super.getPreviewHeight()
		}
	}

	private fun showProgressView(show: Boolean) {
		if (progressView == null) {
			return
		}

		if (fragmentOpened && SharedConfig.animationsEnabled()) {
			if (show == animateTo) {
				return
			}

			animateTo = show

			if (show) {
				if (progressView?.visibility != View.VISIBLE) {
					progressView?.visible()
					progressView?.alpha = 0f
					progressView?.scaleX = 0.3f
					progressView?.scaleY = 0.3f
				}
				loaderAnimationView?.playAnimation()

				progressView?.animate()?.setListener(null)?.cancel()
				progressView?.animate()?.alpha(1f)?.scaleX(1f)?.scaleY(1f)?.setDuration(150)?.start()
			}
			else {
				progressView?.animate()?.setListener(null)?.cancel()
				loaderAnimationView?.stopAnimation()

				progressView?.animate()?.alpha(0f)?.scaleX(0.3f)?.scaleY(0.3f)?.setDuration(150)?.setListener(object : AnimatorListenerAdapter() {
					override fun onAnimationEnd(animation: Animator) {
						progressView?.invisible()
					}
				})?.start()
			}
		}
		else {
			animateTo = show
			progressView?.visibility = if (show) {
				loaderAnimationView?.playAnimation()
				View.VISIBLE
			}
			else {
				loaderAnimationView?.stopAnimation()
				View.INVISIBLE
			}
		}
	}

	private fun hideInfoView() {
		if (distanceToPeer >= 0) {
			distanceToPeer = -1
			val preferences = MessagesController.getNotificationsSettings(currentAccount)
			preferences.edit().putInt("dialog_bar_distance$dialogId", -2).commit()
		}

		infoTopViewAnimator?.cancel()

		if (infoTopView?.tag != null) {
			infoTopView?.tag = null

			val topViewFinal = infoTopView
			val a = ValueAnimator.ofFloat(1f, 0f)

			a.addUpdateListener {
				val alpha = it.animatedValue as Float
				topViewOffset = alpha * AndroidUtilities.dp(30f)
				invalidateChatListViewTopPadding()
				invalidateMessagesVisiblePart()
				topViewFinal?.alpha = alpha
			}

			a.addListener(object : AnimatorListenerAdapter() {
				override fun onAnimationEnd(animation: Animator) {
					topViewOffset = 0f

					if (animation === infoTopViewAnimator) {
						val parent = topViewFinal?.parent as? ViewGroup
						parent?.removeView(topViewFinal)
						infoTopView = null
						infoTopViewAnimator = null
					}
				}
			})

			a.duration = 150

			infoTopViewAnimator = a

			a.start()
		}
	}

	private fun updateChatListViewTopPadding() {
		if (!invalidateChatListViewTopPadding || chatListView == null || fixedKeyboardHeight > 0 && searchExpandProgress == 0f) {
			return
		}

		val topPanelViewH = max(0f, AndroidUtilities.dp(48f) + topChatPanelViewOffset)
		var pinnedViewH = 0f

		if (pinnedMessageView?.visibility == View.VISIBLE) {
			pinnedViewH = max(0f, AndroidUtilities.dp(48f) + pinnedMessageEnterOffset)
		}

		var pendingViewH = 0f
		val pendingRequestsView = pendingRequestsDelegate?.view

		if (pendingRequestsView != null && pendingRequestsView.visibility == View.VISIBLE) {
			pendingViewH = max(0f, pendingRequestsView.height + pendingRequestsDelegate!!.viewEnterOffset)
		}

		val oldPadding = chatListViewPadding

		chatListViewPaddingTopOnlyTopViews = topPanelViewH + pinnedViewH

		chatListViewPadding = AndroidUtilities.dp(4f) + contentPaddingTop + topPanelViewH + pinnedViewH + pendingViewH
		chatListViewPadding += blurredViewTopOffset.toFloat()

		chatListViewPaddingVisibleOffset = 0

		chatListViewPadding += contentPanTranslation + bottomPanelTranslationY

		var searchExpandOffset = 0f

		if (searchExpandProgress != 0f && chatActivityEnterView!!.visibility == View.VISIBLE) {
			chatListViewPadding -= searchExpandProgress * (chatActivityEnterView!!.measuredHeight - searchContainer!!.measuredHeight).also {
				searchExpandOffset = it.toFloat()
			}
		}

		if (bottomPanelTranslationY == 0f && !chatActivityEnterView!!.panelAnimationInProgress() && (contentView!!.layoutParams.height < 0 || contentView!!.keyboardHeight <= AndroidUtilities.dp(20f) && chatActivityEnterView!!.isPopupShowing)) {
			chatListViewPadding += (if (contentView!!.keyboardHeight <= AndroidUtilities.dp(20f) && !AndroidUtilities.isInMultiwindow && !inBubbleMode) chatActivityEnterView!!.emojiPadding else contentView!!.keyboardHeight).toFloat()
		}

		if (!inPreviewMode && chatActivityEnterView != null) {
			if (chatActivityEnterView!!.animatedTop != 0) {
				chatListViewPadding += (chatActivityEnterView!!.heightWithTopView - AndroidUtilities.dp(51f) - chatActivityEnterView!!.animatedTop).toFloat()
			}
			else if (!chatActivityEnterView!!.panelAnimationInProgress()) {
				chatListViewPadding += (chatActivityEnterView!!.heightWithTopView - AndroidUtilities.dp(51f)).toFloat()

				if (chatActivityEnterView!!.currentTopViewAnimation == null) {
					chatListViewPadding -= chatListView!!.translationY
				}
			}
		}

		if (infoTopView != null) {
			infoTopView!!.translationY = chatListViewPadding - AndroidUtilities.dp(30f) + topViewOffset
			chatListViewPadding += topViewOffset
			chatListViewPaddingVisibleOffset += topViewOffset.toInt()
		}

		if (floatingDateView != null) {
			floatingDateView?.translationY = chatListView!!.translationY - searchExpandOffset + chatListViewPadding + floatingDateViewOffset - AndroidUtilities.dp(4f)
		}

		val p = chatListView!!.measuredHeight * 2 / 3

		if (chatListView != null && chatLayoutManager != null && chatAdapter != null) {
			if (chatListView!!.paddingTop != p) {
				val firstVisPos = chatLayoutManager!!.findFirstVisibleItemPosition()
				val lastVisPos = chatLayoutManager!!.findLastVisibleItemPosition()
				var top = 0
				var scrollToMessageObject: MessageObject? = null

				if (firstVisPos != RecyclerView.NO_POSITION) {
					for (i in firstVisPos..lastVisPos) {
						val v = chatLayoutManager!!.findViewByPosition(i)

						if (v is ChatMessageCell) {
							scrollToMessageObject = v.getMessageObject()
							top = chatListView!!.measuredHeight - v.getBottom() - chatListView!!.paddingBottom
							break
						}
						else if (v is ChatActionCell) {
							scrollToMessageObject = v.messageObject
							top = chatListView!!.measuredHeight - v.getBottom() - chatListView!!.paddingBottom
							break
						}
					}
				}

				chatListView?.setPadding(0, p, 0, AndroidUtilities.dp(3f) + blurredViewBottomOffset)

				if (firstVisPos != RecyclerView.NO_POSITION && scrollToMessageObject != null) {
					chatAdapter?.updateRowsSafe()

					val index = messages.indexOf(scrollToMessageObject)

					if (index >= 0) {
						chatLayoutManager?.scrollToPositionWithOffset(chatAdapter!!.messagesStartRow + index, top)
					}
				}

				invalidateMessagesVisiblePart()
			}

			chatListView?.topGlowOffset = (chatListViewPadding - chatListViewPaddingVisibleOffset - AndroidUtilities.dp(4f)).toInt()

			if (oldPadding != chatListViewPadding) {
				val n = chatListView!!.childCount

				for (i in 0 until n) {
					val child = chatListView!!.getChildAt(i)
					val adapterPosition = chatListView!!.getChildAdapterPosition(child)

					if (adapterPosition == chatAdapter!!.itemCount - 1) {
						var padding = chatListViewPadding

						if (isThreadChat && pinnedMessageView != null && pinnedMessageView!!.visibility == View.VISIBLE) {
							padding -= max(0f, AndroidUtilities.dp(48f) + pinnedMessageEnterOffset)
						}

						if (child.top > padding) {
							chatListView!!.scrollBy(0, (child.top - padding).toInt())
						}

						break
					}
				}
			}

			if (!isThreadChat && !wasManualScroll && unreadMessageObject != null && chatListView != null) {
				chatListView!!.scrollBy(0, (oldPadding - chatListViewPadding).toInt())
			}
		}

		invalidateChatListViewTopPadding = false
	}

	private fun invalidateChatListViewTopPadding() {
		if (!invalidateChatListViewTopPadding) {
			invalidateChatListViewTopPadding = true

			contentView?.invalidate()
			chatListView?.invalidate()
		}

		var translation = contentPanTranslation + contentPaddingTop + max(0f, AndroidUtilities.dp(48f) + topChatPanelViewOffset)

		if (pinnedMessageView != null) {
			translation += pinnedMessageEnterOffset
			pinnedMessageView?.translationY = translation
			translation += AndroidUtilities.dp(48f).toFloat()
		}

		val pendingRequestsView = pendingRequestsDelegate?.view

		if (pendingRequestsView != null) {
			translation += pendingRequestsDelegate!!.viewEnterOffset
			pendingRequestsView.translationY = translation
		}

		if (fragmentContextView != null) {
			var from = 0f

			if (fragmentLocationContextView?.visibility == View.VISIBLE) {
				from += AndroidUtilities.dp(36f).toFloat()
			}

			fragmentContextView?.translationY = contentPanTranslation + from + fragmentContextView!!.getTopPadding()
		}

		if (fragmentLocationContextView != null) {
			var from = 0f

			if (fragmentContextView?.visibility == View.VISIBLE) {
				from += AndroidUtilities.dp(fragmentContextView!!.styleHeight.toFloat()) + fragmentContextView!!.getTopPadding()
			}

			fragmentLocationContextView?.translationY = contentPanTranslation + from + fragmentLocationContextView!!.getTopPadding()
		}

		topChatPanelView?.translationY = contentPanTranslation + contentPaddingTop + topChatPanelViewOffset

		if (alertView?.visibility == View.VISIBLE) {
			alertView?.translationY = contentPanTranslation + contentPaddingTop - AndroidUtilities.dp(50f) * (1f - alertViewEnterProgress)
		}

		bottomOverlayChat?.translationY = bottomPanelTranslationYReverse
		bottomMessagesActionContainer?.translationY = bottomPanelTranslationYReverse

		undoView?.setAdditionalTranslationY((chatActivityEnterView!!.heightWithTopView - chatActivityEnterView!!.animatedTop).toFloat())
	}

	private fun createTextureView(add: Boolean): TextureView? {
		val parentActivity = parentActivity ?: return null
		if (parentLayout == null) {
			return null
		}

		AndroidUtilities.cancelRunOnUIThread(destroyTextureViewRunnable)

		if (videoPlayerContainer == null) {
			videoPlayerContainer = object : FrameLayout(parentActivity) {
				override fun setTranslationY(translationY: Float) {
					super.setTranslationY(translationY)
					contentView?.invalidate()
				}
			}

			videoPlayerContainer?.outlineProvider = object : ViewOutlineProvider() {
				override fun getOutline(view: View, outline: Outline) {
					val imageReceiver = view.getTag(R.id.parent_tag) as? ImageReceiver

					if (imageReceiver != null) {
						val rad = imageReceiver.getRoundRadius()
						var maxRad = 0

						for (a in 0..3) {
							maxRad = max(maxRad, rad[a])
						}

						outline.setRoundRect(0, 0, view.measuredWidth, view.measuredHeight, maxRad.toFloat())
					}
					else {
						outline.setOval(0, 0, AndroidUtilities.roundPlayingMessageSize, AndroidUtilities.roundPlayingMessageSize)
					}
				}
			}

			videoPlayerContainer?.clipToOutline = true
			videoPlayerContainer?.setWillNotDraw(false)

			aspectRatioFrameLayout = AspectRatioFrameLayout(parentActivity)
			aspectRatioFrameLayout?.setBackgroundColor(0)

			if (add) {
				videoPlayerContainer?.addView(aspectRatioFrameLayout, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.CENTER))
			}

			videoTextureView = TextureView(parentActivity)
			videoTextureView?.isOpaque = false

			aspectRatioFrameLayout?.addView(videoTextureView, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT.toFloat()))
		}

		var parent: ViewGroup? = videoPlayerContainer?.parent as? ViewGroup

		if (parent != null && parent !== contentView) {
			parent.removeView(videoPlayerContainer)
			parent = null
		}

		if (parent == null) {
			contentView?.addView(videoPlayerContainer, 1, FrameLayout.LayoutParams(AndroidUtilities.roundPlayingMessageSize, AndroidUtilities.roundPlayingMessageSize))
		}

		videoPlayerContainer?.tag = null
		aspectRatioFrameLayout?.isDrawingReady = false

		return videoTextureView
	}

	private fun destroyTextureView() {
		if (videoPlayerContainer?.parent == null) {
			return
		}

		chatListView?.invalidateViews()
		aspectRatioFrameLayout?.isDrawingReady = false
		videoPlayerContainer?.tag = null
		contentView?.removeView(videoPlayerContainer)
	}

	private fun hasSelectedNoforwardsMessage(): Boolean {
		runCatching {
			for (selectedMessagesId in selectedMessagesIds) {
				for (j in 0 until selectedMessagesId.size()) {
					val msg = selectedMessagesId.valueAt(j)

					if (msg.messageOwner?.noforwards == true) {
						return true
					}
				}
			}
		}

		return false
	}

	private fun openForward(fromActionBar: Boolean) {
		val context = context ?: return

		if (messagesController.isChatNoForwards(currentChat) || hasSelectedNoforwardsMessage()) {
			// We should update text if user changed locale without re-opening chat activity

			val str = if (messagesController.isChatNoForwards(currentChat)) {
				if (isChannel(currentChat) && !currentChat!!.megagroup) {
					context.getString(R.string.ForwardsRestrictedInfoChannel)
				}
				else {
					context.getString(R.string.ForwardsRestrictedInfoGroup)
				}
			}
			else {
				context.getString(R.string.ForwardsRestrictedInfoBot)
			}

			if (fromActionBar) {
				if (fwdRestrictedTopHint == null) {
					val frameLayout = fragmentView as SizeNotifierFrameLayout
					val index = frameLayout.indexOfChild(chatActivityEnterView)

					if (index == -1) {
						return
					}

					fwdRestrictedTopHint = HintView(parentActivity, 7, true)

					frameLayout.addView(fwdRestrictedTopHint, index + 1, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.LEFT or Gravity.TOP, 12f, 0f, 12f, 0f))

					fwdRestrictedTopHint?.alpha = 0.0f
					fwdRestrictedTopHint?.invisible()
				}

				fwdRestrictedTopHint?.setText(str)
				fwdRestrictedTopHint?.showForView(actionBar!!.actionMode.getItem(forward), true)
			}
			else {
				if (fwdRestrictedBottomHint == null) {
					val frameLayout = fragmentView as SizeNotifierFrameLayout
					val index = frameLayout.indexOfChild(chatActivityEnterView)

					if (index == -1) {
						return
					}

					fwdRestrictedBottomHint = HintView(parentActivity, 9)

					frameLayout.addView(fwdRestrictedBottomHint, index + 1, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.LEFT or Gravity.TOP, 12f, 0f, 12f, 0f))

					fwdRestrictedBottomHint?.alpha = 0.0f
					fwdRestrictedBottomHint?.invisible()
				}

				fwdRestrictedBottomHint?.setText(str)
				fwdRestrictedBottomHint?.showForView(forwardButton, true)
			}

			return
		}

		var hasPoll = 0
		var hasInvoice = false

		for (a in 0..1) {
			for (b in 0 until selectedMessagesIds[a].size()) {
				val messageObject = selectedMessagesIds[a].valueAt(b)

				if (messageObject?.isPoll == true) {
					hasPoll = if (messageObject.isPublicPoll) 2 else 1

					if (hasPoll == 2) {
						break
					}
				}
				else if (messageObject?.isInvoice == true) {
					hasInvoice = true
				}
			}

			if (hasPoll == 2) {
				break
			}
		}

		val args = Bundle()
		args.putBoolean("onlySelect", true)
		args.putInt("dialogsType", 3)
		args.putInt("messagesCount", canForwardMessagesCount)
		args.putInt("hasPoll", hasPoll)
		args.putBoolean("hasInvoice", hasInvoice)
		args.putBoolean(DialogsActivity.shouldShowBottomNavigationPanelKey, false)

		val fragment = DialogsActivity(args)
		fragment.setDelegate(this@ChatActivity)

		presentFragment(fragment)
	}

	private fun showBottomOverlayProgress(show: Boolean, animated: Boolean) {
		if (show && bottomOverlayProgress?.tag != null || !show && bottomOverlayProgress?.tag == null) {
			return
		}

		bottomOverlayAnimation?.cancel()
		bottomOverlayAnimation = null

		bottomOverlayProgress?.tag = if (show) 1 else null

		if (animated) {
			bottomOverlayAnimation = AnimatorSet()

			if (show) {
				bottomOverlayProgress?.visible()

				bottomOverlayAnimation?.playTogether(ObjectAnimator.ofFloat(bottomOverlayChatText, View.SCALE_X, 0.1f), ObjectAnimator.ofFloat(bottomOverlayChatText, View.SCALE_Y, 0.1f), ObjectAnimator.ofFloat(bottomOverlayChatText, View.ALPHA, 0.0f), ObjectAnimator.ofFloat(bottomOverlayProgress, View.SCALE_X, 1.0f), ObjectAnimator.ofFloat(bottomOverlayProgress, View.SCALE_Y, 1.0f), ObjectAnimator.ofFloat(bottomOverlayProgress, View.ALPHA, 1.0f))
				bottomOverlayAnimation?.startDelay = 200
			}
			else {
				bottomOverlayChatText?.visible()
				bottomOverlayAnimation?.playTogether(ObjectAnimator.ofFloat(bottomOverlayProgress, View.SCALE_X, 0.1f), ObjectAnimator.ofFloat(bottomOverlayProgress, View.SCALE_Y, 0.1f), ObjectAnimator.ofFloat(bottomOverlayProgress, View.ALPHA, 0.0f), ObjectAnimator.ofFloat(bottomOverlayChatText, View.SCALE_X, 1.0f), ObjectAnimator.ofFloat(bottomOverlayChatText, View.SCALE_Y, 1.0f), ObjectAnimator.ofFloat(bottomOverlayChatText, View.ALPHA, 1.0f))
			}

			bottomOverlayAnimation?.addListener(object : AnimatorListenerAdapter() {
				override fun onAnimationEnd(animation: Animator) {
					if (bottomOverlayAnimation != null && bottomOverlayAnimation == animation) {
						if (!show) {
							bottomOverlayProgress?.invisible()
						}
						else {
							bottomOverlayChatText?.invisible()
						}
					}
				}

				override fun onAnimationCancel(animation: Animator) {
					if (bottomOverlayAnimation != null && bottomOverlayAnimation == animation) {
						bottomOverlayAnimation = null
					}
				}
			})

			bottomOverlayAnimation?.duration = 150
			bottomOverlayAnimation?.start()
		}
		else {
			bottomOverlayProgress?.visibility = if (show) View.VISIBLE else View.INVISIBLE
			bottomOverlayProgress?.scaleX = if (show) 1.0f else 0.1f
			bottomOverlayProgress?.scaleY = if (show) 1.0f else 0.1f
			bottomOverlayProgress?.alpha = if (show) 1.0f else 0.1f
			bottomOverlayChatText?.visibility = if (show) View.INVISIBLE else View.VISIBLE
			bottomOverlayChatText?.scaleX = if (show) 0.1f else 1.0f
			bottomOverlayChatText?.scaleY = if (show) 0.1f else 1.0f
			bottomOverlayChatText?.alpha = if (show) 0.0f else 1.0f
		}
	}

	private fun sendBotInlineResult(result: BotInlineResult, notify: Boolean, scheduleDate: Int) {
		val mentionContainer = mentionContainer ?: return
		val uid = mentionContainer.adapter.contextBotId

		val params = HashMap<String, String>()
		params["id"] = result.id
		params["query_id"] = "" + result.query_id
		params["bot"] = "" + uid
		params["bot_name"] = mentionContainer.adapter.contextBotName

		prepareSendingBotContextResult(this, accountInstance, result, params, dialogId, replyMessage, threadMessage, notify, scheduleDate)

		chatActivityEnterView?.fieldText = ""

		hideFieldPanel(false)

		mediaDataController.increaseInlineRating(uid)
	}

	private fun checkBotCommands() {
		URLSpanBotCommand.enabled = false

		val currentChatInfo = currentChatInfo

		if (currentUser?.bot == true) {
			URLSpanBotCommand.enabled = !isReplyUser(currentUser)
		}
		else if (currentChatInfo is TL_chatFull) {
			for (a in currentChatInfo.participants.participants.indices) {
				val participant = currentChatInfo.participants.participants[a]
				val user = messagesController.getUser(participant.user_id)

				if (user != null && user.bot) {
					URLSpanBotCommand.enabled = true
					break
				}
			}
		}
		else if (currentChatInfo is TL_channelFull) {
			URLSpanBotCommand.enabled = !currentChatInfo.bot_info.isNullOrEmpty() && currentChat?.megagroup == true
		}
	}

	private fun getValidGroupedMessage(message: MessageObject?): GroupedMessages? {
		if (message == null) {
			return null
		}

		var groupedMessages: GroupedMessages? = null

		if (message.groupId != 0L) {
			groupedMessages = groupedMessagesMap[message.groupId]

			if (groupedMessages != null && (groupedMessages.messages.size <= 1 || groupedMessages.positions[message] == null)) {
				groupedMessages = null
			}
		}

		return groupedMessages
	}

	fun jumpToDate(date: Int) {
		if (messages.isEmpty()) {
			return
		}

		val firstMessage = messages[0]
		val lastMessage = messages[messages.size - 1]

		if (firstMessage.messageOwner!!.date >= date && lastMessage.messageOwner!!.date <= date || lastMessage.messageOwner!!.date >= date && endReached[0]) {
			for (a in messages.indices.reversed()) {
				val message = messages[a]

				if (message.messageOwner!!.date >= date && message.id != 0) {
					scrollToMessageId(message.id, 0, false, if (message.dialogId == mergeDialogId) 1 else 0, true, 0)
					break
				}
			}
		}
		else if (!DialogObject.isEncryptedDialog(dialogId)) {
			var scrollDirection = RecyclerAnimationScrollHelper.SCROLL_DIRECTION_UNSET
			val end = chatLayoutManager!!.findLastVisibleItemPosition()

			for (i in chatLayoutManager!!.findFirstVisibleItemPosition()..end) {
				if (i >= chatAdapter!!.messagesStartRow && i < chatAdapter!!.messagesEndRow) {
					val message = messages[i - chatAdapter!!.messagesStartRow].messageOwner

					if (message != null) {
						var scrollDown = message.date < date

						if (isSecretChat) {
							scrollDown = !scrollDown
						}

						scrollDirection = if (scrollDown) RecyclerAnimationScrollHelper.SCROLL_DIRECTION_DOWN else RecyclerAnimationScrollHelper.SCROLL_DIRECTION_UP

						break
					}
				}
			}

			chatScrollHelper?.scrollDirection = scrollDirection

			progressDialog?.dismiss()

			updatePinnedListButton(false)

			progressDialog = AlertDialog(parentActivity!!, 3)
			progressDialog?.setOnCancelListener(postponedScrollCancelListener)
			progressDialog?.showDelayed(1000)

			postponedScrollToLastMessageQueryIndex = lastLoadIndex

			waitingForLoad.add(lastLoadIndex)

			postponedScrollMessageId = 0

			postponedScrollIsCanceled = false

			messagesController.loadMessages(dialogId, mergeDialogId, false, 30, 0, date, true, 0, classGuid, 4, 0, chatMode, threadId, replyMaxReadId, lastLoadIndex++)

			floatingDateView?.alpha = 0.0f
			floatingDateView?.tag = null
		}
	}

	fun processInlineBotContextPM(`object`: TL_inlineBotSwitchPM?) {
		if (`object` == null || mentionContainer == null) {
			return
		}

		val user = mentionContainer?.adapter?.contextBotUser ?: return

		chatActivityEnterView?.fieldText = ""

		if (dialogId == user.id) {
			inlineReturn = dialogId
			messagesController.sendBotStart(currentUser, `object`.start_param)
		}
		else {
			val args = Bundle()
			args.putLong("user_id", user.id)
			args.putString("inline_query", `object`.start_param)
			args.putLong("inline_return", dialogId)

			if (!messagesController.checkCanOpenChat(args, this@ChatActivity)) {
				return
			}

			presentFragment(ChatActivity(args))
		}
	}

	private fun createChatAttachView() {
		if (chatAttachAlert == null) {
			chatAttachAlert = object : ChatAttachAlert(parentActivity!!, this@ChatActivity, false, false) {
				override fun dismissInternal() {
					if (chatAttachAlert?.isShowing == true) {
						AndroidUtilities.requestAdjustResize(parentActivity, classGuid)
					}

					super.dismissInternal()

					onEditTextDialogClose(resetAdjust = false, reset = true)
				}

				override fun onDismissAnimationStart() {
					chatAttachAlert?.isFocusable = false

					chatActivityEnterView?.editField?.requestFocus()

					if (chatAttachAlert?.isShowing == true) {
						AndroidUtilities.requestAdjustResize(parentActivity, classGuid)
					}

					onEditTextDialogClose(resetAdjust = false, reset = false)
				}
			}

			chatAttachAlert?.setDelegate(object : ChatAttachViewDelegate {
				override fun openAvatarsSearch() {
					// unused
				}

				override fun didPressedButton(button: Int, arg: Boolean, notify: Boolean, scheduleDate: Int, forceDocument: Boolean) {
					if (parentActivity == null || chatAttachAlert == null) {
						return
					}

					editingMessageObject = chatAttachAlert?.editingMessageObject

					if (button == 8 || button == 7 || button == 4 && !chatAttachAlert?.photoLayout?.selectedPhotos.isNullOrEmpty()) {
						if (button != 8) {
							chatAttachAlert?.dismiss(true)
						}

						val selectedPhotos = chatAttachAlert?.photoLayout?.selectedPhotos

						if (!selectedPhotos.isNullOrEmpty()) {
							val selectedPhotosOrder = chatAttachAlert!!.photoLayout.selectedPhotosOrder
							var i = 0

							while (i < ceil((selectedPhotos.size / 10f).toDouble())) {
								val count = min(10, selectedPhotos.size - i * 10)
								val photos = mutableListOf<SendingMediaInfo>()

								for (a in 0 until count) {
									if (i * 10 + a >= selectedPhotosOrder.size) {
										continue
									}

									val photoEntry = selectedPhotos[selectedPhotosOrder[i * 10 + a]] as PhotoEntry?
									val info = SendingMediaInfo()

									if (!photoEntry!!.isVideo && photoEntry.imagePath != null) {
										info.path = photoEntry.imagePath
									}
									else if (photoEntry.path != null) {
										info.path = photoEntry.path
									}

									info.thumbPath = photoEntry.thumbPath
									info.isVideo = photoEntry.isVideo
									info.caption = photoEntry.caption?.toString()
									info.entities = photoEntry.entities
									info.masks = photoEntry.stickers
									info.ttl = photoEntry.ttl
									info.videoEditedInfo = photoEntry.editedInfo
									info.canDeleteAfter = photoEntry.canDeleteAfter
									info.updateStickersOrder = checkUpdateStickersOrder(photoEntry.caption)

									photos.add(info)

									photoEntry.reset()
								}

								var updateStickersOrder = false

								if (i == 0) {
									fillEditingMediaWithCaption(photos[0].caption, photos[0].entities)
									updateStickersOrder = photos[0].updateStickersOrder
								}

								prepareSendingMedia(accountInstance, photos, dialogId, replyMessage, threadMessage, null, button == 4 || forceDocument, arg, editingMessageObject, notify, scheduleDate, updateStickersOrder, false, null)

								++i
							}

							afterMessageSend()

							chatActivityEnterView?.fieldText = ""
						}

						if (scheduleDate != 0) {
							if (scheduledMessagesCount == -1) {
								scheduledMessagesCount = 0
							}

							scheduledMessagesCount += selectedPhotos?.size ?: 0

							updateScheduledInterface(true)
						}

						return
					}
					else {
						chatAttachAlert?.dismissWithButtonClick(button)
					}

					processSelectedAttach(button)
				}

				override val revealView: View?
					get() = chatActivityEnterView?.attachButton

				override fun didSelectBot(user: User?) {
					if (chatActivityEnterView == null || user == null || TextUtils.isEmpty(user.username)) {
						return
					}

					chatActivityEnterView?.fieldText = "@" + user.username + " "
					chatActivityEnterView?.openKeyboard()
				}

				override fun onCameraOpened() {
					chatActivityEnterView?.closeKeyboard()
				}

				override fun needEnterComment(): Boolean {
					return needEnterText()
				}

				override fun doOnIdle(runnable: Runnable) {
					this@ChatActivity.doOnIdle(runnable)
				}
			})
		}
	}

	fun needEnterText(): Boolean {
		val keyboardVisible = chatActivityEnterView?.isKeyboardVisible ?: false

		if (keyboardVisible) {
			chatActivityEnterView?.showEmojiView()
			openKeyboardOnAttachMenuClose = true
		}

		AndroidUtilities.setAdjustResizeToNothing(parentActivity, classGuid)

		fragmentView?.requestLayout()

		return keyboardVisible
	}

	fun onEditTextDialogClose(resetAdjust: Boolean, reset: Boolean) {
		if (openKeyboardOnAttachMenuClose) {
			AndroidUtilities.runOnUIThread({
				chatActivityEnterView?.openKeyboard()
			}, 50)

			if (reset) {
				openKeyboardOnAttachMenuClose = false
			}
		}

		if (resetAdjust) {
			AndroidUtilities.requestAdjustResize(parentActivity, classGuid)
		}
	}

	fun doOnIdle(runnable: Runnable?) {
		if (runnable != null) {
			notificationCenter.doOnIdle(runnable)
		}
	}

	var onItemLongClickListener = object : OnItemLongClickListenerExtended {
		override fun onMove(dx: Float, dy: Float) {
			// unused
		}

		override fun onLongClickRelease() {
			// unused
		}

		override fun onItemClick(view: View, position: Int, x: Float, y: Float): Boolean {
			if (textSelectionHelper.isTryingSelect || textSelectionHelper.isSelectionMode || inPreviewMode) {
				return false
			}

			wasManualScroll = true

			var result = true

			if (!actionBar!!.isActionModeShowed && (reportType < 0 || view is ChatActionCell && view.messageObject?.messageOwner?.action is TL_messageActionSetMessagesTTL)) {
				result = createMenu(view, single = false, listView = true, x = x, y = y)
			}
			else {
				var outside = false

				if (view is ChatMessageCell) {
					outside = !view.isInsideBackground(x, y)
				}

				processRowSelect(view, outside, x, y)
			}

			if (view is ChatMessageCell) {
				startMultiselect(position)
				result = true
			}

			return result
		}
	}

	fun performHistoryClear(revoke: Boolean) {
		clearingHistory = true

		undoView?.showWithAction(dialogId, UndoView.ACTION_CLEAR, {
			if (pinnedMessageIds.isNotEmpty()) {
				val preferences = MessagesController.getNotificationsSettings(currentAccount)
				preferences.edit().putInt("pin_$dialogId", pinnedMessageIds[0]).commit()

				pinnedMessageIds.clear()
				pinnedMessageObjects.clear()
				currentPinnedMessageId = 0
				loadedPinnedMessagesCount = 0
				totalPinnedMessagesCount = 0

				updatePinnedMessageView(true)
			}

			messagesController.deleteDialog(dialogId, 1, revoke)

			clearingHistory = false

			clearHistory(false, null)

			chatAdapter?.notifyDataSetChanged()
		}) {
			clearingHistory = false
			chatAdapter?.notifyDataSetChanged()
		}

		chatAdapter?.notifyDataSetChanged()
	}

	fun openedWithLivestream(): Boolean {
		return livestream
	}

	fun hasReportSpam(): Boolean {
		return topChatPanelView != null && topChatPanelView?.tag == null && reportSpamButton?.visibility != View.GONE
	}

	val isReport: Boolean
		get() = reportType >= 0

	fun setChatInvite(invite: ChatInvite?) {
		chatInvite = invite
	}

	fun setBotUser(value: String?) {
		if (inlineReturn != 0L) {
			messagesController.sendBotStart(currentUser, value)
		}
		else {
			botUser = value
			updateBottomOverlay()
		}
	}

	private fun afterMessageSend() {
		hideFieldPanel(false)

		if (chatMode == 0) {
			mediaDataController.cleanDraft(dialogId, threadId, true)
		}
	}

	private fun toggleMessagesSearchListView() {
		if (messagesSearchListView != null) {
			showMessagesSearchListView(messagesSearchListView!!.tag == null)
		}
	}

	private fun showMessagesSearchListView(show: Boolean) {
		if (messagesSearchListView == null || show && messagesSearchListView?.tag != null || !show && messagesSearchListView?.tag == null) {
			return
		}

		messagesSearchListViewAnimation?.cancel()
		messagesSearchListViewAnimation = null

		if (show) {
			messagesSearchListView?.visible()
		}

		messagesSearchListView?.tag = if (show) 1 else null

		messagesSearchListViewAnimation = AnimatorSet()
		messagesSearchListViewAnimation?.playTogether(ObjectAnimator.ofFloat(messagesSearchListView, View.ALPHA, if (show) 1.0f else 0.0f))
		messagesSearchListViewAnimation?.interpolator = CubicBezierInterpolator.EASE_IN
		messagesSearchListViewAnimation?.duration = 180

		messagesSearchListViewAnimation?.addListener(object : AnimatorListenerAdapter() {
			override fun onAnimationEnd(animation: Animator) {
				if (animation == messagesSearchListViewAnimation) {
					messagesSearchListViewAnimation = null

					if (!show) {
						messagesSearchListView?.gone()
					}
				}
			}

			override fun onAnimationCancel(animation: Animator) {
				if (animation == messagesSearchListViewAnimation) {
					messagesSearchListViewAnimation = null
				}
			}
		})

		messagesSearchListViewAnimation?.start()
	}

	fun playFirstUnreadVoiceMessage(): Boolean {
		if (chatActivityEnterView?.isRecordingAudioVideo() == true) {
			return true
		}

		for (a in messages.indices.reversed()) {
			val messageObject = messages[a]

			if ((messageObject.isVoice || messageObject.isRoundVideo) && messageObject.isContentUnread && !messageObject.isOut) {
				MediaController.getInstance().setVoiceMessagesPlaylist(if (MediaController.getInstance().playMessage(messageObject)) createVoiceMessagesPlaylist(messageObject, true) else null, true)
				return true
			}
		}

		if (parentActivity?.checkSelfPermission(Manifest.permission.RECORD_AUDIO) != PackageManager.PERMISSION_GRANTED) {
			parentActivity?.requestPermissions(arrayOf(Manifest.permission.RECORD_AUDIO), 3)
			return true
		}

		return false
	}

	private fun openScheduledMessages() {
		if (parentLayout == null || parentLayout?.lastFragment !== this) {
			return
		}

		val bundle = Bundle()

		if (currentEncryptedChat != null) {
			bundle.putInt("enc_id", currentEncryptedChat!!.id)
		}
		else if (currentChat != null) {
			bundle.putLong("chat_id", currentChat!!.id)
		}
		else {
			bundle.putLong("user_id", currentUser!!.id)
		}

		bundle.putInt("chatMode", MODE_SCHEDULED)

		val fragment = ChatActivity(bundle)

		fragment.chatActivityDelegate = object : ChatActivityDelegate {
			override fun openReplyMessage(mid: Int) {
				scrollToMessageId(mid, 0, true, 0, true, 0)
			}

			override fun openSearch(text: String?) {
				openSearchWithText(text)
			}
		}

		presentFragment(fragment, false)
	}

	fun shareMyContact(type: Int, messageObject: MessageObject?) {
//		AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
//		builder.setTitle(getContext().getString(R.string.ShareYouPhoneNumberTitle));
//		if (currentUser != null) {
//			if (currentUser.bot) {
//				builder.setMessage(getContext().getString(R.string.AreYouSureShareMyContactInfoBot));
//			}
//			else {
//				builder.setMessage(AndroidUtilities.replaceTags(LocaleController.formatString("AreYouSureShareMyContactInfoUser", R.string.AreYouSureShareMyContactInfoUser, PhoneFormat.getInstance().format("+" + getUserConfig().getCurrentUser().phone), ContactsController.formatName(currentUser.first_name, currentUser.last_name))));
//			}
//		}
//		else {
//			builder.setMessage(getContext().getString(R.string.AreYouSureShareMyContactInfo));
//		}
//		builder.setPositiveButton(getContext().getString(R.string.ShareContact), (dialogInterface, i) -> {
//			if (type == 1) {
//				TLRPC.TL_contacts_acceptContact req = new TLRPC.TL_contacts_acceptContact();
//				req.id = getMessagesController().getInputUser(currentUser);
//				getConnectionsManager().sendRequest(req, (response, error) -> {
//					if (error != null) {
//						return;
//					}
//					getMessagesController().processUpdates((TLRPC.Updates)response, false);
//				});
//			}
//			else {
//				SendMessagesHelper.getInstance(currentAccount).sendMessage(getUserConfig().getCurrentUser(), dialog_id, messageObject, getThreadMessage(), null, null, true, 0);
//				if (chatMode == 0) {
//					moveScrollToLastMessage(false);
//				}
//				hideFieldPanel(false);
//			}
//		});
//		builder.setNegativeButton(getContext().getString(R.string.Cancel), null);
//		showDialog(builder.create());
	}

	private fun showVoiceHint(hide: Boolean, video: Boolean) {
		val context = context ?: return

		if (parentActivity == null || fragmentView == null || hide && voiceHintTextView == null || chatMode != 0 || chatActivityEnterView == null || chatActivityEnterView?.getAudioVideoButtonContainer() == null || chatActivityEnterView?.getAudioVideoButtonContainer()?.visibility != View.VISIBLE) {
			return
		}

		if (currentUser?.id == 333000L || currentUser?.id == 777000L || currentUser?.id == 42777L) {
			return
		}

		if (voiceHintTextView == null) {
			val frameLayout = fragmentView as SizeNotifierFrameLayout
			val index = frameLayout.indexOfChild(chatActivityEnterView)

			if (index == -1) {
				return
			}

			voiceHintTextView = HintView(parentActivity, 9)

			frameLayout.addView(voiceHintTextView, index + 1, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.LEFT or Gravity.TOP, 10f, 0f, 10f, 0f))
		}

		if (hide) {
			voiceHintTextView?.hide()
			return
		}

		if (chatActivityEnterView?.hasRecordVideo() == true) {
			voiceHintTextView?.setText(if (video) context.getString(R.string.HoldToVideo) else context.getString(R.string.HoldToAudio))
		}
		else {
			voiceHintTextView?.setText(context.getString(R.string.HoldToAudioOnly))
		}

		voiceHintTextView?.showForView(chatActivityEnterView?.getAudioVideoButtonContainer(), true)
	}

	fun checkSlowMode(view: View?): Boolean {
		val time = chatActivityEnterView?.getSlowModeTimer()

		if (time != null) {
			showSlowModeHint(view, true, time)
			return true
		}

		return false
	}

	private fun hideHints(scroll: Boolean) {
		if (!scroll) {
			slowModeHint?.hide()
			searchAsListHint?.hide()
			scheduledOrNoSoundHint?.hide()
		}

		fwdRestrictedBottomHint?.hide()
		fwdRestrictedTopHint?.hide()
		noSoundHintView?.hide()
		forwardHintView?.hide()
		pollHintView?.hide()
		timerHintView?.hide()
		checksHintView?.hide()
	}

	private fun showSlowModeHint(view: View?, show: Boolean, time: CharSequence?) {
		if (parentActivity == null || fragmentView == null || !show && (slowModeHint == null || slowModeHint?.visibility != View.VISIBLE)) {
			return
		}

		slowModeHint?.setText(AndroidUtilities.replaceTags(LocaleController.formatString("SlowModeHint", R.string.SlowModeHint, time)))

		if (show) {
			slowModeHint?.showForView(view, true)
		}
	}

	fun showTimerHint() {
		if (parentActivity == null || fragmentView == null || currentChatInfo == null) {
			return
		}

		if (timerHintView == null) {
			timerHintView = HintView(parentActivity, 7, true)
			timerHintView?.alpha = 0.0f
			timerHintView?.visibility = View.INVISIBLE
			timerHintView?.setShowingDuration(4000)

			contentView?.addView(timerHintView, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.LEFT or Gravity.TOP, 19f, 0f, 19f, 0f))
		}

		val time = if (currentChatInfo!!.ttl_period > 24 * 60 * 60) {
			LocaleController.formatPluralString("Days", currentChatInfo!!.ttl_period / (24 * 60 * 60))
		}
		else if (currentChatInfo!!.ttl_period >= 60 * 60) {
			LocaleController.formatPluralString("Hours", currentChatInfo!!.ttl_period / (60 * 60))
		}
		else if (currentChatInfo!!.ttl_period >= 60) {
			LocaleController.formatPluralString("Minutes", currentChatInfo!!.ttl_period / 60)
		}
		else {
			LocaleController.formatPluralString("Seconds", currentChatInfo!!.ttl_period)
		}

		timerHintView?.setText(LocaleController.formatString("AutoDeleteSetInfo", R.string.AutoDeleteSetInfo, time))
		timerHintView?.showForView(avatarContainer!!.timeItem, true)
	}

	private fun showSearchAsListHint() {
		if (parentActivity == null || fragmentView == null || searchCountText == null) {
			return
		}

		if (searchAsListHint == null) {
			searchAsListHint = HintView(parentActivity, HintView.TYPE_SEARCH_AS_LIST)
			searchAsListHint?.alpha = 0.0f
			searchAsListHint?.invisible()
			searchAsListHint?.setText(context!!.getString(R.string.TapToViewAsList))

			contentView?.addView(searchAsListHint, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.LEFT or Gravity.TOP, 19f, 0f, 19f, 0f))
		}

		searchAsListHint?.showForView(searchCountText, true)
	}

	private fun showScheduledOrNoSoundHint() {
		val disableNoSound = isUserSelf(currentUser) || currentChatInfo != null && currentChatInfo!!.slowmode_next_send_date > 0 && chatMode == 0

		if (SharedConfig.scheduledOrNoSoundHintShows >= 3 || System.currentTimeMillis() % 4 != 0L || disableNoSound) {
			return
		}

		AndroidUtilities.cancelRunOnUIThread(showScheduledOrNoSoundRunnable)
		AndroidUtilities.runOnUIThread(showScheduledOrNoSoundRunnable, 200)
	}

	private fun showMediaBannedHint() {
		if (parentActivity == null || currentChat == null && currentUserInfo == null || fragmentView == null || mediaBanTooltip != null && mediaBanTooltip!!.visibility == View.VISIBLE) {
			return
		}

		val frameLayout = fragmentView as SizeNotifierFrameLayout
		val index = frameLayout.indexOfChild(chatActivityEnterView)

		if (index == -1) {
			return
		}

		try {
			fragmentView?.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP, HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING)
		}
		catch (e: Exception) {
			FileLog.e(e)
		}

		if (mediaBanTooltip == null) {
			mediaBanTooltip = HintView(parentActivity, 9)
			mediaBanTooltip?.gone()

			frameLayout.addView(mediaBanTooltip, index + 1, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.LEFT or Gravity.TOP, 10f, 0f, 10f, 0f))
		}

		if (currentUserInfo != null && currentUserInfo!!.voice_messages_forbidden) {
			mediaBanTooltip?.setText(AndroidUtilities.replaceTags(LocaleController.formatString(if (chatActivityEnterView!!.isInVideoMode) R.string.VideoMessagesRestrictedByPrivacy else R.string.VoiceMessagesRestrictedByPrivacy, currentUser!!.first_name)))
		}
		else if (isActionBannedByDefault(currentChat, ChatObject.ACTION_SEND_MEDIA)) {
			mediaBanTooltip?.setText(context!!.getString(R.string.GlobalAttachMediaRestricted))
		}
		else {
			if (currentChat?.banned_rights == null) {
				return
			}

			if (AndroidUtilities.isBannedForever(currentChat!!.banned_rights)) {
				mediaBanTooltip?.setText(context!!.getString(R.string.AttachMediaRestrictedForever))
			}
			else {
				mediaBanTooltip?.setText(LocaleController.formatString("AttachMediaRestricted", R.string.AttachMediaRestricted, LocaleController.formatDateForBan(currentChat!!.banned_rights.until_date.toLong())))
			}
		}

		val sendBtn = chatActivityEnterView!!.getSendButton()
		val audioVideoBtn = chatActivityEnterView!!.getAudioVideoButtonContainer()
		var viewForTooltip = sendBtn

		if (sendBtn.alpha < audioVideoBtn.alpha) {
			viewForTooltip = audioVideoBtn
		}

		mediaBanTooltip?.showForView(viewForTooltip, true)
	}

	private fun showNoSoundHint() {
		if (scrollingChatListView || SharedConfig.noSoundHintShowed || chatListView == null || parentActivity == null || fragmentView == null || noSoundHintView?.tag != null) {
			return
		}

		if (noSoundHintView == null) {
			val frameLayout = fragmentView as SizeNotifierFrameLayout
			val index = frameLayout.indexOfChild(chatActivityEnterView)

			if (index == -1) {
				return
			}

			noSoundHintView = HintView(parentActivity, 0)
			noSoundHintView?.setShowingDuration(10000)

			frameLayout.addView(noSoundHintView, index + 1, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.LEFT or Gravity.TOP, 19f, 0f, 19f, 0f))

			noSoundHintView?.alpha = 0.0f
			noSoundHintView?.invisible()
		}

		val count = chatListView?.childCount ?: 0

		for (a in 0 until count) {
			val child = chatListView!!.getChildAt(a) as? ChatMessageCell ?: continue
			val messageObject = child.getMessageObject()

			if (messageObject == null || !messageObject.isVideo) {
				continue
			}

			val imageReceiver = child.photoImage
			val animation = imageReceiver.animation

			if (animation == null || animation.currentProgressMs < 3000) {
				continue
			}

			if (noSoundHintView?.showForMessageCell(child, true) == true) {
				SharedConfig.setNoSoundHintShowed(true)
				break
			}
		}
	}

	private fun checkChecksHint() {
		if (messagesController.pendingSuggestions?.contains("NEWCOMER_TICKS") == true) {
			AndroidUtilities.runOnUIThread({
				showChecksHint()
			}, 1000)
		}
	}

	private fun showChecksHint() {
		if (scrollingChatListView || chatListView == null || parentActivity == null || fragmentView == null || checksHintView != null && checksHintView!!.tag != null) {
			return
		}

		if (checksHintView == null) {
			val frameLayout = fragmentView as SizeNotifierFrameLayout
			val index = frameLayout.indexOfChild(chatActivityEnterView)

			if (index == -1) {
				return
			}

			checksHintView = ChecksHintView(parentActivity, null)

			frameLayout.addView(checksHintView, index + 1, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.LEFT or Gravity.TOP, 10f, 0f, 10f, 0f))

			checksHintView?.alpha = 0.0f
			checksHintView?.visibility = View.INVISIBLE
		}

		val count = chatListView?.childCount ?: 0

		for (a in 0 until count) {
			val child = chatListView!!.getChildAt(a) as? ChatMessageCell ?: continue
			val messageObject = child.getMessageObject()

			if (messageObject == null || !messageObject.isOutOwner || !messageObject.isSent) {
				continue
			}

			if (checksHintView?.showForMessageCell(child, true) == true) {
				messagesController.removeSuggestion(0, "NEWCOMER_TICKS")
				break
			}
		}
	}

	private fun showForwardHint(cell: ChatMessageCell) {
		if (scrollingChatListView || chatListView == null || parentActivity == null || fragmentView == null) {
			return
		}

		if (forwardHintView == null) {
			val frameLayout = fragmentView as SizeNotifierFrameLayout
			val index = frameLayout.indexOfChild(chatActivityEnterView)

			if (index == -1) {
				return
			}

			forwardHintView = HintView(parentActivity, 1)

			frameLayout.addView(forwardHintView, index + 1, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.LEFT or Gravity.TOP, 19f, 0f, 19f, 0f))

			forwardHintView?.alpha = 0.0f
			forwardHintView?.invisible()
		}

		forwardHintView?.showForMessageCell(cell, true)
	}

	private fun showTextSelectionHint(messageObject: MessageObject?) {
		if (parentActivity == null || messagesController.isChatNoForwards(messageObject?.chatId) || messageObject?.messageOwner?.noforwards != true) {
			return
		}

		val text: CharSequence?
		var canShowText = false

		if (messageObject.textLayoutBlocks != null && messageObject.textLayoutBlocks!!.isNotEmpty()) {
			text = messageObject.messageText

			if (messageObject.textLayoutBlocks!!.size > 1) {
				canShowText = true
			}
		}
		else {
			text = messageObject.caption
		}

		if (!canShowText && text != null) {
			canShowText = text.length > 200
		}

		if (!canShowText || SharedConfig.textSelectionHintShows > 2 || textSelectionHintWasShowed || lastTouchY > chatActivityEnterView!!.top - AndroidUtilities.dp(60f)) {
			return
		}

		textSelectionHintWasShowed = true

		SharedConfig.increaseTextSelectionHintShowed()

		if (textSelectionHint == null) {
			textSelectionHint = object : TextSelectionHint(parentActivity, null) {
				override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
					super.onMeasure(widthMeasureSpec, heightMeasureSpec)
					updatePosition()
				}

				override fun onDraw(canvas: Canvas) {
					super.onDraw(canvas)
					updatePosition()
				}

				fun updatePosition() {
					val start = -(measuredHeight + AndroidUtilities.dp(16f))
					val end = chatActivityEnterView!!.top - contentView!!.measuredHeight
					translationY = end - (end + start) * (1f - prepareProgress)
				}
			}

			contentView?.addView(textSelectionHint, createFrame(LayoutHelper.WRAP_CONTENT, 56f, Gravity.BOTTOM or Gravity.LEFT, 8f, 0f, 8f, 8f))
		}

		textSelectionHint?.show()
	}

	fun showEmojiHint(): Boolean {
		if (chatActivityEnterView?.visibility != View.VISIBLE) {
			return false
		}

		val preferences = MessagesController.getGlobalMainSettings()
		var moreemojihint: Int

		if (preferences.getInt("moreemojihint", 0).also { moreemojihint = it } > 3 && UserConfig.getInstance(currentAccount).isPremium) {
			return false
		}

		if (UserConfig.getInstance(currentAccount).isPremium) {
			preferences.edit().putInt("moreemojihint", moreemojihint + 1).commit()
		}

		val context = context ?: return false

		if (parentActivity == null || fragmentView == null || emojiHintTextView != null) {
			return false
		}

		if (!allowContextBotPanelSecond) {
			chatActivityEnterView?.setOpenGifsTabFirst()
			return false
		}

		val frameLayout = fragmentView as SizeNotifierFrameLayout
		val index = frameLayout.indexOfChild(chatActivityEnterView)

		if (index == -1) {
			return false
		}

		chatActivityEnterView?.setOpenGifsTabFirst()

		emojiHintTextView = HintView(parentActivity, 9)

		val emojiPlaceholder = "<<EMOJI>>"
		val textString = LocaleController.formatString("TapHereEmoji", R.string.TapHereEmoji, emojiPlaceholder)
		val text = SpannableStringBuilder(textString)
		val i = textString.indexOf(emojiPlaceholder)

		if (i >= 0) {
			val emoji = SpannableString("x")

			val emojiDrawable = ResourcesCompat.getDrawable(context.resources, R.drawable.smiles_tab_smiles, null)?.mutate()
			emojiDrawable?.setBounds(0, 0, AndroidUtilities.dp(20f), AndroidUtilities.dp(20f))
			emojiDrawable?.colorFilter = PorterDuffColorFilter(context.getColor(R.color.hint), PorterDuff.Mode.MULTIPLY)

			emoji.setSpan(ImageSpan(emojiDrawable!!, ImageSpan.ALIGN_BOTTOM), 0, emoji.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

			text.replace(i, i + emojiPlaceholder.length, emoji)

			emojiHintTextView?.textView?.setPadding(AndroidUtilities.dp(8f), AndroidUtilities.dp(0f), AndroidUtilities.dp(8f), AndroidUtilities.dp(6f))
		}

		emojiHintTextView?.setText(text)


		frameLayout.addView(emojiHintTextView, index + 1, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.LEFT or Gravity.BOTTOM, 5f, 0f, 5f, 3f))

		val animatorSet = AnimatorSet()
		animatorSet.playTogether(ObjectAnimator.ofFloat(emojiHintTextView, View.ALPHA, 0.0f, 1.0f))

		animatorSet.addListener(object : AnimatorListenerAdapter() {
			override fun onAnimationEnd(animation: Animator) {
				AndroidUtilities.runOnUIThread({
					if (emojiHintTextView == null) {
						return@runOnUIThread
					}

					val animatorSet1 = AnimatorSet()
					animatorSet1.playTogether(ObjectAnimator.ofFloat(emojiHintTextView, View.ALPHA, 0.0f))

					animatorSet1.addListener(object : AnimatorListenerAdapter() {
						override fun onAnimationEnd(animation: Animator) {
							if (emojiHintTextView != null) {
								emojiHintTextView?.gone()
								frameLayout.removeView(emojiHintTextView)
								emojiHintTextView = null
							}
						}
					})

					animatorSet1.duration = 300
					animatorSet1.start()
				}, 2000)
			}
		})

		animatorSet.duration = 300
		animatorSet.start()

		val emojiButton = chatActivityEnterView?.getEmojiButton()

		emojiHintTextView?.showForView(emojiButton, true)

		return true
	}

	private fun showGifHint(): Boolean {
		if (chatActivityEnterView?.visibility != View.VISIBLE) {
			return false
		}

		val preferences = MessagesController.getGlobalMainSettings()

		if (preferences.getBoolean("gifhint", false)) {
			return false
		}

		preferences.edit().putBoolean("gifhint", true).commit()

		if (parentActivity == null || fragmentView == null || gifHintTextView != null) {
			return false
		}

		if (!allowContextBotPanelSecond) {
			chatActivityEnterView?.setOpenGifsTabFirst()
			return false
		}

		val frameLayout = fragmentView as SizeNotifierFrameLayout
		val index = frameLayout.indexOfChild(chatActivityEnterView)

		if (index == -1) {
			return false
		}

		chatActivityEnterView?.setOpenGifsTabFirst()

		emojiButtonRed = View(parentActivity)
		emojiButtonRed?.setBackgroundResource(R.drawable.redcircle)

		frameLayout.addView(emojiButtonRed, index + 1, createFrame(10, 10f, Gravity.BOTTOM or Gravity.LEFT, 30f, 0f, 0f, 27f))

		gifHintTextView = HintView(parentActivity, 9)
		gifHintTextView?.setText(context!!.getString(R.string.TapHereGifs))

		frameLayout.addView(gifHintTextView, index + 1, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.LEFT or Gravity.BOTTOM, 5f, 0f, 5f, 3f))

		val animatorSet = AnimatorSet()
		animatorSet.playTogether(ObjectAnimator.ofFloat(gifHintTextView, View.ALPHA, 0.0f, 1.0f), ObjectAnimator.ofFloat(emojiButtonRed, View.ALPHA, 0.0f, 1.0f))

		animatorSet.addListener(object : AnimatorListenerAdapter() {
			override fun onAnimationEnd(animation: Animator) {
				AndroidUtilities.runOnUIThread({
					if (gifHintTextView == null) {
						return@runOnUIThread
					}

					val animatorSet1 = AnimatorSet()
					animatorSet1.playTogether(ObjectAnimator.ofFloat(gifHintTextView, View.ALPHA, 0.0f))

					animatorSet1.addListener(object : AnimatorListenerAdapter() {
						override fun onAnimationEnd(animation: Animator) {
							gifHintTextView?.gone()
						}
					})

					animatorSet1.duration = 300
					animatorSet1.start()
				}, 2000)
			}
		})

		animatorSet.duration = 300
		animatorSet.start()

		val emojiButton = chatActivityEnterView?.getEmojiButton()

		gifHintTextView?.showForView(emojiButton, true)

		return true
	}

	private fun openAttachMenu() {
		if (parentActivity == null || !chatActivityEnterView?.getSlowModeTimer().isNullOrEmpty()) {
			return
		}

		createChatAttachView()

		chatAttachAlert?.photoLayout?.loadGalleryPhotos()

		if (currentChat != null && !hasAdminRights(currentChat) && currentChat!!.slowmode_enabled) {
			chatAttachAlert?.setMaxSelectedPhotos(10, true)
		}
		else {
			chatAttachAlert?.setMaxSelectedPhotos(-1, true)
		}

		chatAttachAlert?.init()
		chatAttachAlert?.commentTextView?.text = chatActivityEnterView?.fieldText

		showDialog(chatAttachAlert)
	}

	private fun checkAutoDownloadMessages(scrollUp: Boolean) {
		val chatListView = chatListView ?: return
		val count = chatListView.childCount
		var firstMessagePosition = -1
		var lastMessagePosition = -1

		for (a in 0 until count) {
			val child = chatListView.getChildAt(a) as? ChatMessageCell ?: continue
			val holder = chatListView.findContainingViewHolder(child)

			if (holder != null) {
				val p = holder.adapterPosition

				if (firstMessagePosition == -1) {
					firstMessagePosition = p
				}

				lastMessagePosition = p
			}

			val `object` = child.getMessageObject()

			if (`object` == null || `object`.mediaExists || !`object`.isSent || `object`.loadingCancelled) {
				continue
			}

			val document = `object`.document ?: continue
			var canDownload = -1

			if (!MessageObject.isStickerDocument(document) && !MessageObject.isAnimatedStickerDocument(document, true) && !MessageObject.isGifDocument(document) && !MessageObject.isRoundVideoDocument(document) && downloadController.canDownloadMedia(`object`.messageOwner).also { canDownload = it } != 0) {
				if (canDownload == 2) {
					if (currentEncryptedChat == null && !`object`.shouldEncryptPhotoOrVideo() && `object`.canStreamVideo()) {
						fileLoader.loadFile(document, `object`, 0, 10)
					}
				}
				else {
					val cacheType = if (`object`.isWallpaper || `object`.isTheme) {
						1
					}
					else if (MessageObject.isVideoDocument(document) && `object`.shouldEncryptPhotoOrVideo()) {
						2
					}
					else {
						0
					}

					fileLoader.loadFile(document, `object`, 0, cacheType)

					child.updateButtonState(ifSame = false, animated = true, fromSet = false)
				}
			}
		}

		if (firstMessagePosition != -1) {
			val lastPosition: Int

			if (scrollUp) {
				lastPosition = lastMessagePosition
				firstMessagePosition = lastPosition
				firstMessagePosition = min(firstMessagePosition + 10, chatAdapter!!.messagesEndRow)

				var a = lastPosition
				val N = messages.size

				while (a < firstMessagePosition) {
					val n = a - chatAdapter!!.messagesStartRow

					if (n < 0 || n >= N) {
						a++
						continue
					}

					checkAutoDownloadMessage(messages[n])

					a++
				}
			}
			else {
				lastPosition = max(firstMessagePosition - 20, chatAdapter!!.messagesStartRow)

				var a = firstMessagePosition - 1
				val N = messages.size

				while (a >= lastPosition) {
					val n = a - chatAdapter!!.messagesStartRow

					if (n < 0 || n >= N) {
						a--
						continue
					}

					checkAutoDownloadMessage(messages[n])

					a--
				}
			}
		}

		showNoSoundHint()
	}

	private fun checkAutoDownloadMessage(`object`: MessageObject?) {
		if (`object` == null) {
			return
		}

		if (`object`.mediaExists) {
			return
		}

		val message = `object`.messageOwner
		val canDownload = downloadController.canDownloadMedia(message)

		if (canDownload == 0) {
			return
		}

		val document = `object`.document
		val photo = if (document == null) FileLoader.getClosestPhotoSizeWithSize(`object`.photoThumbs, AndroidUtilities.getPhotoSize()) else null

		if (document == null && photo == null) {
			return
		}

		if (canDownload == 2 || canDownload == 1 && `object`.isVideo) {
			if (document != null && currentEncryptedChat == null && !`object`.shouldEncryptPhotoOrVideo() && `object`.canStreamVideo()) {
				fileLoader.loadFile(document, `object`, FileLoader.PRIORITY_LOW, 10)
			}
		}
		else {
			if (document != null) {
				fileLoader.loadFile(document, `object`, FileLoader.PRIORITY_LOW, if (MessageObject.isVideoDocument(document) && `object`.shouldEncryptPhotoOrVideo()) 2 else 0)
			}
			else {
				fileLoader.loadFile(ImageLocation.getForObject(photo, `object`.photoThumbsObject), `object`, null, FileLoader.PRIORITY_LOW, if (`object`.shouldEncryptPhotoOrVideo()) 2 else 0)
			}
		}
	}

	private fun showFloatingDateView(scroll: Boolean) {
		val floatingDateView = floatingDateView ?: return

		if (floatingDateView.tag == null) {
			floatingDateAnimation?.cancel()

			floatingDateView.tag = 1

			floatingDateAnimation = AnimatorSet()
			floatingDateAnimation?.duration = 150
			floatingDateAnimation?.playTogether(ObjectAnimator.ofFloat(floatingDateView, View.ALPHA, 1.0f))

			floatingDateAnimation?.addListener(object : AnimatorListenerAdapter() {
				override fun onAnimationEnd(animation: Animator) {
					if (animation == floatingDateAnimation) {
						floatingDateAnimation = null
					}
				}
			})

			floatingDateAnimation?.start()
		}
		if (!scroll) {
			invalidateMessagesVisiblePart()
			hideDateDelay = 1000
		}
	}

	private fun hideFloatingDateView(animated: Boolean) {
		if (floatingDateView?.tag != null && !currentFloatingDateOnScreen && (!scrollingFloatingDate || currentFloatingTopIsNotMessage)) {
			floatingDateView?.tag = null

			if (animated) {
				floatingDateAnimation = AnimatorSet()
				floatingDateAnimation?.duration = 150
				floatingDateAnimation?.playTogether(ObjectAnimator.ofFloat(floatingDateView, View.ALPHA, 0.0f))

				floatingDateAnimation?.addListener(object : AnimatorListenerAdapter() {
					override fun onAnimationEnd(animation: Animator) {
						if (animation == floatingDateAnimation) {
							floatingDateAnimation = null
						}
					}
				})

				floatingDateAnimation?.startDelay = hideDateDelay.toLong()
				floatingDateAnimation?.start()
			}
			else {
				floatingDateAnimation?.cancel()
				floatingDateAnimation = null

				floatingDateView?.alpha = 0.0f
			}

			hideDateDelay = 500
		}
	}

	val onItemClickListener = object : OnItemClickListenerExtended {
		override fun onItemClick(view: View, position: Int, x: Float, y: Float) {
			if (inPreviewMode) {
				return
			}

			wasManualScroll = true

			if (view is ChatActionCell && view.messageObject!!.isDateObject) {
				val bundle = Bundle()

				val date = view.messageObject?.messageOwner?.date ?: 0

				bundle.putLong("dialog_id", dialogId)
				bundle.putInt("type", CalendarActivity.TYPE_CHAT_ACTIVITY)

				val calendarActivity = CalendarActivity(bundle, SharedMediaLayout.FILTER_PHOTOS_AND_VIDEOS, date)

				presentFragment(calendarActivity)

				return
			}

			if (view is ChatActionCell && view.messageObject?.messageOwner is TLRPC.TL_messageService) {
				return
			}

			if (actionBar!!.isActionModeShowed || reportType >= 0) {
				var outside = false

				if (view is ChatMessageCell) {
					if (textSelectionHelper.isSelected(view.getMessageObject())) {
						return
					}

					outside = !view.isInsideBackground(x, y)
				}

				processRowSelect(view, outside, x, y)

				return
			}

			createMenu(view, single = true, listView = false, x = x, y = y)
		}

		override fun hasDoubleTap(view: View, position: Int): Boolean {
			val reactionStringSetting = mediaDataController.doubleTapReaction
			val reaction = mediaDataController.reactionsMap[reactionStringSetting]

			if (reaction == null && (reactionStringSetting == null || !reactionStringSetting.startsWith("animated_"))) {
				return false
			}

			var available: Boolean = dialogId >= 0

			if (!available && currentChatInfo != null) {
				available = reactionIsAvailable(currentChatInfo, if (reaction == null) reactionStringSetting else reaction.reaction)
			}

			if (!available || view !is ChatMessageCell) {
				return false
			}

			return !view.getMessageObject()!!.isSending && !view.getMessageObject()!!.isEditing && view.getMessageObject()!!.type != 16 && !actionBar!!.isActionModeShowed && !isSecretChat && !isInScheduleMode && !view.getMessageObject()!!.isSponsored
		}

		override fun onDoubleTap(view: View, position: Int, x: Float, y: Float) {
			if (view !is ChatMessageCell || parentActivity == null || isSecretChat || isInScheduleMode || isInPreviewMode) {
				return
			}

			val primaryMessage = view.primaryMessageObject

			if (primaryMessage!!.isSecretMedia) {
				return
			}

			ReactionsEffectOverlay.removeCurrent(false)

			val reactionString = mediaDataController.doubleTapReaction

			if (reactionString?.startsWith("animated_") == true) {
				var available = dialogId >= 0

				if (!available && currentChatInfo != null) {
					available = reactionIsAvailable(currentChatInfo, reactionString)
				}

				if (!available) {
					return
				}

				selectReaction(primaryMessage, null, null, x, y, fromEmojicon(reactionString), fromDoubleTap = true, bigEmoji = false, addToRecent = false)
			}
			else {
				val reaction = mediaDataController.reactionsMap[reactionString]

				if (reaction == null || view.getMessageObject()?.isSponsored == true) {
					return
				}

				if (isAiBot() || dialogId == BuildConfig.SUPPORT_BOT_ID || currentUser != null) {
					return
				}

				var available = dialogId >= 0

				if (!available && currentChatInfo != null) {
					available = reactionIsAvailable(currentChatInfo, reaction.reaction)
				}

				if (!available) {
					return
				}

				selectReaction(primaryMessage, null, null, x, y, fromEmojicon(reaction), fromDoubleTap = true, bigEmoji = false, addToRecent = false)
			}
		}
	}

	override fun onRemoveFromParent() {
		val messageObject = MediaController.getInstance().playingMessageObject

		if (messageObject != null && messageObject.isVideo) {
			MediaController.getInstance().cleanupPlayer(true, true)
		}
		else {
			MediaController.getInstance().setTextureView(videoTextureView, null, null, false)
		}
	}

	fun setIgnoreAttachOnPause(value: Boolean) {
		ignoreAttachOnPause = value
	}

	val chatActivityEnterViewForStickers: ChatActivityEnterView?
		get() = if (bottomOverlayChat!!.visibility != View.VISIBLE && (currentChat == null || canSendStickers(currentChat))) chatActivityEnterView else null

	val isKeyboardVisible: Boolean
		get() = contentView!!.keyboardHeight > AndroidUtilities.dp(20f)

	private fun checkScrollForLoad(scroll: Boolean) {
		if (chatLayoutManager == null || paused || chatAdapter!!.isFrozen) {
			return
		}

		val firstVisibleItem = chatLayoutManager!!.findFirstVisibleItemPosition()
		val visibleItemCount = if (firstVisibleItem == RecyclerView.NO_POSITION) 0 else abs(chatLayoutManager!!.findLastVisibleItemPosition() - firstVisibleItem) + 1
		val totalItemCount = chatAdapter!!.itemCount

		val checkLoadCount = if (scroll) {
			25
		}
		else {
			5
		}

		if (totalItemCount - firstVisibleItem - visibleItemCount <= checkLoadCount && !loading) {
			if (!endReached[0]) {
				loading = true

				waitingForLoad.add(lastLoadIndex)

				if (messagesByDays.size != 0) {
					messagesController.loadMessages(dialogId, mergeDialogId, false, 50, maxMessageId[0], 0, !cacheEndReached[0], minDate[0], classGuid, 0, 0, chatMode, threadId, replyMaxReadId, lastLoadIndex++)
				}
				else {
					messagesController.loadMessages(dialogId, mergeDialogId, false, 50, 0, 0, !cacheEndReached[0], minDate[0], classGuid, 0, 0, chatMode, threadId, replyMaxReadId, lastLoadIndex++)
				}
			}
			else if (mergeDialogId != 0L && !endReached[1]) {
				loading = true
				waitingForLoad.add(lastLoadIndex)
				messagesController.loadMessages(mergeDialogId, 0, false, 50, maxMessageId[1], 0, !cacheEndReached[1], minDate[1], classGuid, 0, 0, chatMode, threadId, replyMaxReadId, lastLoadIndex++)
			}
		}

		if (visibleItemCount > 0 && !loadingForward && firstVisibleItem <= 10) {
			if (mergeDialogId != 0L && !forwardEndReached[1]) {
				waitingForLoad.add(lastLoadIndex)
				messagesController.loadMessages(mergeDialogId, 0, false, 50, minMessageId[1], 0, true, maxDate[1], classGuid, 1, 0, chatMode, threadId, replyMaxReadId, lastLoadIndex++)
				loadingForward = true
			}
			else if (!forwardEndReached[0]) {
				waitingForLoad.add(lastLoadIndex)
				messagesController.loadMessages(dialogId, mergeDialogId, false, 50, minMessageId[0], 0, true, maxDate[0], classGuid, 1, 0, chatMode, threadId, replyMaxReadId, lastLoadIndex++)
				loadingForward = true
			}
		}
	}

	private fun processSelectedAttach(which: Int) {
		when (which) {
			attach_photo -> {
				if (parentActivity?.checkSelfPermission(Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
					parentActivity?.requestPermissions(arrayOf(Manifest.permission.CAMERA), 19)
					return
				}

				try {
					val takePictureIntent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)
					val image = AndroidUtilities.generatePicturePath()

					if (image != null) {
						if (Build.VERSION.SDK_INT >= 24) {
							takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, FileProvider.getUriForFile(parentActivity!!, ApplicationLoader.applicationId + ".provider", image))
							takePictureIntent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION)
							takePictureIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
						}
						else {
							takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(image))
						}

						currentPicturePath = image.absolutePath
					}

					startActivityForResult(takePictureIntent, 0)
				}
				catch (e: Exception) {
					FileLog.e(e)
				}
			}

			attach_gallery -> {
				val permission = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
					Manifest.permission.READ_MEDIA_IMAGES
				}
				else {
					Manifest.permission.READ_EXTERNAL_STORAGE
				}
				if (parentActivity?.checkSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) {
					runCatching {
						parentActivity!!.requestPermissions(arrayOf(permission), BasePermissionsActivity.REQUEST_CODE_EXTERNAL_STORAGE)
					}

					return
				}

				val allowGifs = !isChannel(currentChat) || currentChat!!.banned_rights == null || !currentChat!!.banned_rights.send_gifs
				val fragment = PhotoAlbumPickerActivity(PhotoAlbumPickerActivity.SELECT_TYPE_ALL, allowGifs, true, this@ChatActivity, false)

				if (currentChat != null && !hasAdminRights(currentChat) && currentChat!!.slowmode_enabled) {
					fragment.setMaxSelectedPhotos(10, true)
				}
				else {
					fragment.setMaxSelectedPhotos(if (editingMessageObject != null) 1 else 0, editingMessageObject == null)
				}

				fragment.setDelegate(object : PhotoAlbumPickerActivityDelegate {
					override fun didSelectPhotos(photos: List<SendingMediaInfo>?, notify: Boolean, scheduleDate: Int) {
						// unused
					}

					override fun startPhotoSelectActivity() {
						try {
							val videoPickerIntent = Intent()
							videoPickerIntent.type = "video/*"
							videoPickerIntent.action = Intent.ACTION_GET_CONTENT
							videoPickerIntent.putExtra(MediaStore.EXTRA_SIZE_LIMIT, FileLoader.DEFAULT_MAX_FILE_SIZE)

							val photoPickerIntent = Intent(Intent.ACTION_PICK)
							photoPickerIntent.type = "image/*"

							val chooserIntent = Intent.createChooser(photoPickerIntent, null)
							chooserIntent.putExtra(Intent.EXTRA_INITIAL_INTENTS, arrayOf(videoPickerIntent))

							startActivityForResult(chooserIntent, 1)
						}
						catch (e: Exception) {
							FileLog.e(e)
						}
					}
				})

				presentFragment(fragment)
			}

			attach_video -> {
				if (parentActivity?.checkSelfPermission(Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
					runCatching {
						parentActivity?.requestPermissions(arrayOf(Manifest.permission.CAMERA), BasePermissionsActivity.REQUEST_CODE_OPEN_CAMERA)
					}

					return
				}

				try {
					val takeVideoIntent = Intent(MediaStore.ACTION_VIDEO_CAPTURE)
					val video = AndroidUtilities.generateVideoPath()

					if (video != null) {
						if (Build.VERSION.SDK_INT >= 24) {
							takeVideoIntent.putExtra(MediaStore.EXTRA_OUTPUT, FileProvider.getUriForFile(parentActivity!!, ApplicationLoader.applicationId + ".provider", video))
							takeVideoIntent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION)
							takeVideoIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
						}
						else {
							takeVideoIntent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(video))
						}

						takeVideoIntent.putExtra(MediaStore.EXTRA_SIZE_LIMIT, FileLoader.DEFAULT_MAX_FILE_SIZE)

						currentPicturePath = video.absolutePath
					}

					startActivityForResult(takeVideoIntent, 2)
				}
				catch (e: Exception) {
					FileLog.e(e)
				}
			}
		}
	}

	fun allowSendGifs(): Boolean {
		return !isChannel(currentChat) || currentChat?.banned_rights == null || !currentChat!!.banned_rights.send_gifs
	}

	fun openPollCreate(quiz: Boolean?) {
		val pollCreateActivity = PollCreateActivity(this@ChatActivity, quiz)

		pollCreateActivity.setDelegate { poll, params, notify, scheduleDate ->
			sendMessagesHelper.sendMessage(poll, dialogId, replyMessage, threadMessage, null, params, notify, scheduleDate, false, null)
			afterMessageSend()
		}

		presentFragment(pollCreateActivity)
	}

	override fun didSelectFiles(files: List<String>?, caption: String?, fmessages: List<MessageObject>?, notify: Boolean, scheduleDate: Int) {
		@Suppress("NAME_SHADOWING") var caption = caption

		fillEditingMediaWithCaption(caption, null)

		if (!fmessages.isNullOrEmpty() && !caption.isNullOrEmpty()) {
			sendMessagesHelper.sendMessage(caption, dialogId, null, null, null, true, null, null, null, true, 0, null, updateStickersOrder = false, isMediaSale = false, mediaSaleHash = null)
			caption = null
		}

		sendMessagesHelper.sendMessage(fmessages, dialogId, forwardFromMyName = false, hideCaption = false, notify = true, scheduleDate = 0)

		prepareSendingDocuments(accountInstance, files, files, null, caption, null, dialogId, replyMessage, threadMessage, null, editingMessageObject, notify, scheduleDate, false, null)

		afterMessageSend()
	}

	override fun didSelectPhotos(photos: List<SendingMediaInfo>?, notify: Boolean, scheduleDate: Int) {
		if (photos.isNullOrEmpty()) {
			return
		}

		fillEditingMediaWithCaption(photos[0].caption, photos[0].entities)
		prepareSendingMedia(accountInstance, photos, dialogId, replyMessage, threadMessage, null, forceDocument = true, groupMedia = false, editingMessageObject = editingMessageObject, notify = notify, scheduleDate = scheduleDate, updateStickersOrder = photos[0].updateStickersOrder, isMediaSale = false, mediaSaleHash = null)
		afterMessageSend()

		if (scheduleDate != 0) {
			if (scheduledMessagesCount == -1) {
				scheduledMessagesCount = 0
			}

			scheduledMessagesCount += photos.size

			updateScheduledInterface(true)
		}
	}

	fun didSelectSearchPhotos(photos: MutableList<SendingMediaInfo>, notify: Boolean, scheduleDate: Int) {
		if (photos.isEmpty()) {
			return
		}

		var hasNoGifs = false

		for (a in photos.indices) {
			val info = photos[a]

			if (info.inlineResult == null && info.videoEditedInfo == null) {
				hasNoGifs = true
				break
			}
		}

		if (!hasNoGifs && !TextUtils.isEmpty(photos[0].caption)) {
			SendMessagesHelper.getInstance(currentAccount).sendMessage(photos[0].caption, dialogId, replyMessage, threadMessage, null, false, photos[0].entities, null, null, notify, scheduleDate, null, updateStickersOrder = false, isMediaSale = false, mediaSaleHash = null)
		}

		var a = 0

		while (a < photos.size) {
			val info = photos[a]

			if (info.inlineResult != null && info.videoEditedInfo == null) {
				prepareSendingBotContextResult(this, accountInstance, info.inlineResult, info.params, dialogId, replyMessage, threadMessage, notify, scheduleDate)
				photos.removeAt(a)
				a--
			}

			a++
		}

		if (photos.isEmpty()) {
			return
		}

		fillEditingMediaWithCaption(photos[0].caption, photos[0].entities)
		prepareSendingMedia(accountInstance, photos, dialogId, replyMessage, threadMessage, null, forceDocument = false, groupMedia = true, editingMessageObject = editingMessageObject, notify = notify, scheduleDate = scheduleDate, updateStickersOrder = photos[0].updateStickersOrder, isMediaSale = false, mediaSaleHash = null)
		afterMessageSend()

		if (scheduleDate != 0) {
			if (scheduledMessagesCount == -1) {
				scheduledMessagesCount = 0
			}

			scheduledMessagesCount += photos.size

			updateScheduledInterface(true)
		}
	}

	override fun startDocumentSelectActivity() {
		try {
			val photoPickerIntent = Intent(Intent.ACTION_GET_CONTENT)
			photoPickerIntent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true)
			photoPickerIntent.type = "*/*"

			startActivityForResult(photoPickerIntent, 21)
		}
		catch (e: Exception) {
			FileLog.e(e)
		}
	}

	override fun dismissDialogOnPause(dialog: Dialog): Boolean {
		return dialog !== chatAttachAlert && super.dismissDialogOnPause(dialog)
	}

	private fun searchLinks(charSequence: CharSequence?, force: Boolean) {
		if (charSequence.isNullOrEmpty()) {
			return
		}

		if (currentEncryptedChat != null && messagesController.secretWebpagePreview == 0 || editingMessageObject != null && !editingMessageObject!!.isWebpage) {
			return
		}

		if (force && foundWebPage != null) {
			if (foundWebPage!!.url != null) {
				var index = TextUtils.indexOf(charSequence, foundWebPage!!.url)
				var lastChar = 0.toChar()
				var lenEqual = false

				if (index == -1) {
					if (foundWebPage!!.display_url != null) {
						index = TextUtils.indexOf(charSequence, foundWebPage!!.display_url)
						lenEqual = index != -1 && index + foundWebPage!!.display_url.length == charSequence.length
						lastChar = if (index != -1 && !lenEqual) charSequence[index + foundWebPage!!.display_url.length] else 0.toChar()
					}
				}
				else {
					lenEqual = index + foundWebPage!!.url.length == charSequence.length
					lastChar = if (!lenEqual) charSequence[index + foundWebPage!!.url.length] else 0.toChar()
				}

				if (index != -1 && (lenEqual || lastChar == ' ' || lastChar == ',' || lastChar == '.' || lastChar == '!' || lastChar == '/')) {
					return
				}
			}

			pendingLinkSearchString = null
			foundUrls = null

			showFieldPanelForWebPage(false, foundWebPage, false)
		}

		val messagesController = messagesController

		Utilities.searchQueue.postRunnable {
			if (linkSearchRequestId != 0) {
				connectionsManager.cancelRequest(linkSearchRequestId, true)
				linkSearchRequestId = 0
			}

			var urls: MutableList<CharSequence>? = null
			var textToCheck: CharSequence?

			try {
				val m = AndroidUtilities.WEB_URL.matcher(charSequence)

				while (m.find()) {
					if (m.start() > 0) {
						if (charSequence[m.start() - 1] == '@') {
							continue
						}
					}

					if (urls == null) {
						urls = mutableListOf()
					}

					urls.add(charSequence.subSequence(m.start(), m.end()))
				}

				if (charSequence is Spannable) {
					val spans = charSequence.getSpans(0, charSequence.length, URLSpanReplacement::class.java)

					if (!spans.isNullOrEmpty()) {
						if (urls == null) {
							urls = mutableListOf()
						}

						for (span in spans) {
							urls.add(span.url)
						}
					}
				}

				if (urls != null && foundUrls != null && urls.size == foundUrls?.size) {
					var clear = true

					for (a in urls.indices) {
						if (!TextUtils.equals(urls[a], foundUrls!![a])) {
							clear = false
						}
					}

					if (clear) {
						return@postRunnable
					}
				}

				foundUrls = urls

				if (urls == null) {
					AndroidUtilities.runOnUIThread {
						if (foundWebPage != null) {
							showFieldPanelForWebPage(false, foundWebPage, false)
							foundWebPage = null
						}
					}

					return@postRunnable
				}

				textToCheck = TextUtils.join(" ", urls)
			}
			catch (e: Exception) {
				FileLog.e(e)

				val text = charSequence.toString().lowercase()

				if (charSequence.length < 13 || !text.contains("http://") && !text.contains("https://")) {
					AndroidUtilities.runOnUIThread {
						if (foundWebPage != null) {
							showFieldPanelForWebPage(false, foundWebPage, false)
							foundWebPage = null
						}
					}

					return@postRunnable
				}

				textToCheck = charSequence
			}

			if (currentEncryptedChat != null && messagesController.secretWebpagePreview == 2) {
				AndroidUtilities.runOnUIThread {
					val parentActivity = parentActivity ?: return@runOnUIThread

					val builder = AlertDialog.Builder(parentActivity)
					builder.setTitle(parentActivity.getString(R.string.AppName))

					builder.setPositiveButton(parentActivity.getString(R.string.OK)) { _, _ ->
						messagesController.secretWebpagePreview = 1
						MessagesController.getGlobalMainSettings().edit().putInt("secretWebpage2", getMessagesController().secretWebpagePreview).commit()

						foundUrls = null

						searchLinks(charSequence, force)
					}

					builder.setNegativeButton(parentActivity.getString(R.string.Cancel), null)
					builder.setMessage(parentActivity.getString(R.string.SecretLinkPreviewAlert))

					showDialog(builder.create())

					messagesController.secretWebpagePreview = 0

					MessagesController.getGlobalMainSettings().edit().putInt("secretWebpage2", messagesController.secretWebpagePreview).commit()
				}

				return@postRunnable
			}

			val req = TL_messages_getWebPagePreview()

			if (textToCheck is String) {
				req.message = textToCheck
			}
			else {
				req.message = textToCheck.toString()
			}

			linkSearchRequestId = connectionsManager.sendRequest(req) { response, error ->
				AndroidUtilities.runOnUIThread {
					linkSearchRequestId = 0

					if (error == null) {
						if (response is TL_messageMediaWebPage) {
							foundWebPage = response.webpage

							if (foundWebPage is TL_webPage || foundWebPage is TL_webPagePending) {
								if (foundWebPage is TL_webPagePending) {
									pendingLinkSearchString = req.message
								}

								if (currentEncryptedChat != null && foundWebPage is TL_webPagePending) {
									foundWebPage?.url = req.message
								}

								showFieldPanelForWebPage(true, foundWebPage, false)
							}
							else {
								if (foundWebPage != null) {
									showFieldPanelForWebPage(false, foundWebPage, false)
									foundWebPage = null
								}
							}
						}
						else {
							if (foundWebPage != null) {
								showFieldPanelForWebPage(false, foundWebPage, false)
								foundWebPage = null
							}
						}
					}
				}
			}

			connectionsManager.bindRequestToGuid(linkSearchRequestId, classGuid)
		}
	}

	private fun forwardMessages(arrayList: List<MessageObject>?, fromMyName: Boolean, hideCaption: Boolean, notify: Boolean, scheduleDate: Int) {
		if (arrayList.isNullOrEmpty()) {
			return
		}

		if (scheduleDate != 0 == (chatMode == MODE_SCHEDULED)) {
			waitingForSendingMessageLoad = true
		}

		val result = sendMessagesHelper.sendMessage(arrayList, dialogId, fromMyName, hideCaption, notify, scheduleDate)

		AlertsCreator.showSendMediaAlert(result, this)

		if (result != 0) {
			AndroidUtilities.runOnUIThread {
				waitingForSendingMessageLoad = false
				hideFieldPanel(true)
			}
		}
	}

	fun shouldShowImport(): Boolean {
		return openImport
	}

	fun setOpenImport() {
		openImport = true
	}

	private fun checkBotKeyboard() {
		if (userBlocked) {
			return
		}

		val botButtons = botButtons ?: return
		val chatActivityEnterView = chatActivityEnterView ?: return

		if (botButtons.messageOwner?.reply_markup is TL_replyKeyboardForceReply) {
			val preferences = MessagesController.getMainSettings(currentAccount)

			if (preferences.getInt("answered_$dialogId", 0) != botButtons.id && (replyMessage == null || chatActivityEnterView.fieldText == null)) {
				botReplyButtons = botButtons
				chatActivityEnterView.setButtons(botButtons)
				showFieldPanelForReply(botButtons)
			}
		}
		else {
			if (replyMessage != null && botReplyButtons === replyMessage) {
				botReplyButtons = null
				hideFieldPanel(true)
			}

			chatActivityEnterView.setButtons(botButtons)
		}
	}

	fun hideFieldPanel(animated: Boolean) {
		showFieldPanel(false, null, null, null, null, true, 0, false, animated)
	}

	fun hideFieldPanel(notify: Boolean, scheduleDate: Int, animated: Boolean) {
		showFieldPanel(false, null, null, null, null, notify, scheduleDate, false, animated)
	}

	fun showFieldPanelForWebPage(show: Boolean, webPage: WebPage?, cancel: Boolean) {
		showFieldPanel(show, null, null, null, webPage, true, 0, cancel, true)
	}

	fun showFieldPanelForForward(show: Boolean, messageObjectsToForward: List<MessageObject>?) {
		showFieldPanel(show, null, null, messageObjectsToForward, null, true, 0, cancel = false, animated = true)
	}

	fun showFieldPanelForReply(messageObjectToReply: MessageObject?) {
		showFieldPanel(true, messageObjectToReply, null, null, null, true, 0, cancel = false, animated = true)
	}

	fun showFieldPanelForEdit(show: Boolean, messageObjectToEdit: MessageObject?) {
		showFieldPanel(show, null, messageObjectToEdit, null, null, true, 0, cancel = false, animated = true)
	}

	fun showFieldPanel(show: Boolean, messageObjectToReply: MessageObject?, messageObjectToEdit: MessageObject?, messageObjectsToForward: List<MessageObject>?, webPage: WebPage?, notify: Boolean, scheduleDate: Int, cancel: Boolean, animated: Boolean) {
		val chatActivityEnterView = chatActivityEnterView ?: return
		@Suppress("NAME_SHADOWING") var messageObjectToReply = messageObjectToReply
		@Suppress("NAME_SHADOWING") var messageObjectsToForward = messageObjectsToForward
		var showHint = false

		if (show) {
			if (messageObjectToReply == null && messageObjectsToForward == null && messageObjectToEdit == null && webPage == null) {
				return
			}

			hideHints(false)

			if (searchItem != null && actionBar?.isSearchFieldVisible == true) {
				actionBar?.closeSearchField(false)

				chatActivityEnterView.setFieldFocused()

				AndroidUtilities.runOnUIThread({
					chatActivityEnterView.openKeyboard()
				}, 100)
			}

			var openKeyboard = false

			if (messageObjectToReply != null && messageObjectToReply.dialogId != dialogId) {
				messageObjectsToForward = mutableListOf()
				messageObjectsToForward.add(messageObjectToReply)

				messageObjectToReply = null

				openKeyboard = true
			}

			chatActivityEnterTopView?.isEditMode = false

			if (messageObjectToEdit != null) {
				forwardingMessages = null

				if (threadId == 0) {
					replyMessage = null
					chatActivityEnterView.setReplyingMessageObject(null)
				}

				editingMessageObject = messageObjectToEdit

				val mediaEmpty = messageObjectToEdit.isMediaEmpty

				chatActivityEnterView.setEditingMessageObject(messageObjectToEdit, !mediaEmpty)

				if (foundWebPage != null) {
					return
				}

				chatActivityEnterView.setForceShowSendButton(value = false, animated = false)

				val canEditMedia = messageObjectToEdit.canEditMedia()

				replyCloseImageView!!.contentDescription = context!!.getString(R.string.AccDescrCancelEdit)

				if (!mediaEmpty && canEditMedia) {
					var editButtonText: String? = null
					val replaceButtonText: String

					if (messageObjectToEdit.isPhoto) {
						editButtonText = context!!.getString(R.string.EditMessageEditPhoto)
						replaceButtonText = context!!.getString(R.string.EditMessageReplacePhoto)
					}
					else if (messageObjectToEdit.isVideo) {
						editButtonText = context!!.getString(R.string.EditMessageEditVideo)
						replaceButtonText = context!!.getString(R.string.EditMessageReplaceVideo)
					}
					else if (messageObjectToEdit.isGif) {
						replaceButtonText = context!!.getString(R.string.EditMessageReplaceGif)
					}
					else if (messageObjectToEdit.isMusic) {
						replaceButtonText = context!!.getString(R.string.EditMessageReplaceAudio)
					}
					else {
						replaceButtonText = context!!.getString(R.string.EditMessageReplaceFile)
					}

					val buttons = chatActivityEnterTopView!!.editView.buttons
					buttons[0].isEditButton = editButtonText != null
					buttons[0].textView.text = editButtonText ?: replaceButtonText
					buttons[0].imageView.setImageResource(if (editButtonText != null) R.drawable.msg_photoeditor else R.drawable.msg_replace)
					buttons[1].visibility = if (editButtonText != null) View.VISIBLE else View.GONE

					if (editButtonText != null) {
						buttons[1].textView.text = replaceButtonText
					}

					chatActivityEnterTopView?.isEditMode = true
				}
				else {
					replyIconImageView?.setImageResource(R.drawable.msg_edit)
					replyIconImageView?.contentDescription = context!!.getString(R.string.AccDescrEditing)

					if (mediaEmpty) {
						replyNameTextView?.setText(context!!.getString(R.string.EditMessage))
					}
					else {
						replyNameTextView?.setText(context!!.getString(R.string.EditCaption))
					}

					if (canEditMedia) {
						replyObjectTextView?.setText(context!!.getString(R.string.EditMessageMedia))
					}
					else if (messageObjectToEdit.messageText != null || messageObjectToEdit.caption != null) {
						var mess = if (messageObjectToEdit.caption != null) messageObjectToEdit.caption.toString() else messageObjectToEdit.messageText.toString()

						if (mess.length > 150) {
							mess = mess.substring(0, 150)
						}

						mess = mess.replace('\n', ' ')

						var cs: Spannable = SpannableStringBuilder(Emoji.replaceEmoji(mess, replyObjectTextView!!.paint.fontMetricsInt, false))

						MediaDataController.addTextStyleRuns(messageObjectToEdit, cs)

						if (messageObjectToEdit.messageOwner != null) {
							cs = MessageObject.replaceAnimatedEmoji(cs, messageObjectToEdit.messageOwner?.entities, replyObjectTextView!!.paint.fontMetricsInt)
						}

						replyObjectTextView?.setText(AnimatedEmojiSpan.cloneSpans(cs))
					}
				}
			}
			else if (messageObjectToReply != null) {
				forwardingMessages = null
				editingMessageObject = null
				replyMessage = messageObjectToReply

				chatActivityEnterView.setReplyingMessageObject(messageObjectToReply)
				chatActivityEnterView.setEditingMessageObject(null, false)

				if (foundWebPage != null) {
					return
				}

				val restrictionReason = MessagesController.getRestrictionReason(messageObjectToReply.messageOwner?.restriction_reason)

				chatActivityEnterView.setForceShowSendButton(value = false, animated = false)

				val name: String

				if (messageObjectToReply.isFromUser) {
					name = if (messageObjectToReply.messageOwner?.from_id?.channel_id != 0L) {
						val chat = messagesController.getChat(messageObjectToReply.messageOwner?.from_id?.channel_id) ?: return
						chat.title
					}
					else {
						val user = messagesController.getUser(messageObjectToReply.messageOwner?.from_id?.user_id) ?: return
						getUserName(user)
					}
				}
				else {
					val chat = if (isChannel(currentChat) && currentChat!!.megagroup && messageObjectToReply.isForwardedChannelPost) {
						messagesController.getChat(messageObjectToReply.messageOwner?.fwd_from?.from_id?.channel_id)
					}
					else if (isChannel(currentChat)) {
						messagesController.getChat(-(messageObjectToReply.messageOwner?.dialog_id ?: 0))
					}
					else {
						messagesController.getChat(-messageObjectToReply.senderId)
					}

					if (chat == null) {
						return
					}

					name = chat.title
				}

				replyIconImageView?.setImageResource(R.drawable.msg_reply)
				replyNameTextView?.setText(name)
				replyIconImageView?.contentDescription = context!!.getString(R.string.AccDescrReplying)
				replyCloseImageView?.contentDescription = context!!.getString(R.string.AccDescrCancelReply)

				var replyObjectText: CharSequence? = null
				var sourceText: CharSequence? = null

				if (!restrictionReason.isNullOrEmpty()) {
					replyObjectText = restrictionReason
					sourceText = restrictionReason
				}
				else if (messageObjectToReply.messageOwner?.media is TL_messageMediaGame) {
					val media = messageObjectToReply.messageOwner?.media as TL_messageMediaGame

					replyObjectText = Emoji.replaceEmoji(media.game?.title, replyObjectTextView?.paint?.fontMetricsInt, false)
					sourceText = media.game?.title
				}
				else if (messageObjectToReply.messageText != null || messageObjectToReply.caption != null) {
					var mess: CharSequence = messageObjectToReply.caption?.toString() ?: messageObjectToReply.messageText?.toString() ?: ""

					sourceText = mess

					if (mess.length > 150) {
						mess = mess.subSequence(0, 150)
					}

					mess = AndroidUtilities.replaceNewLines(mess)

					if (messageObjectToReply.messageOwner?.entities != null) {
						mess = MessageObject.replaceAnimatedEmoji(mess, messageObjectToReply.messageOwner?.entities, replyObjectTextView?.paint?.fontMetricsInt)
					}

					replyObjectText = Emoji.replaceEmoji(mess, replyObjectTextView!!.paint.fontMetricsInt, false)
				}

				if (replyObjectText != null) {
					if (replyObjectText is Spannable && sourceText != null) {
						MediaDataController.addTextStyleRuns(messageObjectToReply.messageOwner?.entities, sourceText, replyObjectText)
					}

					replyObjectTextView?.setText(AnimatedEmojiSpan.cloneSpans(replyObjectText))
				}
			}
			else if (messageObjectsToForward != null) {
				if (messageObjectsToForward.isEmpty()) {
					return
				}

				if (threadId == 0) {
					replyMessage = null
					chatActivityEnterView.setReplyingMessageObject(null)
				}

				editingMessageObject = null

				chatActivityEnterView.setEditingMessageObject(null, false)

				if (forwardingMessages == null) {
					forwardingMessages = ForwardingMessagesParams(messageObjectsToForward, dialogId)
				}

				if (foundWebPage != null) {
					return
				}

				chatActivityEnterView.setForceShowSendButton(value = true, animated = false)

				val uids = mutableListOf<Long>()

				replyIconImageView?.setImageResource(R.drawable.msg_forward)
				replyIconImageView?.contentDescription = context!!.getString(R.string.AccDescrForwarding)

				replyCloseImageView?.contentDescription = context!!.getString(R.string.AccDescrCancelForward)

				var `object` = messageObjectsToForward[0]

				if (`object`.isFromUser) {
					uids.add(`object`.messageOwner!!.from_id!!.user_id)
				}
				else {
					val chat = messagesController.getChat(`object`.messageOwner?.peer_id?.channel_id)

					if (isChannel(chat) && chat.megagroup && `object`.isForwardedChannelPost) {
						uids.add(-`object`.messageOwner!!.fwd_from!!.from_id.channel_id)
					}
					else {
						uids.add(-`object`.messageOwner!!.peer_id!!.channel_id)
					}
				}

				var type = if (`object`.isAnimatedEmoji || `object`.isDice) 0 else `object`.type

				for (a in 1 until messageObjectsToForward.size) {
					`object` = messageObjectsToForward[a]

					val uid = if (`object`.isFromUser) {
						`object`.messageOwner!!.from_id!!.user_id
					}
					else {
						val chat = messagesController.getChat(`object`.messageOwner?.peer_id?.channel_id)

						if (isChannel(chat) && chat.megagroup && `object`.isForwardedChannelPost) {
							-`object`.messageOwner!!.fwd_from!!.from_id.channel_id
						}
						else {
							-`object`.messageOwner!!.peer_id!!.channel_id
						}
					}

					if (!uids.contains(uid)) {
						uids.add(uid)
					}
					if (messageObjectsToForward[a].type != type) {
						type = -1
					}
				}

				val userNames = StringBuilder()

				for (a in uids.indices) {
					val uid = uids[a]
					var chat: Chat? = null
					var user: User? = null

					if (uid > 0) {
						user = messagesController.getUser(uid)
					}
					else {
						chat = messagesController.getChat(-uid)
					}

					if (user == null && chat == null) {
						continue
					}

					if (uids.size == 1) {
						if (user != null) {
							userNames.append(getUserName(user))
						}
						else {
							userNames.append(chat!!.title)
						}
					}
					else if (uids.size == 2 || userNames.isEmpty()) {
						if (userNames.isNotEmpty()) {
							userNames.append(", ")
						}

						if (user != null) {
							if (!user.first_name.isNullOrEmpty()) {
								userNames.append(user.first_name)
							}
							else if (!user.last_name.isNullOrEmpty()) {
								userNames.append(user.last_name)
							}
							else {
								userNames.append(" ")
							}
						}
						else {
							userNames.append(chat!!.title)
						}
					}
					else {
						userNames.append(" ")
						userNames.append(LocaleController.formatPluralString("AndOther", uids.size - 1))

						break
					}
				}

				if (type == -1 || type == 0 || type == 10 || type == 11 || type == MessageObject.TYPE_EMOJIS) {
					replyNameTextView?.setText(LocaleController.formatPluralString("PreviewForwardMessagesCount", messageObjectsToForward.size))
				}
				else if (type == 1) {
					replyNameTextView?.setText(LocaleController.formatPluralString("PreviewForwardPhoto", messageObjectsToForward.size))

					if (messageObjectsToForward.size == 1) {
						messageObjectToReply = messageObjectsToForward[0]
					}
				}
				else if (type == 4) {
					replyNameTextView?.setText(LocaleController.formatPluralString("PreviewForwardLocation", messageObjectsToForward.size))
				}
				else if (type == 3) {
					replyNameTextView?.setText(LocaleController.formatPluralString("PreviewForwardVideo", messageObjectsToForward.size))

					if (messageObjectsToForward.size == 1) {
						messageObjectToReply = messageObjectsToForward[0]
					}
				}
				else if (type == 12) {
					replyNameTextView?.setText(LocaleController.formatPluralString("PreviewForwardContact", messageObjectsToForward.size))
				}
				else if (type == 2) {
					replyNameTextView?.setText(LocaleController.formatPluralString("PreviewForwardAudio", messageObjectsToForward.size))
				}
				else if (type == MessageObject.TYPE_ROUND_VIDEO) {
					replyNameTextView?.setText(LocaleController.formatPluralString("PreviewForwardRound", messageObjectsToForward.size))
				}
				else if (type == 14) {
					replyNameTextView?.setText(LocaleController.formatPluralString("PreviewForwardMusic", messageObjectsToForward.size))
				}
				else if (type == MessageObject.TYPE_STICKER || type == MessageObject.TYPE_ANIMATED_STICKER) {
					replyNameTextView?.setText(LocaleController.formatPluralString("PreviewForwardSticker", messageObjectsToForward.size))
				}
				else if (type == 17) {
					replyNameTextView?.setText(LocaleController.formatPluralString("PreviewForwardPoll", messageObjectsToForward.size))
				}
				else if (type == 8 || type == 9) {
					if ((messageObjectsToForward.size == 1) and (type == 9)) {
						messageObjectToReply = messageObjectsToForward[0]
					}

					if (messageObjectsToForward.size == 1 && type == 8) {
						replyNameTextView?.setText(context!!.getString(R.string.AttachGif))
					}
					else {
						replyNameTextView?.setText(LocaleController.formatPluralString("PreviewForwardFile", messageObjectsToForward.size))
					}
				}

				if (forwardingMessages?.hideForwardSendersName == true) {
					replyObjectTextView?.setText(context!!.getString(R.string.HiddenSendersNameDescription))
				}
				else {
					if ((type == -1 || type == 0 || type == 10 || type == 11 || type == MessageObject.TYPE_EMOJIS) && messageObjectsToForward.size == 1 && messageObjectsToForward[0].messageText != null) {
						val messageObject = messageObjectsToForward[0]
						var mess: CharSequence = SpannableStringBuilder(messageObject.messageText.toString())

						if (mess.length > 150) {
							mess = mess.subSequence(0, 150)
						}

						mess = Emoji.replaceEmoji(mess, replyObjectTextView?.paint?.fontMetricsInt, false) ?: mess

						if (mess is Spannable) {
							MediaDataController.addTextStyleRuns(messageObject.messageOwner?.entities, messageObject.messageText, mess)

							if (messageObject.messageOwner != null) {
								mess = MessageObject.replaceAnimatedEmoji(mess, messageObject.messageOwner?.entities, replyObjectTextView!!.paint.fontMetricsInt)
							}
						}

						replyObjectTextView?.setText(mess)
					}
					else {
						replyObjectTextView?.setText(LocaleController.formatString("ForwardingFromNames", R.string.ForwardingFromNames, userNames))
					}
				}

				if (!SharedConfig.forwardingOptionsHintShown) {
					showHint = true
				}
			}
			else {
				replyIconImageView?.setImageResource(R.drawable.msg_link)

				if (webPage is TL_webPagePending) {
					replyNameTextView?.setText(context!!.getString(R.string.GettingLinkInfo))
					replyObjectTextView?.setText(pendingLinkSearchString)
				}
				else {
					if (webPage?.site_name != null) {
						replyNameTextView?.setText(webPage.site_name)
					}
					else if (webPage?.title != null) {
						replyNameTextView?.setText(webPage.title)
					}
					else {
						replyNameTextView?.setText(context!!.getString(R.string.LinkPreview))
					}

					if (webPage?.title != null) {
						replyObjectTextView?.setText(webPage.title)
					}
					else if (webPage?.description != null) {
						replyObjectTextView?.setText(webPage.description)
					}
					else if (webPage?.author != null) {
						replyObjectTextView?.setText(webPage.author)
					}
					else {
						replyObjectTextView?.setText(webPage?.display_url)
					}

					chatActivityEnterView.setWebPage(webPage, true)
				}
			}

			val thumbMediaMessageObject = messageObjectToReply ?: if (messageObjectToEdit != null) {
				if (!chatActivityEnterTopView!!.isEditMode) {
					messageObjectToEdit
				}
				else {
					null
				}
			}
			else {
				null
			}

			val layoutParams1 = replyNameTextView!!.layoutParams as FrameLayout.LayoutParams
			val layoutParams2 = replyObjectTextView!!.layoutParams as FrameLayout.LayoutParams
			val layoutParams3 = replyObjectHintTextView!!.layoutParams as FrameLayout.LayoutParams
			var cacheType = 1
			var size = 0
			var photoSize: PhotoSize? = null
			var thumbPhotoSize: PhotoSize? = null
			var photoSizeObject: TLObject? = null

			if (thumbMediaMessageObject != null && MessagesController.getRestrictionReason(thumbMediaMessageObject.messageOwner?.restriction_reason).isNullOrEmpty()) {
				photoSize = FileLoader.getClosestPhotoSizeWithSize(thumbMediaMessageObject.photoThumbs2, 320)
				thumbPhotoSize = FileLoader.getClosestPhotoSizeWithSize(thumbMediaMessageObject.photoThumbs2, AndroidUtilities.dp(40f))
				photoSizeObject = thumbMediaMessageObject.photoThumbsObject2

				if (photoSize == null) {
					if (thumbMediaMessageObject.mediaExists) {
						photoSize = FileLoader.getClosestPhotoSizeWithSize(thumbMediaMessageObject.photoThumbs, AndroidUtilities.getPhotoSize())

						if (photoSize != null) {
							size = photoSize.size
						}

						cacheType = 0
					}
					else {
						photoSize = FileLoader.getClosestPhotoSizeWithSize(thumbMediaMessageObject.photoThumbs, 320)
					}

					thumbPhotoSize = FileLoader.getClosestPhotoSizeWithSize(thumbMediaMessageObject.photoThumbs, AndroidUtilities.dp(40f))
					photoSizeObject = thumbMediaMessageObject.photoThumbsObject
				}
			}

			if (photoSize === thumbPhotoSize) {
				thumbPhotoSize = null
			}

			if (photoSize == null || photoSize is TL_photoSizeEmpty || photoSize.location is TL_fileLocationUnavailable || thumbMediaMessageObject!!.isAnyKindOfSticker || thumbMediaMessageObject.isSecretMedia || thumbMediaMessageObject.isWebpageDocument) {
				replyImageView?.setImageBitmap(null)
				replyImageLocation = null
				replyImageLocationObject = null
				replyImageView?.invisible()

				layoutParams3.leftMargin = AndroidUtilities.dp(74f)
				layoutParams2.leftMargin = layoutParams3.leftMargin
				layoutParams1.leftMargin = layoutParams2.leftMargin
			}
			else {
				if (thumbMediaMessageObject.isRoundVideo) {
					replyImageView?.setRoundRadius(AndroidUtilities.dp(17f))
				}
				else {
					replyImageView?.setRoundRadius(AndroidUtilities.dp(2f))
				}

				replyImageSize = size
				replyImageCacheType = cacheType
				replyImageLocation = photoSize
				replyImageThumbLocation = thumbPhotoSize
				replyImageLocationObject = photoSizeObject
				replyImageView?.setImage(ImageLocation.getForObject(replyImageLocation, photoSizeObject), "50_50", ImageLocation.getForObject(thumbPhotoSize, photoSizeObject), "50_50_b", null, size.toLong(), cacheType, thumbMediaMessageObject)
				replyImageView?.visible()

				layoutParams3.leftMargin = AndroidUtilities.dp(128f)
				layoutParams2.leftMargin = layoutParams3.leftMargin
				layoutParams1.leftMargin = layoutParams2.leftMargin
			}

			replyNameTextView?.layoutParams = layoutParams1
			replyObjectTextView?.layoutParams = layoutParams2
			replyObjectHintTextView?.layoutParams = layoutParams3

			chatActivityEnterView.showTopView(true, openKeyboard)
		}
		else {
			if (replyMessage == null && forwardingMessages == null && foundWebPage == null && editingMessageObject == null && !chatActivityEnterView.isTopViewVisible) {
				return
			}

			if (replyMessage?.messageOwner?.reply_markup is TL_replyKeyboardForceReply) {
				val preferences = MessagesController.getMainSettings(currentAccount)
				preferences.edit().putInt("answered_$dialogId", replyMessage!!.id).commit()
			}

			if (foundWebPage != null) {
				foundWebPage = null

				chatActivityEnterView.setWebPage(null, !cancel)

				if (webPage != null && (replyMessage != null || forwardingMessages != null || editingMessageObject != null)) {
					showFieldPanel(true, replyMessage, editingMessageObject, forwardingMessages?.messages, null, notify, scheduleDate, cancel = false, animated = true)
					return
				}
			}

			if (forwardingMessages != null) {
				val messagesToForward = mutableListOf<MessageObject>()
				forwardingMessages?.getSelectedMessages(messagesToForward)
				forwardMessages(messagesToForward, forwardingMessages!!.hideForwardSendersName, forwardingMessages!!.hideCaption, notify, if (scheduleDate != 0 && scheduleDate != 0x7ffffffe) scheduleDate + 1 else scheduleDate)
				forwardingMessages = null
			}

			chatActivityEnterView.setForceShowSendButton(false, animated)

			if (!waitingForSendingMessageLoad) {
				chatActivityEnterView.hideTopView(animated)
			}

			chatActivityEnterView.setReplyingMessageObject(threadMessage)
			chatActivityEnterView.setEditingMessageObject(null, false)

			topViewWasVisible = 0
			replyMessage = threadMessage
			editingMessageObject = null
			replyImageLocation = null
			replyImageLocationObject = null
		}
		if (showHint) {
			if (tapForForwardingOptionsHitRunnable == null) {
				AndroidUtilities.runOnUIThread(Runnable {
					showTapForForwardingOptionsHit = !showTapForForwardingOptionsHit
					replyObjectTextView?.pivotX = 0f
					replyObjectHintTextView?.pivotX = 0f

					if (showTapForForwardingOptionsHit) {
						replyObjectTextView?.animate()?.alpha(0f)?.scaleX(0.98f)?.scaleY(0.98f)?.setDuration(150)?.start()
						replyObjectHintTextView?.animate()?.alpha(1f)?.scaleX(1f)?.scaleY(1f)?.setDuration(150)?.start()
					}
					else {
						replyObjectTextView?.animate()?.alpha(1f)?.scaleX(1f)?.scaleY(1f)?.setDuration(150)?.start()
						replyObjectHintTextView?.animate()?.alpha(0f)?.scaleX(0.98f)?.scaleY(0.98f)?.setDuration(150)?.start()
					}

					AndroidUtilities.runOnUIThread(tapForForwardingOptionsHitRunnable, 6000)
				}.also { tapForForwardingOptionsHitRunnable = it }, 6000)
			}
		}
		else {
			if (tapForForwardingOptionsHitRunnable != null) {
				AndroidUtilities.cancelRunOnUIThread(tapForForwardingOptionsHitRunnable)
				tapForForwardingOptionsHitRunnable = null
			}

			replyObjectTextView?.alpha = 1f
			replyObjectHintTextView?.alpha = 0f
		}
	}

	private fun moveScrollToLastMessage(skipSponsored: Boolean) {
		if (chatListView != null && messages.isNotEmpty() && !pinchToZoomHelper!!.isInOverlayMode) {
			var position = 0

			if (skipSponsored) {
				position += sponsoredMessagesCount
			}

			chatLayoutManager?.scrollToPositionWithOffset(position, 0)
			chatListView?.stopScroll()
		}
	}

	private fun sendSecretMessageRead(messageObject: MessageObject?, readNow: Boolean): Runnable? {
		if (messageObject == null || messageObject.isOut || !messageObject.isSecretMedia || messageObject.messageOwner!!.destroyTime != 0 || messageObject.messageOwner!!.ttl <= 0) {
			return null
		}

		messageObject.messageOwner?.destroyTime = messageObject.messageOwner!!.ttl + connectionsManager.currentTime

		return if (readNow) {
			if (currentEncryptedChat != null) {
				messagesController.markMessageAsRead(dialogId, messageObject.messageOwner!!.random_id, messageObject.messageOwner!!.ttl)
			}
			else {
				messagesController.markMessageAsRead2(dialogId, messageObject.id, null, messageObject.messageOwner!!.ttl, 0)
			}
			null
		}
		else {
			Runnable {
				if (currentEncryptedChat != null) {
					messagesController.markMessageAsRead(dialogId, messageObject.messageOwner!!.random_id, messageObject.messageOwner!!.ttl)
				}
				else {
					messagesController.markMessageAsRead2(dialogId, messageObject.id, null, messageObject.messageOwner!!.ttl, 0)
				}
			}
		}
	}

	private fun clearChatData() {
		messages.clear()
		messagesByDays.clear()
		waitingForLoad.clear()
		groupedMessagesMap.clear()

		threadMessageAdded = false

		if (chatAdapter != null) {
			showProgressView(chatAdapter!!.botInfoRow < 0)
		}

		chatListView?.setEmptyView(null)

		for (a in 0..1) {
			messagesDict[a].clear()

			if (currentEncryptedChat == null) {
				maxMessageId[a] = Int.MAX_VALUE
				minMessageId[a] = Int.MIN_VALUE
			}
			else {
				maxMessageId[a] = Int.MIN_VALUE
				minMessageId[a] = Int.MAX_VALUE
			}

			maxDate[a] = Int.MIN_VALUE
			minDate[a] = 0
			endReached[a] = false
			cacheEndReached[a] = false
			forwardEndReached[a] = true
		}

		first = true
		firstLoading = true
		loading = true
		loadingForward = false
		waitingForReplyMessageLoad = false
		startLoadFromMessageId = 0
		showScrollToMessageError = false
		last_message_id = 0
		unreadMessageObject = null
		createUnreadMessageAfterId = 0
		createUnreadMessageAfterIdLoading = false
		needSelectFromMessageId = false

		chatAdapter?.notifyDataSetChanged(false)
	}

	fun scrollToLastMessage(skipSponsored: Boolean) {
		if (chatListView?.isFastScrollAnimationRunning == true) {
			return
		}

		forceNextPinnedMessageId = 0
		nextScrollToMessageId = 0
		forceScrollToFirst = false
		chatScrollHelper?.scrollDirection = RecyclerAnimationScrollHelper.SCROLL_DIRECTION_DOWN

		if (forwardEndReached[0] && first_unread_id == 0 && startLoadFromMessageId == 0) {
			if (chatLayoutManager?.findFirstCompletelyVisibleItemPosition() == 0) {
				canShowPagedownButton = false
				updatePagedownButtonVisibility(true)
				removeSelectedMessageHighlight()
				updateVisibleRows()
			}
			else {
				chatAdapter?.updateRowsSafe()

				chatScrollHelperCallback.scrollTo = null

				var position = 0

				if (skipSponsored) {
					while (position < messages.size) {
						if (!messages[position].isSponsored) {
							break
						}

						position++
					}
				}

				chatScrollHelper?.scrollToPosition(position, 0, true, true)
			}
		}
		else {
			progressDialog?.dismiss()

			updatePinnedListButton(false)

			progressDialog = AlertDialog(parentActivity!!, 3)
			progressDialog?.setOnCancelListener(postponedScrollCancelListener)
			progressDialog?.showDelayed(1000)

			postponedScrollToLastMessageQueryIndex = lastLoadIndex
			postponedScrollMessageId = 0
			postponedScrollIsCanceled = false

			waitingForLoad.clear()
			waitingForLoad.add(lastLoadIndex)

			messagesController.loadMessages(dialogId, mergeDialogId, false, 30, 0, 0, true, 0, classGuid, 0, 0, chatMode, threadId, replyMaxReadId, lastLoadIndex++)
		}
	}

	fun updateTextureViewPosition(needScroll: Boolean) {
		if (paused) {
			return
		}

		val fragmentView = fragmentView ?: return
		var foundTextureViewMessage = false
		val count = chatListView?.childCount ?: 0

		for (a in 0 until count) {
			val view = chatListView?.getChildAt(a)

			if (view is ChatMessageCell) {
				val messageObject = view.getMessageObject()

				if (videoPlayerContainer != null && (messageObject!!.isRoundVideo || messageObject.isVideo) && MediaController.getInstance().isPlayingMessage(messageObject)) {
					val imageReceiver = view.photoImage

					videoPlayerContainer?.translationX = imageReceiver.imageX + view.x

					val translationY = view.y + imageReceiver.imageY + chatListView!!.y - videoPlayerContainer!!.top

					videoPlayerContainer?.translationY = translationY

					val layoutParams = videoPlayerContainer!!.layoutParams as FrameLayout.LayoutParams

					if (messageObject.isRoundVideo) {
						videoPlayerContainer?.setTag(R.id.parent_tag, null)

						if (layoutParams.width != AndroidUtilities.roundPlayingMessageSize || layoutParams.height != AndroidUtilities.roundPlayingMessageSize) {
							layoutParams.height = AndroidUtilities.roundPlayingMessageSize
							layoutParams.width = layoutParams.height
							aspectRatioFrameLayout?.resizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT
							videoPlayerContainer?.layoutParams = layoutParams
						}

						val scale = (AndroidUtilities.roundPlayingMessageSize + AndroidUtilities.roundMessageInset * 2) / AndroidUtilities.roundPlayingMessageSize.toFloat()
						val transitionScale = view.photoImage.imageWidth / AndroidUtilities.roundPlayingMessageSize

						if (videoPlayerContainer?.scaleX != transitionScale) {
							videoPlayerContainer?.invalidate()
							fragmentView.invalidate()
						}

						videoPlayerContainer?.pivotX = 0f
						videoPlayerContainer?.pivotY = 0f
						videoPlayerContainer?.scaleX = transitionScale
						videoPlayerContainer?.scaleY = transitionScale

						videoTextureView?.scaleX = scale
						videoTextureView?.scaleY = scale
					}
					else {
						videoPlayerContainer?.setTag(R.id.parent_tag, imageReceiver)

						if (layoutParams.width.toFloat() != imageReceiver.imageWidth || layoutParams.height.toFloat() != imageReceiver.imageHeight) {
							aspectRatioFrameLayout?.resizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL

							layoutParams.width = imageReceiver.imageWidth.toInt()
							layoutParams.height = imageReceiver.imageHeight.toInt()

							videoPlayerContainer?.layoutParams = layoutParams
						}

						videoTextureView?.scaleX = 1f
						videoTextureView?.scaleY = 1f
					}

					fragmentView.invalidate()
					videoPlayerContainer?.invalidate()

					foundTextureViewMessage = true

					break
				}
			}
		}

		if (needScroll && videoPlayerContainer != null) {
			val messageObject = MediaController.getInstance().playingMessageObject

			if (messageObject != null && messageObject.eventId == 0L) {
				if (!foundTextureViewMessage) {
					if (checkTextureViewPosition && messageObject.isVideo) {
						MediaController.getInstance().cleanupPlayer(true, true)
					}
					else {
						videoPlayerContainer?.translationY = (-AndroidUtilities.roundPlayingMessageSize - 100).toFloat()

						fragmentView.invalidate()

						if (messageObject.isRoundVideo || messageObject.isVideo) {
							if (checkTextureViewPosition || PipRoundVideoView.getInstance() != null) {
								MediaController.getInstance().setCurrentVideoVisible(false)
							}
							else {
								scrollToMessageId(messageObject.id, 0, false, 0, true, 0)
							}
						}
					}
				}
				else {
					MediaController.getInstance().setCurrentVideoVisible(true)

					if (messageObject.isRoundVideo || scrollToVideo) {
						// scrollToMessageId(messageObject.getId(), 0, false, 0, true, 0)
					}
					else {
						chatListView?.invalidate()
					}
				}
			}
		}
	}

	fun invalidateMessagesVisiblePart() {
		invalidateMessagesVisiblePart = true
		fragmentView?.invalidate()
	}

	private fun findClosest(arrayList: List<Int>, target: Int, index: IntArray): Int {
		if (arrayList.isEmpty()) {
			return 0
		}

		var `val` = arrayList[0]

		if (target >= `val`) {
			index[0] = 0
			return `val`
		}

		val n = arrayList.size

		`val` = arrayList[n - 1]

		if (target <= `val`) {
			index[0] = n - 1
			return `val`
		}

		var i = 0
		var j = n
		var mid = 0

		while (i < j) {
			mid = (i + j) / 2
			`val` = arrayList[mid]

			if (`val` == target) {
				index[0] = mid
				return `val`
			}

			if (target < `val`) {
				if (mid > 0) {
					val val2 = arrayList[mid - 1]

					if (target > val2) {
						index[0] = mid - 1
						return val2
					}
				}

				i = mid + 1
			}
			else {
				if (mid > 0) {
					val val2 = arrayList[mid - 1]

					if (target < val2) {
						index[0] = mid
						return `val`
					}
				}

				j = mid
			}
		}

		index[0] = mid

		return arrayList[mid]
	}

	fun updateMessagesVisiblePart(inLayout: Boolean) {
		val chatListView = chatListView ?: return
		val count = chatListView.childCount
		val height = chatListView.measuredHeight
		var minPositionHolder = Int.MAX_VALUE
		var minPositionDateHolder = Int.MAX_VALUE
		var minDateChild: View? = null
		var minChild: View? = null
		var minMessageChild: View? = null
		var foundTextureViewMessage = false
		val previousThreadMessageVisible = threadMessageVisible
		val previousPinnedMessageId = currentPinnedMessageId
		var maxVisibleId = Int.MIN_VALUE
		var maxVisibleMessageObject: MessageObject? = null

		threadMessageVisible = firstLoading

		var currentReadMaxId: Int?
		val threadId = threadId

		currentReadMaxId = if (threadId != 0 && currentChat != null) {
			replyMaxReadId
		}
		else {
			messagesController.dialogs_read_inbox_max[dialog_id_Long]
		}

		if (currentReadMaxId == null) {
			currentReadMaxId = 0
		}

		var maxPositiveUnreadId = Int.MIN_VALUE
		var maxNegativeUnreadId = Int.MAX_VALUE
		var maxUnreadDate = Int.MIN_VALUE
		val recyclerChatViewHeight = contentView!!.heightWithKeyboard - (if (inPreviewMode) 0 else AndroidUtilities.dp(48f)) - chatListView.top

		pollsToCheck.clear()

		val clipTop = chatListViewPadding
		val currentTime = System.currentTimeMillis()
		var maxAdapterPosition = -1
		var minAdapterPosition = -1
		val blurEnabled = SharedConfig.chatBlurEnabled()

		for (a in 0 until count) {
			val view = chatListView.getChildAt(a)
			var messageObject: MessageObject? = null
			val adapterPosition = chatListView.getChildAdapterPosition(view)

			if (adapterPosition >= 0) {
				if (adapterPosition > maxAdapterPosition || maxAdapterPosition == -1) {
					maxAdapterPosition = adapterPosition
				}

				if (adapterPosition < minAdapterPosition || minAdapterPosition == -1) {
					minAdapterPosition = adapterPosition
				}
			}

			val top = view!!.y.toInt()
			val bottom = top + view.measuredHeight
			var messageCell: ChatMessageCell? = null

			if (view is ChatMessageCell) {
				messageCell = view
			}

			if (messageCell != null) {
				messageCell.isBlurred = top < clipTop && bottom > clipTop || chatListView.measuredHeight - blurredViewBottomOffset in (top + 1)..<bottom
			}

			if (bottom <= clipTop - chatListViewPaddingVisibleOffset || top > chatListView.measuredHeight - blurredViewBottomOffset) {
				if (messageCell != null) {
					if (!blurEnabled) {
						messageCell.setVisibleOnScreen(false)
					}
					else {
						messageCell.setVisibleOnScreen(true)
					}
				}

				continue
			}

			messageCell?.setVisibleOnScreen(true)

			val viewTop = if (top >= 0) 0 else -top
			var viewBottom = view.measuredHeight

			if (viewBottom > height) {
				viewBottom = viewTop + height
			}

			var keyboardOffset = contentView!!.keyboardHeight

			if (keyboardOffset < AndroidUtilities.dp(20f) && chatActivityEnterView!!.isPopupShowing || chatActivityEnterView!!.panelAnimationInProgress()) {
				keyboardOffset = chatActivityEnterView!!.emojiPadding
			}

			if (messageCell != null) {
				messageObject = messageCell.getMessageObject()

				if (messageObject!!.dialogId == dialogId && messageObject.id > maxVisibleId) {
					maxVisibleId = messageObject.id
					maxVisibleMessageObject = messageObject
				}

				messageCell.setParentBounds(chatListViewPadding - chatListViewPaddingVisibleOffset - AndroidUtilities.dp(4f), chatListView.measuredHeight - blurredViewBottomOffset)
				messageCell.setVisiblePart(viewTop, viewBottom - viewTop, recyclerChatViewHeight, keyboardOffset.toFloat(), view.y + (if (isKeyboardVisible) chatListView.top else actionBar!!.measuredHeight) - contentView!!.backgroundTranslationY, contentView!!.measuredWidth, contentView!!.backgroundSizeY, blurredViewTopOffset, blurredViewBottomOffset)

				markSponsoredAsRead(messageObject)

				if (!threadMessageVisible && threadMessage != null && messageObject === threadMessage && messageCell.bottom > chatListViewPadding) {
					threadMessageVisible = true
				}

				if (videoPlayerContainer != null && (messageObject.isVideo || messageObject.isRoundVideo) && MediaController.getInstance().isPlayingMessage(messageObject)) {
					val imageReceiver = messageCell.photoImage

					if (top + imageReceiver.imageY2 < 0) {
						foundTextureViewMessage = false
					}
					else {
						videoPlayerContainer?.translationX = imageReceiver.imageX + messageCell.x

						val translationY = messageCell.y + imageReceiver.imageY + chatListView.y - videoPlayerContainer!!.top

						videoPlayerContainer?.translationY = translationY

						fragmentView?.invalidate()
						videoPlayerContainer?.invalidate()

						foundTextureViewMessage = true
					}
				}

				if (startFromVideoTimestamp >= 0 && fragmentOpened && !chatListView.isFastScrollAnimationRunning && startFromVideoMessageId == messageObject.id && (messageObject.isVideo || messageObject.isRoundVideo || messageObject.isVoice || messageObject.isMusic)) {
					messageObject.forceSeekTo = startFromVideoTimestamp / messageObject.duration.toFloat()

					val finalMessage = messageObject

					AndroidUtilities.runOnUIThread({
						if (finalMessage.isVideo) {
							openPhotoViewerForMessage(null, finalMessage)
						}
						else {
							MediaController.getInstance().playMessage(finalMessage)
						}
					}, 40)

					startFromVideoTimestamp = -1
				}

				if (fragmentOpened && openAnimationEnded && (chatListItemAnimator == null || !chatListItemAnimator!!.isRunning) && messageCell.checkUnreadReactions(clipTop, chatListView.measuredHeight - blurredViewBottomOffset)) {
					reactionsMentionCount--

					messagesStorage.markMessageReactionsAsRead(dialogId, messageCell.getMessageObject()!!.id, true)

					if (reactionsMentionCount <= 0) {
						messagesController.markReactionsAsRead(dialogId)
					}

					if (reactionsMentionCount >= 0) {
						val reaction = messageCell.getMessageObject()!!.randomUnreadReaction

						if (reaction != null) {
							val visibleReaction = fromTLReaction(reaction.reaction)

							ReactionsEffectOverlay.show(this@ChatActivity, null, messageCell, null, 0f, 0f, visibleReaction, currentAccount, if (reaction.big) ReactionsEffectOverlay.LONG_ANIMATION else ReactionsEffectOverlay.SHORT_ANIMATION)

							ReactionsEffectOverlay.startAnimation()
						}

						messageCell.markReactionsAsRead()
					}
					else {
						reactionsMentionCount = 0
					}

					updateReactionsMentionButton(true)
				}

				downloadController.checkUnviewedDownloads(messageCell.id, dialogId)

				val allowPlayEffect = messageObject.messageOwner?.media != null && !messageObject.messageOwner!!.media!!.nopremium || messageObject.isAnimatedEmojiStickerSingle && dialogId > 0

				if ((chatListItemAnimator == null || !chatListItemAnimator!!.isRunning) && (!messageObject.isOutOwner || messageObject.forcePlayEffect) && allowPlayEffect && !messageObject.messageOwner!!.premiumEffectWasPlayed && (messageObject.isPremiumSticker || messageObject.isAnimatedEmojiStickerSingle) && emojiAnimationsOverlay!!.isIdle && emojiAnimationsOverlay!!.checkPosition(messageCell, chatListViewPadding, chatListView.measuredHeight - blurredViewBottomOffset)) {
					emojiAnimationsOverlay!!.onTapItem(messageCell, this@ChatActivity, false)
				}
				else if (messageObject.isAnimatedAnimatedEmoji) {
					emojiAnimationsOverlay!!.preloadAnimation(messageCell)
				}
			}
			else if (view is ChatActionCell) {
				messageObject = view.messageObject

				if (messageObject != null && messageObject.dialogId == dialogId && messageObject.id > maxVisibleId) {
					maxVisibleId = max(maxVisibleId, messageObject.id)
				}

				view.setVisiblePart(view.getY() + (if (isKeyboardVisible) chatListView.top else actionBar!!.measuredHeight) - contentView!!.backgroundTranslationY, contentView!!.backgroundSizeY)
			}
			else {
				(view as? BotHelpCell)?.invalidate()
			}

			if (chatMode != MODE_SCHEDULED && messageObject != null) {
				val id = messageObject.id

				if (!isThreadChat && (!messageObject.isOut && messageObject.isUnread || messageObject.messageOwner!!.from_scheduled && id > currentReadMaxId) || id > 0 && isThreadChat && id > currentReadMaxId && id > replyMaxReadId) {
					if (id > 0) {
						maxPositiveUnreadId = max(maxPositiveUnreadId, messageObject.id)
					}

					if (id < 0 && !isThreadChat) {
						maxNegativeUnreadId = min(maxNegativeUnreadId, messageObject.id)
					}

					maxUnreadDate = max(maxUnreadDate, messageObject.messageOwner!!.date)
				}

				if (messageObject.type == MessageObject.TYPE_POLL && messageObject.id > 0) {
					pollsToCheck.add(messageObject)
				}
			}

			if (bottom <= clipTop) {
				if (view is ChatActionCell && messageObject!!.isDateObject) {
					view.setAlpha(0f)
				}

				continue
			}

			val position = view.bottom

			if (position < minPositionHolder) {
				minPositionHolder = position

				if (view is ChatMessageCell || view is ChatActionCell) {
					minMessageChild = view
				}

				minChild = view
			}

			if (chatListItemAnimator == null || !chatListItemAnimator!!.willRemoved(view) && !chatListItemAnimator!!.willAddedFromAlpha(view)) {
				if (view is ChatActionCell && messageObject!!.isDateObject) {
					if (view.getAlpha() != 1.0f) {
						view.setAlpha(1.0f)
					}

					if (position < minPositionDateHolder) {
						minPositionDateHolder = position
						minDateChild = view
					}
				}
			}
		}

		currentPinnedMessageId = 0

		if (pinnedMessageIds.isNotEmpty()) {
			if (maxVisibleId == Int.MIN_VALUE) {
				maxVisibleId = if (startLoadFromMessageId != 0) {
					startLoadFromMessageId
				}
				else {
					pinnedMessageIds[0] + 1
				}
			}
			else if (maxVisibleId < 0) {
				val idx = messages.indexOf(maxVisibleMessageObject)

				if (idx >= 0) {
					for (a in idx - 1 downTo 0) {
						val `object` = messages[a]

						if (`object`.id > 0) {
							maxVisibleId = `object`.id
							break
						}
					}

					if (maxVisibleId < 0) {
						var a = idx + 1
						val N = messages.size

						while (a < N) {
							val `object` = messages[a]

							if (`object`.id > 0) {
								maxVisibleId = `object`.id
								break
							}

							a++
						}
					}
				}
			}

			currentPinnedMessageId = findClosest(pinnedMessageIds, if (forceNextPinnedMessageId != 0) forceNextPinnedMessageId else maxVisibleId, currentPinnedMessageIndex)

			if (!inMenuMode && !loadingPinnedMessagesList && !pinnedEndReached && pinnedMessageIds.isNotEmpty() && currentPinnedMessageIndex[0] > pinnedMessageIds.size - 2) {
				mediaDataController.loadPinnedMessages(dialogId, pinnedMessageIds[pinnedMessageIds.size - 1], 0)
				loadingPinnedMessagesList = true
			}
		}

		messagesController.addToPollsQueue(dialogId, pollsToCheck)

		if (maxAdapterPosition >= 0 && minAdapterPosition >= 0) {
			var from = minAdapterPosition - chatAdapter!!.messagesStartRow - 10
			var to = maxAdapterPosition - chatAdapter!!.messagesStartRow + 10

			if (from < 0) {
				from = 0
			}

			if (to > messages.size) {
				to = messages.size
			}

			reactionsToCheck.clear()
			extendedMediaToCheck.clear()

			for (i in from until to) {
				val messageObject = messages[i]

				if (threadMessage !== messageObject && messageObject.id > 0 && messageObject.messageOwner?.action == null && currentTime - messageObject.reactionsLastCheckTime > 15000L) {
					messageObject.reactionsLastCheckTime = currentTime
					reactionsToCheck.add(messageObject)
				}

				if (threadMessage !== messageObject && messageObject.id > 0 && messageObject.hasExtendedMediaPreview() && currentTime - messageObject.extendedMediaLastCheckTime > 30000L) {
					messageObject.extendedMediaLastCheckTime = currentTime
					extendedMediaToCheck.add(messageObject)
				}
			}

			messagesController.loadReactionsForMessages(dialogId, reactionsToCheck)
			messagesController.loadExtendedMediaForMessages(dialogId, extendedMediaToCheck)
		}

		if (videoPlayerContainer != null) {
			if (!foundTextureViewMessage) {
				val messageObject = MediaController.getInstance().playingMessageObject

				if (messageObject != null) {
					if (checkTextureViewPosition && messageObject.isVideo) {
						MediaController.getInstance().cleanupPlayer(true, true)
					}
					else {
						videoPlayerContainer?.translationY = (-AndroidUtilities.roundPlayingMessageSize - 100).toFloat()
						fragmentView?.invalidate()

						if ((messageObject.isRoundVideo || messageObject.isVideo) && messageObject.eventId == 0L && checkTextureViewPosition && !chatListView.isFastScrollAnimationRunning) {
							MediaController.getInstance().setCurrentVideoVisible(false)
						}
					}
				}
			}
			else {
				MediaController.getInstance().setCurrentVideoVisible(true)
			}
		}

		if (minMessageChild != null) {
			val messageObject = if (minMessageChild is ChatMessageCell) {
				minMessageChild.getMessageObject()
			}
			else {
				(minMessageChild as? ChatActionCell)?.messageObject
			}

			floatingDateView?.setCustomDate(messageObject?.messageOwner?.date ?: 0, chatMode == MODE_SCHEDULED, true)

		}

		currentFloatingDateOnScreen = false
		currentFloatingTopIsNotMessage = !(minChild is ChatMessageCell || minChild is ChatActionCell)

		if (minDateChild != null) {
			var showFloatingView = false

			if (minDateChild.y > clipTop || currentFloatingTopIsNotMessage) {
				if (minDateChild.alpha != 1.0f) {
					minDateChild.alpha = 1.0f
				}

				if (chatListView.getChildAdapterPosition(minDateChild) == chatAdapter!!.messagesStartRow + messages.size - 1) {
					if (minDateChild.alpha != 1.0f) {
						minDateChild.alpha = 1.0f
					}

					floatingDateAnimation?.cancel()
					floatingDateAnimation = null

					floatingDateView?.tag = null
					floatingDateView?.alpha = 0f

					currentFloatingDateOnScreen = false
				}
				else {
					hideFloatingDateView(!currentFloatingTopIsNotMessage)
				}
			}
			else {
				if (minDateChild.alpha != 0.0f) {
					minDateChild.alpha = 0.0f
				}

				showFloatingView = true
			}

			val offset = minDateChild.y + minDateChild.measuredHeight - clipTop

			if (offset > floatingDateView!!.measuredHeight && offset < floatingDateView!!.measuredHeight * 2) {
				if (chatListView.getChildAdapterPosition(minDateChild) == chatAdapter!!.messagesStartRow + messages.size - 1) {
					showFloatingView = false

					if (minDateChild.alpha != 1.0f) {
						minDateChild.alpha = 1.0f
					}

					floatingDateAnimation?.cancel()
					floatingDateAnimation = null

					floatingDateView?.tag = null
					floatingDateView?.alpha = 0f
				}
				else {
					floatingDateViewOffset = -floatingDateView!!.measuredHeight * 2 + offset
				}
			}
			else {
				floatingDateViewOffset = 0f
			}

			if (showFloatingView) {
				floatingDateAnimation?.cancel()
				floatingDateAnimation = null

				if (floatingDateView?.tag == null) {
					floatingDateView?.tag = 1
				}

				floatingDateView?.alpha = 1.0f

				currentFloatingDateOnScreen = true
			}
		}
		else {
			hideFloatingDateView(true)
			floatingDateViewOffset = 0f
		}

		if (isThreadChat) {
			if (previousThreadMessageVisible != threadMessageVisible) {
				updatePinnedMessageView(openAnimationStartTime != 0L && SystemClock.elapsedRealtime() >= openAnimationStartTime + 150)
			}
		}
		else {
			if (currentPinnedMessageId != 0) {
				var `object` = pinnedMessageObjects[currentPinnedMessageId]

				if (`object` == null) {
					`object` = messagesDict[0][currentPinnedMessageId]
				}

				if (`object` == null) {
					if (loadingPinnedMessages.indexOfKey(currentPinnedMessageId) < 0) {
						loadingPinnedMessages.put(currentPinnedMessageId, true)

						val ids = mutableListOf<Int>()
						ids.add(currentPinnedMessageId)

						mediaDataController.loadPinnedMessages(dialogId, if (isChannel(currentChat)) currentChat!!.id else 0, ids, true)
					}

					currentPinnedMessageId = previousPinnedMessageId
				}
			}
			else if (previousPinnedMessageId != 0 && pinnedMessageIds.isNotEmpty()) {
				currentPinnedMessageId = previousPinnedMessageId
			}

			val animated = fromPullingDownTransition && fragmentView!!.visibility == View.VISIBLE || openAnimationStartTime != 0L && SystemClock.elapsedRealtime() >= openAnimationStartTime + 150

			if (previousPinnedMessageId != currentPinnedMessageId) {
				val animateToNext = if (previousPinnedMessageId == 0) {
					0
				}
				else if (previousPinnedMessageId > currentPinnedMessageId) {
					1
				}
				else {
					2
				}

				updatePinnedMessageView(animated, animateToNext)
			}
			else {
				updatePinnedListButton(animated)
			}
		}

		floatingDateView?.translationY = chatListView.translationY + chatListViewPadding + floatingDateViewOffset - AndroidUtilities.dp(4f)

		invalidateChatListViewTopPadding()

		if (!firstLoading && !paused && !inPreviewMode && chatMode == 0 && !messagesController.ignoreSetOnline) {
			var scheduledRead = 0

			if (maxPositiveUnreadId != Int.MIN_VALUE || maxNegativeUnreadId != Int.MAX_VALUE) {
				var counterDecrement = 0

				for (a in messages.indices) {
					val messageObject = messages[a]
					val id = messageObject.id

					if (maxPositiveUnreadId != Int.MIN_VALUE) {
						if (id in 1..maxPositiveUnreadId && (messageObject.messageOwner!!.from_scheduled && id > currentReadMaxId || messageObject.isUnread && !messageObject.isOut)) {
							if (messageObject.messageOwner!!.from_scheduled) {
								scheduledRead++
							}
							else {
								messageObject.setIsRead()
							}

							counterDecrement++
						}
					}

					if (maxNegativeUnreadId != Int.MAX_VALUE) {
						if (id in maxNegativeUnreadId..-1 && messageObject.isUnread) {
							messageObject.setIsRead()
							counterDecrement++
						}
					}
				}

				if (forwardEndReached[0] && maxPositiveUnreadId == minMessageId[0] || maxNegativeUnreadId == minMessageId[0]) {
					newUnreadMessageCount = 0
				}
				else {
					newUnreadMessageCount -= counterDecrement

					if (newUnreadMessageCount < 0) {
						newUnreadMessageCount = 0
					}
				}

				if (inLayout) {
					AndroidUtilities.runOnUIThread {
						inlineUpdate1()
					}
				}
				else {
					inlineUpdate1()
				}

				messagesController.markDialogAsRead(dialogId, maxPositiveUnreadId, maxNegativeUnreadId, maxUnreadDate, false, threadId, counterDecrement, maxPositiveUnreadId == minMessageId[0] || maxNegativeUnreadId == minMessageId[0], scheduledRead)

				firstUnreadSent = true
			}
			else if (!firstUnreadSent && currentEncryptedChat == null) {
				if (chatLayoutManager!!.findFirstVisibleItemPosition() == 0) {
					newUnreadMessageCount = 0

					if (inLayout) {
						AndroidUtilities.runOnUIThread {
							inlineUpdate2()
						}
					}
					else {
						inlineUpdate2()
					}

					messagesController.markDialogAsRead(dialogId, minMessageId[0], minMessageId[0], maxDate[0], false, threadId, 0, true, scheduledRead)

					firstUnreadSent = true
				}
			}

			if (threadId != 0 && maxPositiveUnreadId > 0 && replyMaxReadId != maxPositiveUnreadId) {
				replyMaxReadId = maxPositiveUnreadId
				messagesStorage.updateRepliesMaxReadId(replyOriginalChat!!.id, replyOriginalMessageId, replyMaxReadId, true)
				notificationCenter.postNotificationName(NotificationCenter.commentsRead, replyOriginalChat!!.id, replyOriginalMessageId, replyMaxReadId)
			}
		}
	}

	private fun inlineUpdate1() {
		if (prevSetUnreadCount != newUnreadMessageCount) {
			prevSetUnreadCount = newUnreadMessageCount
			pagedownButtonCounter?.setCount(newUnreadMessageCount, openAnimationEnded)
		}
	}

	private fun inlineUpdate2() {
		if (prevSetUnreadCount != newUnreadMessageCount) {
			prevSetUnreadCount = newUnreadMessageCount
			pagedownButtonCounter?.setCount(newUnreadMessageCount, true)
		}
	}

	private fun toggleMute(instant: Boolean) {
		val muted = messagesController.isDialogMuted(dialogId)

		if (!muted) {
			if (instant) {
				notificationsController.muteDialog(dialogId, true)
			}
			else {
				val alert = AlertsCreator.createMuteAlert(this, dialogId)
				alert?.setCalcMandatoryInsets(isKeyboardVisible)

				showDialog(alert)
			}
		}
		else {
			notificationsController.muteDialog(dialogId, false)

			if (!instant) {
				BulletinFactory.createMuteBulletin(this, false).show()
			}
		}
	}

	private fun getScrollOffsetForMessage(`object`: MessageObject): Int {
		return getScrollOffsetForMessage(getHeightForMessage(`object`))
	}

	private fun getScrollOffsetForMessage(messageHeight: Int): Int {
		return max(-AndroidUtilities.dp(2f).toFloat(), (chatListView!!.measuredHeight - blurredViewBottomOffset - chatListViewPadding - messageHeight) / 2).toInt()
	}

	private fun getHeightForMessage(`object`: MessageObject?): Int {
		if (dummyMessageCell == null) {
			dummyMessageCell = ChatMessageCell(parentActivity!!)
		}

		dummyMessageCell?.isChat = currentChat != null || isUserSelf(currentUser)
		dummyMessageCell?.isBot = currentUser?.bot == true
		dummyMessageCell?.isMegagroup = isChannel(currentChat) && currentChat?.megagroup == true

		return dummyMessageCell?.computeHeight(`object`, groupedMessagesMap[`object`!!.groupId]) ?: 0
	}

	private fun startMessageUnselect() {
		if (unselectRunnable != null) {
			AndroidUtilities.cancelRunOnUIThread(unselectRunnable)
		}

		unselectRunnable = Runnable {
			highlightMessageId = Int.MAX_VALUE
			updateVisibleRows()
			unselectRunnable = null
		}

		AndroidUtilities.runOnUIThread(unselectRunnable, 1000)
	}

	private fun removeSelectedMessageHighlight() {
		if (unselectRunnable != null) {
			AndroidUtilities.cancelRunOnUIThread(unselectRunnable)
			unselectRunnable = null
		}

		highlightMessageId = Int.MAX_VALUE
	}

	fun scrollToMessageId(id: Int, fromMessageId: Int, select: Boolean, loadIndex: Int, forceScroll: Boolean, forcePinnedMessageId: Int) {
		@Suppress("NAME_SHADOWING") var id = id

		if (id == 0 || NotificationCenter.getInstance(currentAccount).isAnimationInProgress || parentActivity == null) {
			if (NotificationCenter.getInstance(currentAccount).isAnimationInProgress) {
				nextScrollToMessageId = id
				nextScrollFromMessageId = fromMessageId
				nextScrollSelect = select
				nextScrollLoadIndex = loadIndex
				nextScrollForce = forceScroll
				nextScrollForcePinnedMessageId = forcePinnedMessageId

				notificationCenter.doOnIdle {
					if (nextScrollToMessageId != 0) {
						scrollToMessageId(nextScrollToMessageId, nextScrollFromMessageId, nextScrollSelect, nextScrollLoadIndex, nextScrollForce, nextScrollForcePinnedMessageId)
						nextScrollToMessageId = 0
					}
				}
			}

			return
		}

		forceNextPinnedMessageId = abs(forcePinnedMessageId)
		forceScrollToFirst = forcePinnedMessageId > 0
		wasManualScroll = true

		var `object` = messagesDict[loadIndex][id]
		var query = false
		var scrollDirection = RecyclerAnimationScrollHelper.SCROLL_DIRECTION_UNSET
		var scrollFromIndex = 0

		if (fromMessageId != 0) {
			var scrollDown = fromMessageId < id

			if (isSecretChat) {
				scrollDown = !scrollDown
			}

			scrollDirection = if (scrollDown) RecyclerAnimationScrollHelper.SCROLL_DIRECTION_DOWN else RecyclerAnimationScrollHelper.SCROLL_DIRECTION_UP
		}
		else if (messages.size > 0) {
			if (isThreadChat && id == threadId) {
				scrollDirection = RecyclerAnimationScrollHelper.SCROLL_DIRECTION_UP
			}
			else {
				val end = chatLayoutManager!!.findLastVisibleItemPosition()

				for (i in chatLayoutManager!!.findFirstVisibleItemPosition()..end) {
					if (i >= chatAdapter!!.messagesStartRow && i < chatAdapter!!.messagesEndRow) {
						val messageObject = messages[i - chatAdapter!!.messagesStartRow]

						if (messageObject.id == 0) {
							continue
						}

						scrollFromIndex = i - chatAdapter!!.messagesStartRow

						var scrollDown = messageObject.id < id

						if (isSecretChat) {
							scrollDown = !scrollDown
						}

						scrollDirection = if (scrollDown) RecyclerAnimationScrollHelper.SCROLL_DIRECTION_DOWN else RecyclerAnimationScrollHelper.SCROLL_DIRECTION_UP

						break
					}
				}
			}
		}

		chatScrollHelper?.scrollDirection = scrollDirection

		if (`object` != null) {
			val groupedMessages = groupedMessagesMap[`object`.groupId]

			if (`object`.groupId != 0L && groupedMessages != null) {
				val primary = groupedMessages.findPrimaryMessageObject()

				if (primary != null) {
					`object` = primary
				}
			}

			val index = messages.indexOf(`object`)

			if (index != -1) {
				if (scrollFromIndex > 0) {
					scrollDirection = if (scrollFromIndex > index) RecyclerAnimationScrollHelper.SCROLL_DIRECTION_DOWN else RecyclerAnimationScrollHelper.SCROLL_DIRECTION_UP
					chatScrollHelper?.scrollDirection = scrollDirection
				}

				removeSelectedMessageHighlight()

				if (select) {
					highlightMessageId = id
				}

				chatAdapter?.updateRowsSafe()

				val position = chatAdapter!!.messagesStartRow + messages.indexOf(`object`)

				updateVisibleRows()

				var found = false
				val count = chatListView!!.childCount

				for (a in 0 until count) {
					val view = chatListView!!.getChildAt(a)

					if (view is ChatMessageCell) {
						val messageObject = view.getMessageObject()

						if (messageObject != null && messageObject.id == `object`.id) {
							found = true
							view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_FOCUSED)
						}
					}
					else if (view is ChatActionCell) {
						val messageObject = view.messageObject

						if (messageObject != null && messageObject.id == `object`.id) {
							found = true
							view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_FOCUSED)
						}
					}

					if (found) {
						val yOffset = getScrollOffsetForMessage(view.height)
						var scrollY = (view.top - chatListViewPadding - yOffset).toInt()
						var maxScrollOffset = chatListView!!.computeVerticalScrollRange() - chatListView!!.computeVerticalScrollOffset() - chatListView!!.computeVerticalScrollExtent()

						if (maxScrollOffset < 0) {
							maxScrollOffset = 0
						}

						if (scrollY > maxScrollOffset) {
							scrollY = maxScrollOffset
						}

						if (scrollY != 0) {
							scrollByTouch = false
							chatListView?.smoothScrollBy(0, scrollY)
							chatListView?.overScrollMode = View.OVER_SCROLL_NEVER
						}

						break
					}
				}

				if (!found) {
					val yOffset = getScrollOffsetForMessage(`object`)

					chatScrollHelperCallback.scrollTo = `object`
					chatScrollHelperCallback.lastBottom = false
					chatScrollHelperCallback.lastItemOffset = yOffset
					chatScrollHelperCallback.lastPadding = chatListViewPadding.toInt()

					chatScrollHelper?.scrollDirection = scrollDirection
					chatScrollHelper?.scrollToPosition(position, yOffset, false, true)

					canShowPagedownButton = true

					updatePagedownButtonVisibility(true)
				}
			}
			else {
				query = true
			}
		}
		else {
			query = true
		}

		if (query) {
			if (isThreadChat && id == threadId) {
				scrollToThreadMessage = true
				id = 1
			}

			progressDialog?.dismiss()

			showPinnedProgress(forceNextPinnedMessageId != 0)

			progressDialog = AlertDialog(parentActivity!!, 3)

			progressDialog?.setOnShowListener {
				showPinnedProgress(false)
			}

			progressDialog?.setOnCancelListener(postponedScrollCancelListener)
			progressDialog?.showDelayed(400)

			waitingForLoad.clear()

			removeSelectedMessageHighlight()

			scrollToMessagePosition = -10000

			startLoadFromMessageId = id

			showScrollToMessageError = !forceScroll

			if (id == createUnreadMessageAfterId) {
				createUnreadMessageAfterIdLoading = true
			}

			postponedScrollIsCanceled = false

			waitingForLoad.add(lastLoadIndex)

			postponedScrollToLastMessageQueryIndex = lastLoadIndex
			postponedScrollMinMessageId = minMessageId[0]
			postponedScrollMessageId = id

			messagesController.loadMessages(if (loadIndex == 0) dialogId else mergeDialogId, 0, false, if (isThreadChat || AndroidUtilities.isTablet()) 30 else 20, startLoadFromMessageId, 0, true, 0, classGuid, 3, 0, chatMode, threadId, replyMaxReadId, lastLoadIndex++)
		}
		else {
			val child = chatListView?.getChildAt(0)

			if (child != null && child.top <= 0) {
				showFloatingDateView(false)
			}
		}

		returnToMessageId = fromMessageId
		returnToLoadIndex = loadIndex
		needSelectFromMessageId = select
	}

	private fun showPinnedProgress(show: Boolean) {
		if (show) {
			if (updatePinnedProgressRunnable == null) {

				updatePinnedProgressRunnable = Runnable {
					pinnedProgressIsShowing = true
					updatePinnedListButton(true)
				}

				AndroidUtilities.runOnUIThread(updatePinnedProgressRunnable, 100)
			}
		}
		else {
			if (updatePinnedProgressRunnable != null) {
				AndroidUtilities.cancelRunOnUIThread(updatePinnedProgressRunnable)
			}

			updatePinnedProgressRunnable = null
			pinnedProgressIsShowing = false

			updatePinnedListButton(true)
		}
	}

	private fun updatePagedownButtonVisibility(animated: Boolean) {
		@Suppress("NAME_SHADOWING") var animated = animated

		if (pagedownButton == null) {
			return
		}

		val show = canShowPagedownButton && !textSelectionHelper.isSelectionMode && !chatActivityEnterView!!.isRecordingAudioVideo()

		if (show) {
			if (animated && (openAnimationStartTime == 0L || SystemClock.elapsedRealtime() < openAnimationStartTime + 150)) {
				animated = false
			}

			pagedownButtonShowedByScroll = false

			if (pagedownButton?.tag == null) {
				pagedownButtonAnimation?.removeAllListeners()
				pagedownButtonAnimation?.cancel()
				pagedownButtonAnimation = null

				pagedownButton?.tag = 1

				if (animated) {
					pagedownButton?.visible()

					pagedownButtonAnimation = ValueAnimator.ofFloat(pagedownButtonEnterProgress, 1f)

					pagedownButtonAnimation?.addUpdateListener {
						pagedownButtonEnterProgress = it.animatedValue as Float
						contentView?.invalidate()
					}

					pagedownButtonAnimation?.addListener(object : AnimatorListenerAdapter() {
						override fun onAnimationEnd(animation: Animator) {
							pagedownButtonEnterProgress = 1f
							contentView?.invalidate()
						}
					})

					pagedownButtonAnimation?.duration = 200
					pagedownButtonAnimation?.start()
				}
				else {
					pagedownButtonEnterProgress = 1f
					contentView?.invalidate()
					pagedownButton?.visible()
				}
			}
		}
		else {
			returnToMessageId = 0
			newUnreadMessageCount = 0

			if (pagedownButton?.tag != null) {
				pagedownButton?.tag = null

				pagedownButtonAnimation?.removeAllListeners()
				pagedownButtonAnimation?.cancel()
				pagedownButtonAnimation = null

				if (animated) {
					pagedownButton?.visible()

					pagedownButtonAnimation = ValueAnimator.ofFloat(pagedownButtonEnterProgress, 0f)

					pagedownButtonAnimation?.addUpdateListener {
						pagedownButtonEnterProgress = it.animatedValue as Float
						contentView?.invalidate()
					}

					pagedownButtonAnimation?.addListener(object : AnimatorListenerAdapter() {
						override fun onAnimationEnd(animation: Animator) {
							pagedownButtonEnterProgress = 0f
							pagedownButton?.invisible()
							contentView?.invalidate()
						}
					})

					pagedownButtonAnimation?.duration = 200
					pagedownButtonAnimation?.start()
				}
				else {
					pagedownButtonEnterProgress = 0f
					pagedownButton?.invisible()
				}
			}
		}
	}

	private fun showMentionDownButton(show: Boolean, animated: Boolean) {
		if (mentiondownButton == null) {
			return
		}

		if (show) {
			if (mentiondownButton?.tag == null) {
				mentiondownButtonAnimation?.removeAllListeners()
				mentiondownButtonAnimation?.cancel()
				mentiondownButtonAnimation = null

				if (animated) {
					mentiondownButton?.visible()
					mentiondownButton?.tag = 1

					mentiondownButtonAnimation = ValueAnimator.ofFloat(mentionsButtonEnterProgress, 1f)

					mentiondownButtonAnimation?.addUpdateListener {
						mentionsButtonEnterProgress = it.animatedValue as Float
						contentView?.invalidate()
					}

					mentiondownButtonAnimation?.addListener(object : AnimatorListenerAdapter() {
						override fun onAnimationEnd(animation: Animator) {
							mentionsButtonEnterProgress = 1f
							contentView?.invalidate()
						}
					})

					mentiondownButtonAnimation?.duration = 200
					mentiondownButtonAnimation?.start()
				}
				else {
					mentionsButtonEnterProgress = 1f
					contentView?.invalidate()
				}
			}
		}
		else {
			returnToMessageId = 0

			if (mentiondownButton?.tag != null) {
				mentiondownButton?.tag = null

				mentiondownButtonAnimation?.removeAllListeners()
				mentiondownButtonAnimation?.cancel()
				mentiondownButtonAnimation = null

				if (animated) {
					mentiondownButtonAnimation = ValueAnimator.ofFloat(mentionsButtonEnterProgress, 0f)

					mentiondownButtonAnimation?.addUpdateListener {
						mentionsButtonEnterProgress = it.animatedValue as Float
						contentView?.invalidate()
					}

					mentiondownButtonAnimation?.addListener(object : AnimatorListenerAdapter() {
						override fun onAnimationEnd(animation: Animator) {
							mentionsButtonEnterProgress = 0f
							mentiondownButton?.invisible()
							contentView?.invalidate()
						}
					})

					mentiondownButtonAnimation?.duration = 200
					mentiondownButtonAnimation?.start()
				}
				else {
					mentionsButtonEnterProgress = 0f
					mentiondownButton?.invisible()
				}
			}
		}
	}

	private fun updateSecretStatus() {
		if (bottomOverlay == null) {
			return
		}

		var hideKeyboard = false

		if (currentChat != null && !canSendMessages(currentChat) && !currentChat!!.gigagroup && (!isChannel(currentChat) || currentChat!!.megagroup)) {
			if (currentChat?.default_banned_rights != null && currentChat!!.default_banned_rights.send_messages) {
				bottomOverlayText?.text = context!!.getString(R.string.GlobalSendMessageRestricted)
			}
			else if (AndroidUtilities.isBannedForever(currentChat!!.banned_rights)) {
				bottomOverlayText?.text = context!!.getString(R.string.SendMessageRestrictedForever)
			}
			else {
				bottomOverlayText?.text = LocaleController.formatString("SendMessageRestricted", R.string.SendMessageRestricted, LocaleController.formatDateForBan(currentChat!!.banned_rights.until_date.toLong()))
			}

			bottomOverlay?.visible()

			chatActivityEnterView?.gone()

			mentionListAnimation?.cancel()
			mentionListAnimation = null

			mentionContainer?.gone()
			mentionContainer?.tag = null

			updateMessageListAccessibilityVisibility()

			hideKeyboard = true

			suggestEmojiPanel?.forceClose()
		}
		else {
			if (currentEncryptedChat == null || bigEmptyView == null) {
				bottomOverlay?.invisible()

				if (chatActivityEnterView != null) {
					if (bottomOverlayChat != null && bottomOverlayChat!!.visibility == View.VISIBLE) {
						chatActivityEnterView?.invisible()
					}
					else {
						chatActivityEnterView?.visible()
					}
				}

				if (chatActivityEnterView?.hasText() == true) {
					suggestEmojiPanel?.fireUpdate()
				}

				return
			}

			if (currentEncryptedChat is TL_encryptedChatRequested) {
				bottomOverlayText?.text = context!!.getString(R.string.EncryptionProcessing)
				bottomOverlay?.visible()
				chatActivityEnterView?.invisible()

				hideKeyboard = true
			}
			else if (currentEncryptedChat is TL_encryptedChatWaiting) {
				bottomOverlayText?.text = AndroidUtilities.replaceTags(LocaleController.formatString("AwaitingEncryption", R.string.AwaitingEncryption, "<b>" + currentUser!!.first_name + "</b>"))
				bottomOverlay?.visible()
				chatActivityEnterView?.invisible()

				hideKeyboard = true
			}
			else if (currentEncryptedChat is TL_encryptedChatDiscarded) {
				bottomOverlayText?.text = context!!.getString(R.string.EncryptionRejected)

				bottomOverlay?.visible()
				chatActivityEnterView?.invisible()

				chatActivityEnterView?.fieldText = ""

				mediaDataController.cleanDraft(dialogId, threadId, false)

				hideKeyboard = true
			}
			else if (currentEncryptedChat is TL_encryptedChat) {
				bottomOverlay?.invisible()

				if (!inPreviewMode) {
					chatActivityEnterView?.visible()
				}
			}

			checkRaiseSensors()
			checkActionBarMenu(false)
		}

		if (inPreviewMode) {
			bottomOverlay?.invisible()
		}

		if (hideKeyboard) {
			chatActivityEnterView?.hidePopup(false)

			parentActivity?.let {
				AndroidUtilities.hideKeyboard(it.currentFocus)
			}
		}
	}

	override fun onRequestPermissionsResultFragment(requestCode: Int, permissions: Array<String?>?, grantResults: IntArray?) {
		chatActivityEnterView?.onRequestPermissionsResultFragment(requestCode, grantResults)
		mentionContainer?.adapter?.onRequestPermissionsResultFragment(requestCode, grantResults)

		if (requestCode == BasePermissionsActivity.REQUEST_CODE_EXTERNAL_STORAGE && chatAttachAlert != null) {
			chatAttachAlert?.photoLayout?.checkStorage()
		}
		else if (requestCode == 30 && chatAttachAlert != null) {
			chatAttachAlert?.onRequestPermissionsResultFragment(requestCode)
		}
		else if ((requestCode == 17 || requestCode == 18) && chatAttachAlert != null) {
			chatAttachAlert?.photoLayout?.checkCamera(grantResults?.firstOrNull() == PackageManager.PERMISSION_GRANTED)
			chatAttachAlert?.photoLayout?.checkStorage()
		}
		else if (requestCode == ChatAttachAlert.REQUEST_CODE_ATTACH_FILE) {
			val parentActivity = parentActivity ?: return

			if (grantResults != null && grantResults.isNotEmpty() && grantResults.firstOrNull() != PackageManager.PERMISSION_GRANTED) {
				val builder = AlertDialog.Builder(parentActivity)
				builder.setTitle(parentActivity.getString(R.string.AppName))
				builder.setMessage(parentActivity.getString(R.string.PermissionNoAudioVideoWithHint))

				builder.setNegativeButton(parentActivity.getString(R.string.PermissionOpenSettings)) { _, _ ->
					try {
						val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
						intent.data = Uri.parse("package:" + ApplicationLoader.applicationContext.packageName)
						parentActivity.startActivity(intent)
					}
					catch (e: Exception) {
						FileLog.e(e)
					}
				}

				builder.setPositiveButton(parentActivity.getString(R.string.OK), null)
				builder.show()
			}
		}
		else if (requestCode == 19 && grantResults != null && grantResults.firstOrNull() == PackageManager.PERMISSION_GRANTED) {
			processSelectedAttach(attach_photo)
		}
		else if (requestCode == BasePermissionsActivity.REQUEST_CODE_OPEN_CAMERA && grantResults != null && grantResults.firstOrNull() == PackageManager.PERMISSION_GRANTED) {
			processSelectedAttach(attach_video)
		}
		else if ((requestCode == 101 || requestCode == 102) && currentUser != null || requestCode == 103 && currentChat != null) {
			val parentActivity = parentActivity ?: return
			val allGranted = grantResults != null && grantResults.isNotEmpty() && grantResults.firstOrNull { it != PackageManager.PERMISSION_GRANTED } == null

			if (allGranted) {
				if (requestCode == 103) {
					val currentChat = currentChat ?: return
					startCall(currentChat, null, createGroupCall, parentActivity, this@ChatActivity, accountInstance)
				}
				else {
					val currentUser = currentUser ?: return
					startCall(currentUser, requestCode == 102, currentUserInfo?.video_calls_available == true, parentActivity, messagesController.getUserFull(currentUser.id), accountInstance)
				}
			}
			else {
				permissionDenied(parentActivity, null, requestCode)
			}
		}
	}

	private fun checkActionBarMenu(animated: Boolean) {
		if (currentEncryptedChat != null && currentEncryptedChat !is TL_encryptedChat || currentChat != null && (chatMode != 0 || threadId != 0 || currentChatInfo == null || currentChatInfo!!.ttl_period == 0) || currentUser != null && (isDeleted(currentUser) || currentEncryptedChat == null && (currentUserInfo == null || currentUserInfo!!.ttl_period == 0))) {
			timeItem2?.gone()
			avatarContainer?.hideTimeItem(animated)
		}
		else {
			timeItem2?.visible()
			avatarContainer?.showTimeItem(animated)
		}

		if (avatarContainer != null) {
			if (currentEncryptedChat != null) {
				avatarContainer?.setTime(currentEncryptedChat!!.ttl, animated)
			}
			else if (currentUserInfo != null) {
				avatarContainer?.setTime(currentUserInfo!!.ttl_period, animated)
			}
			else if (currentChatInfo != null) {
				avatarContainer?.setTime(currentChatInfo!!.ttl_period, animated)
			}
		}

		if (clearHistoryItem != null && currentChatInfo != null) {
			val visible = currentChatInfo!!.can_delete_channel || !isChannel(currentChat) || currentChat!!.megagroup && TextUtils.isEmpty(currentChat!!.username)
			clearHistoryItem?.visibility = if (visible) View.VISIBLE else View.GONE
		}

		checkAndUpdateAvatar()
	}

	private fun getMessageType(messageObject: MessageObject?): Int {
		if (messageObject == null) {
			return -1
		}

		return if (currentEncryptedChat == null) {
			if (messageObject.isEditing) {
				-1
			}
			else if (messageObject.id <= 0 && messageObject.isOut) {
				if (messageObject.isSendError) {
					if (!messageObject.isMediaEmpty) {
						0
					}
					else {
						20
					}
				}
				else {
					-1
				}
			}
			else {
				if (messageObject.isAnimatedEmoji) {
					2
				}
				else if (messageObject.type == 6) {
					-1
				}
				else if (messageObject.type == 10 || messageObject.type == 11) {
					if (messageObject.id == 0) {
						-1
					}
					else {
						1
					}
				}
				else {
					if (messageObject.isVoice) {
						return 2
					}
					else if (messageObject.isSticker || messageObject.isAnimatedSticker) {
						val inputStickerSet = messageObject.inputStickerSet

						if (inputStickerSet is TL_inputStickerSetID) {
							if (!mediaDataController.isStickerPackInstalled(inputStickerSet.id)) {
								return 7
							}
						}
						else if (inputStickerSet is TL_inputStickerSetShortName) {
							if (!mediaDataController.isStickerPackInstalled(inputStickerSet.short_name)) {
								return 7
							}
						}
						return 9
					}
					else if (!messageObject.isRoundVideo && (messageObject.messageOwner?.media is TL_messageMediaPhoto || messageObject.document != null || messageObject.isMusic || messageObject.isVideo)) {
						var canSave = false
						val path = messageObject.messageOwner?.attachPath

						if (!path.isNullOrEmpty()) {
							val f = File(path)

							if (f.exists()) {
								canSave = true
							}
						}

						if (!canSave) {
							if (messageObject.mediaExists) {
								canSave = true
							}
						}

						if (canSave) {
							if (messageObject.document != null && !messageObject.isMusic) {
								val mime = messageObject.document?.mime_type

								if (mime != null) {
									if (messageObject.documentName?.lowercase()?.endsWith("attheme") == true) {
										return 10
									}
									else if (mime.endsWith("/xml")) {
										return 5
									}
									else if (!messageObject.isNewGif && mime.endsWith("/mp4") || mime.endsWith("/png") || mime.endsWith("/jpg") || mime.endsWith("/jpeg")) {
										return 6
									}
								}
							}

							return 4
						}
					}
					else if (messageObject.type == 12) {
						return 8
					}
					else if (messageObject.isMediaEmpty) {
						return 3
					}
					2
				}
			}
		}
		else {
			if (messageObject.isSending) {
				return -1
			}
			if (messageObject.isAnimatedEmoji) {
				2
			}
			else if (messageObject.type == 6) {
				-1
			}
			else if (messageObject.isSendError) {
				if (!messageObject.isMediaEmpty) {
					0
				}
				else {
					20
				}
			}
			else if (messageObject.type == 10 || messageObject.type == 11) {
				if (messageObject.id == 0 || messageObject.isSending) {
					-1
				}
				else {
					1
				}
			}
			else {
				if (messageObject.isVoice) {
					return 2
				}
				else if (!messageObject.isAnimatedEmoji && (messageObject.isSticker || messageObject.isAnimatedSticker)) {
					val inputStickerSet = messageObject.inputStickerSet

					if (inputStickerSet is TL_inputStickerSetShortName) {
						if (!mediaDataController.isStickerPackInstalled(inputStickerSet.short_name)) {
							return 7
						}
					}
				}
				else if (!messageObject.isRoundVideo && (messageObject.messageOwner?.media is TL_messageMediaPhoto || messageObject.document != null || messageObject.isMusic || messageObject.isVideo)) {
					var canSave = false
					val path = messageObject.messageOwner?.attachPath

					if (!path.isNullOrEmpty()) {
						val f = File(path)

						if (f.exists()) {
							canSave = true
						}
					}

					if (!canSave) {
						val f = FileLoader.getInstance(currentAccount).getPathToMessage(messageObject.messageOwner)

						if (f.exists()) {
							canSave = true
						}
					}

					if (canSave) {
						if (messageObject.document != null) {
							val mime = messageObject.document?.mime_type

							if (mime != null && mime.endsWith("text/xml")) {
								return 5
							}
						}

						if (messageObject.messageOwner!!.ttl <= 0) {
							return 4
						}
					}
				}
				else if (messageObject.type == 12) {
					return 8
				}
				else if (messageObject.isMediaEmpty) {
					return 3
				}

				2
			}
		}
	}

	private fun addToSelectedMessages(messageObject: MessageObject?, outside: Boolean, last: Boolean = true) {
		val prevCantForwardCount = cantForwardMessagesCount

		if (messageObject != null) {
			if (threadMessageObjects?.contains(messageObject) == true) {
				return
			}

			val index = if (messageObject.dialogId == dialogId) 0 else 1

			if (outside && messageObject.groupId != 0L) {
				var hasUnselected = false
				val groupedMessages = groupedMessagesMap[messageObject.groupId]

				if (groupedMessages != null) {
					var lastNum = 0

					for (a in groupedMessages.messages.indices) {
						val message = groupedMessages.messages[a]

						if (selectedMessagesIds[index].indexOfKey(message.id) < 0) {
							hasUnselected = true
							lastNum = a
						}
					}

					for (a in groupedMessages.messages.indices) {
						val message = groupedMessages.messages[a]

						if (hasUnselected) {
							if (selectedMessagesIds[index].indexOfKey(message.id) < 0) {
								addToSelectedMessages(message, false, a == lastNum)
							}
						}
						else {
							addToSelectedMessages(message, false, a == groupedMessages.messages.size - 1)
						}

						if (!message.caption.isNullOrEmpty()) {
							showTextSelectionHint(messageObject)
						}
					}
				}

				return
			}

			if (selectedMessagesIds[index].indexOfKey(messageObject.id) >= 0) {
				selectedMessagesIds[index].remove(messageObject.id)

				if (reportType < 0) {
					if ((messageObject.type == MessageObject.TYPE_COMMON || messageObject.isAnimatedEmoji || messageObject.caption != null) && !(messageObject.messageOwner != null && messageObject.messageOwner!!.noforwards)) {
						selectedMessagesCanCopyIds[index].remove(messageObject.id)
					}

					if (!messageObject.isAnimatedEmoji && (messageObject.isSticker || messageObject.isAnimatedSticker) && MessageObject.isStickerHasSet(messageObject.document)) {
						selectedMessagesCanStarIds[index].remove(messageObject.id)
					}

					if (messageObject.canEditMessage(currentChat)) {
						canEditMessagesCount--
					}

					if (!messageObject.canDeleteMessage(chatMode == MODE_SCHEDULED, currentChat)) {
						cantDeleteMessagesCount--
					}

					val noforwards = messagesController.isChatNoForwards(currentChat)

					if (chatMode == MODE_SCHEDULED || !messageObject.canForwardMessage() || noforwards) {
						cantForwardMessagesCount--
					}
					else {
						canForwardMessagesCount--
					}

					if (messageObject.isMusic && !noforwards) {
						canSaveMusicCount--
					}
					else if (messageObject.isDocument() && !noforwards) {
						canSaveDocumentsCount--
					}
					else {
						cantSaveMessagesCount--
					}
				}
			}
			else {
				if (selectedMessagesIds[0].size() + selectedMessagesIds[1].size() >= 100) {
					AndroidUtilities.shakeView(selectedMessagesCountTextView, 2f, 0)
					ApplicationLoader.applicationContext.vibrate()
					return
				}

				selectedMessagesIds[index].put(messageObject.id, messageObject)

				if (reportType < 0) {
					if ((messageObject.type == MessageObject.TYPE_COMMON || messageObject.isAnimatedEmoji || messageObject.caption != null) && !(messageObject.messageOwner != null && messageObject.messageOwner!!.noforwards)) {
						selectedMessagesCanCopyIds[index].put(messageObject.id, messageObject)
					}

					if (!messageObject.isAnimatedEmoji && (messageObject.isSticker || messageObject.isAnimatedSticker) && MessageObject.isStickerHasSet(messageObject.document)) {
						selectedMessagesCanStarIds[index].put(messageObject.id, messageObject)
					}

					if (messageObject.canEditMessage(currentChat)) {
						canEditMessagesCount++
					}

					if (!messageObject.canDeleteMessage(chatMode == MODE_SCHEDULED, currentChat)) {
						cantDeleteMessagesCount++
					}

					val noforwards = messagesController.isChatNoForwards(currentChat)

					if (chatMode == MODE_SCHEDULED || !messageObject.canForwardMessage() || noforwards) {
						cantForwardMessagesCount++
					}
					else {
						canForwardMessagesCount++
					}

					if (messageObject.isMusic && !noforwards) {
						canSaveMusicCount++
					}
					else if (messageObject.isDocument() && !noforwards) {
						canSaveDocumentsCount++
					}
					else {
						cantSaveMessagesCount++
					}

					if (outside) {
						showTextSelectionHint(messageObject)
					}
				}
			}
		}

		forwardButtonAnimation?.cancel()
		forwardButtonAnimation = null

		if (last && actionBar!!.isActionModeShowed && reportType < 0) {
			val selectedCount = selectedMessagesIds[0].size() + selectedMessagesIds[1].size()

			if (selectedCount == 0) {
				hideActionMode()
				updatePinnedMessageView(true)
			}
			else {
				val saveItem = actionBar!!.createActionMode().getItem(save_to)
				val copyItem = actionBar!!.createActionMode().getItem(copy)
				val starItem = actionBar!!.createActionMode().getItem(star)
				val editItem = actionBar!!.createActionMode().getItem(edit)
				val forwardItem = actionBar!!.createActionMode().getItem(forward)
				val noforwards = messagesController.isChatNoForwards(currentChat) || hasSelectedNoforwardsMessage()

				if (prevCantForwardCount == 0 && cantForwardMessagesCount != 0 || prevCantForwardCount != 0 && cantForwardMessagesCount == 0) {
					forwardButtonAnimation = AnimatorSet()

					val animators = mutableListOf<Animator>()

					if (forwardItem != null) {
						forwardItem.isEnabled = cantForwardMessagesCount == 0 || noforwards

						animators.add(ObjectAnimator.ofFloat(forwardItem, View.ALPHA, if (cantForwardMessagesCount == 0) 1.0f else 0.5f))

						if (noforwards && forwardItem.background != null) {
							forwardItem.background = null
						}
						else if (forwardItem.background == null) {
							forwardItem.background = Theme.createSelectorDrawable(context!!.getColor(R.color.light_background), 5)
						}
					}

					if (forwardButton != null) {
						forwardButton?.isEnabled = cantForwardMessagesCount == 0 || noforwards

						if (noforwards && forwardButton?.background != null) {
							forwardButton?.background = null
						}
						else if (forwardButton?.background == null) {
							forwardButton?.background = Theme.createSelectorDrawable(context!!.getColor(R.color.light_background), 3)
						}

						animators.add(ObjectAnimator.ofFloat(forwardButton, View.ALPHA, if (cantForwardMessagesCount == 0) 1.0f else 0.5f))
					}

					forwardButtonAnimation?.playTogether(animators)
					forwardButtonAnimation?.duration = 100

					forwardButtonAnimation?.addListener(object : AnimatorListenerAdapter() {
						override fun onAnimationEnd(animation: Animator) {
							forwardButtonAnimation = null
						}
					})

					forwardButtonAnimation?.start()
				}
				else {
					if (forwardItem != null) {
						forwardItem.isEnabled = cantForwardMessagesCount == 0 || noforwards
						forwardItem.alpha = if (cantForwardMessagesCount == 0) 1.0f else 0.5f

						if (noforwards) {
							if (forwardItem.background != null) {
								forwardButton?.background = null
							}
						}
						else if (forwardItem.background == null) {
							forwardItem.background = Theme.createSelectorDrawable(context!!.getColor(R.color.light_background), 3)
						}
					}

					if (forwardButton != null) {
						forwardButton?.isEnabled = cantForwardMessagesCount == 0 || noforwards

						if (noforwards) {
							forwardButton?.background = null
						}
						else if (forwardButton?.background == null) {
							forwardButton?.background = Theme.createSelectorDrawable(context!!.getColor(R.color.light_background), 3)
						}

						forwardButton?.alpha = if (cantForwardMessagesCount == 0) 1.0f else 0.5f
					}
				}

				if (saveItem != null) {
					saveItem.visibility = if ((canSaveMusicCount > 0 && canSaveDocumentsCount == 0 || canSaveMusicCount == 0 && canSaveDocumentsCount > 0) && cantSaveMessagesCount == 0) View.VISIBLE else View.GONE
					saveItem.contentDescription = if (canSaveMusicCount > 0) context!!.getString(R.string.SaveToMusic) else context!!.getString(R.string.SaveToDownloads)
				}

				val copyVisible = copyItem!!.visibility
				val starVisible = starItem!!.visibility

				copyItem.visibility = if (!noforwards && selectedMessagesCanCopyIds[0].size() + selectedMessagesCanCopyIds[1].size() != 0) View.VISIBLE else View.GONE
				starItem.visibility = if (mediaDataController.canAddStickerToFavorites() && selectedMessagesCanStarIds[0].size() + selectedMessagesCanStarIds[1].size() == selectedCount) View.VISIBLE else View.GONE

				val newCopyVisible = copyItem.visibility
				val newStarVisible = starItem.visibility
				val deleteItem = actionBar!!.createActionMode().getItem(delete)

				if (deleteItem != null) {
					deleteItem.visibility = if (cantDeleteMessagesCount == 0) View.VISIBLE else View.GONE
				}

				hasUnfavedSelected = false

				for (a in 0..1) {
					for (b in 0 until selectedMessagesCanStarIds[a].size()) {
						val msg = selectedMessagesCanStarIds[a].valueAt(b)

						if (!mediaDataController.isStickerInFavorites(msg.document)) {
							hasUnfavedSelected = true
							break
						}
					}

					if (hasUnfavedSelected) {
						break
					}
				}

				starItem.setIcon(if (hasUnfavedSelected) R.drawable.msg_fave else R.drawable.msg_unfave)

				val newEditVisibility = if (canEditMessagesCount == 1 && selectedCount == 1) View.VISIBLE else View.GONE

				if (replyButton != null) {
					var allowChatActions = true

					if (bottomOverlayChat != null && bottomOverlayChat!!.visibility == View.VISIBLE || currentChat != null && (isNotInChat(currentChat) && !isThreadChat || isChannel(currentChat) && !canPost(currentChat) && !currentChat!!.megagroup || !canSendMessages(currentChat))) {
						allowChatActions = false
					}

					var newVisibility: Int

					if (chatMode == MODE_SCHEDULED || !allowChatActions || selectedMessagesIds[0].size() != 0 && selectedMessagesIds[1].size() != 0) {
						newVisibility = View.GONE
					}
					else if (selectedCount == 1) {
						newVisibility = View.VISIBLE
					}
					else {
						newVisibility = View.VISIBLE

						var lastGroupId: Long = 0

						for (a in 0..1) {
							var b = 0
							val N = selectedMessagesIds[a].size()

							while (b < N) {
								val message = selectedMessagesIds[a].valueAt(b)
								val groupId = message!!.groupId

								if (groupId == 0L || lastGroupId != 0L && lastGroupId != groupId) {
									newVisibility = View.GONE
									break
								}

								lastGroupId = groupId

								b++
							}

							if (newVisibility == View.GONE) {
								break
							}
						}
					}

					if (threadMessageObjects != null && newVisibility == View.VISIBLE) {
						var b = 0
						val N = selectedMessagesIds[0].size()

						while (b < N) {
							val message = selectedMessagesIds[0].valueAt(b)

							if (threadMessageObjects!!.contains(message)) {
								newVisibility = View.GONE
							}

							b++
						}
					}

					if (replyButton?.visibility != newVisibility) {
						replyButtonAnimation?.cancel()

						replyButtonAnimation = AnimatorSet()

						if (newVisibility == View.VISIBLE) {
							replyButton?.visibility = View.VISIBLE

							replyButtonAnimation?.playTogether(ObjectAnimator.ofFloat(replyButton, View.ALPHA, 1.0f), ObjectAnimator.ofFloat(replyButton, View.SCALE_Y, 1.0f))
						}
						else {
							replyButtonAnimation?.playTogether(ObjectAnimator.ofFloat(replyButton, View.ALPHA, 0.0f), ObjectAnimator.ofFloat(replyButton, View.SCALE_Y, 0.0f))
						}

						replyButtonAnimation?.duration = 100

						val newVisibilityFinal = newVisibility

						replyButtonAnimation?.addListener(object : AnimatorListenerAdapter() {
							override fun onAnimationEnd(animation: Animator) {
								if (replyButtonAnimation != null && replyButtonAnimation == animation) {
									if (newVisibilityFinal == View.GONE) {
										replyButton?.gone()
									}
								}
							}

							override fun onAnimationCancel(animation: Animator) {
								if (replyButtonAnimation != null && replyButtonAnimation == animation) {
									replyButtonAnimation = null
								}
							}
						})

						replyButtonAnimation?.start()
					}
				}

				if (editItem != null) {
					if (copyVisible != newCopyVisible || starVisible != newStarVisible) {
						if (newEditVisibility == View.VISIBLE) {
							editItem.alpha = 1.0f
							editItem.scaleX = 1.0f
						}
						else {
							editItem.alpha = 0.0f
							editItem.scaleX = 0.0f
						}

						editItem.visibility = newEditVisibility
					}
					else if (editItem.visibility != newEditVisibility) {
						editButtonAnimation?.cancel()

						editButtonAnimation = AnimatorSet()

						editItem.pivotX = AndroidUtilities.dp(54f).toFloat()
						editItem.pivotX = AndroidUtilities.dp(54f).toFloat()

						if (newEditVisibility == View.VISIBLE) {
							editItem.visibility = View.VISIBLE

							editButtonAnimation?.playTogether(ObjectAnimator.ofFloat(editItem, View.ALPHA, 1.0f), ObjectAnimator.ofFloat(editItem, View.SCALE_X, 1.0f))
						}
						else {
							editButtonAnimation?.playTogether(ObjectAnimator.ofFloat(editItem, View.ALPHA, 0.0f), ObjectAnimator.ofFloat(editItem, View.SCALE_X, 0.0f))
						}

						editButtonAnimation?.duration = 100

						editButtonAnimation?.addListener(object : AnimatorListenerAdapter() {
							override fun onAnimationEnd(animation: Animator) {
								if (editButtonAnimation != null && editButtonAnimation == animation) {
									if (newEditVisibility == View.GONE) {
										editItem.gone()
									}
								}
							}

							override fun onAnimationCancel(animation: Animator) {
								if (editButtonAnimation != null && editButtonAnimation == animation) {
									editButtonAnimation = null
								}
							}
						})

						editButtonAnimation?.start()
					}
				}
			}
		}
	}

	private fun processRowSelect(view: View, outside: Boolean, touchX: Float, touchY: Float) {
		var message: MessageObject? = null

		if (view is ChatMessageCell) {
			message = view.getMessageObject()
			view.setLastTouchCoordinates(touchX, touchY)
		}
		else if (view is ChatActionCell) {
			message = view.messageObject
		}

		val type = getMessageType(message)

		if (type < 2 || type == 20) {
			return
		}

		addToSelectedMessages(message, outside)
		updateActionModeTitle()
		updateVisibleRows()
	}

	private fun updateActionModeTitle() {
		if (reportType < 0) {
			if (!actionBar!!.isActionModeShowed) {
				return
			}

			if (selectedMessagesIds[0].size() != 0 || selectedMessagesIds[1].size() != 0) {
				selectedMessagesCountTextView?.setNumber(selectedMessagesIds[0].size() + selectedMessagesIds[1].size(), true)
			}
		}
		else {
			val size = selectedMessagesIds[0].size() + selectedMessagesIds[1].size()

			if (size == 0) {
				bottomOverlayChatText?.text = context!!.getString(R.string.ReportMessages)
				bottomOverlayChatText?.alpha = 0.5f
				bottomOverlayChatText?.isEnabled = false
			}
			else {
				bottomOverlayChatText?.text = LocaleController.formatString("ReportMessagesCount", R.string.ReportMessagesCount, LocaleController.formatPluralString("messages", size)).uppercase(Locale.getDefault())
				bottomOverlayChatText?.alpha = 1.0f
				bottomOverlayChatText?.isEnabled = true
			}
		}
	}

	fun updateTitle(animated: Boolean) {
		if (avatarContainer == null) {
			return
		}

		val isMuted = messagesController.isDialogMuted(dialogId)

		if (isThreadChat) {
			if (isComments) {
				if (threadMessage?.hasReplies() == true) {
					avatarContainer?.setTitle(LocaleController.formatPluralString("Comments", threadMessage!!.repliesCount))
				}
				else {
					avatarContainer?.setTitle(context!!.getString(R.string.CommentsTitle))
				}
			}
			else {
				avatarContainer?.setTitle(LocaleController.formatPluralString("Replies", threadMessage!!.repliesCount))
			}
		}
		else if (isReplyUser(currentUser)) {
			avatarContainer?.setTitle(context!!.getString(R.string.RepliesTitle))
		}
		else if (chatMode == MODE_SCHEDULED) {
			if (isUserSelf(currentUser)) {
				avatarContainer?.setTitle(context!!.getString(R.string.Reminders))
			}
			else {
				avatarContainer?.setTitle(context!!.getString(R.string.ScheduledMessages))
			}
		}
		else if (chatMode == MODE_PINNED) {
			avatarContainer?.setTitle(LocaleController.formatPluralString("PinnedMessagesCount", pinnedMessagesCount))
		}
		else if (currentChat != null) {
			avatarContainer?.setTitle(currentChat!!.title, currentChat!!.scam, currentChat!!.fake, false, null, animated)
			avatarContainer?.setVerifiedMuteIcon(isMuted, currentUser?.verified == true || currentChat?.verified == true, dialogId)
		}
		else if (currentUser != null) {
			if (currentUser?.self == true) {
				avatarContainer?.setTitle(context!!.getString(R.string.SavedMessages))
			}
			else if (!MessagesController.isSupportUser(currentUser) && contactsController.contactsDict[currentUser!!.id] == null && (contactsController.contactsDict.size != 0 || !contactsController.isLoadingContacts())) {
				avatarContainer?.setTitle(getUserName(currentUser), currentUser!!.scam, currentUser!!.fake, messagesController.isPremiumUser(currentUser), currentUser!!.emoji_status, animated)
				avatarContainer?.setVerifiedMuteIcon(isMuted, currentUser?.verified == true || currentChat?.verified == true, dialogId)
			}
			else {
				avatarContainer?.setTitle(getUserName(currentUser), currentUser!!.scam, currentUser!!.fake, messagesController.isPremiumUser(currentUser), currentUser!!.emoji_status, animated)
				avatarContainer?.setVerifiedMuteIcon(isMuted, currentUser?.verified == true || currentChat?.verified == true, dialogId)
			}
		}

		setParentActivityTitle(avatarContainer?.titleTextView?.getText())
	}

	private val pinnedMessagesCount: Int
		get() = max(loadedPinnedMessagesCount, totalPinnedMessagesCount)

	private fun updateBotButtons() {
		if (headerItem == null || currentUser == null || currentEncryptedChat != null || !currentUser!!.bot) {
			return
		}

		var hasHelp = false
		var hasSettings = false

		if (botInfo.size() != 0) {
			for (b in 0 until botInfo.size()) {
				val info = botInfo.valueAt(b)

				for (a in info.commands.indices) {
					val command = info.commands[a]

					if (command.command.equals("help", ignoreCase = true)) {
						hasHelp = true
					}
					else if (command.command.equals("settings", ignoreCase = true)) {
						hasSettings = true
					}

					if (hasSettings && hasHelp) {
						break
					}
				}
			}
		}

		if (hasHelp) {
			headerItem?.showSubItem(bot_help)
		}
		else {
			headerItem?.hideSubItem(bot_help)
		}

		if (hasSettings) {
			headerItem?.showSubItem(bot_settings)
		}
		else {
			headerItem?.hideSubItem(bot_settings)
		}
	}

	private fun updateTitleIcons(forceToggleMuted: Boolean = false) {
		if (avatarContainer == null || chatMode != 0) {
			return
		}

		var isMuted = messagesController.isDialogMuted(dialogId)

		if (forceToggleMuted) {
			isMuted = !isMuted
		}

		val combinedDrawable = createCombinedChatPropertiesDrawable(currentChat, context!!)

		avatarContainer?.titleTextView?.setLeftDrawableTopPadding(AndroidUtilities.dp(1f))
		avatarContainer?.setTitleIcons(combinedDrawable)
		avatarContainer?.setVerifiedMuteIcon(isMuted, currentUser?.verified == true || currentChat?.verified == true, dialogId)

		if (!forceToggleMuted && muteItem != null) {
			if (isMuted) {
				muteItem?.rightIcon?.gone()
				muteItem?.setTextAndIcon(context!!.getString(R.string.Unmute), R.drawable.msg_mute)
			}
			else {
				muteItem?.rightIcon?.visible()

				if (messagesController.isDialogNotificationsSoundEnabled(dialogId)) {
					muteItem?.setTextAndIcon(context!!.getString(R.string.Mute), R.drawable.msg_unmute)
				}
				else {
					muteItem?.setTextAndIcon(context!!.getString(R.string.Mute), R.drawable.msg_silent)
				}
			}
		}

		chatNotificationsPopupWrapper?.update(dialogId)
	}

	fun checkAndUpdateAvatar() {
		if (currentUser != null) {
			val user = messagesController.getUser(currentUser!!.id) ?: return
			currentUser = user
		}
		else if (currentChat != null) {
			val chat = messagesController.getChat(currentChat!!.id) ?: return
			currentChat = chat
		}

		avatarContainer?.checkAndUpdateAvatar()
	}

	fun openVideoEditor(videoPath: String?, caption: String?) {
		if (parentActivity != null) {
			val thumb = createVideoThumbnail(videoPath!!, MediaStore.Video.Thumbnails.MINI_KIND)

			PhotoViewer.getInstance().setParentActivity(this)

			val cameraPhoto = mutableListOf<Any>()

			val entry = PhotoEntry(0, 0, 0, videoPath, 0, true, 0, 0, 0)
			entry.caption = caption

			cameraPhoto.add(entry)

			PhotoViewer.getInstance().openPhotoForSelect(cameraPhoto, 0, 0, false, object : EmptyPhotoViewerProvider() {
				override fun getThumbForPhoto(messageObject: MessageObject?, fileLocation: FileLocation?, index: Int): BitmapHolder {
					return BitmapHolder(thumb, null, 0)
				}

				override fun sendButtonPressed(index: Int, videoEditedInfo: VideoEditedInfo?, notify: Boolean, scheduleDate: Int, forceDocument: Boolean) {
					sendMedia(cameraPhoto[0] as PhotoEntry, videoEditedInfo, notify, scheduleDate, forceDocument)
				}

				override fun canScrollAway(): Boolean {
					return false
				}
			}, this, false)
		}
		else {
			fillEditingMediaWithCaption(caption, null)
			prepareSendingVideo(accountInstance, videoPath, null, dialogId, replyMessage, threadMessage, null, null, 0, editingMessageObject, true, 0, forceDocument = false, isMediaSale = false, mediaSaleHash = null)
			afterMessageSend()
		}
	}

	fun openPhotosEditor(photoPaths: List<SendingMediaInfo>, caption: CharSequence?): Boolean {
		val entries = mutableListOf<PhotoEntry>()

		for (a in photoPaths.indices) {
			val photoInfo = photoPaths[a]
			var path: String? = null

			if (photoInfo.path != null) {
				path = photoInfo.path
			}
			else if (photoInfo.uri != null) {
				try {
					val file = AndroidUtilities.generatePicturePath(isSecretChat, "")

					ApplicationLoader.applicationContext.contentResolver.openInputStream(photoInfo.uri!!)?.use { `in` ->
						FileOutputStream(file).use { fos ->
							val buffer = ByteArray(8 * 1024)
							var lengthRead: Int

							while (`in`.read(buffer).also { lengthRead = it } > 0) {
								fos.write(buffer, 0, lengthRead)
								fos.flush()
							}
						}
					}

					path = file.absolutePath
				}
				catch (e: Exception) {
					FileLog.e(e)
					continue
				}
			}

			if (path == null) {
				continue
			}

			var orientation = 0

			try {
				val ei = ExifInterface(path)

				when (ei.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL)) {
					ExifInterface.ORIENTATION_ROTATE_90 -> orientation = 90
					ExifInterface.ORIENTATION_ROTATE_180 -> orientation = 180
					ExifInterface.ORIENTATION_ROTATE_270 -> orientation = 270
				}
			}
			catch (e: Exception) {
				FileLog.e(e)
			}

			val entry = PhotoEntry(0, 0, 0, path, orientation, photoInfo.isVideo, 0, 0, 0)

			if (a == photoPaths.size - 1 && caption != null) {
				entry.caption = caption
			}

			entries.add(entry)
		}

		if (entries.isEmpty()) {
			return false
		}

		if (parentActivity != null) {
			val checked = BooleanArray(entries.size)

			Arrays.fill(checked, true)

			PhotoViewer.getInstance().setParentActivity(this)

			PhotoViewer.getInstance().openPhotoForSelect(entries as List<Any>, entries.size - 1, 0, false, object : EmptyPhotoViewerProvider() {
				override fun getThumbForPhoto(messageObject: MessageObject?, fileLocation: FileLocation?, index: Int): BitmapHolder? {
					return null
				}

				override fun sendButtonPressed(index: Int, videoEditedInfo: VideoEditedInfo?, notify: Boolean, scheduleDate: Int, forceDocument: Boolean) {
					for (i in entries.indices.reversed()) {
						if (!checked[i]) {
							entries.removeAt(i)
						}
					}

					sendPhotosGroup(entries, notify, scheduleDate, forceDocument)
				}

				override fun setPhotoChecked(index: Int, videoEditedInfo: VideoEditedInfo?): Int {
					return index
				}

				override fun isPhotoChecked(index: Int): Boolean {
					return checked[index]
				}

				override fun canScrollAway(): Boolean {
					return false
				}
			}, this, false)
		}
		else {
			fillEditingMediaWithCaption(caption, null)
			sendPhotosGroup(entries, false, 0, false)
			afterMessageSend()
		}

		return true
	}

	private fun sendPhotosGroup(entries: List<PhotoEntry>, notify: Boolean, scheduleDate: Int, forceDocument: Boolean) {
		if (entries.isNotEmpty()) {
			val photos = mutableListOf<SendingMediaInfo>()

			for (entry in entries) {
				val info = SendingMediaInfo()

				if (!entry.isVideo && entry.imagePath != null) {
					info.path = entry.imagePath
				}
				else if (entry.path != null) {
					info.path = entry.path
				}

				info.thumbPath = entry.thumbPath
				info.isVideo = entry.isVideo
				info.caption = entry.caption?.toString()
				info.entities = entry.entities
				info.masks = entry.stickers
				info.ttl = entry.ttl
				info.videoEditedInfo = entry.editedInfo
				info.canDeleteAfter = entry.canDeleteAfter

				photos.add(info)

				entry.reset()
			}

			fillEditingMediaWithCaption(photos[0].caption, photos[0].entities)

			prepareSendingMedia(accountInstance, photos, dialogId, null, threadMessage, null, forceDocument, true, null, notify, scheduleDate, photos[0].updateStickersOrder, false, null)

			afterMessageSend()

			chatActivityEnterView?.fieldText = ""
		}

		if (scheduleDate != 0) {
			if (scheduledMessagesCount == -1) {
				scheduledMessagesCount = 0
			}

			scheduledMessagesCount += entries.size

			updateScheduledInterface(true)
		}
	}

	private fun openEditingMessageInPhotoEditor() {
		val `object` = editingMessageObject ?: return

		if (!`object`.canEditMedia() || editingMessageObjectReqId != 0) {
			return
		}

		if (!`object`.isPhoto && !`object`.isVideo) {
			return
		}

		var file: File? = null
		val attachPath = `object`.messageOwner?.attachPath

		if (!attachPath.isNullOrEmpty()) {
			file = File(attachPath)

			if (!file.exists()) {
				file = null
			}
		}

		if (file == null) {
			file = fileLoader.getPathToMessage(`object`.messageOwner)
		}

		if (!file.exists()) {
			return
		}

		PhotoViewer.getInstance().setParentActivity(this)

		val photos = mutableListOf<Any>()

		val entry = PhotoEntry(0, 0, 0, file.absolutePath, 0, `object`.isVideo, 0, 0, 0)
		entry.caption = chatActivityEnterView?.fieldText

		photos.add(entry)

		PhotoViewer.getInstance().openPhotoForSelect(photos, 0, 2, false, object : EmptyPhotoViewerProvider() {
			override fun getPlaceForPhoto(messageObject: MessageObject?, fileLocation: FileLocation?, index: Int, needPreview: Boolean): PlaceProviderObject? {
				return this@ChatActivity.getPlaceForPhoto(`object`, null, needPreview, true)
			}

			override fun sendButtonPressed(index: Int, videoEditedInfo: VideoEditedInfo?, notify: Boolean, scheduleDate: Int, forceDocument: Boolean) {
				if (editingMessageObject !== `object`) {
					return
				}

				if (entry.isCropped || entry.isPainted || entry.isFiltered || videoEditedInfo != null) {
					sendMedia(entry, videoEditedInfo, notify, scheduleDate, forceDocument)
				}
				else {
					chatActivityEnterView?.doneEditingMessage()
				}
			}

			override fun canCaptureMorePhotos(): Boolean {
				return false
			}

			override fun allowSendingSubmenu(): Boolean {
				return false
			}

			override fun getEditingMessageObject(): MessageObject? {
				return if (this@ChatActivity.editingMessageObject === `object`) `object` else null
			}

			override fun onCaptionChanged(caption: CharSequence) {
				if (editingMessageObject === `object`) {
					chatActivityEnterView?.setFieldText(caption, true)
				}
			}

			override fun closeKeyboard(): Boolean {
				if (chatActivityEnterView != null && isKeyboardVisible) {
					chatActivityEnterView?.closeKeyboard()
					return true
				}

				return false
			}
		}, this, false)
	}

	private fun getPlaceForPhoto(messageObject: MessageObject?, fileLocation: FileLocation?, needPreview: Boolean, onlyIfVisible: Boolean): PlaceProviderObject? {
		val count = chatListView?.childCount ?: 0

		for (a in 0 until count) {
			var imageReceiver: ImageReceiver? = null
			val view = chatListView!!.getChildAt(a)

			if (view is ChatMessageCell) {
				if (messageObject != null) {
					val message = view.getMessageObject()

					if (message != null && message.id == messageObject.id) {
						imageReceiver = view.photoImage
					}
				}
			}
			else if (view is ChatActionCell) {
				val message = view.messageObject

				if (message != null) {
					if (messageObject != null) {
						if (message.id == messageObject.id) {
							imageReceiver = view.photoImage
						}
					}
					else if (fileLocation != null && message.photoThumbs != null) {
						for (b in message.photoThumbs!!.indices) {
							val photoSize = message.photoThumbs?.getOrNull(b)

							if (photoSize?.location != null && photoSize.location?.volume_id == fileLocation.volume_id && photoSize.location?.local_id == fileLocation.local_id) {
								imageReceiver = view.photoImage
								break
							}
						}
					}
				}
			}

			if (imageReceiver != null) {
				if (onlyIfVisible && view.y + imageReceiver.imageY2 < chatListViewPadding - AndroidUtilities.dp(4f)) {
					return null
				}

				val coords = IntArray(2)

				view.getLocationInWindow(coords)

				val `object` = PlaceProviderObject()
				`object`.viewX = coords[0]
				`object`.viewY = coords[1]
				`object`.parentView = chatListView
				`object`.animatingImageView = if (!SharedConfig.smoothKeyboard && pagedownButton != null && pagedownButton!!.tag != null && view is ChatMessageCell) animatingImageView else null
				`object`.imageReceiver = imageReceiver

				if (needPreview) {
					`object`.thumb = imageReceiver.bitmapSafe
				}

				`object`.radius = imageReceiver.getRoundRadius()

				if (view is ChatActionCell && currentChat != null) {
					`object`.dialogId = -currentChat!!.id
				}

				`object`.clipTopAddition = (chatListViewPadding - chatListViewPaddingVisibleOffset - AndroidUtilities.dp(4f)).toInt()
				`object`.clipBottomAddition = blurredViewBottomOffset

				return `object`
			}
		}

		return null
	}

	private fun showAttachmentError() {
		if (parentActivity == null) {
			return
		}

		BulletinFactory.of(this).createErrorBulletin(context!!.getString(R.string.UnsupportedAttachment)).show()
	}

	private fun fillEditingMediaWithCaption(caption: CharSequence?, entities: List<MessageEntity>?) {
		if (editingMessageObject == null) {
			return
		}

		if (!caption.isNullOrEmpty()) {
			editingMessageObject?.editingMessage = caption
			editingMessageObject?.editingMessageEntities = entities
		}
		else if (chatActivityEnterView != null) {
			editingMessageObject?.editingMessage = chatActivityEnterView?.fieldText

			if (editingMessageObject?.editingMessage == null && !editingMessageObject?.messageOwner?.message.isNullOrEmpty()) {
				editingMessageObject?.editingMessage = ""
			}
		}
	}

	private fun sendUriAsDocument(uri: Uri?) {
		@Suppress("NAME_SHADOWING") var uri = uri ?: return
		val extractUriFrom = uri.toString()

		if (extractUriFrom.contains("com.google.android.apps.photos.contentprovider")) {
			try {
				var firstExtraction = extractUriFrom.split("/1/".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()[1]
				val index = firstExtraction.indexOf("/ACTUAL")

				if (index != -1) {
					firstExtraction = firstExtraction.substring(0, index)

					val secondExtraction = URLDecoder.decode(firstExtraction, "UTF-8")

					uri = Uri.parse(secondExtraction)
				}
			}
			catch (e: Exception) {
				FileLog.e(e)
			}
		}

		var tempPath = AndroidUtilities.getPath(uri)
		var originalPath = tempPath
		var sendAsUri = false

		if (!BuildVars.NO_SCOPED_STORAGE) {
			sendAsUri = true
		}
		else if (tempPath == null) {
			originalPath = uri.toString()
			tempPath = MediaController.copyFileToCache(uri, "file")

			if (tempPath == null) {
				showAttachmentError()
				return
			}
		}

		fillEditingMediaWithCaption(null, null)

		if (sendAsUri) {
			prepareSendingDocument(accountInstance, null, null, uri, null, null, dialogId, replyMessage, threadMessage, null, editingMessageObject, true, 0, false, null)
		}
		else {
			prepareSendingDocument(accountInstance, tempPath, originalPath, null, null, null, dialogId, replyMessage, threadMessage, null, editingMessageObject, true, 0, false, null)
		}

		hideFieldPanel(false)
	}

	override fun onActivityResultFragment(requestCode: Int, resultCode: Int, data: Intent?) {
		if (resultCode == Activity.RESULT_OK) {
			when (requestCode) {
				0, 2 -> {
					createChatAttachView()
					chatAttachAlert?.photoLayout?.onActivityResultFragment(requestCode, data, currentPicturePath)
					currentPicturePath = null
				}

				1 -> {
					if (data == null || data.data == null) {
						showAttachmentError()
						return
					}

					val uri = data.data

					if (uri.toString().contains("video")) {
						var videoPath: String? = null

						try {
							videoPath = AndroidUtilities.getPath(uri)
						}
						catch (e: Exception) {
							FileLog.e(e)
						}

						if (videoPath == null) {
							showAttachmentError()
						}

						if (paused) {
							startVideoEdit = videoPath
						}
						else {
							openVideoEditor(videoPath, null)
						}
					}
					else {
						if (editingMessageObject == null && chatMode == MODE_SCHEDULED) {
							AlertsCreator.createScheduleDatePickerDialog(parentActivity, dialogId) { notify, scheduleDate ->
								fillEditingMediaWithCaption(null, null)
								prepareSendingPhoto(accountInstance, null, uri, dialogId, replyMessage, threadMessage, null, null, null, null, 0, editingMessageObject, notify, scheduleDate, false, null)
							}
						}
						else {
							fillEditingMediaWithCaption(null, null)
							prepareSendingPhoto(accountInstance, null, uri, dialogId, replyMessage, threadMessage, null, null, null, null, 0, editingMessageObject, true, 0, false, null)
						}
					}

					afterMessageSend()
				}

				ChatAttachAlert.REQUEST_CODE_ATTACH_FILE -> {
					if (data == null) {
						showAttachmentError()
						return
					}

					if (data.data != null) {
						sendUriAsDocument(data.data)
					}
					else if (data.clipData != null) {
						val clipData = data.clipData

						for (i in 0 until clipData!!.itemCount) {
							sendUriAsDocument(clipData.getItemAt(i).uri)
						}
					}
					else {
						showAttachmentError()
					}

					chatAttachAlert?.dismiss()

					afterMessageSend()
				}
			}
		}
	}

	override fun saveSelfArgs(args: Bundle) {
		currentPicturePath?.let {
			args.putString("path", it)
		}
	}

	override fun restoreSelfArgs(args: Bundle) {
		currentPicturePath = args.getString("path")
	}

	private fun removeUnreadPlane(scrollToEnd: Boolean) {
		if (unreadMessageObject != null) {
			if (scrollToEnd) {
				forwardEndReached[0] = true
				forwardEndReached[1] = true
				first_unread_id = 0
				last_message_id = 0
			}

			createUnreadMessageAfterId = 0
			createUnreadMessageAfterIdLoading = false

			removeMessageObject(unreadMessageObject)

			unreadMessageObject = null
		}
	}

	private fun processNewMessagesFromArgs(vararg args: Any?) {
		val guid = args[10] as Int

		if (guid != classGuid) {
			return
		}

		var queryLoadIndex = args[11] as Int
		val doNotRemoveLoadIndex: Boolean

		if (queryLoadIndex < 0) {
			doNotRemoveLoadIndex = true
			queryLoadIndex = -queryLoadIndex
		}
		else {
			doNotRemoveLoadIndex = false
		}

		if (!doNotRemoveLoadIndex && !fragmentBeginToShow && !paused) {
			val allowedNotifications = intArrayOf(NotificationCenter.messagesDidLoad, NotificationCenter.chatInfoDidLoad, NotificationCenter.groupCallUpdated, NotificationCenter.dialogsNeedReload, NotificationCenter.scheduledMessagesUpdated, NotificationCenter.closeChats, NotificationCenter.botKeyboardDidLoad, NotificationCenter.userInfoDidLoad, NotificationCenter.pinnedInfoDidLoad, NotificationCenter.needDeleteDialog /*, NotificationCenter.botInfoDidLoad*/)

			if (transitionAnimationIndex == 0) {
				transitionAnimationIndex = notificationCenter.setAnimationInProgress(transitionAnimationIndex, allowedNotifications)

				AndroidUtilities.runOnUIThread({
					notificationCenter.onAnimationFinish(transitionAnimationIndex)
				}, 800)
			}
			else {
				notificationCenter.updateAllowedNotifications(transitionAnimationIndex, allowedNotifications)
			}
		}

		val index = waitingForLoad.indexOf(queryLoadIndex)
		val currentUserId = userConfig.getClientUserId()
		val mode = args[14] as Int
		val isCache = args[3] as Boolean
		val postponedScroll = postponedScrollToLastMessageQueryIndex > 0 && queryLoadIndex == postponedScrollToLastMessageQueryIndex

		if (postponedScroll) {
			postponedScrollToLastMessageQueryIndex = 0
		}

		if (index == -1) {
			if (chatMode == MODE_SCHEDULED && mode == MODE_SCHEDULED && !isCache) {
				waitingForReplyMessageLoad = true
				waitingForLoad.add(lastLoadIndex)

				messagesController.loadMessages(dialogId, mergeDialogId, false, if (AndroidUtilities.isTablet()) 30 else 20, 0, 0, true, 0, classGuid, 2, 0, chatMode, threadId, replyMaxReadId, lastLoadIndex++)
			}

			return
		}
		else if (!doNotRemoveLoadIndex) {
			waitingForLoad.removeAt(index)
		}

		var messArr = (args[2] as List<MessageObject>).toMutableList()

		if (messages.isEmpty() && messArr.size == 1 && MessageObject.isSystemSignUp(messArr[0])) {
			forceHistoryEmpty = true

			endReached[0] = true
			endReached[1] = true

			forwardEndReached[0] = true
			forwardEndReached[1] = true

			firstLoading = false

			showProgressView(false)

			if (chatListView != null) {
				if (!fragmentOpened) {
					chatListView?.setAnimateEmptyView(false, 1)
					chatListView?.setEmptyView(emptyViewContainer)
					chatListView?.setAnimateEmptyView(true, 1)
				}
				else {
					chatListView?.setEmptyView(emptyViewContainer)
				}

				chatAdapter?.notifyDataSetChanged(true)
			}

			resumeDelayedFragmentAnimation()

			val messageObject = messArr[0]

			messagesController.markDialogAsRead(dialogId, messageObject.id, messageObject.id, messageObject.messageOwner!!.date, false, 0, 0, true, 0)

			AndroidUtilities.cancelRunOnUIThread(fragmentTransitionRunnable)

			fragmentTransitionRunnable.run()

			return
		}

		if (chatMode != mode) {
			if (chatMode != MODE_SCHEDULED) {
				scheduledMessagesCount = messArr.size
				updateScheduledInterface(true)
			}

			return
		}

		var createUnreadLoading = false
		val showDateAfter = waitingForReplyMessageLoad

		if (waitingForReplyMessageLoad) {
			if (chatMode != MODE_SCHEDULED && !createUnreadMessageAfterIdLoading) {
				var found = false

				for (a in messArr.indices) {
					val obj = messArr[a]

					if (obj.id == startLoadFromMessageId) {
						found = true
						break
					}

					if (a + 1 < messArr.size) {
						val obj2 = messArr[a + 1]

						if (obj.id >= startLoadFromMessageId && obj2.id < startLoadFromMessageId) {
							startLoadFromMessageId = obj.id
							found = true
							break
						}
					}
				}

				if (!found) {
					startLoadFromMessageId = 0
					return
				}
			}

			val startLoadFrom = startLoadFromMessageId
			val needSelect = needSelectFromMessageId
			val unreadAfterId = createUnreadMessageAfterId

			createUnreadLoading = createUnreadMessageAfterIdLoading

			clearChatData()

			if (chatMode == 0) {
				createUnreadMessageAfterId = unreadAfterId
				startLoadFromMessageId = startLoadFrom
				needSelectFromMessageId = needSelect
			}
		}

		loadsCount++

		val did = args[0] as Long
		val loadIndex = if (did == dialogId) 0 else 1
		var count = args[1] as Int
		val fnid = args[4] as Int
		// val last_unread_date = args[7] as Int
		val load_type = args[8] as Int
		val isEnd = args[9] as Boolean
		val loaded_max_id = args[12] as Int
		var loaded_mentions_count = if (chatWasReset) 0 else (args[13] as Int)

		if (loaded_mentions_count < 0) {
			loaded_mentions_count *= -1
			hasAllMentionsLocal = false
		}
		else if (first) {
			hasAllMentionsLocal = true
		}

		if (load_type == 4) {
			startLoadFromMessageId = loaded_max_id

			for (a in messArr.size - 1 downTo 1) {
				val obj = messArr[a]

				if (obj.type < 0 && obj.id == startLoadFromMessageId) {
					startLoadFromMessageId = messArr[a - 1].id
					break
				}
			}
		}

		if (postponedScroll) {
			if (load_type == 0 && isCache && messArr.size < count) {
				postponedScrollToLastMessageQueryIndex = lastLoadIndex
				waitingForLoad.add(lastLoadIndex)
				messagesController.loadMessages(dialogId, mergeDialogId, false, count, 0, 0, false, 0, classGuid, 0, 0, chatMode, threadId, replyMaxReadId, lastLoadIndex++)
				return
			}

			if (load_type == 4) {
				postponedScrollMessageId = startLoadFromMessageId
			}

			progressDialog?.dismiss()

			showPinnedProgress(false)

			if (postponedScrollIsCanceled) {
				return
			}

			if (postponedScrollMessageId == 0) {
				clearChatData()
			}
			else {
				if (showScrollToMessageError) {
					var found = false

					for (k in messArr.indices) {
						if (messArr[k].id == postponedScrollMessageId) {
							found = true
							break
						}
					}

					if (!found) {
						if (isThreadChat) {
							val bundle = Bundle()

							if (currentEncryptedChat != null) {
								bundle.putInt("enc_id", currentEncryptedChat!!.id)
							}
							else if (currentChat != null) {
								bundle.putLong("chat_id", currentChat!!.id)
							}
							else {
								bundle.putLong("user_id", currentUser!!.id)
							}

							bundle.putInt("message_id", postponedScrollMessageId)

							presentFragment(ChatActivity(bundle), true)
						}
						else {
							BulletinFactory.of(this).createErrorBulletin(context!!.getString(R.string.MessageNotFound)).show()
						}

						return
					}

					showScrollToMessageError = false
				}

				val startLoadFrom = startLoadFromMessageId
				val needSelect = needSelectFromMessageId
				val unreadAfterId = createUnreadMessageAfterId

				createUnreadLoading = createUnreadMessageAfterIdLoading

				clearChatData()

				if (chatMode == 0) {
					createUnreadMessageAfterId = unreadAfterId
					startLoadFromMessageId = startLoadFrom
					needSelectFromMessageId = needSelect
				}
			}
		}

		chatListItemAnimator?.setShouldAnimateEnterFromBottom(false)

		var unread_to_load = 0

		if (fnid != 0) {
			if (!chatWasReset) {
				last_message_id = args[5] as Int
			}

			if (load_type == 3) {
				if (loadingFromOldPosition) {
					if (!chatWasReset) {
						unread_to_load = args[6] as Int

						if (unread_to_load != 0) {
							createUnreadMessageAfterId = fnid
						}
					}

					loadingFromOldPosition = false
				}

				first_unread_id = 0
			}
			else {
				first_unread_id = fnid

				if (!chatWasReset) {
					unread_to_load = args[6] as Int
				}
			}
		}
		else if (!chatWasReset && startLoadFromMessageId != 0 && (load_type == 3 || load_type == 4)) {
			last_message_id = args[5] as Int
		}
		else if (did == 777000L && load_type == 2) {
			var unreadCount = args[6] as Int
			unreadCount--

			if (unreadCount > 0 && unreadCount < messArr.size - 1) {
				first_unread_id = messArr[unreadCount].messageOwner!!.id
			}
		}

		if (isThreadChat && threadUnreadMessagesCount != 0) {
			unread_to_load = threadUnreadMessagesCount
			threadUnreadMessagesCount = 0
		}

		var newRowsCount = 0

		if (load_type != 0 && (isThreadChat && first_unread_id != 0 || startLoadFromMessageId != 0 || last_message_id != 0)) {
			forwardEndReached[loadIndex] = false
			hideForwardEndReached = false
		}

		if ((load_type == 1 || load_type == 3) && loadIndex == 1) {
			cacheEndReached[0] = true
			endReached[0] = cacheEndReached[0]
			forwardEndReached[0] = false
			hideForwardEndReached = false
			minMessageId[0] = 0
		}

		if (chatMode == MODE_SCHEDULED) {
			cacheEndReached[0] = true
			endReached[0] = cacheEndReached[0]
			forwardEndReached[0] = true
		}

		if (!isThreadChat && isChannel(currentChat) && !messagesController.dialogs_dict.containsKey(dialogId) && load_type == 2 && loadIndex == 0) {
			forwardEndReached[0] = false
			hideForwardEndReached = true
		}

		if (loadsCount == 1 && messArr.size > 20) {
			loadsCount++
		}

		val isFirstLoading = firstLoading

		if (firstLoading) {
			if (!forwardEndReached[loadIndex]) {
				messages.clear()
				messagesByDays.clear()
				groupedMessagesMap.clear()

				threadMessageAdded = false

				for (a in 0..1) {
					messagesDict[a].clear()

					if (currentEncryptedChat == null) {
						maxMessageId[a] = Int.MAX_VALUE
						minMessageId[a] = Int.MIN_VALUE
					}
					else {
						maxMessageId[a] = Int.MIN_VALUE
						minMessageId[a] = Int.MAX_VALUE
					}

					maxDate[a] = Int.MIN_VALUE
					minDate[a] = 0
				}
			}

			firstLoading = false

			AndroidUtilities.runOnUIThread {
				notificationCenter.runDelayedNotifications()
				resumeDelayedFragmentAnimation()
				AndroidUtilities.cancelRunOnUIThread(fragmentTransitionRunnable)
				fragmentTransitionRunnable.run()
			}
		}

		if (isThreadChat && (load_type == 2 || load_type == 3) && !isCache) {
			if (load_type == 3 && scrollToThreadMessage) {
				startLoadFromMessageId = threadId
			}

			var beforeMax = 0
			var afterMax = 0
			var hasMaxId = false
			var a = 0
			val N = messArr.size

			while (a < N) {
				val message = messArr[a]
				val mid = message.id

				if (mid == loaded_max_id) {
					hasMaxId = true
				}

				if (mid > loaded_max_id) {
					afterMax++
				}
				else {
					beforeMax++
				}

				a++
			}

			var num = if (load_type == 2) {
				10
			}
			else {
				count / 2
			}

			if (hasMaxId) {
				num++
			}

			if (beforeMax < num) {
				endReached[0] = true
			}

			if (!chatWasReset && afterMax < count - num) {
				forwardEndReached[0] = true
			}
		}

		if (chatMode == MODE_PINNED) {
			endReached[loadIndex] = true
		}

		if (load_type == 0 && forwardEndReached[0] && pendingSendMessages.isNotEmpty()) {
			var a = 0
			val N = messArr.size

			while (a < N) {
				val existing = pendingSendMessagesDict[messArr[a].id]

				if (existing != null) {
					pendingSendMessagesDict.remove(existing.id)
					pendingSendMessages.remove(existing)
				}

				a++
			}

			if (pendingSendMessages.isNotEmpty()) {
				var pasteIndex = 0
				val date = pendingSendMessages[0].messageOwner!!.date

				if (messArr.isNotEmpty()) {
					if (date >= messArr[0].messageOwner!!.date) {
						pasteIndex = 0
					}
					else if (date <= messArr[messArr.size - 1].messageOwner!!.date) {
						pasteIndex = messArr.size
					}
					else {
						@Suppress("NAME_SHADOWING") var a = 0
						@Suppress("NAME_SHADOWING") val N = messArr.size

						while (a < N - 1) {
							if (messArr[a].messageOwner!!.date >= date && messArr[a + 1].messageOwner!!.date <= date) {
								pasteIndex = a + 1
							}

							a++
						}
					}
				}

				messArr = messArr.toMutableList()
				messArr.addAll(pasteIndex, pendingSendMessages)

				pendingSendMessages.clear()
				pendingSendMessagesDict.clear()
			}
		}

		if (!threadMessageAdded && isThreadChat && (load_type == 0 && messArr.size < count || (load_type == 2 || load_type == 3) && endReached[0])) {
			val msg: Message = TL_message()

			if (threadMessage!!.repliesCount == 0) {
				if (isComments) {
					msg.message = context!!.getString(R.string.NoComments)
				}
				else {
					msg.message = context!!.getString(R.string.NoReplies)
				}
			}
			else {
				msg.message = context!!.getString(R.string.DiscussionStarted)
			}

			msg.id = 0
			msg.date = threadMessage!!.messageOwner!!.date

			replyMessageHeaderObject = MessageObject(currentAccount, msg, generateLayout = false, checkMediaExists = false)
			replyMessageHeaderObject?.type = 10
			replyMessageHeaderObject?.contentType = 1
			replyMessageHeaderObject?.isDateObject = true
			replyMessageHeaderObject?.stableId = lastStableId++

			messArr.add(replyMessageHeaderObject!!)

			updateReplyMessageHeader(false)

			messArr.addAll(threadMessageObjects!!)

			count += 2

			threadMessageAdded = true
		}

		if (load_type == 1) {
			messArr.reverse()
		}

		if (currentEncryptedChat == null) {
			mediaDataController.loadReplyMessagesForMessages(messArr, dialogId, chatMode == MODE_SCHEDULED, null)
		}

		var approximateHeightSum = 0

		if (!chatWasReset && (load_type == 2 || load_type == 1) && messArr.isEmpty() && !isCache) {
			forwardEndReached[0] = true
		}

		var newGroups: LongSparseArray<GroupedMessages>? = null
		var changedGroups: LongSparseArray<GroupedMessages?>? = null
		val mediaController = MediaController.getInstance()
		var dropPhotoAction: MessageAction? = null
		var createdWas = false
		var moveCurrentDateObject = false
		var scrolledToUnread = false

		run {
			var a = 0
			val N = messArr.size

			while (a < N) {
				val obj = messArr[N - a - 1]
				val action = obj.messageOwner?.action

				if (a == 0 && action is TL_messageActionChatCreate) {
					createdWas = true
				}
				else if (!createdWas) {
					break
				}
				else if (a < 2 && action is TL_messageActionChatEditPhoto) {
					dropPhotoAction = action
				}

				a++
			}
		}

		for (a in messArr.indices) {
			var obj = messArr[a]

			if (obj.replyMessageObject != null) {
				repliesMessagesDict.put(obj.replyMessageObject!!.id, obj.replyMessageObject)
				addReplyMessageOwner(obj, 0)
			}

			val messageId = obj.id

			if (threadId != 0) {
				if (messageId <= (if (obj.isOut) threadMaxOutboxReadId else threadMaxInboxReadId)) {
					obj.setIsRead()
				}
			}

			approximateHeightSum += obj.approximateHeight

			if (currentUser != null) {
				if (currentUser!!.self) {
					obj.messageOwner?.out = true
				}

				if (chatMode != MODE_SCHEDULED && (currentUser!!.bot && obj.isOut || currentUser!!.id == currentUserId)) {
					obj.setIsRead()
				}
			}

			if (messagesDict[loadIndex].indexOfKey(messageId) >= 0) {
				continue
			}

			if (threadId != 0 && obj.messageOwner is TL_messageEmpty) {
				continue
			}

			if (currentEncryptedChat != null && obj.messageOwner?.stickerVerified == 0) {
				mediaDataController.verifyAnimatedStickerMessage(obj.messageOwner)
			}

			addToPolls(obj, null)

			if (isSecretChat) {
				checkSecretMessageForLocation(obj)
			}

			if (mediaController.isPlayingMessage(obj)) {
				val player = mediaController.playingMessageObject
				obj.audioProgress = player!!.audioProgress
				obj.audioProgressSec = player.audioProgressSec
				obj.audioPlayerDuration = player.audioPlayerDuration
			}

			if (loadIndex == 0 && isChannel(currentChat) && messageId == 1) {
				endReached[loadIndex] = true
				cacheEndReached[loadIndex] = true
			}

			if (messageId > 0) {
				maxMessageId[loadIndex] = min(messageId, maxMessageId[loadIndex])
				minMessageId[loadIndex] = max(messageId, minMessageId[loadIndex])
			}
			else if (currentEncryptedChat != null) {
				maxMessageId[loadIndex] = max(messageId, maxMessageId[loadIndex])
				minMessageId[loadIndex] = min(messageId, minMessageId[loadIndex])
			}

			if (obj.messageOwner?.date != 0) {
				maxDate[loadIndex] = max(maxDate[loadIndex], obj.messageOwner!!.date)

				if (minDate[loadIndex] == 0 || obj.messageOwner!!.date < minDate[loadIndex]) {
					minDate[loadIndex] = obj.messageOwner!!.date
				}
			}

			if (!chatWasReset && messageId != 0 && messageId == last_message_id) {
				forwardEndReached[loadIndex] = true
			}

			val action = obj.messageOwner?.action

			if (obj.type < 0 || loadIndex == 1 && action is TL_messageActionChatMigrateTo) {
				continue
			}

			if (currentChat != null && currentChat!!.creator && (action is TL_messageActionChatCreate || dropPhotoAction != null && action === dropPhotoAction)) {
				continue
			}

			if (obj.messageOwner?.action is TL_messageActionChannelMigrateFrom) {
				continue
			}

			if (needAnimateToMessage?.id == messageId && messageId < 0 && chatMode != MODE_SCHEDULED) {
				obj = needAnimateToMessage!!
				animatingMessageObjects.add(obj)
				needAnimateToMessage = null
			}

			messagesDict[loadIndex].put(messageId, obj)

			var dayArray = messagesByDays[obj.dateKey]

			if (dayArray == null) {
				dayArray = mutableListOf()

				messagesByDays[obj.dateKey!!] = dayArray

				val dateMsg: Message = TL_message()

				if (chatMode == MODE_SCHEDULED) {
					if (obj.messageOwner?.date == 0x7ffffffe) {
						dateMsg.message = context!!.getString(R.string.MessageScheduledUntilOnline)
					}
					else {
						dateMsg.message = LocaleController.formatString("MessageScheduledOn", R.string.MessageScheduledOn, LocaleController.formatDateChat(obj.messageOwner!!.date.toLong(), true))
					}
				}
				else {
					dateMsg.message = LocaleController.formatDateChat(obj.messageOwner!!.date.toLong())
				}

				dateMsg.id = 0

				val calendar = Calendar.getInstance()
				calendar.timeInMillis = obj.messageOwner!!.date.toLong() * 1000
				calendar[Calendar.HOUR_OF_DAY] = 0
				calendar[Calendar.MINUTE] = 0

				dateMsg.date = (calendar.timeInMillis / 1000).toInt()

				val dateObj = MessageObject(currentAccount, dateMsg, generateLayout = false, checkMediaExists = false)
				dateObj.type = 10
				dateObj.contentType = 1
				dateObj.isDateObject = true
				dateObj.stableId = lastStableId++

				if (load_type == 1) {
					messages.add(0, dateObj)
				}
				else {
					messages.add(dateObj)
				}

				newRowsCount++
			}
			else {
				if (!moveCurrentDateObject && messages.isNotEmpty() && messages[messages.size - 1].isDateObject) {
					messages[messages.size - 1].stableId = lastStableId++
					moveCurrentDateObject = true
				}
			}

			if (obj.hasValidGroupId()) {
				var groupedMessages = groupedMessagesMap[obj.groupIdForUse]

				if (groupedMessages != null) {
					if (messages.size > 1) {

						val previous = if (load_type == 1) {
							messages[0]
						}
						else {
							messages[messages.size - 2]
						}

						if (previous.groupIdForUse == obj.groupIdForUse) {
							if (previous.localGroupId != 0L) {
								obj.localGroupId = previous.localGroupId
								groupedMessages = groupedMessagesMap[previous.localGroupId]
							}
						}
						else if (previous.groupIdForUse != obj.groupIdForUse) {
							obj.localGroupId = Utilities.random.nextLong()
							groupedMessages = null
						}
					}
				}

				if (groupedMessages == null) {
					groupedMessages = GroupedMessages()
					groupedMessages.groupId = obj.groupId

					groupedMessagesMap.put(groupedMessages.groupId, groupedMessages)
				}
				else if (newGroups == null || newGroups.indexOfKey(obj.groupId) < 0) {
					if (changedGroups == null) {
						changedGroups = LongSparseArray()
					}

					changedGroups.put(obj.groupId, groupedMessages)
				}

				if (newGroups == null) {
					newGroups = LongSparseArray()
				}

				newGroups.put(groupedMessages.groupId, groupedMessages)

				if (load_type == 1) {
					groupedMessages.messages.add(obj)
				}
				else {
					groupedMessages.messages.add(0, obj)
				}
			}
			else if (obj.groupIdForUse != 0L) {
				obj.messageOwner?.groupId = 0
				obj.localSentGroupId = 0
			}

			newRowsCount++

			dayArray.add(obj)

			obj.stableId = lastStableId++

			if (load_type == 1) {
				messages.add(0, obj)
			}
			else {
				messages[messages.size - 1].stableId = lastStableId++
				messages.add(messages.size - 1, obj)
			}

			var prevObj: MessageObject?

			if (currentEncryptedChat == null) {
				if (createUnreadMessageAfterId != 0 && load_type != 1 && a + 1 < messArr.size) {
					prevObj = messArr[a + 1]

					if (obj.isOut && !obj.messageOwner!!.from_scheduled || prevObj.id >= createUnreadMessageAfterId) {
						prevObj = null
					}
				}
				else {
					prevObj = null
				}
			}
			else {
				if (createUnreadMessageAfterId != 0 && load_type != 1 && a - 1 >= 0) {
					prevObj = messArr[a - 1]

					if (obj.isOut && !obj.messageOwner!!.from_scheduled || prevObj.id >= createUnreadMessageAfterId) {
						prevObj = null
					}
				}
				else {
					prevObj = null
				}
			}

			if (load_type == 2 && messageId != 0 && messageId == first_unread_id) {
				if (approximateHeightSum > AndroidUtilities.displaySize.y / 2 || isThreadChat || !forwardEndReached[0]) {
					if (!isThreadChat || threadMaxInboxReadId != 0) {
						val dateMsg: Message = TL_message()
						dateMsg.message = ""
						dateMsg.id = 0

						val dateObj = MessageObject(currentAccount, dateMsg, generateLayout = false, checkMediaExists = false)
						dateObj.type = 6
						dateObj.contentType = 2
						dateObj.stableId = lastStableId++

						messages.add(messages.size - 1, dateObj)

						unreadMessageObject = dateObj
						scrollToMessage = unreadMessageObject
					}
					else {
						scrollToMessage = obj
					}

					scrollToMessagePosition = -10000
					scrolledToUnread = true

					newRowsCount++
				}
			}
			else if ((load_type == 3 || load_type == 4) && (startLoadFromMessageId < 0 && messageId == startLoadFromMessageId || startLoadFromMessageId > 0 && messageId > 0 && messageId <= startLoadFromMessageId)) {
				removeSelectedMessageHighlight()

				if (needSelectFromMessageId && messageId == startLoadFromMessageId) {
					highlightMessageId = messageId
				}

				if (showScrollToMessageError && messageId != startLoadFromMessageId) {
					BulletinFactory.of(this).createErrorBulletin(context!!.getString(R.string.MessageNotFound)).show()
				}

				scrollToMessage = obj

				if (postponedScroll) {
					postponedScrollMessageId = scrollToMessage!!.id
				}

				startLoadFromMessageId = 0

				if (scrollToMessagePosition == -10000) {
					scrollToMessagePosition = -9000
				}
			}

			if (load_type != 2 && unreadMessageObject == null && createUnreadMessageAfterId != 0 && (currentEncryptedChat == null && (!obj.isOut || obj.messageOwner!!.from_scheduled) && messageId >= createUnreadMessageAfterId || currentEncryptedChat != null && (!obj.isOut || obj.messageOwner!!.from_scheduled) && messageId <= createUnreadMessageAfterId) && (load_type == 1 || prevObj != null || createUnreadLoading && a == messArr.size - 1)) {
				val dateMsg: Message = TL_message()
				dateMsg.message = ""
				dateMsg.id = 0

				val dateObj = MessageObject(currentAccount, dateMsg, generateLayout = false, checkMediaExists = false)
				dateObj.type = 6
				dateObj.contentType = 2
				dateObj.stableId = lastStableId++

				if (load_type == 1) {
					messages.add(1, dateObj)
				}
				else {
					messages.add(messages.size - 1, dateObj)
				}

				unreadMessageObject = dateObj

				if (load_type == 3) {
					scrollToMessage = unreadMessageObject
					startLoadFromMessageId = 0
					scrollToMessagePosition = -9000
				}

				newRowsCount++
			}
		}

		if (createUnreadLoading) {
			createUnreadMessageAfterId = 0
		}

		if (load_type == 0 && newRowsCount == 0) {
			loadsCount--
		}

		if (forwardEndReached[loadIndex] && loadIndex != 1) {
			first_unread_id = 0
			last_message_id = 0
			createUnreadMessageAfterId = 0
		}

		if (load_type == 1) {
			if (!chatWasReset && messArr.size != count && (!isCache || currentEncryptedChat != null || forwardEndReached[loadIndex])) {
				forwardEndReached[loadIndex] = true

				if (loadIndex != 1) {
					first_unread_id = 0
					last_message_id = 0
					createUnreadMessageAfterId = 0

					chatAdapter?.notifyItemRemoved(chatAdapter!!.loadingDownRow)
				}

				startLoadFromMessageId = 0
			}

			if (newRowsCount > 0) {
				val firstVisPos = chatLayoutManager!!.findFirstVisibleItemPosition()
				val lastVisPos = chatLayoutManager!!.findLastVisibleItemPosition()
				var top = 0
				var scrollToMessageObject: MessageObject? = null

				if (firstVisPos != RecyclerView.NO_POSITION) {
					for (i in firstVisPos..lastVisPos) {
						val v = chatLayoutManager!!.findViewByPosition(i)

						if (v is ChatMessageCell) {
							scrollToMessageObject = v.getMessageObject()
							top = chatListView!!.measuredHeight - v.getBottom() - chatListView!!.paddingBottom
							break
						}
						else if (v is ChatActionCell) {
							scrollToMessageObject = v.messageObject
							top = chatListView!!.measuredHeight - v.getBottom() - chatListView!!.paddingBottom
							break
						}
					}
				}

				if (!postponedScroll) {
					chatAdapter?.notifyItemRangeInserted(1, newRowsCount)

					if (scrollToMessageObject != null) {
						val scrollToIndex = messages.indexOf(scrollToMessageObject)

						if (scrollToIndex > 0) {
							chatLayoutManager?.scrollToPositionWithOffset(chatAdapter!!.messagesStartRow + scrollToIndex, top)
						}
					}
				}
			}

			loadingForward = false
		}
		else {
			if (messArr.size < count && load_type != 3 && load_type != 4) {
				if (isCache) {
					if (currentEncryptedChat != null || loadIndex == 1 && mergeDialogId != 0L && isEnd) {
						endReached[loadIndex] = true
					}

					if (load_type != 2) {
						cacheEndReached[loadIndex] = true
					}
				}
				else if (load_type != 2 || messArr.size == 0 && messages.isEmpty()) {
					endReached[loadIndex] = true
				}
			}

			loading = false

			onChatMessagesLoaded?.run()
			onChatMessagesLoaded = null

			loadSendAsPeers(false)

			if (chatListView != null && chatScrollHelper != null) {
				if (first || scrollToTopOnResume || forceScrollToTop) {
					forceScrollToTop = false

					if (!postponedScroll) {
						chatAdapter?.notifyDataSetChanged(true)
					}

					if (scrollToMessage != null) {
						addSponsoredMessages()

						var yOffset: Int
						var bottom = true

						if (startLoadFromMessageOffset != Int.MAX_VALUE) {
							yOffset = -startLoadFromMessageOffset - chatListView!!.paddingBottom
							startLoadFromMessageOffset = Int.MAX_VALUE
						}
						else if (scrollToMessagePosition == -9000) {
							yOffset = getScrollOffsetForMessage(scrollToMessage!!)
							bottom = false
						}
						else if (scrollToMessagePosition == -10000) {
							yOffset = -AndroidUtilities.dp(11f)

							if (scrolledToUnread && threadId != 0) {
								yOffset += AndroidUtilities.dp(48f)
							}

							bottom = false
						}
						else {
							yOffset = scrollToMessagePosition
						}

						yOffset += AndroidUtilities.dp(50f) // in case pinned message view is visible

						if (!postponedScroll) {
							if (messages.isNotEmpty()) {
								if (chatAdapter!!.loadingUpRow >= 0 && messages.isNotEmpty() && (messages[messages.size - 1] === scrollToMessage || messages[messages.size - 2] === scrollToMessage)) {
									chatLayoutManager!!.scrollToPositionWithOffset(chatAdapter!!.loadingUpRow, yOffset, bottom)
								}
								else {
									chatLayoutManager!!.scrollToPositionWithOffset(chatAdapter!!.messagesStartRow + messages.indexOf(scrollToMessage), yOffset, bottom)
								}
							}
						}

						chatListView?.invalidate()

						if (scrollToMessagePosition == -10000 || scrollToMessagePosition == -9000) {
							canShowPagedownButton = true

							updatePagedownButtonVisibility(true)

							if (unread_to_load != 0) {
								if (pagedownButtonCounter != null) {
									if (prevSetUnreadCount != newUnreadMessageCount) {
										pagedownButtonCounter?.setCount(unread_to_load.also {
											newUnreadMessageCount = it
										}, openAnimationEnded)

										prevSetUnreadCount = newUnreadMessageCount
									}
								}
							}
						}

						scrollToMessagePosition = -10000
						scrollToMessage = null
					}
					else {
						addSponsoredMessages()
						moveScrollToLastMessage(true)
					}

					if (loaded_mentions_count != 0) {
						showMentionDownButton(show = true, animated = true)

						if (mentiondownButtonCounter != null) {
							mentiondownButtonCounter?.visible()
							mentiondownButtonCounter?.setText(String.format(Locale.getDefault(), "%d", loaded_mentions_count.also { newMentionsCount = it }))
						}
					}
				}
				else {
					if (newRowsCount != 0) {
						val firstVisPos = chatLayoutManager!!.findFirstVisibleItemPosition()
						val lastVisPos = chatLayoutManager!!.findLastVisibleItemPosition()
						var top = 0
						var scrollToMessageObject: MessageObject? = null

						if (firstVisPos != RecyclerView.NO_POSITION) {
							for (i in firstVisPos..lastVisPos) {
								val v = chatLayoutManager!!.findViewByPosition(i)

								if (v is ChatMessageCell) {
									scrollToMessageObject = v.getMessageObject()
									top = chatListView!!.measuredHeight - v.getBottom() - chatListView!!.paddingBottom
									break
								}
								else if (v is ChatActionCell) {
									scrollToMessageObject = v.messageObject
									top = chatListView!!.measuredHeight - v.getBottom() - chatListView!!.paddingBottom
									break
								}
							}
						}

						val insertStart = chatAdapter!!.messagesEndRow
						val loadingUpRow = chatAdapter!!.loadingUpRow

						chatAdapter?.updateRowsInternal()

						if (loadingUpRow >= 0 && chatAdapter!!.loadingUpRow < 0) {
							chatAdapter?.notifyItemRemoved(loadingUpRow)
						}

						if (newRowsCount > 0) {
							if (moveCurrentDateObject) {
								chatAdapter?.notifyItemRemoved(insertStart - 1)
								chatAdapter?.notifyItemRangeInserted(insertStart - 1, newRowsCount + 1)
							}
							else {
								chatAdapter?.notifyItemChanged(insertStart - 1)
								chatAdapter?.notifyItemRangeInserted(insertStart, newRowsCount)
							}
						}

						if (!postponedScroll && scrollToMessageObject != null) {
							val scrollToIndex = messages.indexOf(scrollToMessageObject)

							if (scrollToIndex > 0) {
								chatLayoutManager?.scrollToPositionWithOffset(chatAdapter!!.messagesStartRow + scrollToIndex, top)
							}
						}
					}
					else if (chatAdapter!!.loadingUpRow >= 0 && endReached[loadIndex] && (loadIndex == 0 && mergeDialogId == 0L || loadIndex == 1)) {
						chatAdapter?.notifyItemRemoved(chatAdapter!!.loadingUpRow)
					}
					else {
						chatAdapter?.notifyDataSetChanged(true)
					}
				}

				if (paused) {
					scrollToTopOnResume = true

					if (scrollToMessage != null) {
						scrollToTopUnReadOnResume = true
					}
				}

				if (first) {
					if (chatListView != null) {
						if (!fragmentBeginToShow) {
							chatListView?.setAnimateEmptyView(false, 1)
							chatListView?.setEmptyView(emptyViewContainer)
							chatListView?.setAnimateEmptyView(true, 1)
						}
						else {
							chatListView?.setEmptyView(emptyViewContainer)
						}
					}
				}
			}
			else {
				scrollToTopOnResume = true

				if (scrollToMessage != null) {
					scrollToTopUnReadOnResume = true
				}
			}
		}

		if (newGroups != null) {
			for (a in 0 until newGroups.size()) {
				val groupedMessages = newGroups.valueAt(a)
				groupedMessages.calculate()

				if (chatAdapter != null && changedGroups != null && changedGroups.indexOfKey(newGroups.keyAt(a)) >= 0) {
					val messageObject = groupedMessages.messages[groupedMessages.messages.size - 1]
					val idx = messages.indexOf(messageObject)

					if (idx >= 0) {
						chatListItemAnimator?.groupWillChanged(groupedMessages)
						chatAdapter?.notifyItemRangeChanged(idx + chatAdapter!!.messagesStartRow, groupedMessages.messages.size)
					}
				}
			}
		}

		if (first && messages.size > 0) {
			first = false

			if (isThreadChat) {
				invalidateMessagesVisiblePart()
			}

			if (startLoadFromDate != 0) {
				var dateObjectIndex = -1
				var closeDateObjectIndex = -1
				var closeDateDiff = 0

				for (i in messages.indices) {
					if (messages[i].isDateObject && abs(startLoadFromDate - messages[i].messageOwner!!.date) <= 100) {
						dateObjectIndex = i
						break
					}

					if (messages[i].isDateObject) {
						val timeDiff = abs(startLoadFromDate - messages[i].messageOwner!!.date)

						if (closeDateObjectIndex == -1 || timeDiff < closeDateDiff) {
							closeDateDiff = timeDiff
							closeDateObjectIndex = i
						}
					}
				}

				if (dateObjectIndex >= 0) {
					chatLayoutManager!!.scrollToPositionWithOffset(chatAdapter!!.messagesStartRow + dateObjectIndex, AndroidUtilities.dp(4f), false)
				}
				else if (closeDateObjectIndex >= 0) {
					chatLayoutManager!!.scrollToPositionWithOffset(chatAdapter!!.messagesStartRow + closeDateObjectIndex, chatListView!!.measuredHeight / 2 - AndroidUtilities.dp(24f), false)
				}
			}
		}

		if (messages.isEmpty() && currentEncryptedChat == null && currentUser != null && currentUser!!.bot && botUser == null) {
			botUser = ""
			updateBottomOverlay()
		}

		if (newRowsCount == 0 && (mergeDialogId != 0L && loadIndex == 0 || currentEncryptedChat != null && !endReached[0])) {
			first = true

			chatListView?.setEmptyView(null)
			emptyViewContainer?.invisible()
		}
		else {
			showProgressView(false)
		}

		if (newRowsCount == 0 && mergeDialogId != 0L && loadIndex == 0) {
			notificationCenter.updateAllowedNotifications(transitionAnimationIndex, intArrayOf(NotificationCenter.chatInfoDidLoad, NotificationCenter.groupCallUpdated, NotificationCenter.dialogsNeedReload, NotificationCenter.scheduledMessagesUpdated, NotificationCenter.closeChats, NotificationCenter.messagesDidLoad, NotificationCenter.botKeyboardDidLoad, NotificationCenter.userInfoDidLoad, NotificationCenter.pinnedInfoDidLoad, NotificationCenter.needDeleteDialog /*, NotificationCenter.botInfoDidLoad*/))
		}

		if (showDateAfter) {
			showFloatingDateView(false)
		}

		addSponsoredMessages()
		checkScrollForLoad(false)

		if (postponedScroll) {
			chatAdapter?.notifyDataSetChanged(true)

			progressDialog?.dismiss()

			updatePinnedListButton(false)

			if (postponedScrollMessageId == 0) {
				chatScrollHelperCallback.scrollTo = null
				chatScrollHelperCallback.lastBottom = true
				chatScrollHelperCallback.lastItemOffset = 0
				chatScrollHelperCallback.lastPadding = chatListViewPadding.toInt()

				chatScrollHelper?.scrollToPosition(0, 0, true, true)
			}
			else {
				var `object` = messagesDict[loadIndex][postponedScrollMessageId]

				if (`object` != null) {
					val groupedMessages = groupedMessagesMap[`object`.groupId]

					if (`object`.groupId != 0L && groupedMessages != null) {
						val primary = groupedMessages.findPrimaryMessageObject()

						if (primary != null) {
							`object` = primary
						}
					}
				}

				if (`object` != null) {
					val k = messages.indexOf(`object`)

					if (k >= 0) {
						val fromPosition = chatLayoutManager!!.findFirstVisibleItemPosition()

						highlightMessageId = `object`.id

						val direction = if (postponedScrollMinMessageId != 0) {
							if (highlightMessageId < 0 && postponedScrollMinMessageId < 0) {
								if (highlightMessageId < postponedScrollMinMessageId) RecyclerAnimationScrollHelper.SCROLL_DIRECTION_DOWN else RecyclerAnimationScrollHelper.SCROLL_DIRECTION_UP
							}
							else {
								if (highlightMessageId > postponedScrollMinMessageId) RecyclerAnimationScrollHelper.SCROLL_DIRECTION_DOWN else RecyclerAnimationScrollHelper.SCROLL_DIRECTION_UP
							}
						}
						else {
							if (fromPosition > k) RecyclerAnimationScrollHelper.SCROLL_DIRECTION_DOWN else RecyclerAnimationScrollHelper.SCROLL_DIRECTION_UP
						}

						chatScrollHelper?.scrollDirection = direction

						if (!needSelectFromMessageId) {
							removeSelectedMessageHighlight()
						}

						val yOffset = getScrollOffsetForMessage(`object`)

						chatScrollHelperCallback.scrollTo = `object`
						chatScrollHelperCallback.lastBottom = false
						chatScrollHelperCallback.lastItemOffset = yOffset
						chatScrollHelperCallback.lastPadding = chatListViewPadding.toInt()

						chatScrollHelper?.scrollToPosition(chatAdapter!!.messagesStartRow + k, yOffset, false, true)
					}
				}
			}
		}

		chatWasReset = false
	}

	override fun didReceivedNotification(id: Int, account: Int, vararg args: Any?) {
		when (id) {
			NotificationCenter.chatIsBlocked -> {
				val chatId = args[0] as Long

				if (currentChatInfo == null || currentChat?.id != chatId) {
					return
				}

				val error = args[1] as? String

				if (error != NotificationCenter.ERROR_CHAT_BLOCKED) {
					return
				}

				val errorText = if (isOnlineCourse(currentChat)) {
					context?.getString(R.string.banned_course_message)
				}
				else if (isMegagroup(currentChat)) {
					context?.getString(R.string.banned_group_message)
				}
				else {
					context?.getString(R.string.banned_channel_message)
				} ?: return

				BulletinFactory.of(this@ChatActivity).createErrorBulletin(errorText, duration = Bulletin.DURATION_LONG).show()
			}

			NotificationCenter.messagesDidLoad -> {
				processNewMessagesFromArgs(*args.toList().toTypedArray())
			}

			NotificationCenter.invalidateMotionBackground -> {
				chatListView?.invalidateViews()
				messageEnterTransitionContainer?.invalidate()
			}

			NotificationCenter.emojiLoaded -> {
				chatListView?.invalidateViews()
				replyObjectTextView?.invalidate()
				alertTextView?.invalidate()

				for (a in 0..1) {
					pinnedMessageTextView[a]?.invalidate()
				}

				mentionContainer?.listView?.invalidateViews()
				messagesSearchListView?.invalidateViews()
				undoView?.invalidate()

				if (chatActivityEnterView != null) {
					val editText: EditTextBoldCursor = chatActivityEnterView!!.editField
					val color = editText.currentTextColor
					editText.setTextColor(-0x1)
					editText.setTextColor(color)
				}

				pinnedMessageButton[0]?.invalidate()
				pinnedMessageButton[1]?.invalidate()
			}

			NotificationCenter.didUpdateConnectionState -> {
				val state = ConnectionsManager.getInstance(account).getConnectionState()

				if (state == ConnectionsManager.ConnectionStateConnected) {
					checkAutoDownloadMessages(false)
				}
			}

			NotificationCenter.chatOnlineCountDidLoad -> {
				val chatId = args[0] as Long

				if (currentChatInfo == null || currentChat == null || currentChat!!.id != chatId) {
					return
				}

				currentChatInfo?.online_count = (args[1] as Int)

				avatarContainer?.updateOnlineCount()
				avatarContainer?.updateSubtitle()
			}

			NotificationCenter.updateDefaultSendAsPeer -> {
				val chatId = args[0] as Long

				if (chatId == dialogId) {
					chatActivityEnterView?.updateSendAsButton(true)
				}
			}

			NotificationCenter.updateInterfaces -> {
				val updateMask = args[0] as Int

				if (updateMask and MessagesController.UPDATE_MASK_NAME != 0 || updateMask and MessagesController.UPDATE_MASK_CHAT_NAME != 0 || updateMask and MessagesController.UPDATE_MASK_EMOJI_STATUS != 0) {
					if (currentChat != null) {
						val chat = messagesController.getChat(currentChat?.id)

						if (chat != null) {
							currentChat = chat
						}
					}
					else if (currentUser != null) {
						val user = messagesController.getUser(currentUser?.id)

						if (user != null) {
							currentUser = user
						}
					}

					updateTitle(true)
				}

				var updateSubtitle = false

				if (!isThreadChat && (updateMask and MessagesController.UPDATE_MASK_CHAT_MEMBERS != 0 || updateMask and MessagesController.UPDATE_MASK_STATUS != 0)) {
					if (currentChat != null) {
						avatarContainer?.updateOnlineCount()
					}

					updateSubtitle = true
				}

				if (updateMask and MessagesController.UPDATE_MASK_AVATAR != 0 || updateMask and MessagesController.UPDATE_MASK_CHAT_AVATAR != 0 || updateMask and MessagesController.UPDATE_MASK_NAME != 0) {
					checkAndUpdateAvatar()
					updateVisibleRows()
				}

				if (updateMask and MessagesController.UPDATE_MASK_USER_PRINT != 0) {
					updateSubtitle = true

//					if (BuildConfig.AI_BOT_ID == dialogId) {
//						AndroidUtilities.runOnUIThread {
//							if (!chatbotStatusIsShowing) {
//								showDialog(AiChatbotStatusBottomSheet(context!!, this@ChatActivity))
//								chatbotStatusIsShowing = true
//							}
//						}
//					}
				}

				if (updateMask and MessagesController.UPDATE_MASK_CHAT != 0 && currentChat != null) {
					val fwdBefore = messagesController.isChatNoForwards(currentChat)
					val chat = messagesController.getChat(currentChat?.id) ?: return

					currentChat = chat

					updateTitleIcons()

					val fwdChanged = messagesController.isChatNoForwards(currentChat) != fwdBefore

					updateSubtitle = !isThreadChat

					updateBottomOverlay()

					chatActivityEnterView?.setDialogId(dialogId, currentAccount)

					if (currentEncryptedChat != null && SharedConfig.passcodeHash.isEmpty() && !SharedConfig.allowScreenCapture && unregisterFlagSecurePasscode == null) {
						unregisterFlagSecurePasscode = AndroidUtilities.registerFlagSecure(parentActivity!!.window)
					}

					if (fwdChanged) {
						val value = messagesController.isChatNoForwards(currentChat)

						if (!value && unregisterFlagSecureNoforwards != null) {
							unregisterFlagSecureNoforwards?.run()
							unregisterFlagSecureNoforwards = null
						}
						else if (value && unregisterFlagSecureNoforwards == null) {
							unregisterFlagSecureNoforwards = AndroidUtilities.registerFlagSecure(parentActivity!!.window)
						}
					}
				}

				if (updateSubtitle) {
					avatarContainer?.updateSubtitle(true)
				}

				if (updateMask and MessagesController.UPDATE_MASK_USER_PHONE != 0) {
					updateTopPanel(true)
				}

				// MARK: attempt to load new comments in thread
//			if (isThreadChat() && isComments) {
//				waitingForLoad.add(lastLoadIndex);
//
//				var lastMessage = messages.stream().max(Comparator.comparingInt(o -> o.messageOwner.date)).orElse(null);
//				var msgId = lastMessage != null ? lastMessage.messageOwner.id : 0;
//				var offsetDate = lastMessage != null ? lastMessage.messageOwner.date : 0;
//
//				getMessagesController().loadMessages(dialog_id, mergeDialogId, false, AndroidUtilities.isTablet() ? 30 : 20, startLoadFromMessageId, offsetDate, false, 0, classGuid, 2, msgId, chatMode, threadMessageId, replyMaxReadId, lastLoadIndex++);
//			}
			}

			NotificationCenter.didReceiveNewMessages -> {
				val did = args[0] as Long
				val arr = args[1] as List<MessageObject>

				if (did == dialogId) {
					val scheduled = args[2] as Boolean

					if (scheduled != (chatMode == MODE_SCHEDULED)) {
						if (chatMode != MODE_SCHEDULED && !isPaused && forwardingMessages == null) {
							if (arr.isNotEmpty() && arr[0].id < 0) {
								openScheduledMessages()
							}
						}

						return
					}

					processNewMessages(arr.toMutableList())

					if (isAiBot()) {
						chatBotController.updateSubscriptionsInfo()
					}
				}
				else if (isChannel(currentChat) && !currentChat!!.megagroup && currentChatInfo != null && did == -currentChatInfo!!.linked_chat_id) {
					var a = 0
					val N = arr.size

					while (a < N) {
						val messageObject = arr[a]

						if (messageObject.isReply) {
							waitingForReplies.put(messageObject.id, messageObject)
						}

						a++
					}
					checkWaitingForReplies()
				}
			}

			NotificationCenter.didLoadSendAsPeers -> {
				loadSendAsPeers(true)
			}

			NotificationCenter.didLoadSponsoredMessages -> {
				addSponsoredMessages()
			}

			NotificationCenter.closeChats -> {
				if (args.isNotEmpty()) {
					val did = args[0] as Long

					if (did == dialogId) {
						finishFragment()
					}
				}
				else {
					if (AndroidUtilities.isTablet() && parentLayout != null && parentLayout!!.fragmentsStack.size > 1) {
						finishFragment()
					}
					else {
						removeSelfFromStack()
					}
				}
			}

			NotificationCenter.commentsRead -> {
				val channelId = args[0] as Long

				if (currentChat != null && currentChat!!.id == channelId) {
					val mid = args[1] as Int
					val obj = messagesDict[0][mid]

					if (obj != null && obj.hasReplies()) {
						val maxReadId = args[2] as Int

						if (paused) {
							if (delayedReadRunnable != null) {
								AndroidUtilities.cancelRunOnUIThread(delayedReadRunnable)
								delayedReadRunnable = null
							}

							obj.messageOwner?.replies?.read_max_id = maxReadId
						}
						else {
							AndroidUtilities.runOnUIThread(Runnable {
								delayedReadRunnable = null
								obj.messageOwner?.replies?.read_max_id = maxReadId
							}.also {
								delayedReadRunnable = it
							}, 500)
						}
					}
				}
			}

			NotificationCenter.changeRepliesCounter -> {
				val channelId = args[0] as Long

				if (currentChat?.id == channelId) {
					val mid = args[1] as Int
					val obj = messagesDict[0][mid]

					if (obj != null && obj.messageOwner?.replies != null) {
						val count = args[2] as Int

						obj.messageOwner!!.replies!!.replies += count

						if (count > 0) {
							val peer = messagesController.getPeer(getSendAsPeerId(currentChat, messagesController.getChatFull(currentChat!!.id)))
							var c = 0
							val N = obj.messageOwner!!.replies!!.recent_repliers.size

							while (c < N) {
								if (MessageObject.getPeerId(obj.messageOwner!!.replies!!.recent_repliers[c]) == MessageObject.getPeerId(peer)) {
									obj.messageOwner?.replies?.recent_repliers?.removeAt(c)
									break
								}

								c++
							}

							obj.messageOwner?.replies?.recent_repliers?.add(0, peer)
						}

						if ((obj.messageOwner?.replies?.replies ?: 0) < 0) {
							obj.messageOwner?.replies?.replies = 0
						}
					}
				}
			}

			NotificationCenter.threadMessagesRead -> {
				val did = args[0] as Long

				if (dialogId != did) {
					return
				}

				val threadId = args[1] as Int

				if (threadId != this.threadId) {
					return
				}

				val inbox = args[2] as Int
				val outbox = args[3] as Int

				if (inbox > threadMaxInboxReadId) {
					threadMaxInboxReadId = inbox

					var a = 0
					val size2 = messages.size

					while (a < size2) {
						val obj = messages[a]
						val messageId = obj.id

						if (!obj.isOut && messageId > 0 && messageId <= threadMaxInboxReadId) {
							if (!obj.isUnread) {
								break
							}

							obj.setIsRead()

							chatAdapter?.invalidateRowWithMessageObject(obj)
						}

						a++
					}
				}

				if (outbox > threadMaxOutboxReadId) {
					threadMaxOutboxReadId = outbox

					var a = 0
					val size2 = messages.size

					while (a < size2) {
						val obj = messages[a]
						val messageId = obj.id

						if (obj.isOut && messageId > 0 && messageId <= threadMaxOutboxReadId) {
							if (!obj.isUnread) {
								break
							}

							obj.setIsRead()

							chatAdapter?.updateRowWithMessageObject(obj, false)
						}

						a++
					}
				}
			}

			NotificationCenter.messagesRead -> {
				if (chatMode == MODE_SCHEDULED) {
					return
				}

				val inbox = args[0] as? LongSparseIntArray
				val outbox = args[1] as? LongSparseIntArray
				var updated = false

				if (inbox != null) {
					var b = 0
					val size = inbox.size()

					while (b < size) {
						val key = inbox.keyAt(b)
						val messageId = inbox[key].toLong()

						if (key != dialogId) {
							b++
							continue
						}

						var a = 0
						val size2 = messages.size

						while (a < size2) {
							val obj = messages[a]

							if (!obj.isOut && obj.id > 0 && obj.id <= messageId.toInt()) {
								if (!obj.isUnread) {
									break
								}

								obj.setIsRead()

								chatAdapter?.invalidateRowWithMessageObject(obj)

								updated = true

								newUnreadMessageCount--
							}

							a++
						}

						removeUnreadPlane(false)

						break
					}
				}

				if (updated) {
					if (newUnreadMessageCount < 0) {
						newUnreadMessageCount = 0
					}

					if (pagedownButtonCounter != null) {
						if (prevSetUnreadCount != newUnreadMessageCount) {
							prevSetUnreadCount = newUnreadMessageCount
							pagedownButtonCounter?.setCount(newUnreadMessageCount, true)
						}
					}
				}

				if (outbox != null) {
					var b = 0
					val size = outbox.size()

					while (b < size) {
						val key = outbox.keyAt(b)
						val messageId = outbox[key]

						if (key != dialogId) {
							b++
							continue
						}

						var a = 0
						val size2 = messages.size

						while (a < size2) {
							val obj = messages[a]

							if (obj.isOut && obj.id > 0 && obj.id <= messageId) {
								obj.setIsRead()
								chatAdapter?.invalidateRowWithMessageObject(obj)
							}

							a++
						}

						break
					}
				}
			}

			NotificationCenter.historyCleared -> {
				val did = args[0] as Long

				if (did != dialogId) {
					return
				}

				val max_id = args[1] as Int

				if (pinnedMessageIds.isNotEmpty()) {
					pinnedMessageIds.clear()
					pinnedMessageObjects.clear()

					currentPinnedMessageId = 0
					loadedPinnedMessagesCount = 0
					totalPinnedMessagesCount = 0

					updatePinnedMessageView(true)
				}

				var updated = false
				var b = 0

				while (b < messages.size) {
					val obj = messages[b]
					val mid = obj.id

					if (mid <= 0 || mid > max_id) {
						b++
						continue
					}

					messages.removeAt(b)

					b--

					messagesDict[0].remove(mid)

					val dayArr = messagesByDays[obj.dateKey]

					if (dayArr != null) {
						dayArr.remove(obj)

						if (dayArr.isEmpty()) {
							messagesByDays.remove(obj.dateKey)

							if (b >= 0 && b < messages.size) {
								messages.removeAt(b)
								b--
							}
						}
					}

					updated = true

					b++
				}

				if (messages.isEmpty()) {
					if (!endReached[0] && !loading) {
						showProgressView(false)

						chatListView?.setEmptyView(null)

						if (currentEncryptedChat == null) {
							maxMessageId[1] = Int.MAX_VALUE
							maxMessageId[0] = maxMessageId[1]
							minMessageId[1] = Int.MIN_VALUE
							minMessageId[0] = minMessageId[1]
						}
						else {
							maxMessageId[1] = Int.MIN_VALUE
							maxMessageId[0] = maxMessageId[1]
							minMessageId[1] = Int.MAX_VALUE
							minMessageId[0] = minMessageId[1]
						}

						maxDate[1] = Int.MIN_VALUE
						maxDate[0] = maxDate[1]
						minDate[1] = 0
						minDate[0] = minDate[1]

						waitingForLoad.add(lastLoadIndex)

						messagesController.loadMessages(dialogId, mergeDialogId, false, 30, 0, 0, !cacheEndReached[0], minDate[0], classGuid, 0, 0, chatMode, threadId, replyMaxReadId, lastLoadIndex++)

						loading = true
					}
					else {
						if (botButtons != null) {
							botButtons = null
							chatActivityEnterView?.setButtons(null, false)
						}

						if (currentEncryptedChat == null && currentUser != null && currentUser!!.bot && botUser == null) {
							botUser = ""
							updateBottomOverlay()
						}
					}
				}

				canShowPagedownButton = false

				updatePagedownButtonVisibility(true)
				showMentionDownButton(show = false, animated = true)
				removeUnreadPlane(true)

				if (updated) {
					chatAdapter?.notifyDataSetChanged(false)
				}
			}

			NotificationCenter.messagesDeleted -> {
				val scheduled = args[2] as Boolean

				if (scheduled != (chatMode == MODE_SCHEDULED)) {
					return
				}

				val markAsDeletedMessages = args[0] as List<Int>
				val channelId = args[1] as Long

				processDeletedMessages(markAsDeletedMessages, channelId)
			}

			NotificationCenter.messageReceivedByServer -> {
				val scheduled = args[6] as Boolean

				if (scheduled != (chatMode == MODE_SCHEDULED)) {
					return
				}

				val msgId = args[0] as Int
				val obj = messagesDict[0][msgId]

				if (isThreadChat && pendingSendMessagesDict.size() > 0) {
					val `object` = pendingSendMessagesDict[msgId]

					if (`object` != null) {
						val newMsgId = args[1] as Int
						pendingSendMessagesDict.put(newMsgId, `object`)
					}
				}

				if (obj != null) {
					checkChecksHint()

					if (obj.shouldRemoveVideoEditedInfo) {
						obj.videoEditedInfo = null
						obj.shouldRemoveVideoEditedInfo = false
					}

					val newMsgId = args[1] as Int

					if (newMsgId != msgId && messagesDict[0].indexOfKey(newMsgId) >= 0) {
						val removed = messagesDict[0][msgId]

						messagesDict[0].remove(msgId)

						if (removed != null) {
							val index = messages.indexOf(removed)

							messages.removeAt(index)

							val dayArr = messagesByDays[removed.dateKey]!!
							dayArr.remove(obj)

							if (dayArr.isEmpty()) {
								messagesByDays.remove(obj.dateKey)

								if (index >= 0 && index < messages.size) {
									messages.removeAt(index)
								}
							}

							chatAdapter?.notifyDataSetChanged(true)
						}

						return
					}

					val newMsgObj = args[2] as? Message

					val grouped_id = if (args.size >= 4) {
						args[4] as Long
					}
					else {
						0L
					}

					var mediaUpdated = false
					var updatedForward = false

					if (newMsgObj != null) {
						try {
							updatedForward = obj.isForwarded && (obj.messageOwner?.reply_markup == null && newMsgObj.reply_markup != null || obj.messageOwner?.message != newMsgObj.message)
							mediaUpdated = updatedForward || obj.messageOwner?.params != null && obj.messageOwner!!.params!!.containsKey("query_id") || newMsgObj.media != null && obj.messageOwner?.media != null && newMsgObj.media?.javaClass != obj.messageOwner?.media?.javaClass
						}
						catch (e: Exception) {
							FileLog.e(e)
						}

						if (obj.groupId != 0L && newMsgObj.groupId != 0L) {
							val oldGroup = groupedMessagesMap[obj.groupId]

							if (oldGroup != null) {
								groupedMessagesMap.put(newMsgObj.groupId, oldGroup)
							}

							obj.localSentGroupId = obj.messageOwner!!.groupId
							obj.messageOwner?.groupId = grouped_id
						}

						val fwdHeader = obj.messageOwner?.fwd_from

						obj.messageOwner = newMsgObj

						if (fwdHeader != null && newMsgObj.fwd_from != null && !newMsgObj.fwd_from?.from_name.isNullOrEmpty()) {
							obj.messageOwner?.fwd_from = fwdHeader
						}

						obj.generateThumbs(true)
						obj.setType()

						if (newMsgObj.media is TL_messageMediaGame) {
							obj.applyNewText()
						}
					}

					if (updatedForward) {
						obj.measureInlineBotButtons()
					}

					messagesDict[0].remove(msgId)
					messagesDict[0].put(newMsgId, obj)

					obj.messageOwner?.id = newMsgId
					obj.messageOwner?.send_state = MessageObject.MESSAGE_SEND_STATE_SENT
					obj.forceUpdate = mediaUpdated

					addReplyMessageOwner(obj, msgId)

					if (args.size >= 6) {
						obj.applyMediaExistanceFlags((args[5] as Int))
					}

					addToPolls(obj, null)

					val messArr = mutableListOf<MessageObject>()
					messArr.add(obj)

					if (currentEncryptedChat == null) {
						mediaDataController.loadReplyMessagesForMessages(messArr, dialogId, chatMode == MODE_SCHEDULED, null)
					}

					chatAdapter?.updateRowWithMessageObject(obj, false)

					if (chatLayoutManager != null) {
						if (mediaUpdated && chatLayoutManager?.findFirstVisibleItemPosition() == 0) {
							moveScrollToLastMessage(false)
						}
					}

					if (obj.messageOwner == null || !obj.messageOwner!!.silent) {
						notificationsController.playOutChatSound()
					}
				}
			}

			NotificationCenter.messageReceivedByAck -> {
				val msgId = args[0] as Int
				val obj = messagesDict[0][msgId]

				if (obj != null) {
					obj.messageOwner?.send_state = MessageObject.MESSAGE_SEND_STATE_SENT
					chatAdapter?.updateRowWithMessageObject(obj, false)
				}
			}

			NotificationCenter.messageSendError -> {
				val msgId = args[0] as Int
				val obj = messagesDict[0][msgId]

				if (obj != null) {
					obj.messageOwner?.send_state = MessageObject.MESSAGE_SEND_STATE_SEND_ERROR
					updateVisibleRows()
				}
			}

			NotificationCenter.groupCallUpdated -> {
				val chatId = args[0] as Long

				if (dialogId == -chatId) {
					groupCall = messagesController.getGroupCall(currentChat!!.id, false)
					fragmentContextView?.checkCall(openAnimationStartTime == 0L || SystemClock.elapsedRealtime() < openAnimationStartTime + 150)
					checkGroupCallJoin(false)
				}
			}

			NotificationCenter.didLoadChatInviter -> {
				val chatId = args[0] as Long

				if (dialogId == -chatId && chatInviterId == 0L) {
					chatInviterId = args[1] as Long
					currentChatInfo?.inviterId = chatInviterId
					updateInfoTopView(openAnimationStartTime != 0L && SystemClock.elapsedRealtime() >= openAnimationStartTime + 150)
				}
			}

			NotificationCenter.chatInfoDidLoad -> {
				val chatFull = args[0] as ChatFull

				if (currentChat != null && chatFull.id == currentChat!!.id) {
					if (chatFull is TL_channelFull) {
						if (currentChat!!.megagroup) {
							var lastDate = 0

							if (chatFull.participants != null) {
								for (a in chatFull.participants.participants.indices) {
									lastDate = max(chatFull.participants.participants[a].date, lastDate)
								}
							}

							if (lastDate == 0 || abs(System.currentTimeMillis() / 1000 - lastDate) > 60 * 60) {
								messagesController.loadChannelParticipants(currentChat!!.id)
							}
						}

						if (chatFull.participants == null && currentChatInfo != null) {
							chatFull.participants = currentChatInfo?.participants
						}
					}

					showGigagroupConvertAlert()

					val prevLinkedChatId = currentChatInfo?.linked_chat_id ?: 0

					currentChatInfo = chatFull

					currentChat?.let { currentChat ->
						if (isPaidChannel(currentChat)) {
							ioScope.launch {
								checkSubscription(currentChat)
							}
						}
						else if (currentChat.adult) {
							ioScope.launch {
								if (isChannel(currentChat) && currentChat !is TL_channelForbidden) {
									if (isNotInChat(currentChat) && (!isThreadChat || currentChat.join_to_send)) {
										checkAdultSubscription(currentChat)
									}
								}
							}
						}
						else {
							// stub
						}
					}

					groupCall = messagesController.getGroupCall(currentChat!!.id, true)

					if (isChannel(currentChat) && currentChat!!.megagroup && fragmentContextView != null) {
						fragmentContextView!!.checkCall(openAnimationStartTime == 0L || SystemClock.elapsedRealtime() < openAnimationStartTime + 150)
					}

					loadSendAsPeers(false)

					chatActivityEnterView?.updateSendAsButton(false)
					chatActivityEnterView?.updateFieldHint(false)

					chatAdapter?.notifyDataSetChanged(true)

					if (prevLinkedChatId != currentChatInfo!!.linked_chat_id) {
						if (prevLinkedChatId != 0L) {
							val chat = messagesController.getChat(prevLinkedChatId)
							messagesController.startShortPoll(chat, classGuid, true)
						}

						if (currentChatInfo!!.linked_chat_id != 0L) {
							val chat = messagesController.getChat(currentChatInfo!!.linked_chat_id)

							if (chat != null && chat.megagroup) {
								messagesController.startShortPoll(chat, classGuid, false)
							}
						}
					}

					val animated = openAnimationStartTime != 0L && SystemClock.elapsedRealtime() >= openAnimationStartTime + 150

					checkActionBarMenu(animated)

					if (chatInviterId == 0L) {
						fillInviterId(true)
						updateInfoTopView(animated)
					}

					chatActivityEnterView?.setChatInfo(currentChatInfo!!)

					mentionContainer?.adapter?.setChatInfo(currentChatInfo)

					if (!isThreadChat) {
						avatarContainer?.updateOnlineCount()
						avatarContainer?.updateSubtitle()

						if (!inMenuMode && !loadingPinnedMessagesList && pinnedMessageIds.isNotEmpty() && currentChatInfo!!.pinned_msg_id > pinnedMessageIds[0]) {
							mediaDataController.loadPinnedMessages(dialogId, 0, currentChatInfo!!.pinned_msg_id)
							loadingPinnedMessagesList = true
						}
					}

					if (currentChatInfo is TL_chatFull) {
						hasBotsCommands = false

						botInfo.clear()

						botsCount = 0

						URLSpanBotCommand.enabled = false

						for (a in currentChatInfo!!.participants.participants.indices) {
							val participant = currentChatInfo!!.participants.participants[a]
							val user = messagesController.getUser(participant.user_id)

							if (user != null && user.bot) {
								URLSpanBotCommand.enabled = true

								botsCount++

								if (!isThreadChat) {
									hasBotsCommands = true
								}

								mediaDataController.loadBotInfo(user.id, -currentChatInfo!!.id, true, classGuid)
							}
						}

						chatListView?.invalidateViews()
					}
					else if (currentChatInfo is TL_channelFull) {
						hasBotsCommands = false

						botInfo.clear()

						botsCount = 0

						URLSpanBotCommand.enabled = currentChatInfo!!.bot_info.isNotEmpty() && currentChat != null && currentChat!!.megagroup

						botsCount = currentChatInfo!!.bot_info.size

						for (a in currentChatInfo!!.bot_info.indices) {
							val bot = currentChatInfo!!.bot_info[a]
							if (!isThreadChat && bot.commands.isNotEmpty() && (!isChannel(currentChat) || currentChat != null && currentChat!!.megagroup)) {
								hasBotsCommands = true
							}

							botInfo.put(bot.user_id, bot)
						}

						chatListView?.invalidateViews()

						if (!isChannel(currentChat) || currentChat != null && currentChat!!.megagroup) {
							mentionContainer?.adapter?.setBotInfo(botInfo)
							chatActivityEnterView?.setBotInfo(botInfo)
						}
					}

					chatActivityEnterView?.setBotsCount(botsCount, hasBotsCommands, true)

					mentionContainer?.adapter?.setBotsCount(botsCount)

					if (chatMode == 0 && isChannel(currentChat) && mergeDialogId == 0L && currentChatInfo!!.migrated_from_chat_id != 0L && !isThreadChat) {
						mergeDialogId = -currentChatInfo!!.migrated_from_chat_id
						maxMessageId[1] = currentChatInfo!!.migrated_from_max_id

						chatAdapter?.notifyDataSetChanged(true)

						if (mergeDialogId != 0L && endReached[0]) {
							checkScrollForLoad(false)
						}
					}

					checkGroupCallJoin(args[3] as Boolean)
					checkThemeEmoticon()

					pendingRequestsDelegate?.setChatInfo(currentChatInfo, true)
				}
			}

			NotificationCenter.chatInfoCantLoad -> {
				val chatId = args[0] as Long

				if (currentChat != null && currentChat!!.id == chatId) {
					val reason = args[1] as Int

					if (parentActivity == null || closeChatDialog != null) {
						return
					}

					val builder = AlertDialog.Builder(parentActivity!!)
					builder.setTitle(context!!.getString(R.string.AppName))

					if (reason == 0) {
						if (currentChat is TL_channelForbidden) {
							builder.setMessage(context!!.getString(R.string.ChannelCantOpenBannedByAdmin))
						}
						else {
							builder.setTitle(context!!.getString(R.string.ChannelPrivate))
							builder.setMessage(context!!.getString(R.string.ChannelCantOpenPrivate2))
						}
					}
					else if (reason == 1) {
						builder.setMessage(context!!.getString(R.string.ChannelCantOpenNa))
					}
					else if (reason == 2) {
						builder.setMessage(context!!.getString(R.string.ChannelCantOpenBanned))
					}
					else if (reason == 3) {
						builder.setTitle(context!!.getString(R.string.ChannelPrivate))
						builder.setMessage(context!!.getString(R.string.JoinByPeekChannelText))
					}

					builder.setPositiveButton(context!!.getString(R.string.OK), null)

					if (showDialog(builder.create().also { closeChatDialog = it }) == null) {
						showCloseChatDialogLater = true
					}

					loading = false

					showProgressView(false)

					chatAdapter?.notifyDataSetChanged(false)
				}
			}

			NotificationCenter.contactsDidLoad -> {
				updateTopPanel(true)

				if (!isThreadChat) {
					avatarContainer?.updateSubtitle()
				}
			}

			NotificationCenter.encryptedChatUpdated -> {
				val chat = args[0] as EncryptedChat

				if (currentEncryptedChat != null && chat.id == currentEncryptedChat!!.id) {
					currentEncryptedChat = chat

					updateTopPanel(true)
					updateSecretStatus()

					suggestEmojiPanel?.fireUpdate()

					chatActivityEnterView?.setAllowStickersAndGifs(needAnimatedEmoji = true, needStickers = true, needGifs = true)
					chatActivityEnterView?.checkRoundVideo()

					mentionContainer?.adapter?.setNeedBotContext(!chatActivityEnterView!!.isEditingMessage)
				}
			}

			NotificationCenter.messagesReadEncrypted -> {
				val encId = args[0] as Int

				if (currentEncryptedChat != null && currentEncryptedChat!!.id == encId) {
					val date = args[1] as Int

					for (obj in messages) {
						if (!obj.isOut) {
							continue
						}
						else if (obj.isOut && !obj.isUnread) {
							break
						}

						if (obj.messageOwner!!.date - 1 <= date) {
							obj.setIsRead()
							chatAdapter?.invalidateRowWithMessageObject(obj)
						}
					}
				}
			}

			NotificationCenter.removeAllMessagesFromDialog -> {
				val did = args[0] as Long

				if (dialogId == did) {
					if (threadId != 0) {
						if (forwardEndReached[0]) {
							forwardEndReached[0] = false
							hideForwardEndReached = false

							chatAdapter?.notifyItemInserted(0)
						}

						threadMessage?.let {
							messagesController.addToViewsQueue(it)
						}

					}
					else {
						clearHistory(args[1] as Boolean, args[2] as? TL_updates_channelDifferenceTooLong)
					}
				}
			}

			NotificationCenter.screenshotTook -> {
				updateInformationForScreenshotDetector()
			}

			NotificationCenter.blockedUsersDidLoad -> {
				if (currentUser != null && !isReplyUser(currentUser)) {
					val oldValue = userBlocked

					userBlocked = messagesController.blockedPeers.indexOfKey(currentUser!!.id) >= 0

					if (oldValue != userBlocked) {
						updateBottomOverlay()
					}
				}
			}

			NotificationCenter.fileNewChunkAvailable -> {
				val messageObject = args[0] as MessageObject
				val finalSize = args[3] as Long

				if (finalSize != 0L && dialogId == messageObject.dialogId) {
					val currentObject = messagesDict[0][messageObject.id]

					if (currentObject?.messageOwner?.media?.document != null) {
						currentObject.messageOwner?.media?.document?.size = finalSize.toInt().toLong()
						updateVisibleRows()
					}
				}
			}

			NotificationCenter.didCreatedNewDeleteTask -> {
				val dialogId = args[0] as Long

				if (dialogId != this.dialogId) {
					return
				}

				val mids = args[1] as SparseArray<List<Int>>
				var changed = false

				for (i in 0 until mids.size()) {
					val key = mids.keyAt(i)
					val arr = mids[key]

					for (a in arr.indices) {
						val mid = arr[a]
						val messageObject = messagesDict[0][mid]

						if (messageObject != null) {
							messageObject.messageOwner?.destroyTime = key
							changed = true
						}
					}
				}

				if (changed) {
					updateVisibleRows()
				}
			}

			NotificationCenter.messagePlayingDidStart -> {
				val messageObject = args[0] as MessageObject

				if (messageObject.eventId != 0L) {
					return
				}

				sendSecretMessageRead(messageObject, true)

				if ((messageObject.isRoundVideo || messageObject.isVideo) && fragmentView != null && fragmentView!!.parent != null) {
					MediaController.getInstance().setTextureView(createTextureView(true), aspectRatioFrameLayout, videoPlayerContainer, true)
					updateTextureViewPosition(true)
				}

				if (chatListView != null) {
					var count = chatListView?.childCount ?: 0

					for (a in 0 until count) {
						val view = chatListView?.getChildAt(a)

						if (view is ChatMessageCell) {
							val messageObject1 = view.getMessageObject()

							if (messageObject1 != null) {
								val isVideo = messageObject1.isVideo

								if (messageObject1.isRoundVideo || isVideo) {
									view.checkVideoPlayback(!messageObject.equals(messageObject1), null)

									if (!MediaController.getInstance().isPlayingMessage(messageObject1)) {
										if (isVideo && !MediaController.getInstance().isGoingToShowMessageObject(messageObject1)) {
											val animation = view.photoImage.animation
											animation?.start()
										}

										if (messageObject1.audioProgress != 0f) {
											messageObject1.resetPlayingProgress()
											view.invalidate()
										}
									}
									else if (isVideo) {
										view.updateButtonState(ifSame = false, animated = true, fromSet = false)
									}

									if (messageObject1.isRoundVideo) {
										val position = chatListView!!.getChildAdapterPosition(view)

										if (position >= 0) {
											if (MediaController.getInstance().isPlayingMessage(messageObject1)) {
												val keyboardIsVisible = contentView!!.keyboardHeight >= AndroidUtilities.dp(20f)
												val topPadding = chatListViewPadding - (contentPanTranslation + bottomPanelTranslationY)
												val offset = ((chatListView!!.measuredHeight - topPadding - blurredViewBottomOffset) / 2 - (if (keyboardIsVisible) AndroidUtilities.roundMessageSize else AndroidUtilities.roundPlayingMessageSize) / 2 - if (view.reactionsLayoutInBubble == null) 0 else view.reactionsLayoutInBubble.totalHeight).toInt()

												chatLayoutManager?.scrollToPositionWithOffset(position, offset, false)
											}

											chatAdapter?.notifyItemChanged(position)
										}
									}
								}
								else if (messageObject1.isVoice || messageObject1.isMusic) {
									view.updateButtonState(ifSame = false, animated = true, fromSet = false)
								}
							}
						}
					}

					if (mentionContainer?.listView != null) {
						count = mentionContainer?.listView?.childCount ?: 0

						for (a in 0 until count) {
							val view = mentionContainer?.listView?.getChildAt(a)

							if (view is ContextLinkCell) {
								val messageObject1 = view.messageObject

								if (messageObject1 != null && (messageObject1.isVoice || messageObject1.isMusic)) {
									view.updateButtonState(false, true)
								}
							}
						}
					}
				}
			}

			NotificationCenter.messagePlayingGoingToStop -> {
				val injecting = args[1] as Boolean

				if (injecting) {
					contentView?.removeView(videoPlayerContainer)

					videoPlayerContainer = null
					videoTextureView = null
					aspectRatioFrameLayout = null
				}
				else {
					if (chatListView != null && videoPlayerContainer?.tag != null) {
						val messageObject = args[0] as MessageObject
						val count = chatListView?.childCount ?: 0

						for (a in 0 until count) {
							val view = chatListView!!.getChildAt(a)

							if (view is ChatMessageCell) {
								val messageObject1 = view.getMessageObject()

								if (messageObject === messageObject1) {
									val animation = view.photoImage.animation

									if (animation != null) {
										val bitmap = animation.animatedBitmap

										if (bitmap != null) {
											try {
												val src = videoTextureView!!.getBitmap(bitmap.width, bitmap.height)
												val canvas = Canvas(bitmap)
												canvas.drawBitmap(src!!, 0f, 0f, null)
												src.recycle()
											}
											catch (e: Throwable) {
												FileLog.e(e)
											}
										}

										animation.seekTo(messageObject.audioProgressMs.toLong(), !fileLoader.isLoadingVideo(messageObject.document, true))
									}

									break
								}
							}
						}
					}
				}
			}

			NotificationCenter.messagePlayingDidReset, NotificationCenter.messagePlayingPlayStateChanged -> {
				if (id == NotificationCenter.messagePlayingDidReset) {
					AndroidUtilities.runOnUIThread(destroyTextureViewRunnable)
				}

				val messageId = args[0] as Int

				if (chatListView != null) {
					var count = chatListView!!.childCount

					for (a in 0 until count) {
						val view = chatListView!!.getChildAt(a)

						if (view is ChatMessageCell) {
							val messageObject = view.getMessageObject()

							if (messageObject != null) {
								if (messageObject.isVoice || messageObject.isMusic) {
									view.updateButtonState(ifSame = false, animated = true, fromSet = false)
								}
								else if (messageObject.isVideo) {
									view.updateButtonState(ifSame = false, animated = true, fromSet = false)

									if (!MediaController.getInstance().isPlayingMessage(messageObject) && !MediaController.getInstance().isGoingToShowMessageObject(messageObject)) {
										val animation = view.photoImage.animation
										animation?.start()
									}
								}
								else if (messageObject.isRoundVideo) {
									if (!MediaController.getInstance().isPlayingMessage(messageObject)) {
										var bitmap: Bitmap? = null

										if (id == NotificationCenter.messagePlayingDidReset && view.getMessageObject()!!.id == messageId && videoTextureView != null) {
											bitmap = videoTextureView?.bitmap

											if (bitmap != null && bitmap.getPixel(0, 0) == Color.TRANSPARENT) {
												bitmap = null
											}
										}

										view.checkVideoPlayback(true, bitmap)
									}

									val position = chatListView!!.getChildAdapterPosition(view)

									messageObject.forceUpdate = true

									if (position >= 0) {
										chatAdapter?.notifyItemChanged(position)
									}
								}
							}
						}
					}

					if (mentionContainer?.listView != null) {
						count = mentionContainer?.listView?.childCount ?: 0

						for (a in 0 until count) {
							val view = mentionContainer?.listView?.getChildAt(a)

							if (view is ContextLinkCell) {
								val messageObject = view.messageObject

								if (messageObject != null && (messageObject.isVoice || messageObject.isMusic)) {
									view.updateButtonState(false, true)
								}
							}
						}
					}
				}
			}

			NotificationCenter.messagePlayingProgressDidChanged -> {
				val mid = args[0] as Int
				val chatListView = chatListView ?: return

				val count = chatListView.childCount

				for (a in 0 until count) {
					val view = chatListView.getChildAt(a)

					if (view is ChatMessageCell) {
						val playing = view.getMessageObject()

						if (playing != null && playing.id == mid) {
							val player = MediaController.getInstance().playingMessageObject

							if (player != null && !view.seekBar.isDragging) {
								playing.audioProgress = player.audioProgress
								playing.audioProgressSec = player.audioProgressSec
								playing.audioPlayerDuration = player.audioPlayerDuration

								view.updatePlayingMessageProgress()

								if (drawLaterRoundProgressCell === view) {
									fragmentView?.invalidate()
								}
							}

							break
						}
					}
				}
			}

			NotificationCenter.didUpdatePollResults -> {
				val pollId = args[0] as Long
				val arrayList = polls[pollId] ?: return

				val poll = args[1] as? TL_poll
				val results = args[2] as? PollResults
				var pollView: View? = null
				var isVotedChanged = false
				var isQuiz = false

				for (`object` in arrayList) {
					val isVoted = `object`.isVoted
					val media = `object`.messageOwner?.media as? TL_messageMediaPoll

					if (poll != null) {
						media?.poll = poll
						isQuiz = poll.quiz
					}
					else if (media?.poll != null) {
						isQuiz = media.poll.quiz
					}

					MessageObject.updatePollResults(media, results)

					if (chatAdapter != null) {
						pollView = chatAdapter?.updateRowWithMessageObject(`object`, true)
					}

					if (isVoted != `object`.isVoted) {
						isVotedChanged = true
					}
				}

				if (isVotedChanged && isQuiz && undoView != null && pollView is ChatMessageCell) {
					val cell = pollView

					if (cell.isAnimatingPollAnswer) {
						var a = 0
						val N = results?.results?.size ?: 0

						while (a < N) {
							val voters = results?.results?.get(a)

							if (voters?.chosen == true) {
								if (voters.correct) {
									fireworksOverlay?.start()
									pollView.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP, HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING)
								}
								else {
									pollView.shakeView()
									pollView.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP, HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING)
									showPollSolution(cell.getMessageObject(), results)
									cell.showHintButton(show = false, animated = true, type = 0)
								}

								break
							}

							a++
						}
					}
				}
			}

			NotificationCenter.didUpdateExtendedMedia -> {
				val did = args[0] as Long

				doOnIdle {
					val msgId = args[1] as Int
					val messageObject = messagesDict[if (did == dialogId) 0 else 1][msgId]

					if (messageObject != null) {
						messageObject.messageOwner?.media?.extended_media = args[2] as MessageExtendedMedia
						messageObject.forceUpdate = true
						messageObject.setType()
						updateMessageAnimated(messageObject, false)
					}
				}
			}

			NotificationCenter.didUpdateReactions -> {
				val did = args[0] as Long

				doOnIdle {
					val msgId = args[1] as Int
					val messageObject = messagesDict[if (did == dialogId) 0 else 1][msgId]

					if (messageObject != null) {
						MessageObject.updateReactions(messageObject.messageOwner, args[2] as TL_messageReactions)
						messageObject.forceUpdate = true
						messageObject.reactionsChanged = true
						updateMessageAnimated(messageObject, true)
					}
				}
			}

			NotificationCenter.didVerifyMessagesStickers -> {
				val messages = args[0] as List<Message>

				for (message in messages) {
					val existMessageObject = messagesDict[0][message.id]

					if (existMessageObject != null) {
						existMessageObject.messageOwner?.stickerVerified = message.stickerVerified
						existMessageObject.setType()

						chatAdapter?.updateRowWithMessageObject(existMessageObject, false)
					}
				}
			}

			NotificationCenter.updateMessageMedia -> {
				val message = args[0] as Message
				val existMessageObject = messagesDict[0][message.id] ?: return

				existMessageObject.messageOwner?.media = message.media
				existMessageObject.messageOwner?.attachPath = message.attachPath
				existMessageObject.generateThumbs(false)

				if (existMessageObject.groupId != 0L && existMessageObject.photoThumbs.isNullOrEmpty()) {
					val groupedMessages = groupedMessagesMap[existMessageObject.groupId]

					if (groupedMessages != null) {
						val idx = groupedMessages.messages.indexOf(existMessageObject)

						if (idx >= 0) {
							val updateCount = groupedMessages.messages.size
							var messageObject: MessageObject? = null

							if (idx > 0 && idx < groupedMessages.messages.size - 1) {
								val slicedGroup = GroupedMessages()
								slicedGroup.groupId = Utilities.random.nextLong()
								slicedGroup.messages.addAll(groupedMessages.messages.subList(idx + 1, groupedMessages.messages.size))

								for (b in slicedGroup.messages.indices) {
									slicedGroup.messages[b].localGroupId = slicedGroup.groupId
									groupedMessages.messages.removeAt(idx + 1)
								}

								groupedMessagesMap.put(slicedGroup.groupId, slicedGroup)

								messageObject = slicedGroup.messages[slicedGroup.messages.size - 1]

								slicedGroup.calculate()
							}

							groupedMessages.messages.removeAt(idx)

							if (groupedMessages.messages.isEmpty()) {
								groupedMessagesMap.remove(groupedMessages.groupId)
							}
							else {
								if (messageObject == null) {
									messageObject = groupedMessages.messages[groupedMessages.messages.size - 1]
								}

								groupedMessages.calculate()

								val index = messages.indexOf(messageObject)

								if (index >= 0) {
									chatAdapter?.notifyItemRangeChanged(index + chatAdapter!!.messagesStartRow, updateCount)
								}
							}
						}
					}
				}

				if (message.media!!.ttl_seconds != 0 && (message.media!!.photo is TL_photoEmpty || message.media!!.document is TL_documentEmpty)) {
					existMessageObject.setType()
					chatAdapter?.updateRowWithMessageObject(existMessageObject, false)
				}
				else {
					updateVisibleRows()
				}
			}

			NotificationCenter.voiceTranscriptionUpdate -> {
				val chatAdapter = chatAdapter ?: return
				var messageObject: MessageObject? = args[0] as? MessageObject
				var transcriptionId: Long = 0
				var transcriptionText: String? = null

				if (args[1] != null) {
					transcriptionId = args[1] as Long
					transcriptionText = args[2] as String
				}

				val messages = if (chatAdapter.isFrozen) chatAdapter.frozenMessages else messages

				if (!messages.contains(messageObject) && args[1] != null) {
					for (a in messages.indices) {
						if (messages[a] != null && messages[a].messageOwner != null && (messages[a].messageOwner?.voiceTranscriptionId == transcriptionId || messageObject != null && messageObject.id == messages[a].id && messageObject.dialogId == messages[a].dialogId)) {
							messageObject = messages[a]
							break
						}
					}
				}

				if (messageObject != null) {
					if (transcriptionText != null && messageObject.messageOwner != null) {
						messageObject.messageOwner?.voiceTranscription = transcriptionText
					}

					if (args.size > 3 && args[3] != null) {
						messageObject.messageOwner?.voiceTranscriptionOpen = (args[3] as Boolean)
					}

					if (args.size > 4 && args[4] != null) {
						messageObject.messageOwner?.voiceTranscriptionFinal = (args[4] as Boolean)
					}

					val index = messages.indexOf(messageObject)

					if (index >= 0 && index < messages.size) {
						val position = index + chatAdapter.messagesStartRow

						chatAdapter.updateRowAtPosition(position)

						for (i in 0 until chatListView!!.childCount) {
							val child = chatListView!!.getChildAt(i)

							if (child is ChatMessageCell && child.getMessageObject() === messageObject) {
								val top = child.getTop() - chatListViewPadding.toInt()
								val halfHeight = ((chatListView!!.measuredHeight - chatListViewPadding) / 2).toInt()

								if (messageObject.measureVoiceTranscriptionHeight() > halfHeight * .4f) {
									chatLayoutManager!!.scrollToPositionWithOffset(position, if (top > halfHeight * .6f && messageObject.isVoiceTranscriptionOpen) (halfHeight * .6f).toInt() else top, false)
								}

								break
							}
						}
					}
				}
			}

			NotificationCenter.animatedEmojiDocumentLoaded -> {
				if (chatAdapter != null) {
					val messageObject = args[0] as? MessageObject

					if (messageObject != null) {
						val messages = (if (chatAdapter?.isFrozen == true) chatAdapter?.frozenMessages else messages) ?: return
						val index = messages.indexOf(messageObject)

						if (index >= 0 && index < messages.size) {
							val position = index + chatAdapter!!.messagesStartRow
							chatAdapter?.updateRowAtPosition(position)
						}
					}
				}
			}

			NotificationCenter.replaceMessagesObjects -> {
				val did = args[0] as Long

				if (did != dialogId && did != mergeDialogId) {
					return
				}

				val loadIndex = if (did == dialogId) 0 else 1

				doOnIdle {
					val messageObjects = args[1] as MutableList<MessageObject>
					replaceMessageObjects(messageObjects, loadIndex, false)
				}
			}

			NotificationCenter.notificationsSettingsUpdated -> {
				updateTitleIcons()

				if (isChannel(currentChat) || isReplyUser(currentUser)) {
					updateBottomOverlay()
				}
			}

			NotificationCenter.replyMessagesDidLoad -> {
				val did = args[0] as Long

				if (did == dialogId) {
					val loadedMessages = args[1] as List<MessageObject>
					val replyMessageOwners = args[2] as? LongSparseArray<SparseArray<List<MessageObject>>>

					for (obj in loadedMessages) {
						repliesMessagesDict.put(obj.id, obj)
					}

					if (replyMessageOwners != null) {
						var a = 0
						val N = replyMessageOwners.size()

						while (a < N) {
							val sparseArray = replyMessageOwners.valueAt(a)
							var c = 0
							val N3 = sparseArray.size()

							while (c < N3) {
								val arrayList = sparseArray.valueAt(c)
								var b = 0
								val N2 = arrayList.size

								while (b < N2) {
									addReplyMessageOwner(arrayList[b], 0)
									b++
								}

								c++
							}

							a++
						}
					}

					updateVisibleRows()
				}
				else if (waitingForReplies.size() != 0 && isChannel(currentChat) && !currentChat!!.megagroup && currentChatInfo != null && did == -currentChatInfo!!.linked_chat_id) {
					checkWaitingForReplies()
				}

				updateReplyMessageHeader(true)
			}

			NotificationCenter.didLoadPinnedMessages -> {
				val did = args[0] as Long

				if (did == dialogId) {
					val ids = args[1] as? List<Int>
					val pin = args[2] as Boolean
					val arrayList = args[3] as? MutableList<MessageObject>
					var dict: HashMap<Int?, MessageObject?>? = null

					if (ids != null) {
						val replaceObjects = args[4] as? Map<Int, MessageObject>
						val maxId = args[5] as Int
						val totalPinnedCount = args[6] as Int
						val endReached = args[7] as Boolean
						val oldPinned = HashMap(pinnedMessageObjects)

						if (replaceObjects != null) {
							loadingPinnedMessagesList = false

							if (maxId == 0) {
								pinnedMessageIds.clear()
								pinnedMessageObjects.clear()
							}

							totalPinnedMessagesCount = totalPinnedCount
							pinnedEndReached = endReached
						}

						var updated = false

						if (arrayList != null) {
							mediaDataController.loadReplyMessagesForMessages(arrayList, dialogId, false, null)
						}

						var a = 0
						val N = ids.size

						while (a < N) {
							val mid = ids[a]

							if (pin) {
								if (pinnedMessageObjects.containsKey(mid)) {
									a++
									continue
								}

								pinnedMessageIds.add(mid)

								var `object` = oldPinned[mid]

								if (`object` == null) {
									`object` = messagesDict[0][mid]
								}

								if (`object` == null && arrayList != null) {
									if (dict == null) {
										dict = HashMap()

										var b = 0
										val N2 = arrayList.size

										while (b < N2) {
											val obj = arrayList[b]
											dict[obj.id] = obj
											b++
										}
									}

									`object` = dict[mid]
								}

								if (`object` == null && replaceObjects != null) {
									`object` = replaceObjects[mid]
								}

								if (`object` != null) {
									pinnedMessageObjects[mid] = `object`
								}

								if (replaceObjects == null) {
									totalPinnedMessagesCount++
								}
							}
							else {
								if (!pinnedMessageObjects.containsKey(mid)) {
									a++
									continue
								}

								pinnedMessageObjects.remove(mid)
								pinnedMessageIds.remove(mid)

								if (replaceObjects == null) {
									totalPinnedMessagesCount--
								}
							}

							loadedPinnedMessagesCount = pinnedMessageIds.size

							if (chatAdapter != null) {
								val obj = messagesDict[0][mid]

								if (obj != null) {
									if (obj.hasValidGroupId()) {
										val groupedMessages = groupedMessagesMap[obj.groupId]

										if (groupedMessages != null) {
											val index = messages.indexOf(groupedMessages.messages[groupedMessages.messages.size - 1])

											if (index >= 0) {
												chatAdapter?.notifyItemRangeChanged(index, groupedMessages.messages.size)
											}
										}
									}
									else {
										chatAdapter?.updateRowWithMessageObject(obj, false)
									}
								}
							}

							updated = true

							a++
						}

						if (updated) {
							if (chatMode == MODE_PINNED && avatarContainer != null) {
								avatarContainer?.setTitle(LocaleController.formatPluralString("PinnedMessagesCount", pinnedMessagesCount))
							}

							pinnedMessageIds.sortWith { o1: Int?, o2: Int ->
								o2.compareTo(o1!!)
							}

							if (pinnedMessageIds.isEmpty()) {
								hidePinnedMessageView(true)
							}
							else {
								updateMessagesVisiblePart(false)
							}
						}

						if (chatMode == MODE_PINNED) {
							if (pin) {
								arrayList?.let {
									processNewMessages(it)
								}
							}
							else {
								processDeletedMessages(ids, if (isChannel(currentChat)) dialogId else 0)
							}
						}
					}
					else {
						if (pin) {
							arrayList?.forEach { message ->
								if (pinnedMessageObjects.containsKey(message.id)) {
									pinnedMessageObjects[message.id] = message
								}

								loadingPinnedMessages.delete(message.id)
							}

							mediaDataController.loadReplyMessagesForMessages(arrayList, dialogId, false, null)

							updateMessagesVisiblePart(false)
						}
						else {
							pinnedMessageIds.clear()
							pinnedMessageObjects.clear()

							currentPinnedMessageId = 0
							loadedPinnedMessagesCount = 0
							totalPinnedMessagesCount = 0

							hidePinnedMessageView(true)
						}
					}
				}
			}

			NotificationCenter.didReceivedWebpages -> {
				val arrayList = args[0] as? List<Message> ?: return
				var updated = false

				for (message in arrayList) {
					val did = MessageObject.getDialogId(message)

					if (did != dialogId && did != mergeDialogId) {
						continue
					}

					val currentMessage = messagesDict[if (did == dialogId) 0 else 1][message.id]

					if (currentMessage != null) {
						currentMessage.messageOwner?.media = TL_messageMediaWebPage()
						currentMessage.messageOwner?.media?.webpage = message.media?.webpage

						currentMessage.generateThumbs(true)

						updated = true
					}
				}

				if (updated) {
					updateVisibleRows()
				}
			}

			NotificationCenter.didReceivedWebpagesInUpdates -> {
				if (foundWebPage != null) {
					val hashMap = args[0] as LongSparseArray<WebPage>

					for (a in 0 until hashMap.size()) {
						val webPage = hashMap.valueAt(a)

						if (webPage.id == foundWebPage?.id) {
							showFieldPanelForWebPage(webPage !is TL_webPageEmpty, webPage, false)
							break
						}
					}
				}
			}

			NotificationCenter.messagesReadContent -> {
				val did = args[0] as Long

				if (did != dialogId && (isChannel(currentChat) || did != 0L)) {
					return
				}

				val arrayList = args[1] as? List<Int> ?: return

				for (mid in arrayList) {
					val currentMessage = messagesDict[0][mid]

					if (currentMessage != null) {
						currentMessage.setContentIsRead()

						if (currentMessage.messageOwner?.mentioned == true) {
							newMentionsCount--

							if (newMentionsCount <= 0) {
								newMentionsCount = 0
								hasAllMentionsLocal = true

								showMentionDownButton(show = false, animated = true)
							}
							else {
								mentiondownButtonCounter?.setText(String.format("%d", newMentionsCount))
							}
						}

						chatAdapter?.invalidateRowWithMessageObject(currentMessage)
					}
				}
			}

			NotificationCenter.botInfoDidLoad -> {
				val guid = args[1] as Int

				if (classGuid == guid || guid == 0) {
					val info = args[0] as BotInfo

					if (currentEncryptedChat == null) {
						if (info.commands.isNotEmpty() && !isChannel(currentChat) && !isThreadChat) {
							hasBotsCommands = true
						}

						if (info.user_id == 0L && currentUser != null) {
							info.user_id = currentUser!!.id
						}

						botInfo.put(info.user_id, info)

						if (chatAdapter != null) {
							val prevRow = chatAdapter!!.botInfoRow

							chatAdapter?.updateRowsInternal()

							if (prevRow < 0 && chatAdapter!!.botInfoRow >= 0) {
								chatAdapter?.notifyItemInserted(chatAdapter!!.botInfoRow)
							}
							else if (prevRow >= 0 && chatAdapter!!.botInfoRow < 0) {
								chatAdapter?.notifyItemRemoved(prevRow)
							}
							else if (prevRow >= 0 && chatAdapter!!.botInfoRow >= 0) {
								chatAdapter?.notifyItemChanged(chatAdapter!!.botInfoRow)
							}
						}

						if (!isChannel(currentChat) || currentChat != null && currentChat!!.megagroup) {
							mentionContainer?.adapter?.setBotInfo(botInfo)
							chatActivityEnterView?.setBotInfo(botInfo)
						}

						if (chatActivityEnterView != null) {
							chatActivityEnterView?.setBotsCount(botsCount, hasBotsCommands, true)

							// val hasBotWebView = messagesController.getUser(info.user_id)!!.bot_menu_webview

							chatActivityEnterView?.updateBotWebView(true)
						}
					}

					updateBotButtons()
				}
			}

			NotificationCenter.botKeyboardDidLoad -> {
				if (dialogId == args[1] as Long) {
					val message = args[0] as? Message

					if (message != null && !userBlocked) {
						botButtons = MessageObject(currentAccount, message, generateLayout = false, checkMediaExists = false)
						checkBotKeyboard()
					}
					else {
						botButtons = null

						if (chatActivityEnterView != null) {
							if (replyMessage != null && botReplyButtons === replyMessage) {
								botReplyButtons = null
								hideFieldPanel(true)
							}

							chatActivityEnterView?.setButtons(botButtons)
						}
					}
				}
			}

			NotificationCenter.chatSearchResultsAvailable -> {
				if (classGuid == args[0] as Int) {
					val jumpToMessage = args[6] as Boolean

					if (jumpToMessage) {
						val messageId = args[1] as Int
						val did = args[3] as Long

						if (messageId != 0) {
							scrollToMessageId(messageId, 0, true, if (did == dialogId) 0 else 1, true, 0)
						}
						else {
							updateVisibleRows()
						}

						updateSearchButtons(args[2] as Int, args[4] as Int, args[5] as Int)

						searchItem?.setShowSearchProgress(false)
					}

					messagesSearchAdapter?.notifyDataSetChanged()
				}
			}

			NotificationCenter.chatSearchResultsLoading -> {
				if (classGuid == args[0] as Int) {
					searchItem?.setShowSearchProgress(true)
					messagesSearchAdapter?.notifyDataSetChanged()
				}
			}

			NotificationCenter.didUpdateMessagesViews -> {
				val channelViews = args[0] as? LongSparseArray<SparseIntArray>
				val channelForwards = args[1] as? LongSparseArray<SparseIntArray>
				val channelReplies = args[2] as? LongSparseArray<SparseArray<MessageReplies>>
				val addingReplies = args[3] as Boolean
				var updated = false
				var newGroups: LongSparseArray<GroupedMessages>? = null
				var updatedRows: MutableList<Int>? = null

				for (b in 0..1) {
					val sparseArray = (if (b == 0) channelViews else channelForwards) ?: continue
					val array = sparseArray[dialogId]

					if (array != null) {
						for (a in 0 until array.size()) {
							val messageId = array.keyAt(a)
							val messageObject = messagesDict[0][messageId]

							if (messageObject != null) {
								val newValue = array[messageId]

								if (b == 0) {
									if (newValue <= messageObject.messageOwner!!.views) {
										continue
									}

									messageObject.messageOwner?.views = newValue
								}
								else {
									if (newValue <= messageObject.messageOwner!!.forwards) {
										continue
									}

									messageObject.messageOwner?.forwards = newValue
								}

								if (messageObject.hasValidGroupId()) {
									val groupedMessages = groupedMessagesMap[messageObject.groupId]

									if (groupedMessages != null) {
										if (newGroups == null) {
											newGroups = LongSparseArray()
										}

										newGroups.put(groupedMessages.groupId, groupedMessages)
									}
								}

								chatAdapter?.updateRowWithMessageObject(messageObject, false)
							}
						}
					}
				}

				if (channelReplies != null) {
					val array = channelReplies[dialogId]
					var hasChatInBack = false

					if (threadMessage != null && parentLayout != null) {
						var a = 0
						val N = parentLayout!!.fragmentsStack.size - 1

						while (a < N) {
							val fragment = parentLayout?.fragmentsStack?.get(a)

							if (fragment !== this && fragment is ChatActivity) {
								if (fragment.needRemovePreviousSameChatActivity && fragment.dialogId == dialogId && fragment.chatMode == chatMode) {
									hasChatInBack = true
									break
								}
							}

							a++
						}
					}

					if (array != null) {
						for (a in 0 until array.size()) {
							val messageId = array.keyAt(a)
							val messageObject = messagesDict[0][messageId]

							if (messageObject != null && messageObject !== threadMessage) {
								val newValue = array[messageId]

								if (newValue == null || !addingReplies && messageObject.messageOwner?.replies != null && newValue.replies_pts <= messageObject.messageOwner!!.replies!!.replies_pts && newValue.read_max_id <= messageObject.messageOwner!!.replies!!.read_max_id && newValue.max_id <= messageObject.messageOwner!!.replies!!.max_id) {
									continue
								}

								if (addingReplies) {
									if (!hasChatInBack) {
										if (messageObject.messageOwner?.replies == null) {
											messageObject.messageOwner?.replies = TL_messageReplies()
										}

										messageObject.messageOwner!!.replies!!.replies += newValue.replies

										var c = 0
										val N = newValue.recent_repliers.size

										while (c < N) {
											messageObject.messageOwner?.replies?.recent_repliers?.remove(newValue.recent_repliers[c])
											c++
										}

										messageObject.messageOwner?.replies?.recent_repliers?.addAll(0, newValue.recent_repliers)

										while (messageObject.messageOwner!!.replies!!.recent_repliers.size > 3) {
											messageObject.messageOwner!!.replies!!.recent_repliers.removeAt(0)
										}
									}
								}
								else {
									if (messageObject.messageOwner?.replies != null && messageObject.messageOwner!!.replies!!.read_max_id > newValue.read_max_id) {
										newValue.read_max_id = messageObject.messageOwner!!.replies!!.read_max_id
									}

									messageObject.messageOwner?.replies = newValue
								}

								if (messageObject.hasValidGroupId()) {
									val groupedMessages = groupedMessagesMap[messageObject.groupId]

									if (groupedMessages != null) {
										if (newGroups == null) {
											newGroups = LongSparseArray()
										}

										newGroups.put(groupedMessages.groupId, groupedMessages)

										var b = 0
										val N2 = groupedMessages.messages.size

										while (b < N2) {
											groupedMessages.messages[b].animateComments = true
											b++
										}
									}
								}
								else if (chatAdapter != null) {
									val row = messages.indexOf(messageObject)

									if (row >= 0) {
										if (updatedRows == null) {
											updatedRows = mutableListOf()
										}

										updatedRows.add(row + chatAdapter!!.messagesStartRow)
									}

									messageObject.animateComments = true
								}

								updated = true
							}
						}
					}
				}

				if (updated) {
					if (chatAdapter != null) {
						if (newGroups != null) {
							var b = 0
							val N = newGroups.size()

							while (b < N) {
								val groupedMessages = newGroups.valueAt(b)
								val messageObject = groupedMessages.messages[groupedMessages.messages.size - 1]
								val index = messages.indexOf(messageObject)

								if (index >= 0) {
									chatAdapter?.notifyItemRangeChanged(index + chatAdapter!!.messagesStartRow, groupedMessages.messages.size)
								}

								b++
							}
						}

						if (updatedRows != null) {
							var b = 0
							val N = updatedRows.size

							while (b < N) {
								chatAdapter?.notifyItemChanged(updatedRows[b])
								b++
							}
						}
					}
					updateVisibleRows()
					updateReplyMessageHeader(true)
				}
			}

			NotificationCenter.peerSettingsDidLoad -> {
				val did = args[0] as Long

				if (did == dialogId || currentUser?.id == did) {
					updateTopPanel(!paused)
					updateInfoTopView(true)
				}
			}

			NotificationCenter.newDraftReceived -> {
				val did = args[0] as Long

				if (did == dialogId) {
					applyDraftMaybe(true)
				}
			}

			NotificationCenter.pinnedInfoDidLoad -> {
				val did = args[0] as Long

				if (did == dialogId) {
					val pinnedMessages = args[1] as List<Int>

					if (chatMode == MODE_PINNED) {
						pinnedMessageIds = pinnedMessages.toMutableList()
						pinnedMessageObjects = (args[2] as Map<Int, MessageObject>).toMutableMap()
					}
					else {
						pinnedMessageIds = pinnedMessages.toMutableList()
						pinnedMessageObjects = (args[2] as Map<Int, MessageObject>).toMutableMap()
					}

					loadedPinnedMessagesCount = pinnedMessageIds.size
					totalPinnedMessagesCount = args[3] as Int
					pinnedEndReached = args[4] as Boolean

					mediaDataController.loadReplyMessagesForMessages(pinnedMessageObjects.values.toList(), dialogId, false, null)

					if (!inMenuMode && !loadingPinnedMessagesList && totalPinnedMessagesCount == 0 && !pinnedEndReached) {
						mediaDataController.loadPinnedMessages(dialogId, 0, if (pinnedMessageIds.isEmpty()) 0 else pinnedMessageIds[0])
						loadingPinnedMessagesList = true
					}
				}
			}

			NotificationCenter.userInfoDidLoad -> {
				val uid = args[0] as Long

				if (currentUser != null && currentUser?.id == uid) {
					currentUserInfo = args[1] as UserFull

					checkThemeEmoticon()

					chatActivityEnterView?.checkChannelRights()

					if (headerItem != null) {
						showAudioCallAsIcon = currentUserInfo!!.phone_calls_available && !inPreviewMode

						avatarContainer?.setTitleExpand(showAudioCallAsIcon)

						if (currentUserInfo!!.phone_calls_available) {
							if (showAudioCallAsIcon) {
								if (audioCallIconItem != null) {
									if (openAnimationStartTime != 0L && audioCallIconItem!!.visibility != View.VISIBLE) {
										audioCallIconItem?.alpha = 0f
										audioCallIconItem?.animate()?.alpha(1f)?.setDuration(160)?.setInterpolator(CubicBezierInterpolator.EASE_IN)?.setStartDelay(50)?.start()
									}

									audioCallIconItem?.visible()
								}
							}
							else {
								headerItem?.showSubItem(call)
							}

							if (currentUserInfo!!.video_calls_available) {
								headerItem?.showSubItem(video_call)
							}
							else {
								headerItem?.hideSubItem(video_call)
							}
						}
						else {
							headerItem?.hideSubItem(call)
							headerItem?.hideSubItem(video_call)

							audioCallIconItem?.gone()
						}
					}

					checkActionBarMenu(fragmentOpened)

					if (!inMenuMode && !loadingPinnedMessagesList && pinnedMessageIds.isNotEmpty() && currentUserInfo!!.pinned_msg_id > pinnedMessageIds[0]) {
						mediaDataController.loadPinnedMessages(dialogId, 0, currentUserInfo!!.pinned_msg_id)
						loadingPinnedMessagesList = true
					}
				}
				else if (uid == callToThisUser) {
					callToThisUser = 0

					val uf = args[1] as? UserFull

					if (uf != null) {
						val u = messagesController.getUser(uf.id)

						if (u != null) {
							val activity = parentActivity

							if (activity != null) {
								startCall(u, false, uf.video_calls_available, activity, uf, accountInstance)
							}
						}
					}
				}
			}

			NotificationCenter.didSetNewWallpapper -> {
				if (fragmentView != null) {
					contentView?.setBackgroundImage(ResourcesCompat.getDrawable(context!!.resources, R.drawable.chat_background, null), false)

					progressView2?.invalidate()
					emptyView?.invalidate()
					bigEmptyView?.invalidate()
					floatingDateView?.invalidate()
					chatListView?.invalidateViews()
				}
			}

			NotificationCenter.goingToPreviewTheme -> {
				isPauseOnThemePreview = true

				if (chatLayoutManager != null) {
					scrollToPositionOnRecreate = chatLayoutManager!!.findFirstVisibleItemPosition()

					val holder = chatListView?.findViewHolderForAdapterPosition(scrollToPositionOnRecreate) as? RecyclerListView.Holder

					if (holder != null) {
						scrollToOffsetOnRecreate = chatListView!!.measuredHeight - holder.itemView.bottom - chatListView!!.paddingBottom
					}
					else {
						scrollToPositionOnRecreate = -1
					}
				}
			}

			NotificationCenter.channelRightsUpdated -> {
				val chat = args[0] as Chat

				if (currentChat != null && chat.id == currentChat?.id && chatActivityEnterView != null) {
					currentChat = chat
					chatActivityEnterView?.checkChannelRights()
					checkRaiseSensors()
					updateSecretStatus()

					if (currentChat!!.gigagroup) {
						updateBottomOverlay()
					}
				}
			}

			NotificationCenter.updateMentionsCount -> {
				if (dialogId == args[0] as Long) {
					val count = args[1] as Int

					if (newMentionsCount > count) {
						newMentionsCount = count

						if (newMentionsCount <= 0) {
							newMentionsCount = 0
							hasAllMentionsLocal = true

							showMentionDownButton(show = false, animated = true)
						}
						else {
							mentiondownButtonCounter?.setText(String.format("%d", newMentionsCount))
						}
					}
				}
			}

			NotificationCenter.audioRecordTooShort -> {
				val guid = args[0] as Int

				if (guid != classGuid) {
					return
				}

				val time = args[2] as Int

				if (time < 100) {
					showVoiceHint(false, args[1] as Boolean)
				}
			}

			NotificationCenter.videoLoadingStateChanged -> {
				val chatListView = chatListView ?: return
				val fileName = args[0] as String
				val count = chatListView.childCount

				for (a in 0 until count) {
					val child = chatListView.getChildAt(a) as? ChatMessageCell ?: continue
					val document = child.getStreamingMedia() ?: continue

					if (FileLoader.getAttachFileName(document) == fileName) {
						child.updateButtonState(ifSame = false, animated = true, fromSet = false)
					}
				}
			}

			NotificationCenter.scheduledMessagesUpdated -> {
				val did = args[0] as Long

				if (dialogId == did) {
					scheduledMessagesCount = args[1] as Int
					updateScheduledInterface(openAnimationEnded)
				}
			}

			NotificationCenter.diceStickersDidLoad -> {
				val chatListView = chatListView ?: return
				val count = chatListView.childCount

				for (a in 0 until count) {
					val child = chatListView.getChildAt(a) as? ChatMessageCell ?: continue

					if (child.getMessageObject()?.isDice == true) {
						child.setCurrentDiceValue(true)
					}
				}
			}

			NotificationCenter.dialogDeleted -> {
				val did = args[0] as Long

				if (did == dialogId) {
					if (parentLayout != null && parentLayout!!.fragmentsStack[parentLayout!!.fragmentsStack.size - 1] === this) {
						finishFragment()
					}
					else {
						removeSelfFromStack()
					}
				}
			}

			NotificationCenter.chatAvailableReactionsUpdated -> {
				val chatId = args[0] as Long

				if (chatId == -dialogId) {
					currentChatInfo = messagesController.getChatFull(chatId)
				}
			}

			NotificationCenter.dialogsUnreadReactionsCounterChanged -> {
				val dialogId = args[0] as Long

				if (dialogId == this.dialogId) {
					reactionsMentionCount = args[1] as Int

					var messages: List<Int>? = null

					if (args[2] != null) {
						messages = args[2] as List<Int>
					}

					if (messages != null) {
						for (i in messages.indices) {
							val messageId = messages[i]
							val cell = findMessageCell(messageId, true)

							if (cell != null && reactionsMentionCount > 0) {
								reactionsMentionCount--
								messagesStorage.markMessageReactionsAsRead(this.dialogId, cell.getMessageObject()!!.id, true)
								AndroidUtilities.runOnUIThread({ playReactionAnimation(messageId) }, 200)
							}
						}
					}

					if (reactionsMentionCount <= 0) {
						reactionsMentionCount = 0
						messagesController.markReactionsAsRead(dialogId)
					}

					updateReactionsMentionButton(true)
				}
			}

			NotificationCenter.aiSubscriptionSuccess -> {
				AndroidUtilities.runOnUIThread({ updateTopPanel(true) }, 200)
			}

			NotificationCenter.aiSubscriptionStatusReceived -> {
				// val (isEasyMode, textTotal, textExpireAt, isTextSubscriptionActive, imgTotal, imgExpireAt, isImgSubscriptionActive) = args[0] as SubscriptionInfoAiBot
				AndroidUtilities.runOnUIThread({ updateTopPanel(true) }, 200)
			}

			NotificationCenter.aiBotStarted -> {
				// val (isEasyMode, textTotal, textExpireAt, isTextSubscriptionActive, imgTotal, imgExpireAt, isImgSubscriptionActive) = args[0] as SubscriptionInfoAiBot
				isChatBotStarted = true
			}

			NotificationCenter.aiBotStopped -> {
				// val (isEasyMode, textTotal, textExpireAt, isTextSubscriptionActive, imgTotal, imgExpireAt, isImgSubscriptionActive) = args[0] as SubscriptionInfoAiBot
				isChatBotStarted = false
			}

			NotificationCenter.aiBotRequestFailed -> {
				// TLRPC.TL_error error = (TLRPC.TL_error)args[0];
				// FileLog.e("aiBotRequestFailed " + error.text);
			}

			NotificationCenter.aiBotUpdate -> {
				// FileLog.d("aiBotUpdate " + args);
			}
		}
	}

	private fun checkSecretMessageForLocation(messageObject: MessageObject) {
		if (messageObject.type != MessageObject.TYPE_GEO || locationAlertShown || SharedConfig.isSecretMapPreviewSet()) {
			return
		}

		locationAlertShown = true

		val parentActivity = parentActivity ?: return

		AlertsCreator.showSecretLocationAlert(parentActivity, currentAccount, {
			chatListView?.children?.forEach { view ->
				if (view is ChatMessageCell) {
					val message = view.getMessageObject()

					if (message != null && message.type == MessageObject.TYPE_GEO) {
						view.forceResetMessageObject()
					}
				}
			}
		}, true)
	}

	private fun loadSendAsPeers(animatedUpdate: Boolean) {
		if (sendAsPeers != null || currentChat == null || !canSendAsPeers(currentChat) || chatActivityEnterView == null) {
			return
		}

		sendAsPeers = messagesController.getSendAsPeers(dialogId)

		if (sendAsPeers != null) {
			chatActivityEnterView?.updateSendAsButton(animatedUpdate)
		}
	}

	private fun addSponsoredMessages() {
		if (sponsoredMessagesAdded || chatMode != 0 || !isChannel(currentChat) || !forwardEndReached[0] || userConfig.isPremium) {
			return
		}

		val arrayList = messagesController.getSponsoredMessages(dialogId) ?: return

		for (messageObject in arrayList) {
			messageObject.resetLayout()

			val dialogId = MessageObject.getPeerId(messageObject.messageOwner?.from_id)
			var messageId = 0

			if (messageObject.sponsoredChannelPost != 0) {
				messageId = messageObject.sponsoredChannelPost
			}

			messagesController.ensureMessagesLoaded(dialogId, messageId, null)
		}

		sponsoredMessagesAdded = true

		processNewMessages(arrayList.toMutableList())
	}

	private fun checkGroupCallJoin(fromServer: Boolean) {
		if (groupCall == null || voiceChatHash == null || !openAnimationEnded) {
			if (voiceChatHash != null && fromServer && currentChatInfo != null && currentChatInfo!!.call == null && fragmentView != null && parentActivity != null) {
				BulletinFactory.of(this).createSimpleBulletin(R.raw.linkbroken, context!!.getString(R.string.LinkHashExpired)).show()
				voiceChatHash = null
			}

			lastCallCheckFromServer = !openAnimationEnded

			return
		}

		startCall(currentChat!!, voiceChatHash, createGroupCall, !groupCall!!.call!!.rtmp_stream, parentActivity, this@ChatActivity, accountInstance)

		voiceChatHash = null
	}

	private fun checkWaitingForReplies() {
		if (waitingForReplies.size() == 0) {
			return
		}

		var idsToRemove: MutableList<Int>? = null
		var newGroups: LongSparseArray<GroupedMessages>? = null
		var updatedRows: MutableList<Int>? = null
		var a = 0
		val N = waitingForReplies.size()

		while (a < N) {
			val `object` = waitingForReplies.valueAt(a)

			if (`object`.replyMessageObject != null) {
				if (idsToRemove == null) {
					idsToRemove = mutableListOf()
				}

				idsToRemove.add(waitingForReplies.keyAt(a))

				if (`object`.messageOwner?.action !is TL_messageActionPinMessage && `object`.replyMessageObject?.messageOwner?.fwd_from != null && MessageObject.getPeerId(`object`.replyMessageObject?.messageOwner?.fwd_from?.saved_from_peer) == dialogId && `object`.replyMessageObject?.messageOwner?.fwd_from?.channel_post != 0) {
					val obj = messagesDict[0][`object`.replyMessageObject!!.messageOwner!!.fwd_from!!.channel_post]

					if (obj?.messageOwner?.replies != null) {
						obj.messageOwner!!.replies!!.replies += 1
						obj.animateComments = true

						var peer = `object`.messageOwner?.from_id

						if (peer == null) {
							peer = `object`.messageOwner?.peer_id
						}

						var c = 0
						val N2 = obj.messageOwner!!.replies!!.recent_repliers.size

						while (c < N2) {
							if (MessageObject.getPeerId(obj.messageOwner?.replies?.recent_repliers?.get(c)) == MessageObject.getPeerId(peer)) {
								obj.messageOwner?.replies?.recent_repliers?.removeAt(c)
								break
							}

							c++
						}

						obj.messageOwner?.replies?.recent_repliers?.add(0, peer)

						if (!`object`.isOut) {
							obj.messageOwner?.replies?.max_id = `object`.id
						}

						messagesStorage.updateRepliesCount(currentChat!!.id, obj.id, obj.messageOwner!!.replies!!.recent_repliers, obj.messageOwner!!.replies!!.max_id, 1)

						if (obj.hasValidGroupId()) {
							val groupedMessages = groupedMessagesMap[obj.groupId]

							if (groupedMessages != null) {
								if (newGroups == null) {
									newGroups = LongSparseArray()
								}

								newGroups.put(groupedMessages.groupId, groupedMessages)

								var b = 0
								@Suppress("NAME_SHADOWING") val N2 = groupedMessages.messages.size

								while (b < N2) {
									groupedMessages.messages[b].animateComments = true
									b++
								}
							}
						}
						else if (chatAdapter != null) {
							val row = messages.indexOf(obj)

							if (row >= 0) {
								if (updatedRows == null) {
									updatedRows = mutableListOf()
								}

								updatedRows.add(row + chatAdapter!!.messagesStartRow)
							}
						}
					}
				}
			}

			a++
		}

		idsToRemove?.forEach {
			waitingForReplies.remove(it)
		}

		if (chatAdapter != null) {
			if (newGroups != null) {
				var b = 0
				@Suppress("NAME_SHADOWING") val N = newGroups.size()

				while (b < N) {
					val groupedMessages = newGroups.valueAt(b)
					val messageObject = groupedMessages.messages[groupedMessages.messages.size - 1]
					val index = messages.indexOf(messageObject)

					if (index >= 0) {
						chatAdapter!!.notifyItemRangeChanged(index + chatAdapter!!.messagesStartRow, groupedMessages.messages.size)
					}

					b++
				}
			}

			updatedRows?.forEach {
				chatAdapter?.notifyItemChanged(it)
			}
		}
	}

	private fun clearHistory(overwrite: Boolean, differenceTooLong: TL_updates_channelDifferenceTooLong?) {
		if (overwrite) {
			FileLog.d("clear history by overwrite firstLoading=" + firstLoading + " minMessage=" + minMessageId[0] + " topMessage=" + differenceTooLong!!.dialog.top_message)

			if (differenceTooLong.dialog.top_message > minMessageId[0]) {
				createUnreadMessageAfterId = max(minMessageId[0] + 1, differenceTooLong.dialog.read_inbox_max_id)
			}

			forwardEndReached[0] = false
			hideForwardEndReached = false

			if (chatAdapter != null && chatAdapter!!.loadingDownRow < 0) {
				chatAdapter?.notifyItemInserted(0)
			}

			newUnreadMessageCount = differenceTooLong.dialog.unread_count
			newMentionsCount = differenceTooLong.dialog.unread_mentions_count

			if (prevSetUnreadCount != newUnreadMessageCount) {
				pagedownButtonCounter?.setCount(newUnreadMessageCount, openAnimationEnded)
				prevSetUnreadCount = newUnreadMessageCount
				updatePagedownButtonVisibility(true)
			}

			if (newMentionsCount != differenceTooLong.dialog.unread_mentions_count) {
				newMentionsCount = differenceTooLong.dialog.unread_mentions_count

				if (newMentionsCount <= 0) {
					newMentionsCount = 0
					hasAllMentionsLocal = true

					showMentionDownButton(show = false, animated = true)
				}
				else {
					mentiondownButtonCounter?.setText(String.format(Locale.getDefault(), "%d", newMentionsCount))
					showMentionDownButton(show = true, animated = true)
				}
			}

			checkScrollForLoad(false)

			return
		}

		messages.clear()
		waitingForLoad.clear()
		messagesByDays.clear()
		groupedMessagesMap.clear()

		threadMessageAdded = false

		for (a in 1 downTo 0) {
			messagesDict[a].clear()

			if (currentEncryptedChat == null) {
				maxMessageId[a] = Int.MAX_VALUE
				minMessageId[a] = Int.MIN_VALUE
			}
			else {
				maxMessageId[a] = Int.MIN_VALUE
				minMessageId[a] = Int.MAX_VALUE
			}

			maxDate[a] = Int.MIN_VALUE
			minDate[a] = 0

			selectedMessagesIds[a].clear()
			selectedMessagesCanCopyIds[a].clear()
			selectedMessagesCanStarIds[a].clear()
		}

		hideActionMode()
		updatePinnedMessageView(true)

		if (botButtons != null) {
			botButtons = null
			chatActivityEnterView?.setButtons(null, false)
		}

		if (progressView != null) {
			showProgressView(false)
			chatListView?.setEmptyView(emptyViewContainer)
		}

		chatAdapter?.notifyDataSetChanged(false)

		if (currentEncryptedChat == null && currentUser?.bot == true && botUser == null) {
			botUser = ""
			updateBottomOverlay()
		}
	}

	fun processSwitchButton(button: TL_keyboardButtonSwitchInline): Boolean {
		if (inlineReturn == 0L || button.same_peer || parentLayout == null) {
			return false
		}

		val query = "@" + currentUser?.username + " " + button.query

		if (inlineReturn == dialogId) {
			inlineReturn = 0
			chatActivityEnterView?.fieldText = query
		}
		else {
			mediaDataController.saveDraft(inlineReturn, 0, query, null, null, false)

			if (parentLayout!!.fragmentsStack.size > 1) {
				val prevFragment = parentLayout!!.fragmentsStack[parentLayout!!.fragmentsStack.size - 2]

				if (prevFragment is ChatActivity && prevFragment.dialogId == inlineReturn) {
					finishFragment()
				}
				else {
					val bundle = Bundle()

					if (DialogObject.isEncryptedDialog(inlineReturn)) {
						bundle.putInt("enc_id", DialogObject.getEncryptedChatId(inlineReturn))
					}
					else if (DialogObject.isUserDialog(inlineReturn)) {
						bundle.putLong("user_id", inlineReturn)
					}
					else {
						bundle.putLong("chat_id", -inlineReturn)
					}

					addToPulledDialogsMyself()

					presentFragment(ChatActivity(bundle), true)
				}
			}
		}

		return true
	}

	private fun showGigagroupConvertAlert() {
		if (currentChatInfo != null && !paused && currentChat!!.creator && currentChat!!.megagroup && !currentChat!!.gigagroup && currentChatInfo!!.pending_suggestions.contains("CONVERT_GIGAGROUP") && visibleDialog == null) {
			AndroidUtilities.runOnUIThread({
				if (currentChatInfo != null && !paused && currentChat!!.creator && currentChat!!.megagroup && !currentChat!!.gigagroup && currentChatInfo!!.pending_suggestions.contains("CONVERT_GIGAGROUP") && visibleDialog == null) {
					val preferences = MessagesController.getNotificationsSettings(currentAccount)
					val lastShowTime = preferences.getInt("group_convert_time", 0)
					val timeout = if (BuildConfig.DEBUG_PRIVATE_VERSION) 120 else 60 * 60 * 24 * 7
					val currentTime = connectionsManager.currentTime

					if (abs(currentTime - lastShowTime) >= timeout) {
						if (visibleDialog == null && parentActivity != null) {
							preferences.edit().putInt("group_convert_time", currentTime).commit()

							parentActivity?.let {
								showDialog(AlertsCreator.createGigagroupConvertAlert(it, { _, _ ->
									showDialog(object : GigagroupConvertAlert(parentActivity, this@ChatActivity) {
										override fun onCovert() {
											messagesController.convertToGigaGroup(parentActivity, currentChat, this@ChatActivity) { result ->
												if (result) {
													undoView?.showWithAction(0, UndoView.ACTION_GIGAGROUP_SUCCESS, null)
												}
											}
										}

										override fun onCancel() {
											undoView?.showWithAction(0, UndoView.ACTION_GIGAGROUP_CANCEL, null)
											messagesController.removeSuggestion(dialogId, "CONVERT_GIGAGROUP")
										}
									})
								}) { _, _ ->
									undoView?.showWithAction(0, UndoView.ACTION_GIGAGROUP_CANCEL, null)
								}.create())
							}
						}
					}
				}
			}, 1000)
		}
	}

	private fun addReplyMessageOwner(obj: MessageObject, oldId: Int) {
		if (obj.replyMessageObject == null) {
			return
		}

		var id = obj.replyMessageObject?.id ?: 0
		var ids = replyMessageOwners[id]

		if (ids == null) {
			ids = mutableListOf()
			replyMessageOwners.put(id, ids)
		}

		id = obj.id

		if (!ids.contains(id)) {
			ids.add(id)
		}

		if (oldId != 0) {
			ids.remove(oldId)
		}
	}

	private fun updateReplyMessageOwners(id: Int, update: MessageObject?) {
		val ids = replyMessageOwners[id] ?: return
		val emptyMessage = if (update == null) MessageObject(currentAccount, TL_messageEmpty(), generateLayout = false, checkMediaExists = false) else null

		for (@Suppress("NAME_SHADOWING") id in ids) {
			val `object` = messagesDict[0][id]

			if (`object` != null) {
				if (update == null) {
					`object`.replyMessageObject = emptyMessage
				}
				else {
					`object`.replyMessageObject = update
				}

				chatAdapter?.updateRowWithMessageObject(`object`, true)
			}
		}

		if (update == null) {
			replyMessageOwners.remove(id)
		}
	}

	private fun rotateMotionBackgroundDrawable() {
		val drawable = getThemedDrawable(Theme.key_drawable_msgOut)

		if (drawable is MessageDrawable) {
			val motionDrawable = drawable.motionBackgroundDrawable
			motionDrawable?.switchToNextPosition()
		}
	}

	private fun processNewMessages(arr: MutableList<MessageObject>) {
		val currentUserId = userConfig.getClientUserId()
		var updateChat = false
		var hasFromMe = false
		var isAd = false

		chatListItemAnimator?.setShouldAnimateEnterFromBottom(true)

		var notifiedSearch = false
		var scheduledGroupReplacement: LongSparseArray<Long?>? = null

		for (messageObject in arr) {
			if (!isAd) {
				isAd = messageObject.isSponsored
			}

			val messageId = messageObject.id

			if (threadId != 0) {
				if (messageId > 0 && messageId <= (if (messageObject.isOut) threadMaxOutboxReadId else threadMaxInboxReadId)) {
					messageObject.setIsRead()
				}
			}

			if (currentEncryptedChat == null && !forwardEndReached[0] && messageId < 0) {
				pendingSendMessagesDict.put(messageId, messageObject)
				pendingSendMessages.add(0, messageObject)
			}

			if (messageObject.isDice && !messageObject.isForwarded || messageObject.messageOwner?.action is TL_messageActionGiftPremium) {
				messageObject.wasUnread = true
			}

			if (chatMode == MODE_SCHEDULED && messageObject.hasValidGroupId() && messagesDict[0].indexOfKey(messageObject.id) >= 0) {
				val groupId = messageObject.groupId

				if (scheduledGroupReplacement == null) {
					scheduledGroupReplacement = LongSparseArray()
				}

				var localId = scheduledGroupReplacement[groupId]

				if (localId == null) {
					localId = Utilities.random.nextLong()
					scheduledGroupReplacement.put(groupId, localId)
				}

				messageObject.localGroupId = localId
			}

			if (messageObject.isOut) {
				if (!notifiedSearch) {
					notifiedSearch = true
					NotificationCenter.globalInstance.postNotificationName(NotificationCenter.closeSearchByActiveAction)
				}

				if (currentChat != null) {
					val newChat = messagesController.getChat(currentChat!!.id)

					if (newChat != null) {
						currentChat = newChat

						if (!newChat.gigagroup && newChat.slowmode_enabled && messageObject.isSent && chatMode != MODE_SCHEDULED) {
							if (currentChatInfo != null) {
								val date = messageObject.messageOwner!!.date + currentChatInfo!!.slowmode_seconds
								val currentTime = connectionsManager.currentTime

								if (date > connectionsManager.currentTime) {
									currentChatInfo?.slowmode_next_send_date = max(currentChatInfo!!.slowmode_next_send_date, min(currentTime + currentChatInfo!!.slowmode_seconds, date))
									chatActivityEnterView?.setSlowModeTimer(currentChatInfo!!.slowmode_next_send_date)
								}
							}
							messagesController.loadFullChat(currentChat!!.id, 0, true)
						}
					}
				}

				if (messageObject.wasJustSent && (userConfig.isPremium || messageObject.isAnimatedAnimatedEmoji)) {
					messageObject.forcePlayEffect = true
				}
			}

			if (currentChat != null) {
				if (messageObject.messageOwner?.action is TL_messageActionChatDeleteUser && messageObject.messageOwner?.action?.user_id == currentUserId || messageObject.messageOwner?.action is TL_messageActionChatAddUser && messageObject.messageOwner?.action?.users?.contains(currentUserId) == true) {
					val newChat = messagesController.getChat(currentChat!!.id)

					if (newChat != null) {
						currentChat = newChat

						checkActionBarMenu(false)
						updateBottomOverlay()

						avatarContainer?.updateSubtitle(true)
					}
				}
			}
			else if (inlineReturn != 0L) {
				if (messageObject.messageOwner?.reply_markup != null) {
					for (b in messageObject.messageOwner!!.reply_markup!!.rows.indices) {
						val row = messageObject.messageOwner!!.reply_markup!!.rows[b]

						for (c in row.buttons.indices) {
							val button = row.buttons[c]

							if (button is TL_keyboardButtonSwitchInline) {
								processSwitchButton(button)
								break
							}
						}
					}
				}
			}

			if (messageObject.replyMsgId != 0 && messageObject.replyMessageObject == null) {
				messageObject.replyMessageObject = messagesDict[0][messageObject.replyMsgId]

				if (messageObject.replyMessageObject == null && messageObject.dialogId != mergeDialogId) {
					messageObject.replyMessageObject = repliesMessagesDict[messageObject.replyMsgId]
				}

				when (messageObject.messageOwner?.action) {
					is TL_messageActionPinMessage -> {
						messageObject.generatePinMessageText(null, null)
					}

					is TL_messageActionGameScore -> {
						messageObject.generateGameMessageText(null)
					}

					is TL_messageActionPaymentSent -> {
						messageObject.generatePaymentSentMessageText(null)
					}
				}
			}

			if (messageObject.replyMessageObject != null) {
				repliesMessagesDict.put(messageObject.replyMessageObject!!.id, messageObject.replyMessageObject)
				addReplyMessageOwner(messageObject, 0)
			}
		}

		if (chatMode == MODE_SCHEDULED && arr.isNotEmpty()) {
			replaceMessageObjects(arr, 0, true)
		}

		var needMoveScrollToLastMessage = false
		var reloadMegagroup = false

		if (!forwardEndReached[0]) {
			var currentMaxDate = Int.MIN_VALUE

			for (a in arr.indices) {
				val obj = arr[a]

				if (obj.isOut) {
					rotateMotionBackgroundDrawable()
				}

				if (threadId != 0 && threadId != obj.replyTopMsgId && threadId != obj.replyMsgId) {
					continue
				}

				val messageId = obj.id

				if (obj.isOut && waitingForSendingMessageLoad) {
					waitingForSendingMessageLoad = false

					chatActivityEnterView?.hideTopView(true)

					changeBoundAnimator?.start()
				}

				if (chatMode != MODE_SCHEDULED && currentUser != null && (currentUser!!.bot && obj.isOut || currentUser!!.id == currentUserId)) {
					obj.setIsRead()
				}

				val action = obj.messageOwner?.action

				if (avatarContainer != null && currentEncryptedChat != null && action is TL_messageEncryptedAction && action.encryptedAction is TL_decryptedMessageActionSetMessageTTL) {
					avatarContainer?.setTime(action.encryptedAction.ttl_seconds, true)
				}

				if (action is TL_messageActionChatMigrateTo) {
					migrateToNewChat(obj)
					return
				}
				else if (currentChat != null && currentChat!!.megagroup && (action is TL_messageActionChatAddUser || action is TL_messageActionChatDeleteUser)) {
					reloadMegagroup = true
				}

				if (a == 0 && obj.shouldAnimateSending() && chatMode != MODE_SCHEDULED) {
					needAnimateToMessage = obj
				}

				if (obj.isOut && obj.wasJustSent) {
					scrollToLastMessage(true)
					return
				}

				if (obj.type < 0 || messagesDict[0].indexOfKey(messageId) >= 0) {
					continue
				}

				if (currentChat != null && currentChat!!.creator && (!isChannel(currentChat) || currentChat!!.megagroup) && (action is TL_messageActionChatCreate || action is TL_messageActionChatEditPhoto && messages.size < 2)) {
					continue
				}

				if (action is TL_messageActionChannelMigrateFrom) {
					continue
				}

				if (threadId != 0 && obj.messageOwner is TL_messageEmpty) {
					continue
				}

				if (threadMessage != null && obj.isReply && obj.messageOwner?.action !is TL_messageActionPinMessage) {
					val mid = obj.replyAnyMsgId

					if (threadMessage?.id == mid) {
						threadMessage!!.messageOwner!!.replies!!.replies++
					}
				}

				addToPolls(obj, null)
				obj.checkLayout()
				currentMaxDate = max(currentMaxDate, obj.messageOwner!!.date)

				if (messageId > 0) {
					last_message_id = max(last_message_id, messageId)
				}
				else if (currentEncryptedChat != null) {
					last_message_id = min(last_message_id, messageId)
				}

				if (threadId == 0) {
					if (obj.messageOwner!!.mentioned && obj.isContentUnread) {
						newMentionsCount++
					}
				}

				if (!isAd) {
					newUnreadMessageCount++
				}

				if (obj.type == 10 || obj.type == 11) {
					updateChat = true
				}
			}

			if (newUnreadMessageCount != 0 && pagedownButtonCounter != null) {
				pagedownButtonCounter?.visible()

				if (prevSetUnreadCount != newUnreadMessageCount) {
					prevSetUnreadCount = newUnreadMessageCount
					pagedownButtonCounter?.setCount(newUnreadMessageCount, true)
				}
			}

			if (newMentionsCount != 0 && mentiondownButtonCounter != null) {
				mentiondownButtonCounter?.visible()
				mentiondownButtonCounter?.setText(String.format("%d", newMentionsCount))

				showMentionDownButton(show = true, animated = true)
			}

			updateVisibleRows()
		}
		else {
			var newGroups: LongSparseArray<GroupedMessages>? = null
			var webpagesToReload: MutableMap<String, MutableList<MessageObject>>? = null

			FileLog.d("received new messages " + arr.size + " in dialog " + dialogId)

			var lastActionSetChatThemeMessageObject: MessageObject? = null

			for (a in arr.indices) {
				val obj = arr[a]

				if (obj.scheduled != (chatMode == MODE_SCHEDULED) || threadId != 0 && threadId != obj.replyTopMsgId && threadId != obj.replyMsgId) {
					continue
				}

				if (obj.isOut) {
					rotateMotionBackgroundDrawable()
				}

				var placeToPaste = -1
				val messageId = obj.id

				if (chatMode == MODE_SCHEDULED && messagesDict[0].indexOfKey(messageId) >= 0) {
					val removed = messagesDict[0][messageId]

					messagesDict[0].remove(messageId)

					if (removed != null) {
						val index = messages.indexOf(removed)

						messages.removeAt(index)

						val dayArr = messagesByDays[removed.dateKey]!!
						dayArr.remove(removed)

						if (dayArr.isEmpty()) {

							messagesByDays.remove(removed.dateKey)
							if (index >= 0 && index < messages.size) {
								messages.removeAt(index)
							}
						}

						if (removed.hasValidGroupId()) {
							val groupedMessages = groupedMessagesMap[removed.groupId]
							groupedMessages?.messages?.remove(removed)

							if (newGroups == null) {
								newGroups = LongSparseArray()
							}

							newGroups.put(groupedMessages!!.groupId, groupedMessages)
						}

						chatAdapter?.notifyDataSetChanged(true)
					}
				}

				if (isSecretChat) {
					checkSecretMessageForLocation(obj)
				}

				if (chatMode != MODE_SCHEDULED && currentUser != null && (currentUser!!.bot && obj.isOut || currentUser!!.id == currentUserId)) {
					obj.setIsRead()
				}

				val action = obj.messageOwner?.action

				if (avatarContainer != null && currentEncryptedChat != null && action is TL_messageEncryptedAction && action.encryptedAction is TL_decryptedMessageActionSetMessageTTL) {
					avatarContainer?.setTime(action.encryptedAction.ttl_seconds, true)
				}

				if (obj.type < 0 || messagesDict[0].indexOfKey(messageId) >= 0) {
					continue
				}

				if (currentChat != null && currentChat!!.creator && (!isChannel(currentChat) || currentChat!!.megagroup) && (action is TL_messageActionChatCreate || action is TL_messageActionChatEditPhoto && messages.size < 2)) {
					continue
				}

				if (action is TL_messageActionChannelMigrateFrom) {
					continue
				}

				if (threadId != 0 && obj.messageOwner is TL_messageEmpty) {
					continue
				}

				if (threadMessage != null && threadMessage!!.messageOwner?.replies != null && obj.isReply && obj.messageOwner?.action !is TL_messageActionPinMessage) {
					val mid = obj.replyAnyMsgId

					if (threadMessage?.id == mid) {
						threadMessage!!.messageOwner!!.replies!!.replies++
					}
				}

				addToPolls(obj, null)

				if (a == 0 && obj.shouldAnimateSending() && chatMode != MODE_SCHEDULED) {
					animatingMessageObjects.add(obj)
				}

				var groupedMessages: GroupedMessages?

				if (obj.hasValidGroupId()) {
					groupedMessages = groupedMessagesMap[obj.groupId]

					if (groupedMessages == null) {
						groupedMessages = GroupedMessages()
						groupedMessages.groupId = obj.groupId
						groupedMessagesMap.put(groupedMessages.groupId, groupedMessages)
					}

					if (newGroups == null) {
						newGroups = LongSparseArray()
					}

					newGroups.put(groupedMessages.groupId, groupedMessages)

					groupedMessages.messages.add(obj)
				}
				else {
					groupedMessages = null
				}

				if (groupedMessages != null) {
					val size = groupedMessages.messages.size
					val messageObject = if (size > 1) groupedMessages.messages[groupedMessages.messages.size - 2] else null

					if (messageObject != null) {
						placeToPaste = messages.indexOf(messageObject)
					}
				}

				if (placeToPaste == -1) {
					if (!obj.scheduled && obj.messageOwner!!.id < 0 || messages.isEmpty()) {
						placeToPaste = 0
					}
					else {
						val size = messages.size

						for (b in 0 until size) {
							val lastMessage = messages[b]

							if (lastMessage.type >= 0 && lastMessage.messageOwner!!.date > 0) {
								if (chatMode != MODE_SCHEDULED && lastMessage.messageOwner!!.id > 0 && obj.messageOwner!!.id > 0 && lastMessage.messageOwner!!.id < obj.messageOwner!!.id || lastMessage.messageOwner!!.date <= obj.messageOwner!!.date) {
									var lastGroupedMessages: GroupedMessages?

									if (lastMessage.groupId != 0L) {
										lastGroupedMessages = groupedMessagesMap[lastMessage.groupId]

										if (lastGroupedMessages != null && lastGroupedMessages.messages.size == 0) {
											lastGroupedMessages = null
										}
									}
									else {
										lastGroupedMessages = null
									}

									placeToPaste = if (lastGroupedMessages == null) {
										b
									}
									else {
										messages.indexOf(lastGroupedMessages.messages[lastGroupedMessages.messages.size - 1])
									}

									break
								}
							}
						}

						if (placeToPaste == -1 || placeToPaste > messages.size) {
							placeToPaste = messages.size
						}
					}
				}

				if (currentEncryptedChat != null && obj.messageOwner?.media is TL_messageMediaWebPage && obj.messageOwner?.media?.webpage is TL_webPageUrlPending) {
					if (webpagesToReload == null) {
						webpagesToReload = mutableMapOf()
					}

					var arrayList = webpagesToReload[obj.messageOwner!!.media!!.webpage?.url]

					if (arrayList == null) {
						arrayList = mutableListOf()
						webpagesToReload[obj.messageOwner!!.media!!.webpage.url] = arrayList
					}

					arrayList.add(obj)
				}

				obj.checkLayout()

				if (action is TL_messageActionChatMigrateTo) {
					migrateToNewChat(obj)

					if (newGroups != null) {
						for (b in 0 until newGroups.size()) {
							newGroups.valueAt(b)!!.calculate()
						}
					}

					return
				}
				else if (currentChat != null && currentChat!!.megagroup && (action is TL_messageActionChatAddUser || action is TL_messageActionChatDeleteUser)) {
					reloadMegagroup = true
				}

				if (minDate[0] == 0 || obj.messageOwner!!.date < minDate[0]) {
					minDate[0] = obj.messageOwner!!.date
				}

				if (obj.isOut && !obj.messageOwner!!.from_scheduled) {
					removeUnreadPlane(true)
					hideInfoView()
					hasFromMe = true
				}

				if (messageId > 0) {
					maxMessageId[0] = min(messageId, maxMessageId[0])
					minMessageId[0] = max(messageId, minMessageId[0])
				}
				else if (currentEncryptedChat != null) {
					maxMessageId[0] = max(messageId, maxMessageId[0])
					minMessageId[0] = min(messageId, minMessageId[0])
				}

				maxDate[0] = max(maxDate[0], obj.messageOwner!!.date)

				messagesDict[0].put(messageId, obj)

				var dayArray = if (isAd && messages.isNotEmpty()) {
					messagesByDays[messages[0].dateKey]
				}
				else {
					messagesByDays[obj.dateKey]
				}

				if (placeToPaste > messages.size) {
					placeToPaste = messages.size
				}

				val sponsoredMessagesCount = sponsoredMessagesCount

				if (!isAd && placeToPaste < sponsoredMessagesCount && (currentChat == null || isChannelAndNotMegaGroup(currentChat))) {
					placeToPaste = sponsoredMessagesCount
				}

				if (dayArray == null) {
					dayArray = mutableListOf()

					messagesByDays[obj.dateKey!!] = dayArray

					val dateMsg: Message = TL_message()

					if (chatMode == MODE_SCHEDULED) {
						if (obj.messageOwner?.date == 0x7ffffffe) {
							dateMsg.message = context!!.getString(R.string.MessageScheduledUntilOnline)
						}
						else {
							dateMsg.message = LocaleController.formatString("MessageScheduledOn", R.string.MessageScheduledOn, LocaleController.formatDateChat(obj.messageOwner!!.date.toLong(), true))
						}
					}
					else {
						dateMsg.message = LocaleController.formatDateChat(obj.messageOwner!!.date.toLong())
					}

					dateMsg.id = 0

					val calendar = Calendar.getInstance()
					calendar.timeInMillis = obj.messageOwner!!.date.toLong() * 1000
					calendar[Calendar.HOUR_OF_DAY] = 0
					calendar[Calendar.MINUTE] = 0

					dateMsg.date = (calendar.timeInMillis / 1000).toInt()

					val dateObj = MessageObject(currentAccount, dateMsg, generateLayout = false, checkMediaExists = false)
					dateObj.type = 10
					dateObj.contentType = 1
					dateObj.isDateObject = true
					dateObj.stableId = lastStableId++

					messages.add(placeToPaste, dateObj)

					chatAdapter?.notifyItemInserted(placeToPaste)
				}

				if (obj.messageOwner?.action !is TL_messageActionGeoProximityReached && (!obj.isOut || obj.messageOwner!!.from_scheduled)) {
					if (paused && placeToPaste == 0) {
						if (!scrollToTopUnReadOnResume && unreadMessageObject != null) {
							removeMessageObject(unreadMessageObject)
							unreadMessageObject = null
						}

						if (unreadMessageObject == null) {
							val dateMsg: Message = TL_message()
							dateMsg.message = ""
							dateMsg.id = 0

							val dateObj = MessageObject(currentAccount, dateMsg, generateLayout = false, checkMediaExists = false)
							dateObj.type = 6
							dateObj.contentType = 2
							dateObj.stableId = lastStableId++

							messages.add(0, dateObj)

							chatAdapter?.notifyItemInserted(0)

							unreadMessageObject = dateObj
							scrollToMessage = unreadMessageObject
							scrollToMessagePosition = -10000
							scrollToTopUnReadOnResume = true
						}
					}
				}

				dayArray.add(0, obj)

				if (chatAdapter != null && placeToPaste < messages.size) {
					val prevMessage = messages[placeToPaste]

					if (prevMessage.hasValidGroupId() && prevMessage.groupId != obj.groupId) {
						val group = groupedMessagesMap[prevMessage.groupId]

						if (group != null && group.messages.size > 1) {
							val size = group.messages.size
							chatAdapter?.notifyItemRangeChanged(1, size - 1)
						}
					}
				}

				obj.stableId = lastStableId++

				messages.add(placeToPaste, obj)

				if (placeToPaste == 0 && !obj.isSponsored) {
					needMoveScrollToLastMessage = true
				}

				chatAdapter?.notifyItemChanged(placeToPaste)
				chatAdapter?.notifyItemInserted(placeToPaste)

				if (obj.isOut && waitingForSendingMessageLoad) {
					waitingForSendingMessageLoad = false

					if (!animatingMessageObjects.contains(obj)) {
						chatActivityEnterView?.hideTopView(true)
					}

					changeBoundAnimator?.start()
				}

				if (threadId == 0) {
					if (!obj.isOut && obj.messageOwner!!.mentioned && obj.isContentUnread) {
						newMentionsCount++
					}
				}

				if (!isAd) {
					newUnreadMessageCount++
				}

				if (obj.type == 10 || obj.type == 11) {
					updateChat = true
				}

				if (obj.messageOwner?.action is TL_messageActionSetChatTheme) {
					lastActionSetChatThemeMessageObject = obj
				}
			}

			(lastActionSetChatThemeMessageObject?.messageOwner?.action as? TL_messageActionSetChatTheme)?.let {
				setChatThemeEmoticon(it.emoticon)
			}

			if (webpagesToReload != null) {
				messagesController.reloadWebPages(dialogId, webpagesToReload, chatMode == MODE_SCHEDULED)
			}

			if (newGroups != null) {
				for (a in 0 until newGroups.size()) {
					val groupedMessages = newGroups.valueAt(a)
					val oldCount = groupedMessages!!.posArray.size

					groupedMessages.calculate()

					val newCount = groupedMessages.posArray.size

					if (newCount - oldCount > 0 && chatAdapter != null) {
						val index = messages.indexOf(groupedMessages.messages[groupedMessages.messages.size - 1])

						if (index >= 0) {
							chatAdapter!!.notifyItemRangeChanged(index, newCount)
						}
					}
				}
			}

			showProgressView(false)

			if (chatAdapter == null) {
				scrollToTopOnResume = true
			}

			if (chatListView != null && chatAdapter != null) {
				var lastVisible = chatLayoutManager!!.findFirstVisibleItemPosition()

				if (lastVisible == RecyclerView.NO_POSITION) {
					lastVisible = 0
				}

				val child = chatLayoutManager?.findViewByPosition(lastVisible)

				val diff = if (child != null) {
					child.bottom - (chatListView?.measuredHeight ?: 0)
				}
				else {
					0
				}

				if (!isAd) {
					if (lastVisible == 0 && diff <= AndroidUtilities.dp(5f) || hasFromMe) {
						newUnreadMessageCount = 0

						if (!firstLoading && chatMode != MODE_SCHEDULED) {
							if (paused) {
								scrollToTopOnResume = true
							}
							else {
								forceScrollToTop = true
								moveScrollToLastMessage(true)
							}
						}
					}
					else {
						if (newUnreadMessageCount != 0 && pagedownButtonCounter != null) {
							if (prevSetUnreadCount != newUnreadMessageCount) {
								prevSetUnreadCount = newUnreadMessageCount
								pagedownButtonCounter?.setCount(newUnreadMessageCount, true)
							}
						}

						canShowPagedownButton = true

						updatePagedownButtonVisibility(true)
					}
				}
				else {
					if (child != null) {
						chatLayoutManager?.scrollToPositionWithOffset(lastVisible + 1, chatListView!!.measuredHeight - child.bottom - chatListView!!.paddingBottom)
					}
				}

				if (newMentionsCount != 0 && mentiondownButtonCounter != null) {
					mentiondownButtonCounter?.visible()
					mentiondownButtonCounter?.setText(String.format("%d", newMentionsCount))

					showMentionDownButton(show = true, animated = true)
				}
			}
			else {
				scrollToTopOnResume = true
			}
		}

		if (chatMode == MODE_SCHEDULED && arr.isNotEmpty()) {
			val messageObject = arr[0]
			val mid = messageObject.id

			if (mid < 0) {
				if (chatListItemAnimator != null) {
					chatListItemAnimator?.setShouldAnimateEnterFromBottom(needMoveScrollToLastMessage)
				}

				if (needMoveScrollToLastMessage) {
					moveScrollToLastMessage(false)
				}
				else {
					val index = messages.indexOf(messageObject)

					if (chatLayoutManager != null && index > 0 && (chatLayoutManager!!.findViewByPosition(chatAdapter!!.messagesStartRow + index) != null || chatLayoutManager!!.findViewByPosition(chatAdapter!!.messagesStartRow + index - 1) != null)) {
						chatLayoutManager!!.scrollToPositionWithOffset(chatAdapter!!.messagesStartRow + messages.indexOf(messageObject), getScrollOffsetForMessage(messageObject), false)
					}
					else {
						AndroidUtilities.runOnUIThread {
							scrollToMessageId(mid, 0, false, 0, true, 0)
						}
					}
				}
			}
		}

		if (messages.isNotEmpty() && botUser != null && botUser?.length == 0) {
			botUser = null
			updateBottomOverlay()
		}

		if (updateChat) {
			updateTitle(false)
			checkAndUpdateAvatar()
		}

		if (reloadMegagroup) {
			messagesController.loadFullChat(currentChat!!.id, 0, true)
		}

		checkWaitingForReplies()
		updateReplyMessageHeader(true)

//		if (chatbotStatusIsShowing) {
//			dismissCurrentDialog()
//			chatbotStatusIsShowing = false
//		}
	}

	private val sponsoredMessagesCount: Int
		get() {
			var sponsoredMessagesCount = 0

			while (sponsoredMessagesCount < messages.size) {
				if (!messages[sponsoredMessagesCount].isSponsored) {
					break
				}

				sponsoredMessagesCount++
			}

			return sponsoredMessagesCount
		}

	private fun processDeletedMessages(markAsDeletedMessages: List<Int>, channelId: Long) {
		val removedIndexes = mutableListOf<Int>()
		var loadIndex = 0

		if (isChannel(currentChat)) {
			loadIndex = if (channelId == 0L && mergeDialogId != 0L) {
				1
			}
			else if (channelId == -dialogId) {
				0
			}
			else {
				return
			}
		}
		else if (channelId != 0L) {
			return
		}

		var updated = false
		var newGroups: LongSparseArray<GroupedMessages>? = null
		var newGroupsSizes: LongSparseArray<Int?>? = null
		val size = markAsDeletedMessages.size
		var updatedSelected = false
		var updatedSelectedLast = false
		var updateScheduled = false
		var hasChatInBack = false
		var updatedReplies = false

		if (threadMessage != null && parentLayout != null) {
			var a = 0
			val N = parentLayout!!.fragmentsStack.size - 1

			while (a < N) {
				val fragment = parentLayout!!.fragmentsStack[a]

				if (fragment !== this && fragment is ChatActivity) {
					if (fragment.needRemovePreviousSameChatActivity && fragment.dialogId == dialogId && fragment.chatMode == chatMode) {
						hasChatInBack = true
						break
					}
				}

				a++
			}
		}

		var commentsDeleted = 0

		for (a in 0 until size) {
			val mid = markAsDeletedMessages[a]
			val obj = messagesDict[loadIndex][mid]

			if (selectedObject != null && obj === selectedObject || obj != null && selectedObjectGroup != null && selectedObjectGroup == groupedMessagesMap[obj.groupId]) {
				closeMenu()
			}

			if (loadIndex == 0) {
				if (pinnedMessageObjects.containsKey(mid)) {
					pinnedMessageObjects.remove(mid)
					pinnedMessageIds.remove(mid)
					loadedPinnedMessagesCount = pinnedMessageIds.size
					totalPinnedMessagesCount--

					if (totalPinnedMessagesCount < 0) {
						totalPinnedMessagesCount = 0
					}

					if (currentPinnedMessageId == mid) {
						currentPinnedMessageId = 0
					}
				}

				repliesMessagesDict.remove(mid)

				updateReplyMessageOwners(mid, null)
			}

			if (obj != null) {
				if (obj.messageOwner?.reply_to != null && obj.messageOwner?.action !is TL_messageActionPinMessage) {
					val replyId = obj.replyAnyMsgId

					if (threadMessage != null && threadMessage!!.id == replyId) {
						if (!hasChatInBack && threadMessage!!.hasReplies()) {
							threadMessage!!.messageOwner!!.replies!!.replies--
						}

						if (replyOriginalMessageId != 0) {
							commentsDeleted++
						}

						updatedReplies = true
					}
					else {
						val replyObject = messagesDict[loadIndex][replyId]

						if (replyObject != null && replyObject.hasReplies()) {
							replyObject.messageOwner!!.replies!!.replies--
							replyObject.viewsReloaded = false
						}
					}
				}

				obj.deleted = true

				if (editingMessageObject === obj) {
					hideFieldPanel(true)
				}

				val index = messages.indexOf(obj)

				if (index != -1) {
					if (obj.scheduled) {
						scheduledMessagesCount--
						updateScheduled = true
					}

					if (selectedMessagesIds[loadIndex].indexOfKey(mid) >= 0) {
						updatedSelected = true
						addToSelectedMessages(obj, false, (a == size - 1).also { updatedSelectedLast = it })
					}

					val removed = messages.removeAt(index)

					if (chatAdapter != null) {
						removedIndexes.add(chatAdapter!!.messagesStartRow + index)
					}

					if (removed.groupId != 0L) {
						val groupedMessages = groupedMessagesMap[removed.groupId]

						if (groupedMessages != null) {
							if (newGroups == null) {
								newGroups = LongSparseArray()
								newGroupsSizes = LongSparseArray()
							}

							newGroups.put(groupedMessages.groupId, groupedMessages)

							if (newGroupsSizes!![groupedMessages.groupId] == null) {
								newGroupsSizes.put(groupedMessages.groupId, groupedMessages.messages.size)
							}

							groupedMessages.messages.remove(obj)
						}
					}

					messagesDict[loadIndex].remove(mid)

					val dayArr = messagesByDays[obj.dateKey]

					if (dayArr != null) {
						dayArr.remove(obj)

						if (dayArr.isEmpty()) {
							messagesByDays.remove(obj.dateKey)

							if (index < messages.size) {
								messages.removeAt(index)

								if (chatAdapter != null) {
									removedIndexes.add(chatAdapter!!.messagesStartRow + index)
								}
							}
						}
					}

					updated = true
				}
			}
		}

		if (updatedReplies) {
			updateReplyMessageHeader(true)
		}

		if (commentsDeleted != 0) {
			notificationCenter.postNotificationName(NotificationCenter.changeRepliesCounter, replyOriginalChat!!.id, replyOriginalMessageId, -commentsDeleted)
			messagesStorage.updateRepliesCount(replyOriginalChat!!.id, replyOriginalMessageId, null, 0, -commentsDeleted)
		}

		if (updatedSelected) {
			if (!updatedSelectedLast) {
				addToSelectedMessages(null, outside = false, last = true)
			}

			updateActionModeTitle()
		}

		if (newGroups != null) {
			for (a in 0 until newGroups.size()) {
				val groupedMessages = newGroups.valueAt(a)

				if (chatListItemAnimator != null) {
					if (groupedMessages.messages.size == 1) {
						chatListItemAnimator?.groupWillTransformToSingleMessage(groupedMessages)
					}
					else {
						chatListItemAnimator?.groupWillChanged(groupedMessages)
					}
				}

				if (groupedMessages.messages.isEmpty()) {
					groupedMessagesMap.remove(groupedMessages.groupId)
				}
				else {
					groupedMessages.calculate()

					val messageObject = groupedMessages.messages[groupedMessages.messages.size - 1]
					val index = messages.indexOf(messageObject)

					if (index >= 0) {
						chatAdapter?.notifyItemRangeChanged(index + chatAdapter!!.messagesStartRow, newGroupsSizes!![groupedMessages.groupId]!!)
					}
				}
			}
		}

		if (messages.isEmpty()) {
			if (!endReached[0] && !loading) {
				showProgressView(false)

				chatListView?.setEmptyView(null)

				if (currentEncryptedChat == null) {
					maxMessageId[1] = Int.MAX_VALUE
					maxMessageId[0] = maxMessageId[1]
					minMessageId[1] = Int.MIN_VALUE
					minMessageId[0] = minMessageId[1]
				}
				else {
					maxMessageId[1] = Int.MIN_VALUE
					maxMessageId[0] = maxMessageId[1]
					minMessageId[1] = Int.MAX_VALUE
					minMessageId[0] = minMessageId[1]
				}

				maxDate[1] = Int.MIN_VALUE
				maxDate[0] = Int.MIN_VALUE
				minDate[1] = 0
				minDate[0] = 0

				waitingForLoad.add(lastLoadIndex)

				messagesController.loadMessages(dialogId, mergeDialogId, false, 30, 0, 0, !cacheEndReached[0], minDate[0], classGuid, 0, 0, chatMode, threadId, replyMaxReadId, lastLoadIndex++)

				loading = true
			}
			else {
				if (botButtons != null) {
					botButtons = null
					chatActivityEnterView?.setButtons(null, false)
				}

				if (currentEncryptedChat == null && currentUser != null && currentUser!!.bot && botUser == null) {
					botUser = ""
					updateBottomOverlay()
				}
			}

			canShowPagedownButton = false

			updatePagedownButtonVisibility(true)

			showMentionDownButton(show = false, animated = true)
		}

		if (updated) {
			if (chatMode == MODE_PINNED) {
				avatarContainer?.setTitle(LocaleController.formatPluralString("PinnedMessagesCount", pinnedMessagesCount))
			}

			if (chatAdapter != null) {
				val prevLoadingUpRow = chatAdapter!!.loadingUpRow
				val prevLoadingDownRow = chatAdapter!!.loadingDownRow
				var a = 0
				val N = removedIndexes.size

				while (a < N) {
					chatAdapter?.notifyItemRemoved(removedIndexes[a])
					a++
				}

				if (!isThreadChat || messages.size <= 3) {
					removeUnreadPlane(false)
				}

				if (messages.isEmpty()) {
					if (prevLoadingUpRow >= 0) {
						chatAdapter?.notifyItemRemoved(0)
					}

					if (prevLoadingDownRow >= 0) {
						chatAdapter?.notifyItemRemoved(0)
					}
				}
				else {
					chatAdapter?.notifyItemRangeChanged(chatAdapter!!.messagesStartRow, messages.size)
				}
			}

			updateVisibleRows()
		}
		else if (threadId == 0) {
			first_unread_id = 0
			last_message_id = 0
			createUnreadMessageAfterId = 0

			removeMessageObject(unreadMessageObject)

			unreadMessageObject = null
		}

		if (updateScheduled) {
			updateScheduledInterface(true)
		}
	}

	private fun replaceMessageObjects(messageObjects: MutableList<MessageObject>, loadIndex: Int, remove: Boolean) {
		var newGroups: LongSparseArray<GroupedMessages>? = null
		var a = 0

		while (a < messageObjects.size) {
			val messageObject = messageObjects[a]
			val pinnedOld = pinnedMessageObjects[messageObject.id]

			if (pinnedOld != null) {
				pinnedMessageObjects[messageObject.id] = messageObject
			}

			val old = messagesDict[loadIndex][messageObject.id]

			if (pinnedMessageObjects.containsKey(messageObject.id)) {
				pinnedMessageObjects[messageObject.id] = messageObject

				if (messageObject.id == currentPinnedMessageId) {
					updatePinnedMessageView(true)
				}
			}

			if (loadIndex == 0 && repliesMessagesDict.indexOfKey(messageObject.id) >= 0) {
				repliesMessagesDict.put(messageObject.id, messageObject)
			}

			if (old == null || remove && old.messageOwner?.date != messageObject.messageOwner?.date) {
				a++
				continue
			}

			if (remove) {
				messageObjects.removeAt(a)
				a--
			}

			addToPolls(messageObject, old)

			if (messageObject.type >= 0) {
				if (old.replyMessageObject != null) {
					messageObject.replyMessageObject = old.replyMessageObject

					if (messageObject.messageOwner?.action is TL_messageActionGameScore) {
						messageObject.generateGameMessageText(null)
					}
					else if (messageObject.messageOwner?.action is TL_messageActionPaymentSent) {
						messageObject.generatePaymentSentMessageText(null)
					}
				}

				if (!old.isEditing) {
					if (old.fileName == messageObject.fileName) {
						messageObject.messageOwner?.attachPath = old.messageOwner?.attachPath
						messageObject.attachPathExists = old.attachPathExists
						messageObject.mediaExists = old.mediaExists
					}
					else {
						messageObject.checkMediaExistence()
					}
				}

				messagesDict[loadIndex].put(old.id, messageObject)
			}
			else {
				messagesDict[loadIndex].remove(old.id)
			}

			val index = messages.indexOf(old)

			if (index >= 0) {
				val dayArr = messagesByDays[old.dateKey]
				var index2 = -1

				if (dayArr != null) {
					index2 = dayArr.indexOf(old)
				}

				if (old.groupId != 0L) {
					val groupedMessages = groupedMessagesMap[old.groupId]

					if (groupedMessages != null) {
						val idx = groupedMessages.messages.indexOf(old)

						if (idx >= 0) {
							if (old.groupId != messageObject.groupId) {
								groupedMessagesMap.put(messageObject.groupId, groupedMessages)
							}

							if (!messageObject.isMusic && !messageObject.isDocument() && messageObject.photoThumbs.isNullOrEmpty()) {
								if (newGroups == null) {
									newGroups = LongSparseArray()
								}

								newGroups.put(groupedMessages.groupId, groupedMessages)

								if (idx > 0 && idx < groupedMessages.messages.size - 1) {
									val slicedGroup = GroupedMessages()
									slicedGroup.groupId = Utilities.random.nextLong()
									slicedGroup.messages.addAll(groupedMessages.messages.subList(idx + 1, groupedMessages.messages.size))

									for (b in slicedGroup.messages.indices) {
										slicedGroup.messages[b].localGroupId = slicedGroup.groupId
										groupedMessages.messages.removeAt(idx + 1)
									}

									newGroups.put(slicedGroup.groupId, slicedGroup)

									groupedMessagesMap.put(slicedGroup.groupId, slicedGroup)
								}

								groupedMessages.messages.removeAt(idx)
							}
							else {
								groupedMessages.messages[idx] = messageObject

								val oldPosition = groupedMessages.positions.remove(old)

								if (oldPosition != null) {
									groupedMessages.positions[messageObject] = oldPosition
								}

								if (newGroups == null) {
									newGroups = LongSparseArray()
								}

								newGroups.put(groupedMessages.groupId, groupedMessages)
							}
						}
					}
				}

				if (messageObject.type >= 0) {
					messageObject.copyStableParams(old)

					messages[index] = messageObject

					chatAdapter?.updateRowAtPosition(chatAdapter!!.messagesStartRow + index)

					if (index2 >= 0) {
						dayArr!![index2] = messageObject
					}
				}
				else {
					messages.removeAt(index)

					chatAdapter?.notifyItemRemoved(chatAdapter!!.messagesStartRow + index)

					if (index2 >= 0) {
						dayArr?.removeAt(index2)

						if (dayArr.isNullOrEmpty()) {
							messagesByDays.remove(old.dateKey)
							messages.removeAt(index)

							val prevLoadingUpRow = chatAdapter!!.loadingUpRow
							val prevLoadingDownRow = chatAdapter!!.loadingDownRow

							chatAdapter?.notifyItemRemoved(chatAdapter!!.messagesStartRow + index)

							if (messages.isEmpty()) {
								if (prevLoadingUpRow >= 0) {
									chatAdapter?.notifyItemRemoved(0)
								}

								if (prevLoadingDownRow >= 0) {
									chatAdapter?.notifyItemRemoved(0)
								}
							}
						}
					}
				}
			}

			updateReplyMessageOwners(old.id, messageObject)

			a++
		}

		if (newGroups != null) {
			for (b in 0 until newGroups.size()) {
				val groupedMessages = newGroups.valueAt(b)

				if (groupedMessages.messages.isEmpty()) {
					groupedMessagesMap.remove(groupedMessages.groupId)
				}
				else {
					groupedMessages.calculate()

					val messageObject = groupedMessages.messages[groupedMessages.messages.size - 1]
					val index = messages.indexOf(messageObject)

					if (index >= 0) {
						if (chatAdapter != null) {
							chatAdapter?.notifyItemRangeChanged(index + chatAdapter!!.messagesStartRow, groupedMessages.messages.size)
							chatListItemAnimator?.groupWillChanged(groupedMessages)
						}
					}
				}
			}
		}
	}

	private fun migrateToNewChat(obj: MessageObject) {
		val actionBarLayout = parentLayout ?: return
		val channelId = obj.messageOwner?.action?.channel_id ?: 0L
		val lastFragment = actionBarLayout.fragmentsStack.lastOrNull()
		val index = actionBarLayout.fragmentsStack.indexOf(this@ChatActivity)

		if (index > 0 && lastFragment !is ChatActivity && lastFragment !is ProfileActivity && currentChat!!.creator) {
			var a = index
			val N = actionBarLayout.fragmentsStack.size - 1

			while (a < N) {
				when (val fragment = actionBarLayout.fragmentsStack[a]) {
					is ChatActivity -> {
						val bundle = Bundle()
						bundle.putLong("chat_id", channelId)
						actionBarLayout.addFragmentToStack(ChatActivity(bundle), a)
						fragment.removeSelfFromStack()
					}

					is ProfileActivity -> {
						// MARK: open profile
						val args = Bundle()
						args.putLong("chat_id", channelId)
						actionBarLayout.addFragmentToStack(ProfileActivity(args), a)
						fragment.removeSelfFromStack()
					}

					is ChatEditActivity -> {
						val args = Bundle()
						args.putLong("chat_id", channelId)
						actionBarLayout.addFragmentToStack(ChatEditActivity(args), a)
						fragment.removeSelfFromStack()
					}

					is ChatUsersActivity -> {
						if (!fragment.hasSelectType()) {
							val args = fragment.getArguments() ?: Bundle()
							args.putLong("chat_id", channelId)
							actionBarLayout.addFragmentToStack(ChatUsersActivity(args), a)
						}

						fragment.removeSelfFromStack()
					}
				}

				a++
			}
		}
		else {
			AndroidUtilities.runOnUIThread {
				if (lastFragment is NotificationCenterDelegate) {
					notificationCenter.removeObserver((lastFragment as NotificationCenterDelegate?)!!, NotificationCenter.closeChats)
				}

				notificationCenter.postNotificationName(NotificationCenter.closeChats)

				val bundle = Bundle()
				bundle.putLong("chat_id", obj.messageOwner?.action?.channel_id ?: 0L)

				actionBarLayout.addFragmentToStack(ChatActivity(bundle), actionBarLayout.fragmentsStack.size - 1)

				lastFragment?.finishFragment()
			}
		}

		AndroidUtilities.runOnUIThread({
			messagesController.loadFullChat(channelId, 0, true)
		}, 1000)
	}

	private fun addToPolls(obj: MessageObject, old: MessageObject?) {
		val pollId = obj.pollId

		if (pollId != 0L) {
			var arrayList = polls[pollId]

			if (arrayList == null) {
				arrayList = mutableListOf()
				polls.put(pollId, arrayList)
			}

			arrayList.add(obj)

			if (old != null) {
				arrayList.remove(old)
			}
		}
	}

	private fun showInfoHint(messageObject: MessageObject?, text: CharSequence, type: Int) {
		if (topUndoView == null) {
			return
		}

		val runnable = Runnable {
			if (chatListView != null) {
				val count = chatListView?.childCount ?: 0

				for (a in 0 until count) {
					val view = chatListView?.getChildAt(a) as? ChatMessageCell ?: continue
					val message = view.getMessageObject()

					if (message != null && message == hintMessageObject) {
						view.showHintButton(show = true, animated = true, type = type)
					}
				}
			}

			hintMessageObject = null
		}

		topUndoView?.showWithAction(0, UndoView.ACTION_TEXT_INFO, text, runnable, runnable)

		hintMessageObject = messageObject
		hintMessageType = type
	}

	private fun showPollSolution(messageObject: MessageObject?, results: PollResults?) {
		if (results == null || results.solution.isNullOrEmpty()) {
			return
		}

		val text: CharSequence

		if (results.solution_entities.isNotEmpty()) {
			text = SpannableStringBuilder(results.solution)
			MessageObject.addEntitiesToText(text, results.solution_entities, out = false, usernames = true, photoViewer = true, useManualParse = false)
		}
		else {
			text = results.solution
		}

		showInfoHint(messageObject, text, 0)
	}

	private fun updateSearchButtons(mask: Int, num: Int, count: Int) {
		if (searchUpButton != null) {
			searchUpButton?.isEnabled = mask and 1 != 0
			searchDownButton?.isEnabled = mask and 2 != 0
			searchUpButton?.alpha = if (searchUpButton!!.isEnabled) 1.0f else 0.5f
			searchDownButton?.alpha = if (searchDownButton!!.isEnabled) 1.0f else 0.5f

			if (count < 0) {
				searchCountText?.setCount("", 0, false)
			}
			else if (count == 0) {
				searchCountText?.setCount(context!!.getString(R.string.NoResult), 0, false)
			}
			else {
				searchCountText?.setCount(LocaleController.formatString("OfCounted", R.string.OfCounted, num + 1, count), num + 1, true)
			}
		}
	}

	override fun needDelayOpenAnimation(): Boolean {
		if (chatMode != MODE_SCHEDULED && getParentLayout()!!.fragmentsStack.size > 1) {
			val previousFragment = getParentLayout()!!.fragmentsStack[getParentLayout()!!.fragmentsStack.size - 2]

			if (previousFragment is ChatActivity && previousFragment.isKeyboardVisible) {
				return false
			}
		}

		return firstLoading
	}

	override fun onBecomeFullyVisible() {
		isFullyVisible = true

		super.onBecomeFullyVisible()

		if (showCloseChatDialogLater) {
			showDialog(closeChatDialog)
		}

		parentLayout?.drawerLayoutContainer?.setBehindKeyboardColor(context!!.getColor(R.color.background))
	}

	override fun onBecomeFullyHidden() {
		isFullyVisible = false

		hideUndoViews()

		parentLayout?.drawerLayoutContainer?.setBehindKeyboardColor(context!!.getColor(R.color.background))
	}

	override fun saveKeyboardPositionBeforeTransition() {
		if (cancelFixedPositionRunnable != null) {
			AndroidUtilities.cancelRunOnUIThread(cancelFixedPositionRunnable)
		}

		fixedKeyboardHeight = if (chatActivityEnterView != null && contentView != null && chatActivityEnterView!!.adjustPanLayoutHelper != null && !chatActivityEnterView!!.adjustPanLayoutHelper!!.animationInProgress()) {
			contentView?.keyboardHeight ?: -1
		}
		else {
			-1
		}
	}

	fun removeKeyboardPositionBeforeTransition() {
		if (fixedKeyboardHeight > 0) {
			AndroidUtilities.runOnUIThread(Runnable {
				cancelFixedPositionRunnable = null
				fixedKeyboardHeight = -1

				fragmentView?.requestLayout()
			}.also { cancelFixedPositionRunnable = it }, 200)
		}
	}

	public override fun onTransitionAnimationStart(isOpen: Boolean, backward: Boolean) {
		super.onTransitionAnimationStart(isOpen, backward)
		var allowedNotifications: IntArray? = null

		if (isOpen) {
			if (!fragmentOpened) {
				fragmentOpened = true
				updateMessagesVisiblePart(false)
			}

			allowedNotifications = if (transitionAnimationIndex == 0) {
				intArrayOf(NotificationCenter.dialogsNeedReload, NotificationCenter.closeChats, NotificationCenter.botKeyboardDidLoad, NotificationCenter.needDeleteDialog, NotificationCenter.messagesDidLoad)
			}
			else {
				intArrayOf(NotificationCenter.dialogsNeedReload, NotificationCenter.closeChats, NotificationCenter.botKeyboardDidLoad, NotificationCenter.needDeleteDialog)
			}

			openAnimationEnded = false

			if (!backward) {
				openAnimationStartTime = SystemClock.elapsedRealtime()
			}
		}
		else {
			if (isUserSelf(currentUser)) {
				allowedNotifications = intArrayOf(NotificationCenter.dialogsNeedReload, NotificationCenter.closeChats, NotificationCenter.botKeyboardDidLoad, NotificationCenter.needDeleteDialog, NotificationCenter.mediaDidLoad)
			}

			chatActivityEnterView?.onBeginHide()
		}

		checkShowBlur()

		transitionAnimationIndex = notificationCenter.setAnimationInProgress(transitionAnimationIndex, allowedNotifications)
	}

	public override fun onTransitionAnimationEnd(isOpen: Boolean, backward: Boolean) {
		super.onTransitionAnimationEnd(isOpen, backward)

		if (isOpen) {
			if (backward) {
				if (showPinBulletin && pinBulletin != null) {
					pinBulletin?.show()
					showPinBulletin = false
				}
			}
		}

		if (cancelFixedPositionRunnable != null) {
			AndroidUtilities.cancelRunOnUIThread(cancelFixedPositionRunnable)
		}

		fixedKeyboardHeight = -1

		if (isOpen) {
			checkShowBlur()

			openAnimationEnded = true

			notificationCenter.onAnimationFinish(transitionAnimationIndex)

			createChatAttachView()
			checkGroupCallJoin(lastCallCheckFromServer)

			if (chatActivityEnterView!!.hasRecordVideo() && !chatActivityEnterView!!.isSendButtonVisible) {
				var isChannel = false

				if (currentChat != null) {
					isChannel = isChannel(currentChat) && !currentChat!!.megagroup
				}

				val preferences = MessagesController.getGlobalMainSettings()
				val key = if (isChannel) "needShowRoundHintChannel2" else "needShowRoundHint2"
				var showCount = preferences.getInt(key, 0)

				if (showCount < 3) {
					if (Utilities.random.nextFloat() <= 0.2f) {
						showVoiceHint(false, chatActivityEnterView!!.isInVideoMode)
						preferences.edit().putInt(key, ++showCount).commit()
					}
				}
			}

			if (!backward && parentLayout != null && needRemovePreviousSameChatActivity) {
				var a = 0
				val N = parentLayout!!.fragmentsStack.size - 1

				while (a < N) {
					val fragment = parentLayout!!.fragmentsStack[a]

					if (fragment !== this && fragment is ChatActivity) {
						if (fragment.needRemovePreviousSameChatActivity && fragment.dialogId == dialogId && fragment.chatMode == chatMode && fragment.threadId == threadId && fragment.reportType == reportType) {
							fragment.removeSelfFromStack()
							break
						}
					}

					a++
				}
			}

			showScheduledOrNoSoundHint()

			if (!backward && firstOpen) {
				if (chatActivityEnterView != null && threadMessage != null && threadMessage!!.repliesCount == 0 && canSendMessages(currentChat)) {
					chatActivityEnterView?.setFieldFocused()
					chatActivityEnterView?.openKeyboard()
				}

				if (messagesController.isPromoDialog(dialogId, true)) {
					val type = messagesController.promoDialogType
					var message: String?
					val preferences = MessagesController.getGlobalNotificationsSettings()

					if (type == MessagesController.PROMO_TYPE_PROXY) {
						message = if (AndroidUtilities.getPrefIntOrLong(preferences, "proxychannel", 0) != dialogId) {
							context!!.getString(R.string.UseProxySponsorInfo)
						}
						else {
							null
						}
					}
					else if (type == MessagesController.PROMO_TYPE_PSA) {
						val psaType = messagesController.promoPsaType

						if (!preferences.getBoolean(psaType + "_shown", false)) {
							message = LocaleController.getString("PsaInfo_$psaType")

							if (message.isNullOrEmpty()) {
								message = context!!.getString(R.string.PsaInfoDefault)
							}
						}
						else {
							message = null
						}
					}
					else {
						message = null
					}

					if (!message.isNullOrEmpty()) {
						if (topUndoView != null) {
							if (type == MessagesController.PROMO_TYPE_PROXY) {
								preferences.edit().putLong("proxychannel", dialogId).commit()
							}
							else if (type == MessagesController.PROMO_TYPE_PSA) {
								val psaType = messagesController.promoPsaType
								preferences.edit().putBoolean(psaType + "_shown", true).commit()
							}

							val stringBuilder = SpannableStringBuilder(message)

							MessageObject.addLinks(false, stringBuilder)

							topUndoView?.showWithAction(0, UndoView.ACTION_TEXT_INFO, stringBuilder, null, null)
						}
					}
				}

				firstOpen = false
			}

			if (!backward && fromPullingDownTransition && parentLayout != null && parentLayout!!.fragmentsStack.size >= 2) {
				val fragment = parentLayout!!.fragmentsStack[parentLayout!!.fragmentsStack.size - 2]

				if (fragment is ChatActivity) {
					backToPreviousFragment = fragment
					parentLayout!!.fragmentsStack.remove(backToPreviousFragment)
				}
			}

			if (backward) {
				pendingRequestsDelegate?.onBackToScreen()
			}

			updateMessagesVisiblePart(false)
		}
		else {
			notificationCenter.onAnimationFinish(transitionAnimationIndex)
		}

		contentView?.invalidate()

		if (!attachMenuBotToOpen.isNullOrEmpty()) {
			val req = TL_contacts_resolveUsername()
			req.username = attachMenuBotToOpen

			connectionsManager.sendRequest(req) { response, _ ->
				AndroidUtilities.runOnUIThread {
					if (response != null) {
						val resolvedPeer = response as TL_contacts_resolvedPeer

						if (resolvedPeer.users.isNotEmpty()) {
							val user = resolvedPeer.users[0]

							if (user.bot && user.bot_attach_menu) {
								val getAttachMenuBot = TL_messages_getAttachMenuBot()
								getAttachMenuBot.bot = MessagesController.getInstance(currentAccount).getInputUser(user.id)

								connectionsManager.sendRequest(getAttachMenuBot) { response1, _ ->
									AndroidUtilities.runOnUIThread {
										if (response1 is TL_attachMenuBotsBot) {
											messagesController.putUsers(response1.users, false)

											val attachMenuBot = response1.bot

											if (!MediaDataController.canShowAttachMenuBot(attachMenuBot, if (currentUser != null) currentUser else currentChat)) {
												if (currentUser != null && currentUser!!.bot && user.id == attachMenuBot.bot_id) {
													BulletinFactory.of(this).createErrorBulletin(context!!.getString(R.string.BotCantOpenAttachMenuSameBot)).show()
												}
												else if (currentUser != null && currentUser!!.bot && user.id != attachMenuBot.bot_id) {
													BulletinFactory.of(this).createErrorBulletin(context!!.getString(R.string.BotCantOpenAttachMenuBot)).show()
												}
												else if (currentUser != null && !currentUser!!.bot) {
													BulletinFactory.of(this).createErrorBulletin(context!!.getString(R.string.BotCantOpenAttachMenuUser)).show()
												}
												else if (currentChat != null && !isChannelAndNotMegaGroup(currentChat)) {
													BulletinFactory.of(this).createErrorBulletin(context!!.getString(R.string.BotCantOpenAttachMenuGroup)).show()
												}
												else if (currentChat != null && isChannelAndNotMegaGroup(currentChat)) {
													BulletinFactory.of(this).createErrorBulletin(context!!.getString(R.string.BotCantOpenAttachMenuChannel)).show()
												}

												return@runOnUIThread
											}

											if (!attachMenuBot.inactive) {
												openAttachBotLayout(user.id, attachMenuBotStartCommand)
											}
											else {
												val parentActivity = parentActivity ?: return@runOnUIThread

												val introTopView = AttachBotIntroTopView(parentActivity)
												introTopView.setColor(ResourcesCompat.getColor(parentActivity.resources, R.color.white, null))
												introTopView.setBackgroundColor(ResourcesCompat.getColor(parentActivity.resources, R.color.brand, null))
												introTopView.setAttachBot(attachMenuBot)

												AlertDialog.Builder(parentActivity).setTopView(introTopView).setMessage(AndroidUtilities.replaceTags(LocaleController.formatString("BotRequestAttachPermission", R.string.BotRequestAttachPermission, getUserName(user)))).setPositiveButton(context!!.getString(R.string.BotAddToMenu)) { _, _ ->
													val botRequest = TL_messages_toggleBotInAttachMenu()
													botRequest.bot = MessagesController.getInstance(currentAccount).getInputUser(user.id)
													botRequest.enabled = true

													connectionsManager.sendRequest(botRequest, { _, error2 ->
														AndroidUtilities.runOnUIThread {
															if (error2 == null) {
																mediaDataController.loadAttachMenuBots(cache = false, force = true)
																openAttachBotLayout(user.id, attachMenuBotStartCommand)
															}
														}
													}, ConnectionsManager.RequestFlagInvokeAfter or ConnectionsManager.RequestFlagFailOnServerErrors)
												}.setNegativeButton(context!!.getString(R.string.Cancel), null).show()
											}
										}
									}
								}
							}
						}
					}
				}
			}

			attachMenuBotToOpen = null
		}
	}

	fun openAttachBotLayout(botId: Long, startCommand: String?) {
		openAttachMenu()
		chatAttachAlert?.showBotLayout(botId, startCommand)
	}

	override fun onDialogDismiss(dialog: Dialog) {
		if (closeChatDialog != null && dialog === closeChatDialog) {
			messagesController.deleteDialog(dialogId, 0)

			if (parentLayout != null && parentLayout!!.fragmentsStack.isNotEmpty() && parentLayout!!.fragmentsStack[parentLayout!!.fragmentsStack.size - 1] !== this) {
				val fragment = parentLayout!!.fragmentsStack[parentLayout!!.fragmentsStack.size - 1]
				removeSelfFromStack()
				fragment.finishFragment()
			}
			else {
				finishFragment()
			}
		}
	}

	override fun extendActionMode(menu: Menu): Boolean {
		if (PhotoViewer.hasInstance() && PhotoViewer.getInstance().isVisible) {
			if (PhotoViewer.getInstance().selectiongLength == 0 || menu.findItem(android.R.id.copy) == null) {
				return true
			}
		}
		else {
			if (chatActivityEnterView?.selectionLength == 0 || menu.findItem(android.R.id.copy) == null) {
				return true
			}
		}

		fillActionModeMenu(menu)

		return true
	}

	fun fillActionModeMenu(menu: Menu) {
		if (menu.findItem(R.id.menu_bold) != null) {
			return
		}

		menu.removeItem(android.R.id.shareText)

		var order = 6

		menu.add(R.id.menu_groupbolditalic, R.id.menu_spoiler, order++, context!!.getString(R.string.Spoiler))

		var stringBuilder = SpannableStringBuilder(context!!.getString(R.string.Bold))
		stringBuilder.setSpan(TypefaceSpan(Theme.TYPEFACE_BOLD), 0, stringBuilder.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

		menu.add(R.id.menu_groupbolditalic, R.id.menu_bold, order++, stringBuilder)

		stringBuilder = SpannableStringBuilder(context!!.getString(R.string.Italic))
		stringBuilder.setSpan(TypefaceSpan(Theme.TYPEFACE_ITALIC), 0, stringBuilder.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

		menu.add(R.id.menu_groupbolditalic, R.id.menu_italic, order++, stringBuilder)

		stringBuilder = SpannableStringBuilder(context!!.getString(R.string.Mono))
		stringBuilder.setSpan(TypefaceSpan(Theme.TYPEFACE_MONOSPACE), 0, stringBuilder.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

		menu.add(R.id.menu_groupbolditalic, R.id.menu_mono, order++, stringBuilder)

		if (currentEncryptedChat == null || AndroidUtilities.getPeerLayerVersion(currentEncryptedChat!!.layer) >= 101) {
			stringBuilder = SpannableStringBuilder(context!!.getString(R.string.Strike))

			var run = TextStyleRun()
			run.styleFlags = run.styleFlags or TextStyleSpan.FLAG_STYLE_STRIKE

			stringBuilder.setSpan(TextStyleSpan(run), 0, stringBuilder.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

			menu.add(R.id.menu_groupbolditalic, R.id.menu_strike, order++, stringBuilder)

			stringBuilder = SpannableStringBuilder(context!!.getString(R.string.Underline))

			run = TextStyleRun()
			run.styleFlags = run.styleFlags or TextStyleSpan.FLAG_STYLE_UNDERLINE

			stringBuilder.setSpan(TextStyleSpan(run), 0, stringBuilder.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

			menu.add(R.id.menu_groupbolditalic, R.id.menu_underline, order++, stringBuilder)
		}

		menu.add(R.id.menu_groupbolditalic, R.id.menu_link, order++, context!!.getString(R.string.CreateLink))
		menu.add(R.id.menu_groupbolditalic, R.id.menu_regular, order++, context!!.getString(R.string.Regular))
	}

	private fun updateScheduledInterface(animated: Boolean) {
		chatActivityEnterView?.updateScheduleButton(animated)
	}

	private fun updateBottomOverlay() {
		if (bottomOverlayChatText == null || chatMode == MODE_SCHEDULED) {
			return
		}

		val currentChat = currentChat

		if (reportType >= 0) {
			updateActionModeTitle()
		}
		else if (chatMode == MODE_PINNED) {
			val allowPin = if (currentChat != null) {
				canPinMessages(currentChat)
			}
			else {
				currentUserInfo?.can_pin_message ?: false
			}

			if (allowPin) {
				bottomOverlayChatText?.tag = 1
				bottomOverlayChatText?.text = context!!.getString(R.string.UnpinAllMessages)
			}
			else {
				bottomOverlayChatText?.tag = null
				bottomOverlayChatText?.text = context!!.getString(R.string.HidePinnedMessages)
			}

			showBottomOverlayProgress(show = false, animated = false)
		}
		else if (currentChat != null) {
			val requestedTime = MessagesController.getNotificationsSettings(currentAccount).getLong("dialog_join_requested_time_$dialogId", -1)
			var shouldApply = false

			if (isChannel(currentChat) && currentChat !is TL_channelForbidden) {
				if (isNotInChat(currentChat) && (!isThreadChat || currentChat.join_to_send)) {
					if (messagesController.isJoiningChannel(currentChat.id)) {
						showBottomOverlayProgress(show = true, animated = false)
					}
					else {
						if (currentChat.join_request) {
							shouldApply = true

							if (requestedTime > 0 && System.currentTimeMillis() - requestedTime < 1000 * 60 * 2) {
								bottomOverlayChatText?.text = context!!.getString(R.string.ChannelJoinRequestSent)
								bottomOverlayChatText?.setCompoundDrawables(null, null, null, null)
								bottomOverlayChatText?.isEnabled = false
							}
							else {
								if (isPaidChannel(currentChat)) {
									ioScope.launch {
										checkSubscription(currentChat)
									}

									bottomOverlayChatText?.isEnabled = false
								}
								else if (currentChat.adult) {
									ioScope.launch {
										checkAdultSubscription(currentChat)
									}

									bottomOverlayChatText?.isEnabled = false
								}
								else {
									bottomOverlayChatText?.setCompoundDrawablesWithIntrinsicBounds(ResourcesCompat.getDrawable(context!!.resources, R.drawable.mouse, null), null, null, null)
									bottomOverlayChatText?.text = context!!.getString(R.string.ChannelJoinRequest).uppercase(Locale.getDefault())
									bottomOverlayChatText?.isEnabled = true
								}
							}
						}
						else {
							bottomOverlayChatText?.setCompoundDrawablesWithIntrinsicBounds(ResourcesCompat.getDrawable(context!!.resources, R.drawable.mouse, null), null, null, null)
							bottomOverlayChatText?.text = if (isMegagroup(currentChat)) {
								context!!.getString(R.string.JoinGroup).uppercase(Locale.getDefault())
							}
							else {
								context!!.getString(R.string.ChannelJoin).uppercase(Locale.getDefault())
							}
							bottomOverlayChatText?.isEnabled = true
						}

						showBottomOverlayProgress(show = false, animated = false)
					}
				}
				else if (!isThreadChat) {
					if (!messagesController.isDialogMuted(dialogId)) {
						bottomOverlayChatText?.setCompoundDrawablesWithIntrinsicBounds(ResourcesCompat.getDrawable(context!!.resources, R.drawable.notification_mute, null), null, null, null)
						bottomOverlayChatText?.text = context!!.getString(R.string.ChannelMute).uppercase(Locale.getDefault())
						bottomOverlayChatText?.isEnabled = true
					}
					else {
						bottomOverlayChatText?.setCompoundDrawablesWithIntrinsicBounds(ResourcesCompat.getDrawable(context!!.resources, R.drawable.notification_unmute, null), null, null, null)
						bottomOverlayChatText?.text = context!!.getString(R.string.ChannelUnmute).uppercase(Locale.getDefault())
						bottomOverlayChatText?.isEnabled = true
					}

					showBottomOverlayProgress(false, bottomOverlayProgress?.tag != null)
				}
			}
			else if (!isThreadChat) {
				bottomOverlayChatText?.setCompoundDrawablesWithIntrinsicBounds(null, null, null, null)
				bottomOverlayChatText?.text = context!!.getString(R.string.DeleteThisGroup)
				bottomOverlayChatText?.isEnabled = true
			}

			if (!shouldApply && requestedTime > 0) {
				MessagesController.getNotificationsSettings(currentAccount).edit().putLong("dialog_join_requested_time_$dialogId", -1).commit()
			}
		}
		else {
			showBottomOverlayProgress(show = false, animated = true)

			if (userBlocked) {
				if (currentUser!!.bot) {
					bottomOverlayChatText?.text = context!!.getString(R.string.BotUnblock)
				}
				else {
					bottomOverlayChatText?.text = context!!.getString(R.string.Unblock)
				}

				if (botButtons != null) {
					botButtons = null

					if (chatActivityEnterView != null) {
						if (replyMessage != null && botReplyButtons === replyMessage) {
							botReplyButtons = null
							hideFieldPanel(false)
						}

						chatActivityEnterView?.setButtons(botButtons, false)
					}
				}
			}
			else if (isReplyUser(currentUser)) {
				if (!messagesController.isDialogMuted(dialogId)) {
					bottomOverlayChatText?.setCompoundDrawablesWithIntrinsicBounds(ResourcesCompat.getDrawable(context!!.resources, R.drawable.notification_mute, null), null, null, null)
					bottomOverlayChatText?.text = context!!.getString(R.string.ChannelMute)
				}
				else {
					bottomOverlayChatText?.setCompoundDrawablesWithIntrinsicBounds(ResourcesCompat.getDrawable(context!!.resources, R.drawable.notification_unmute, null), null, null, null)
					bottomOverlayChatText?.text = context!!.getString(R.string.ChannelUnmute)
				}

				showBottomOverlayProgress(show = false, animated = true)
			}
			else if (botUser != null && currentUser!!.bot) {
				bottomOverlayChatText?.text = context!!.getString(R.string.BotStart)

				chatActivityEnterView?.hidePopup(false)
				emptyViewContainer?.visible()

				if (parentActivity != null) {
					AndroidUtilities.hideKeyboard(parentActivity!!.currentFocus)
				}
			}
			else {
				bottomOverlayChatText?.text = context!!.getString(R.string.DeleteThisChat)
			}
		}
		if (currentChat != null && currentChat.gigagroup && reportType < 0 && chatMode == 0) {
			bottomOverlayImage?.visible()
		}
		else {
			bottomOverlayImage?.invisible()
		}

		if (inPreviewMode) {
			searchContainer?.invisible()
			bottomOverlayChat?.invisible()

			chatActivityEnterView?.setFieldFocused(false)
			chatActivityEnterView?.invisible()
		}
		else if (searchItem != null && searchItemVisible) {
			searchContainer?.animate()?.setListener(null)?.cancel()

			if (searchContainer?.visibility != View.VISIBLE) {
				searchContainer?.visible()
				searchContainer?.alpha = 0f
			}

			searchContainer?.animate()?.alpha(1f)?.setDuration(150)?.start()

			searchExpandAnimator?.removeAllListeners()
			searchExpandAnimator?.cancel()

			if (searchExpandProgress != 1f) {
				searchExpandAnimator = ValueAnimator.ofFloat(searchExpandProgress, 1f)

				searchExpandAnimator?.addUpdateListener {
					searchExpandProgress = it.animatedValue as Float
					chatListView?.translationY = searchExpandProgress * (chatActivityEnterView!!.measuredHeight - searchContainer!!.measuredHeight)
					chatActivityEnterView?.setChatSearchExpandOffset(searchExpandProgress * (chatActivityEnterView!!.measuredHeight - searchContainer!!.measuredHeight))
					invalidateChatListViewTopPadding()
				}

				searchExpandAnimator?.addListener(object : AnimatorListenerAdapter() {
					override fun onAnimationEnd(animation: Animator) {
						searchExpandProgress = 1f
						chatActivityEnterView?.invisible()
						bottomOverlayChat?.invisible()
						invalidateChatListViewTopPadding()
					}
				})

				searchExpandAnimator?.duration = 250
				searchExpandAnimator?.interpolator = ChatListItemAnimator.DEFAULT_INTERPOLATOR
				searchExpandAnimator?.start()
			}
			else {
				chatActivityEnterView?.invisible()
				bottomOverlayChat?.invisible()
				invalidateChatListViewTopPadding()
			}

			chatActivityEnterView?.setFieldFocused(false)

			if (chatActivityEnterView!!.isTopViewVisible) {
				topViewWasVisible = 1
				chatActivityEnterView?.hideTopView(false)
			}
			else {
				topViewWasVisible = 2
			}
		}
		else {
			searchContainer?.animate()?.setListener(null)?.cancel()

			if (searchContainer?.visibility == View.VISIBLE) {
				searchContainer?.animate()?.alpha(0f)?.setDuration(150)?.setListener(object : AnimatorListenerAdapter() {
					override fun onAnimationEnd(animation: Animator) {
						super.onAnimationEnd(animation)
						searchContainer?.invisible()
					}
				})?.start()
			}

			chatActivityEnterView?.visible()

			searchExpandAnimator?.removeAllListeners()
			searchExpandAnimator?.cancel()

			if (searchExpandProgress != 0f) {
				searchExpandAnimator = ValueAnimator.ofFloat(searchExpandProgress, 0f)

				invalidateChatListViewTopPadding()

				searchExpandAnimator?.addUpdateListener {
					searchExpandProgress = it.animatedValue as Float
					chatListView?.translationY = searchExpandProgress * (chatActivityEnterView!!.measuredHeight - searchContainer!!.measuredHeight)
					chatActivityEnterView?.setChatSearchExpandOffset(searchExpandProgress * (chatActivityEnterView!!.measuredHeight - searchContainer!!.measuredHeight))
					invalidateChatListViewTopPadding()
				}

				searchExpandAnimator?.addListener(object : AnimatorListenerAdapter() {
					override fun onAnimationEnd(animation: Animator) {
						searchExpandProgress = 0f
						invalidateChatListViewTopPadding()
					}
				})

				searchExpandAnimator?.duration = 250
				searchExpandAnimator?.interpolator = ChatListItemAnimator.DEFAULT_INTERPOLATOR
				searchExpandAnimator?.start()
			}

			if (muteItem != null) {
				if (currentChat != null && isNotInChat(currentChat)) {
					muteItem?.gone()
					muteItemGap?.gone()
				}
				else {
					muteItem?.visible()
					muteItemGap?.visible()
				}
			}

			if (reportType >= 0) {
				bottomOverlayChat?.visible()
				chatActivityEnterView?.invisible()
			}
			else if (chatMode == MODE_PINNED || currentChat != null && (isNotInChat(currentChat) || !canWriteToChat(currentChat)) && (currentChat.join_to_send || !isThreadChat) || currentUser != null && (isDeleted(currentUser) || userBlocked || isReplyUser(currentUser))) {
				if (chatActivityEnterView!!.isEditingMessage) {
					chatActivityEnterView?.visible()
					bottomOverlayChat?.invisible()
					chatActivityEnterView?.setFieldFocused()

					AndroidUtilities.runOnUIThread({
						chatActivityEnterView?.openKeyboard()
					}, 100)
				}
				else {
					bottomOverlayChat?.visible()

					chatActivityEnterView?.setFieldFocused(false)
					chatActivityEnterView?.invisible()
					chatActivityEnterView?.closeKeyboard()

					suggestEmojiPanel?.forceClose()
				}

				attachItem?.gone()
				editTextItem?.gone()
				headerItem?.visible()
			}
			else {
				if (botUser != null && currentUser != null && currentUser!!.bot) {
					bottomOverlayChat?.visible()
					chatActivityEnterView?.invisible()
				}
				else {
					chatActivityEnterView?.visible()
					bottomOverlayChat?.invisible()
				}
			}

			if (topViewWasVisible == 1) {
				chatActivityEnterView?.showTopView(animated = false, openKeyboard = false)
				topViewWasVisible = 0
			}
		}

		if (currentUser != null && (currentUser!!.id == 333000L || currentUser!!.id == 777000L || currentUser!!.id == 42777L)) {
			bottomOverlayChatText?.text = context!!.getString(R.string.ServiceNotifications).uppercase(Locale.getDefault())
			bottomOverlayChatText?.setCompoundDrawables(null, null, null, null)
			bottomOverlayChatText?.isEnabled = false

			bottomOverlayChat?.visible()
			chatActivityEnterView?.invisible()
		}

		checkRaiseSensors()
	}

	fun updateReplyMessageHeader(notify: Boolean) {
		if (avatarContainer != null && threadId != 0) {
			if (isComments) {
				if (threadMessage!!.hasReplies()) {
					avatarContainer?.setTitle(LocaleController.formatPluralString("Comments", threadMessage!!.repliesCount))
				}
				else {
					avatarContainer?.setTitle(context!!.getString(R.string.CommentsTitle))
				}
			}
			else {
				avatarContainer?.setTitle(LocaleController.formatPluralString("Replies", threadMessage!!.repliesCount))
			}
		}

		if (replyMessageHeaderObject == null) {
			return
		}

		val text = if (threadMessage!!.repliesCount == 0) {
			if (isComments) {
				context!!.getString(R.string.NoComments)
			}
			else {
				context!!.getString(R.string.NoReplies)
			}
		}
		else {
			context!!.getString(R.string.DiscussionStarted)
		}

		replyMessageHeaderObject?.messageOwner?.message = text
		replyMessageHeaderObject?.messageText = replyMessageHeaderObject?.messageOwner?.message

		if (notify) {
			chatAdapter?.updateRowWithMessageObject(replyMessageHeaderObject, true)
		}
	}

	fun showAlert(name: String?, message: String?) {
		if (alertView == null || name == null || message == null) {
			return
		}

		if (alertView?.tag != null) {
			alertView?.tag = null

			alertViewAnimator?.cancel()
			alertViewAnimator = null

			if (alertView!!.visibility != View.VISIBLE) {
				alertViewEnterProgress = 0f
				invalidateChatListViewTopPadding()
			}

			alertView?.visible()

			alertViewAnimator = AnimatorSet()

			val animator = ValueAnimator.ofFloat(alertViewEnterProgress, 1f)

			animator.addUpdateListener {
				alertViewEnterProgress = it.animatedValue as Float
				invalidateChatListViewTopPadding()
			}

			alertViewAnimator?.playTogether(animator)
			alertViewAnimator?.duration = 200

			alertViewAnimator?.addListener(object : AnimatorListenerAdapter() {
				override fun onAnimationEnd(animation: Animator) {
					if (alertViewAnimator != null && alertViewAnimator == animation) {
						alertViewEnterProgress = 1f
						invalidateChatListViewTopPadding()
						alertViewAnimator = null
					}
				}

				override fun onAnimationCancel(animation: Animator) {
					if (alertViewAnimator != null && alertViewAnimator == animation) {
						alertViewAnimator = null
					}
				}
			})

			alertViewAnimator?.start()
		}

		alertNameTextView?.text = name
		alertTextView?.text = Emoji.replaceEmoji(message.replace('\n', ' '), alertTextView!!.paint.fontMetricsInt, false)

		if (hideAlertViewRunnable != null) {
			AndroidUtilities.cancelRunOnUIThread(hideAlertViewRunnable)
		}

		AndroidUtilities.runOnUIThread(object : Runnable {
			override fun run() {
				if (hideAlertViewRunnable !== this) {
					return
				}

				if (alertView?.tag == null) {
					alertView?.tag = 1

					alertViewAnimator?.cancel()
					alertViewAnimator = null

					alertViewAnimator = AnimatorSet()

					val animator = ValueAnimator.ofFloat(alertViewEnterProgress, 0f)

					animator.addUpdateListener {
						alertViewEnterProgress = it.animatedValue as Float
						invalidateChatListViewTopPadding()
					}

					alertViewAnimator?.playTogether(animator)
					alertViewAnimator?.duration = 200

					alertViewAnimator?.addListener(object : AnimatorListenerAdapter() {
						override fun onAnimationEnd(animation: Animator) {
							if (alertViewAnimator != null && alertViewAnimator == animation) {
								alertView?.gone()
								alertViewEnterProgress = 0f
								invalidateChatListViewTopPadding()
								alertViewAnimator = null
							}
						}

						override fun onAnimationCancel(animation: Animator) {
							if (alertViewAnimator != null && alertViewAnimator == animation) {
								alertViewAnimator = null
							}
						}
					})

					alertViewAnimator?.start()
				}
			}
		}.also {
			hideAlertViewRunnable = it
		}, 3000)
	}

	private fun hidePinnedMessageView(animated: Boolean): Boolean {
		if (pinnedMessageView != null && pinnedMessageView?.tag == null) {
			for (a in pinnedNextAnimation.indices) {
				pinnedNextAnimation[a]?.cancel()
				pinnedNextAnimation[a] = null
			}

			setPinnedTextTranslationX = false
			pinnedMessageView?.tag = 1

			pinnedMessageViewAnimator?.cancel()
			pinnedMessageViewAnimator = null

			if (animated) {
				pinnedMessageViewAnimator = AnimatorSet()

				val animator = ValueAnimator.ofFloat(pinnedMessageEnterOffset, -AndroidUtilities.dp(50f).toFloat())

				animator.addUpdateListener {
					pinnedMessageEnterOffset = it.animatedValue as Float
					invalidateChatListViewTopPadding()
					invalidateMessagesVisiblePart()
					chatListView?.invalidate()
				}

				pinnedMessageViewAnimator?.playTogether(animator)
				pinnedMessageViewAnimator?.duration = 200

				pinnedMessageViewAnimator?.addListener(object : AnimatorListenerAdapter() {
					override fun onAnimationEnd(animation: Animator) {
						if (pinnedMessageViewAnimator != null && pinnedMessageViewAnimator == animation) {
							pinnedMessageView?.gone()
							pinnedMessageViewAnimator = null
						}
					}

					override fun onAnimationCancel(animation: Animator) {
						if (pinnedMessageViewAnimator != null && pinnedMessageViewAnimator == animation) {
							pinnedMessageViewAnimator = null
						}
					}
				})

				pinnedMessageViewAnimator?.start()
			}
			else {
				pinnedMessageEnterOffset = -AndroidUtilities.dp(50f).toFloat()
				pinnedMessageView?.gone()
				chatListView?.invalidate()
			}

			return true
		}

		return false
	}

	private fun updatePinnedListButton(animated: Boolean) {
		if (isThreadChat || pinnedListButton == null) {
			return
		}

		val show = pinnedMessageIds.size > 1 && !pinnedMessageButtonShown
		val visible = pinnedListButton!!.tag != null
		val progressIsVisible = pinnedProgress!!.tag != null
		val closeIsVisible = closePinned!!.tag != null
		val showClosed = !show && !pinnedProgressIsShowing && !pinnedMessageButtonShown
		val showPinned = show && !pinnedProgressIsShowing && !pinnedMessageButtonShown
		val showProgress = pinnedProgressIsShowing && !pinnedMessageButtonShown

		if (visible != show || progressIsVisible != showProgress || closeIsVisible != showClosed) {
			pinnedListAnimator?.cancel()
			pinnedListAnimator = null

			if (animated) {
				if (show) {
					pinnedListButton?.visible()
				}
				else if (showClosed) {
					closePinned?.visible()
				}
				if (showProgress) {
					pinnedProgress?.visible()
					pinnedProgress?.alpha = 0f
					pinnedProgress?.scaleX = 0.4f
					pinnedProgress?.scaleY = 0.4f
				}

				pinnedListAnimator = AnimatorSet()
				pinnedListAnimator?.playTogether(ObjectAnimator.ofFloat(pinnedListButton, View.ALPHA, if (showPinned) 1.0f else 0.0f), ObjectAnimator.ofFloat(pinnedListButton, View.SCALE_X, if (showPinned) 1.0f else 0.4f), ObjectAnimator.ofFloat(pinnedListButton, View.SCALE_Y, if (showPinned) 1.0f else 0.4f), ObjectAnimator.ofFloat(closePinned, View.ALPHA, if (showClosed) 1.0f else 0.0f), ObjectAnimator.ofFloat(closePinned, View.SCALE_X, if (showClosed) 1.0f else 0.4f), ObjectAnimator.ofFloat(closePinned, View.SCALE_Y, if (showClosed) 1.0f else 0.4f), ObjectAnimator.ofFloat(pinnedProgress, View.ALPHA, if (!showProgress) 0.0f else 1.0f), ObjectAnimator.ofFloat(pinnedProgress, View.SCALE_X, if (!showProgress) 0.4f else 1.0f), ObjectAnimator.ofFloat(pinnedProgress, View.SCALE_Y, if (!showProgress) 0.4f else 1.0f))
				pinnedListAnimator?.interpolator = CubicBezierInterpolator.EASE_OUT_QUINT
				pinnedListAnimator?.duration = (180 * 2).toLong()

				pinnedListAnimator?.addListener(object : AnimatorListenerAdapter() {
					override fun onAnimationEnd(animation: Animator) {
						pinnedListAnimator = null
						closePinned?.visibility = if (showClosed) View.VISIBLE else View.INVISIBLE
						pinnedListButton?.visibility = if (showPinned) View.VISIBLE else View.INVISIBLE
						pinnedProgress?.visibility = if (showProgress) View.VISIBLE else View.INVISIBLE
					}
				})

				pinnedListAnimator?.start()
			}
			else {
				closePinned?.alpha = if (showClosed) 1.0f else 0.0f
				closePinned?.scaleX = if (showClosed) 1.0f else 0.4f
				closePinned?.scaleY = if (showClosed) 1.0f else 0.4f
				closePinned?.visibility = if (showClosed) View.VISIBLE else View.INVISIBLE

				pinnedListButton?.alpha = if (showPinned) 1.0f else 0.0f
				pinnedListButton?.scaleX = if (showPinned) 1.0f else 0.4f
				pinnedListButton?.scaleY = if (showPinned) 1.0f else 0.4f
				pinnedListButton?.visibility = if (showPinned) View.VISIBLE else View.INVISIBLE

				pinnedProgress?.alpha = if (showProgress) 1.0f else 0.0f
				pinnedProgress?.scaleX = if (showProgress) 1.0f else 0.4f
				pinnedProgress?.scaleY = if (showProgress) 1.0f else 0.4f
				pinnedProgress?.visibility = if (showProgress) View.VISIBLE else View.GONE
			}

			closePinned?.tag = if (showClosed) 1 else null
			pinnedListButton?.tag = if (show) 1 else null
			pinnedProgress?.tag = if (showProgress) 1 else null
		}

		if (pinnedLineView != null) {
			if (isThreadChat) {
				pinnedLineView!![0, 1] = false
			}
			else {
				val position = Collections.binarySearch(pinnedMessageIds, currentPinnedMessageId, Comparator.reverseOrder())
				pinnedLineView!![pinnedMessageIds.size - 1 - position, pinnedMessageIds.size] = animated
			}
		}
	}

	private fun pinnedButton(message: MessageObject?): KeyboardButton? {
		return message?.messageOwner?.reply_markup?.rows?.firstOrNull()?.buttons?.firstOrNull()
	}

	private fun updatePinnedMessageView(animated: Boolean, animateToNext: Int = 0) {
		if (pinnedMessageView == null || chatMode != 0) {
			return
		}

		val pinned_msg_id: Int
		var changed = false
		var pinnedMessageObject: MessageObject?

		if (isThreadChat) {
			if (!threadMessageVisible) {
				pinnedMessageObject = threadMessage
				pinned_msg_id = threadId
			}
			else {
				pinnedMessageObject = null
				pinned_msg_id = 0
			}
		}
		else if (currentPinnedMessageId != 0 && pinnedMessageIds.isNotEmpty()) {
			pinnedMessageObject = pinnedMessageObjects[currentPinnedMessageId]

			if (pinnedMessageObject == null) {
				pinnedMessageObject = messagesDict[0][currentPinnedMessageId]
			}

			pinned_msg_id = currentPinnedMessageId
		}
		else {
			pinnedMessageObject = null
			pinned_msg_id = 0
		}

		val botButton = pinnedButton(pinnedMessageObject)

		pinnedMessageButtonShown = botButton != null

		val preferences = MessagesController.getNotificationsSettings(currentAccount)

		if (threadMessage == null && (currentChatInfo == null && currentUserInfo == null || pinned_msg_id == 0 || pinnedMessageIds.isNotEmpty() && pinnedMessageIds[0] == preferences.getInt("pin_$dialogId", 0)) || reportType >= 0 || actionBar != null && (actionBar!!.isActionModeShowed || actionBar!!.isSearchFieldVisible)) {
			changed = hidePinnedMessageView(animated)
		}
		else {
			updatePinnedListButton(animated)

			if (pinnedMessageObject != null) {
				if (pinnedMessageView?.tag != null) {
					pinnedMessageView?.tag = null

					changed = true

					pinnedMessageViewAnimator?.cancel()
					pinnedMessageViewAnimator = null

					if (animated) {
						val animator = ValueAnimator.ofFloat(pinnedMessageEnterOffset, 0f)

						animator.addUpdateListener(object : AnimatorUpdateListener {
							val position = -1

							override fun onAnimationUpdate(animation: ValueAnimator) {
								pinnedMessageEnterOffset = animation.animatedValue as Float
								invalidateChatListViewTopPadding()
								invalidateMessagesVisiblePart()
							}
						})

						pinnedMessageView?.visible()

						pinnedMessageViewAnimator = AnimatorSet()
						pinnedMessageViewAnimator?.playTogether(animator)
						pinnedMessageViewAnimator?.duration = 200

						pinnedMessageViewAnimator?.addListener(object : AnimatorListenerAdapter() {
							override fun onAnimationEnd(animation: Animator) {
								if (pinnedMessageViewAnimator != null && pinnedMessageViewAnimator == animation) {
									pinnedMessageViewAnimator = null
								}
							}

							override fun onAnimationCancel(animation: Animator) {
								if (pinnedMessageViewAnimator != null && pinnedMessageViewAnimator == animation) {
									pinnedMessageViewAnimator = null
								}
							}
						})

						pinnedMessageViewAnimator?.start()
					}
					else {
						pinnedMessageEnterOffset = 0f
						invalidateChatListViewTopPadding()
						invalidateMessagesVisiblePart()
						pinnedMessageView?.visible()
					}
				}
				for (a in pinnedNextAnimation.indices) {
					pinnedNextAnimation[a]?.cancel()
					pinnedNextAnimation[a] = null
				}

				setPinnedTextTranslationX = false

				val nameTextView = pinnedNameTextView[if (animateToNext != 0) 1 else 0]
				val messageTextView = pinnedMessageTextView[if (animateToNext != 0) 1 else 0]
				val buttonTextView = pinnedMessageButton[if (animateToNext != 0) 1 else 0]

				buttonTextView?.visibility = if (botButton != null) View.VISIBLE else View.GONE

				pinnedMessageButton[if (animateToNext != 0) 0 else 1]!!.setOnClickListener(null)
				pinnedMessageButton[if (animateToNext != 0) 0 else 1]!!.setOnLongClickListener(null)

				if (botButton == null) {
					buttonTextView?.text = null
					buttonTextView?.setOnClickListener(null)
				}
				else {
					val string = SpannableString(botButton.text)

					Emoji.replaceEmoji(string, buttonTextView?.paint?.fontMetricsInt, false)

					buttonTextView?.text = string

					val buttonMessage: MessageObject = pinnedMessageObject

					buttonTextView?.setOnClickListener {
						if (parentActivity == null || bottomOverlayChat!!.visibility == View.VISIBLE && botButton !is TL_keyboardButtonSwitchInline && botButton !is TL_keyboardButtonCallback && botButton !is TL_keyboardButtonGame && botButton !is TL_keyboardButtonUrl && botButton !is TL_keyboardButtonBuy && botButton !is TL_keyboardButtonUrlAuth && botButton !is TL_keyboardButtonUserProfile) {
							return@setOnClickListener
						}

						chatActivityEnterView?.didPressedBotButton(botButton, buttonMessage, buttonMessage)
					}

					buttonTextView?.setOnLongClickListener {
						if (parentActivity == null || bottomOverlayChat!!.visibility == View.VISIBLE && botButton !is TL_keyboardButtonSwitchInline && botButton !is TL_keyboardButtonCallback && botButton !is TL_keyboardButtonGame && botButton !is TL_keyboardButtonUrl && botButton !is TL_keyboardButtonBuy && botButton !is TL_keyboardButtonUrlAuth && botButton !is TL_keyboardButtonUserProfile) {
							return@setOnLongClickListener false
						}

						if (botButton is TL_keyboardButtonUrl) {
							openClickableLink(null, botButton.url, true, null, buttonMessage)

							runCatching {
								buttonTextView.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS, HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING)
							}

							return@setOnLongClickListener true
						}

						false
					}
				}

				buttonTextView?.measure(MeasureSpec.makeMeasureSpec(999999, MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(28f), MeasureSpec.EXACTLY))

				if (messageTextView?.layoutParams is MarginLayoutParams) {
					(messageTextView.layoutParams as MarginLayoutParams).rightMargin = if (botButton == null) AndroidUtilities.dp(44f) else (buttonTextView?.measuredWidth ?: 0) + AndroidUtilities.dp((14 + 8).toFloat())
				}

				if (nameTextView?.layoutParams is MarginLayoutParams) {
					(nameTextView.layoutParams as MarginLayoutParams).rightMargin = if (botButton == null) AndroidUtilities.dp(44f) else (buttonTextView?.measuredWidth ?: 0) + AndroidUtilities.dp((14 + 8).toFloat())
				}

				val layoutParams1 = pinnedNameTextView[0]!!.layoutParams as FrameLayout.LayoutParams
				val layoutParams2 = pinnedNameTextView[1]!!.layoutParams as FrameLayout.LayoutParams
				val layoutParams3 = pinnedCounterTextView!!.layoutParams as FrameLayout.LayoutParams
				val layoutParams4 = pinnedMessageTextView[0]!!.layoutParams as FrameLayout.LayoutParams
				val layoutParams5 = pinnedMessageTextView[1]!!.layoutParams as FrameLayout.LayoutParams
				var cacheType = 1
				var size = 0
				var photoSize = FileLoader.getClosestPhotoSizeWithSize(pinnedMessageObject.photoThumbs2, AndroidUtilities.dp(320f))
				var thumbPhotoSize = FileLoader.getClosestPhotoSizeWithSize(pinnedMessageObject.photoThumbs2, AndroidUtilities.dp(40f))
				var photoSizeObject = pinnedMessageObject.photoThumbsObject2

				if (photoSize == null) {
					if (pinnedMessageObject.mediaExists) {
						photoSize = FileLoader.getClosestPhotoSizeWithSize(pinnedMessageObject.photoThumbs, AndroidUtilities.getPhotoSize())

						if (photoSize != null) {
							size = photoSize.size
						}

						cacheType = 0
					}
					else {
						photoSize = FileLoader.getClosestPhotoSizeWithSize(pinnedMessageObject.photoThumbs, AndroidUtilities.dp(320f))
					}

					thumbPhotoSize = FileLoader.getClosestPhotoSizeWithSize(pinnedMessageObject.photoThumbs, AndroidUtilities.dp(40f))
					photoSizeObject = pinnedMessageObject.photoThumbsObject
				}

				if (photoSize === thumbPhotoSize) {
					thumbPhotoSize = null
				}

				var noImage: Boolean
				val prevMargin = layoutParams1.leftMargin

				if ((photoSize == null || photoSize is TL_photoSizeEmpty || photoSize.location is TL_fileLocationUnavailable || pinnedMessageObject.isAnyKindOfSticker || pinnedMessageObject.isSecretMedia).also { noImage = it }) {
					pinnedImageLocation = null
					pinnedImageLocationObject = null

					if (animateToNext == 0) {
						pinnedMessageImageView[0]?.setImageBitmap(null)
						pinnedMessageImageView[0]?.invisible()
					}

					layoutParams5.leftMargin = AndroidUtilities.dp(18f)
					layoutParams4.leftMargin = layoutParams5.leftMargin
					layoutParams3.leftMargin = layoutParams4.leftMargin
					layoutParams2.leftMargin = layoutParams3.leftMargin
					layoutParams1.leftMargin = layoutParams2.leftMargin
				}
				else {
					if (pinnedMessageObject.isRoundVideo) {
						pinnedMessageImageView[1]?.setRoundRadius(AndroidUtilities.dp(16f))
					}
					else {
						pinnedMessageImageView[1]?.setRoundRadius(AndroidUtilities.dp(2f))
					}

					pinnedImageSize = size
					pinnedImageCacheType = cacheType
					pinnedImageLocation = photoSize
					pinnedImageThumbLocation = thumbPhotoSize
					pinnedImageLocationObject = photoSizeObject

					pinnedMessageImageView[1]?.setImage(ImageLocation.getForObject(pinnedImageLocation, photoSizeObject), "50_50", ImageLocation.getForObject(thumbPhotoSize, photoSizeObject), "50_50_b", null, size.toLong(), cacheType, pinnedMessageObject)
					pinnedMessageImageView[1]?.visible()

					if (animateToNext != 0) {
						pinnedMessageImageView[1]?.alpha = 0.0f
					}

					layoutParams5.leftMargin = AndroidUtilities.dp(55f)
					layoutParams4.leftMargin = layoutParams5.leftMargin
					layoutParams3.leftMargin = layoutParams4.leftMargin
					layoutParams2.leftMargin = layoutParams3.leftMargin
					layoutParams1.leftMargin = layoutParams2.leftMargin
				}

				pinnedNameTextView[0]?.layoutParams = layoutParams1
				pinnedNameTextView[1]?.layoutParams = layoutParams2

				pinnedCounterTextView?.layoutParams = layoutParams3

				pinnedMessageTextView[0]?.layoutParams = layoutParams4
				pinnedMessageTextView[1]?.layoutParams = layoutParams5

				var showCounter = false
				var shouldAnimateName = loadedPinnedMessagesCount == 2 || !pinnedNameTextView[if (animateToNext != 0) 0 else 1]!!.trackWidth
				pinnedNameTextView[if (animateToNext != 0) 0 else 1]?.trackWidth = false

				nameTextView?.trackWidth = true
				nameTextView?.visible()

				if (threadId != 0) {
					val messagesController = messagesController
					val fwd_from = threadMessage?.messageOwner?.fwd_from
					var user: User? = null
					var chat: Chat? = null

					if (fwd_from?.saved_from_peer != null) {
						if (fwd_from.saved_from_peer.user_id != 0L) {
							user = if (fwd_from.from_id is TL_peerUser) {
								messagesController.getUser(fwd_from.from_id.user_id)
							}
							else {
								messagesController.getUser(fwd_from.saved_from_peer.user_id)
							}
						}
						else if (fwd_from.saved_from_peer.channel_id != 0L) {
							if (threadMessage!!.isSavedFromMegagroup && fwd_from.from_id is TL_peerUser) {
								user = messagesController.getUser(fwd_from.from_id.user_id)
							}
							else {
								chat = messagesController.getChat(fwd_from.saved_from_peer.channel_id)
							}
						}
						else if (fwd_from.saved_from_peer.chat_id != 0L) {
							when (fwd_from.from_id) {
								is TL_peerUser -> user = messagesController.getUser(fwd_from.from_id.user_id)
								is TL_peerChat -> chat = messagesController.getChat(fwd_from.from_id.chat_id)
								is TL_peerChannel -> chat = messagesController.getChat(fwd_from.from_id.channel_id)
								else -> chat = messagesController.getChat(fwd_from.saved_from_peer.chat_id)
							}
						}
					}
					else if (threadMessage?.isFromUser == true) {
						user = messagesController.getUser(threadMessage?.messageOwner?.from_id?.user_id)
					}
					else if (threadMessage?.messageOwner?.from_id is TL_peerChannel) {
						chat = messagesController.getChat(threadMessage?.messageOwner?.from_id?.channel_id)
					}
					else if (threadMessage?.messageOwner?.from_id is TL_peerChat) {
						chat = messagesController.getChat(threadMessage?.messageOwner?.from_id?.chat_id)
					}
					else if (threadMessage?.messageOwner?.post == true) {
						chat = messagesController.getChat(threadMessage?.messageOwner?.peer_id?.channel_id)
					}

					if (user != null) {
						nameTextView?.setText(formatName(user.first_name, user.last_name))
					}
					else if (chat != null) {
						nameTextView?.setText(chat.title)
					}
				}
				else {
					if (pinnedMessageObject.isInvoice && pinnedMessageObject.messageOwner?.media?.title != null) {
						nameTextView?.trackWidth = false
						nameTextView?.setText(pinnedMessageObject.messageOwner?.media?.title)

						shouldAnimateName = true
						showCounter = false
					}
					else {
						if (currentPinnedMessageIndex[0] == 0 || loadedPinnedMessagesCount != 2) {
							nameTextView?.setText(context!!.getString(R.string.PinnedMessage), true)
						}
						else {
							nameTextView?.setText(context!!.getString(R.string.PreviousPinnedMessage), true)
						}

						if (currentPinnedMessageIndex[0] != 0) {
							val total = pinnedMessagesCount
							pinnedCounterTextView!!.setNumber(min(total - 1, max(1, total - currentPinnedMessageIndex[0])), animated && pinnedCounterTextView!!.tag == null)
							showCounter = true
						}
					}
				}

				var pinnedText: CharSequence? = null

				if (pinnedMessageObject.type == MessageObject.TYPE_MUSIC) {
					pinnedText = String.format("%s - %s", pinnedMessageObject.musicAuthor, pinnedMessageObject.musicTitle)
				}
				else if (pinnedMessageObject.type == MessageObject.TYPE_POLL) {
					val poll = pinnedMessageObject.messageOwner?.media as? TL_messageMediaPoll
					var mess = poll?.poll?.question ?: ""

					if (mess.length > 150) {
						mess = mess.substring(0, 150)
					}

					mess = mess.replace('\n', ' ')
					pinnedText = mess
				}
				else if (pinnedMessageObject.messageOwner?.media is TL_messageMediaGame) {
					pinnedText = Emoji.replaceEmoji(pinnedMessageObject.messageOwner?.media?.game?.title, messageTextView?.paint?.fontMetricsInt, false)
				}
				else if (!TextUtils.isEmpty(pinnedMessageObject.caption)) {
					var mess = pinnedMessageObject.caption.toString()
					if (mess.length > 150) {
						mess = mess.substring(0, 150)
					}

					mess = mess.replace('\n', ' ')

					var message: CharSequence? = mess

					if (pinnedMessageObject.messageOwner != null) {
						message = MessageObject.replaceAnimatedEmoji(mess, pinnedMessageObject.messageOwner?.entities, messageTextView?.paint?.fontMetricsInt)
					}

					pinnedText = Emoji.replaceEmoji(message, messageTextView?.paint?.fontMetricsInt, false)
				}
				else if (pinnedMessageObject.messageText != null) {
					var mess = pinnedMessageObject.messageText.toString()

					if (mess.length > 150) {
						mess = mess.substring(0, 150)
					}

					mess = mess.replace('\n', ' ')

					var message: CharSequence? = mess

					if (pinnedMessageObject.messageOwner != null) {
						message = MessageObject.replaceAnimatedEmoji(mess, pinnedMessageObject.messageOwner?.entities, messageTextView?.paint?.fontMetricsInt)
					}

					pinnedText = Emoji.replaceEmoji(message, messageTextView?.paint?.fontMetricsInt, false)
				}
				if (pinnedText != null) {
					if (pinnedText is Spannable) {
						MediaDataController.addTextStyleRuns(pinnedMessageObject, pinnedText, TextStyleSpan.FLAG_STYLE_SPOILER or TextStyleSpan.FLAG_STYLE_STRIKE)
					}

					messageTextView?.setText(AnimatedEmojiSpan.cloneSpans(pinnedText))
				}

				if (animateToNext != 0) {
					pinnedNextAnimation[0] = AnimatorSet()
					pinnedNextAnimation[1] = AnimatorSet()

					val animators = mutableListOf<Animator>()
					val animators2 = mutableListOf<Animator>()

					messageTextView?.visibility = View.VISIBLE
					nameTextView?.visibility = View.VISIBLE

					if (botButton != null) {
						buttonTextView?.visibility = View.VISIBLE
					}

					if (!showCounter) {
						if (pinnedCounterTextView?.tag == null) {

							animators.add(ObjectAnimator.ofFloat(pinnedCounterTextView, View.ALPHA, 1.0f, 0.0f))
							animators.add(ObjectAnimator.ofFloat(pinnedCounterTextView, View.TRANSLATION_Y, 0.0f, -AndroidUtilities.dp(4f).toFloat()))

							pinnedCounterTextView?.tag = 1
						}
					}
					else {
						if (pinnedCounterTextView?.tag != null) {
							pinnedCounterTextView?.visibility = View.VISIBLE
							pinnedCounterTextView?.alpha = 0.0f

							animators.add(ObjectAnimator.ofFloat(pinnedCounterTextView, View.ALPHA, 0.0f, 1.0f))
							animators.add(ObjectAnimator.ofFloat(pinnedCounterTextView, View.TRANSLATION_Y, -AndroidUtilities.dp(4f).toFloat(), 0f))

							pinnedCounterTextView?.tag = null
						}
					}

					var animateName: Boolean

					if (shouldAnimateName && !TextUtils.equals(nameTextView?.getText(), pinnedNameTextView[0]!!.getText())) {
						nameTextView?.alpha = 0f

						animators.add(ObjectAnimator.ofFloat(nameTextView, View.ALPHA, 0.0f, 1.0f))
						animators.add(ObjectAnimator.ofFloat(pinnedNameTextView[0], View.ALPHA, 1.0f, 0.0f))
						animators.add(ObjectAnimator.ofFloat(nameTextView, View.TRANSLATION_Y, AndroidUtilities.dp((if (animateToNext == 2) 4 else -4).toFloat()).toFloat(), 0.0f))

						if ((forceScrollToFirst && loadedPinnedMessagesCount > 5).also { animateName = it }) {
							animators2.add(ObjectAnimator.ofFloat(nameTextView, View.TRANSLATION_Y, AndroidUtilities.dp(4f).toFloat(), AndroidUtilities.dp(-2f).toFloat()))
						}
						else {
							animators.add(ObjectAnimator.ofFloat(nameTextView, View.TRANSLATION_Y, AndroidUtilities.dp((if (animateToNext == 2) 4 else -4).toFloat()).toFloat(), 0.0f))
						}

						animators.add(ObjectAnimator.ofFloat(pinnedNameTextView[0], View.TRANSLATION_Y, 0.0f, AndroidUtilities.dp((if (animateToNext == 2) -4 else 4).toFloat()).toFloat()))
					}
					else {
						animateName = false

						if (nameTextView !== pinnedNameTextView[0]) {
							nameTextView?.alpha = 1.0f
							pinnedNameTextView[0]!!.alpha = 0.0f
							nameTextView?.translationY = 0.0f
							pinnedNameTextView[0]!!.translationY = 0.0f
						}
						else {
							nameTextView?.alpha = 1.0f
							nameTextView?.translationY = 0.0f
							pinnedNameTextView[1]!!.translationY = 0.0f
							pinnedNameTextView[1]!!.alpha = 0.0f
						}
					}

					var animateText: Boolean

					if (!TextUtils.equals(messageTextView?.getText(), pinnedMessageTextView[0]!!.getText())) {
						messageTextView?.alpha = 0f

						animators.add(ObjectAnimator.ofFloat(messageTextView, View.ALPHA, 0.0f, 1.0f))
						animators.add(ObjectAnimator.ofFloat(pinnedMessageTextView[0], View.ALPHA, 1.0f, 0.0f))

						if ((forceScrollToFirst && loadedPinnedMessagesCount > 5).also { animateText = it }) {
							animators2.add(ObjectAnimator.ofFloat(messageTextView, View.TRANSLATION_Y, AndroidUtilities.dp(4f).toFloat(), AndroidUtilities.dp(-2f).toFloat()))
						}
						else {
							animators.add(ObjectAnimator.ofFloat(messageTextView, View.TRANSLATION_Y, AndroidUtilities.dp((if (animateToNext == 2) 4 else -4).toFloat()).toFloat(), 0.0f))
						}

						animators.add(ObjectAnimator.ofFloat(pinnedMessageTextView[0], View.TRANSLATION_Y, 0.0f, AndroidUtilities.dp((if (animateToNext == 2) -4 else 4).toFloat()).toFloat()))
					}
					else {
						animateText = false
						messageTextView?.alpha = 1.0f
						pinnedMessageTextView[0]!!.alpha = 0.0f
						messageTextView?.translationY = 0.0f
						pinnedMessageTextView[0]!!.translationY = 0.0f
					}

					var animateButton: Boolean

					if (!TextUtils.equals(buttonTextView?.text, pinnedMessageButton[0]!!.text)) {
						buttonTextView?.alpha = 0f

						animators.add(ObjectAnimator.ofFloat(buttonTextView, View.ALPHA, 0.0f, 1.0f))
						animators.add(ObjectAnimator.ofFloat(pinnedMessageButton[0], View.ALPHA, 1.0f, 0.0f))

						if ((forceScrollToFirst && loadedPinnedMessagesCount > 5).also { animateButton = it }) {
							animators2.add(ObjectAnimator.ofFloat(buttonTextView, View.TRANSLATION_Y, AndroidUtilities.dp(4f).toFloat(), AndroidUtilities.dp(-2f).toFloat()))
						}
						else {
							animators.add(ObjectAnimator.ofFloat(buttonTextView, View.TRANSLATION_Y, AndroidUtilities.dp((if (animateToNext == 2) 4 else -4).toFloat()).toFloat(), 0.0f))
						}

						animators.add(ObjectAnimator.ofFloat(pinnedMessageButton[0], View.TRANSLATION_Y, 0.0f, AndroidUtilities.dp((if (animateToNext == 2) -4 else 4).toFloat()).toFloat()))
					}
					else {
						animateButton = false
						buttonTextView?.alpha = 1.0f
						pinnedMessageButton[0]!!.alpha = 0.0f
						buttonTextView?.translationY = 0.0f
						pinnedMessageButton[0]!!.translationY = 0.0f
					}

					val animateImage: BackupImageView?

					if (layoutParams1.leftMargin != prevMargin) {
						animateImage = null

						setPinnedTextTranslationX = true

						val diff = prevMargin - layoutParams1.leftMargin
						animators.add(ObjectAnimator.ofFloat(pinnedMessageTextView[0], View.TRANSLATION_X, diff.toFloat(), 0.0f))
						animators.add(ObjectAnimator.ofFloat(pinnedMessageTextView[1], View.TRANSLATION_X, diff.toFloat(), 0.0f))
						animators.add(ObjectAnimator.ofFloat(pinnedNameTextView[0], View.TRANSLATION_X, diff.toFloat(), 0.0f))
						animators.add(ObjectAnimator.ofFloat(pinnedNameTextView[1], View.TRANSLATION_X, diff.toFloat(), 0.0f))
						// animators.add(ObjectAnimator.ofFloat(pinnedMessageButton[0], View.TRANSLATION_X, diff, 0.0f));
						// animators.add(ObjectAnimator.ofFloat(pinnedMessageButton[1], View.TRANSLATION_X, diff, 0.0f));

						animators.add(ObjectAnimator.ofFloat(pinnedCounterTextView, View.TRANSLATION_X, (pinnedCounterTextViewX + diff).toFloat(), pinnedCounterTextViewX.toFloat()))

						if (diff > 0) {
							pinnedMessageImageView[0]!!.alpha = 1f
							animators.add(ObjectAnimator.ofFloat(pinnedMessageImageView[0], View.ALPHA, 1.0f, 0.0f))
							animators.add(ObjectAnimator.ofFloat(pinnedMessageImageView[0], View.SCALE_X, 1.0f, 0.7f))
							animators.add(ObjectAnimator.ofFloat(pinnedMessageImageView[0], View.SCALE_Y, 1.0f, 0.7f))
						}
						else {
							animators.add(ObjectAnimator.ofFloat(pinnedMessageImageView[1], View.ALPHA, 0.0f, 1.0f))
							animators.add(ObjectAnimator.ofFloat(pinnedMessageImageView[1], View.SCALE_X, 0.7f, 1.0f))
							animators.add(ObjectAnimator.ofFloat(pinnedMessageImageView[1], View.SCALE_Y, 0.7f, 1.0f))
						}
					}
					else {
						setPinnedTextTranslationX = false
						messageTextView?.translationX = 0f
						pinnedMessageTextView[0]!!.translationX = 0f
						nameTextView?.translationX = 0f
						pinnedNameTextView[0]!!.translationX = 0f
						buttonTextView?.translationX = 0f
						pinnedMessageButton[0]!!.translationX = 0f
						pinnedCounterTextView!!.translationX = pinnedCounterTextViewX.toFloat()
						pinnedMessageImageView[1]!!.alpha = 1.0f

						if (!noImage) {
							animators.add(ObjectAnimator.ofFloat(pinnedMessageImageView[1], View.ALPHA, 0.0f, 1.0f))
							animators.add(ObjectAnimator.ofFloat(pinnedMessageImageView[0], View.ALPHA, 1.0f, 0.0f))

							if (forceScrollToFirst && loadedPinnedMessagesCount > 5) {
								animateImage = pinnedMessageImageView[1]
								animators2.add(ObjectAnimator.ofFloat(pinnedMessageImageView[1], View.TRANSLATION_Y, AndroidUtilities.dp(3f).toFloat(), AndroidUtilities.dp(-2f).toFloat()))
							}
							else {
								animateImage = null
								animators.add(ObjectAnimator.ofFloat(pinnedMessageImageView[1], View.TRANSLATION_Y, AndroidUtilities.dp((if (animateToNext == 2) 3 else -3).toFloat()).toFloat(), 0.0f))
							}

							animators.add(ObjectAnimator.ofFloat(pinnedMessageImageView[0], View.TRANSLATION_Y, 0.0f, AndroidUtilities.dp((if (animateToNext == 2) -3 else 3).toFloat()).toFloat()))
						}
						else {
							animateImage = null
						}
					}

					pinnedNextAnimation[1]?.addListener(object : AnimatorListenerAdapter() {
						override fun onAnimationCancel(animation: Animator) {
							pinnedNextAnimation[1] = null
							pinnedMessageImageView[1]!!.translationY = 0f
						}

						override fun onAnimationEnd(animation: Animator) {
							if (animation == pinnedNextAnimation[1]) {
								if (animateName || animateText || animateImage != null) {
									pinnedNextAnimation[1] = AnimatorSet()
									pinnedNextAnimation[1]!!.interpolator = CubicBezierInterpolator.EASE_OUT_QUINT
									pinnedNextAnimation[1]!!.duration = (180 * 2).toLong()

									val animators1 = mutableListOf<Animator>()

									if (animateName) {
										animators1.add(ObjectAnimator.ofFloat(nameTextView, View.TRANSLATION_Y, 0.0f))
									}

									if (animateText) {
										animators1.add(ObjectAnimator.ofFloat(messageTextView, View.TRANSLATION_Y, 0.0f))
									}

									if (animateButton) {
										animators1.add(ObjectAnimator.ofFloat(buttonTextView, View.TRANSLATION_Y, 0.0f))
									}

									if (animateImage != null) {
										animators1.add(ObjectAnimator.ofFloat(animateImage, View.TRANSLATION_Y, 0.0f))
									}

									pinnedNextAnimation[1]!!.addListener(object : AnimatorListenerAdapter() {
										override fun onAnimationEnd(animation: Animator) {
											if (animateName) {
												nameTextView?.translationY = 0.0f
											}
											if (animateText) {
												messageTextView?.translationY = 0.0f
											}
											if (animateButton) {
												buttonTextView?.translationY = 0.0f
											}

											animateImage?.translationY = 0.0f

											pinnedNextAnimation[1] = null
										}
									})

									pinnedNextAnimation[1]?.playTogether(animators1)
									pinnedNextAnimation[1]?.start()
								}
								else {
									pinnedNextAnimation[1] = null
								}
							}
						}
					})

					pinnedNextAnimation[1]?.duration = (180 * 2).toLong()
					//                    if (forceScrollToFirst && loadedPinnedMessagesCount > 5) {
					pinnedNextAnimation[1]?.interpolator = CubicBezierInterpolator.EASE_OUT_QUINT
					//                    }
					pinnedNextAnimation[1]?.playTogether(animators2)

					pinnedNextAnimation[0]?.playTogether(animators)

					pinnedNextAnimation[0]?.addListener(object : AnimatorListenerAdapter() {
						override fun onAnimationEnd(animation: Animator) {
							if (pinnedCounterTextView?.tag != null) {
								pinnedCounterTextView?.visibility = View.INVISIBLE
								val total: Int = pinnedMessagesCount
								pinnedCounterTextView?.setNumber(min(total - 1, max(1, total - currentPinnedMessageIndex[0])), false)
							}
							else {
								pinnedCounterTextView?.alpha = 1.0f
							}

							pinnedCounterTextView?.translationY = 0.0f

							pinnedMessageTextView[0]!!.translationX = 0f
							pinnedMessageTextView[1]!!.translationX = 0f

							pinnedCounterTextView!!.translationX = pinnedCounterTextViewX.toFloat()

							nameTextView?.translationY = 0.0f

							if (!animateText) {
								nameTextView?.translationY = 0.0f
							}

							if (!animateText) {
								messageTextView?.translationY = 0.0f
							}

							if (!animateButton) {
								buttonTextView?.translationY = 0.0f
							}

							pinnedNameTextView[0]!!.translationX = 0f
							pinnedNameTextView[1]!!.translationX = 0f

							pinnedMessageImageView[1]!!.alpha = 1.0f
							pinnedMessageImageView[1]!!.scaleX = 1f
							pinnedMessageImageView[1]!!.scaleY = 1f
							pinnedMessageImageView[0]!!.alpha = 1.0f
							pinnedMessageImageView[0]!!.scaleX = 1f
							pinnedMessageImageView[0]!!.scaleY = 1f

							pinnedMessageTextView[1] = pinnedMessageTextView[0]
							pinnedMessageTextView[0] = messageTextView
							pinnedMessageTextView[1]!!.visibility = View.INVISIBLE

							pinnedMessageButton[1] = pinnedMessageButton[0]
							pinnedMessageButton[0] = buttonTextView
							pinnedMessageButton[1]!!.visibility = View.INVISIBLE

							if (nameTextView !== pinnedNameTextView[0]) {
								pinnedNameTextView[1] = pinnedNameTextView[0]
								pinnedNameTextView[0] = nameTextView
								pinnedNameTextView[1]!!.visibility = View.INVISIBLE
							}

							if (noImage) {
								pinnedMessageImageView[1]!!.setImageBitmap(null)
								pinnedMessageImageView[1]!!.visibility = View.INVISIBLE
							}

							val backupImageView = pinnedMessageImageView[1]

							pinnedMessageImageView[1] = pinnedMessageImageView[0]
							pinnedMessageImageView[0] = backupImageView
							pinnedMessageImageView[1]!!.alpha = 1.0f
							pinnedMessageImageView[1]!!.scaleX = 1f
							pinnedMessageImageView[1]!!.scaleY = 1f
							pinnedMessageImageView[1]!!.visibility = View.INVISIBLE

							pinnedNextAnimation[0] = null

							setPinnedTextTranslationX = false
						}
					})

					pinnedNextAnimation[0]!!.interpolator = CubicBezierInterpolator.EASE_OUT_QUINT
					pinnedNextAnimation[0]!!.duration = (180 * 2).toLong()

					if (!setPinnedTextTranslationX) {
						pinnedNextAnimation[0]!!.start()
						pinnedNextAnimation[1]!!.start()
					}
				}
				else {
					if (!showCounter || currentPinnedMessageIndex[0] == 0) {
						if (pinnedCounterTextView!!.tag == null) {
							pinnedCounterTextView!!.alpha = 0.0f
							pinnedCounterTextView!!.visibility = View.INVISIBLE
							pinnedCounterTextView!!.tag = 1
						}
					}
					else {
						if (pinnedCounterTextView!!.tag != null) {
							pinnedCounterTextView!!.visibility = View.VISIBLE
							pinnedCounterTextView!!.alpha = 1.0f
							pinnedCounterTextView!!.tag = null
						}
					}

					pinnedCounterTextView!!.translationY = 0.0f
					pinnedCounterTextView!!.translationX = pinnedCounterTextViewX.toFloat()
					pinnedCounterTextView!!.alpha = if (shouldAnimateName || currentPinnedMessageIndex[0] == 0) 0.0f else 1.0f

					messageTextView?.visibility = View.VISIBLE
					messageTextView?.alpha = 1.0f
					messageTextView?.translationX = 0f
					messageTextView?.translationY = 0f

					nameTextView?.visibility = View.VISIBLE
					nameTextView?.alpha = 1.0f
					nameTextView?.translationX = 0f
					nameTextView?.translationY = 0f

					pinnedMessageTextView[1]!!.visibility = View.INVISIBLE
					pinnedMessageTextView[1]!!.translationX = 0f
					pinnedMessageTextView[1]!!.translationY = 0f

					pinnedMessageButton[1]!!.visibility = View.INVISIBLE
					pinnedMessageButton[1]!!.translationX = 0f
					pinnedMessageButton[1]!!.translationY = 0f

					pinnedNameTextView[1]!!.visibility = View.INVISIBLE
					pinnedNameTextView[1]!!.translationX = 0f
					pinnedNameTextView[1]!!.translationY = 0f

					pinnedMessageImageView[0]!!.visibility = View.INVISIBLE

					val backupImageView = pinnedMessageImageView[1]

					pinnedMessageImageView[1] = pinnedMessageImageView[0]
					pinnedMessageImageView[0] = backupImageView
					pinnedMessageImageView[0]!!.alpha = 1.0f
					pinnedMessageImageView[0]!!.scaleX = 1f
					pinnedMessageImageView[0]!!.scaleY = 1f
					pinnedMessageImageView[0]!!.translationY = 0f
					pinnedMessageImageView[1]!!.alpha = 1.0f
					pinnedMessageImageView[1]!!.scaleX = 1f
					pinnedMessageImageView[1]!!.scaleY = 1f
					pinnedMessageImageView[1]!!.translationY = 0f
				}

				if (isThreadChat) {
					pinnedLineView!![0, 1] = false
				}
				else {
					val position = Collections.binarySearch(pinnedMessageIds, currentPinnedMessageId, Comparator.reverseOrder())
					pinnedLineView!![pinnedMessageIds.size - 1 - position, pinnedMessageIds.size] = animated
				}
			}
			else {
				pinnedCounterTextView!!.visibility = if (loadedPinnedMessagesCount == 2 || currentPinnedMessageIndex[0] == 0) View.INVISIBLE else View.VISIBLE
				pinnedCounterTextView!!.alpha = if (loadedPinnedMessagesCount == 2 || currentPinnedMessageIndex[0] == 0) 0.0f else 1.0f
				pinnedImageLocation = null
				pinnedImageLocationObject = null

				changed = hidePinnedMessageView(animated)

				if (loadingPinnedMessages.indexOfKey(pinned_msg_id) < 0) {
					loadingPinnedMessages.put(pinned_msg_id, true)
					val ids = mutableListOf<Int>()
					ids.add(pinned_msg_id)
					mediaDataController.loadPinnedMessages(dialogId, if (isChannel(currentChat)) currentChat!!.id else 0, ids, true)
				}
			}
		}

		if (changed) {
			checkListViewPaddings()
		}
	}

	private fun updateTopPanel(animated: Boolean) {
		if (topChatPanelView == null || chatMode != 0) {
			return
		}

		val context = context ?: return
		val preferences = MessagesController.getNotificationsSettings(currentAccount)
		var show: Boolean
		var did = dialogId
		var showAiFreeRequests = false

		if ((isAiBot()) && !chatBotController.userSettingsUpdated) {
			showAiFreeRequests = (chatBotController.lastSubscriptionInfo?.realState ?: ElloRpc.SubscriptionInfoAiBotState.NONE) != ElloRpc.SubscriptionInfoAiBotState.NONE
			show = showAiFreeRequests
		}
		else if (currentEncryptedChat != null) {
			show = !(currentEncryptedChat!!.admin_id == userConfig.getClientUserId() || contactsController.isLoadingContacts()) && contactsController.contactsDict[currentUser!!.id] == null
			did = currentUser!!.id

			val vis = preferences.getInt("dialog_bar_vis3$did", 0)

			if (show && (vis == 1 || vis == 3)) {
				show = false
			}
		}
		else {
			show = preferences.getInt("dialog_bar_vis3$did", 0) == 2
		}

		val showShare = preferences.getBoolean("dialog_bar_share$did", false)
		val showReport = preferences.getBoolean("dialog_bar_report$did", false)
		val showBlock = preferences.getBoolean("dialog_bar_block$did", false)
		val showAdd = preferences.getBoolean("dialog_bar_add$did", false)
		val showArchive = preferences.getBoolean("dialog_bar_archived$dialogId", false)
		val showGeo = preferences.getBoolean("dialog_bar_location$did", false)
		val chatWithAdmin = preferences.getString("dialog_bar_chat_with_admin_title$did", null)
		val chatWithAdminChannel = preferences.getBoolean("dialog_bar_chat_with_channel$did", false)
		val chatWithAdminDate = preferences.getInt("dialog_bar_chat_with_date$did", 0)
		val showAddMembersToGroup = preferences.getBoolean("dialog_bar_invite$did", false)
		val showEmojiStatusReport = if (currentUser != null && (showReport || showBlock) && (currentUser!!.emoji_status is TL_emojiStatus || currentUser!!.emoji_status is TL_emojiStatusUntil && (currentUser!!.emoji_status as TL_emojiStatusUntil?)!!.until > (System.currentTimeMillis() / 1000).toInt())) currentUser!!.emoji_status else null

		if (showReport || showBlock || showGeo) {
			reportSpamButton?.visibility = View.VISIBLE
		}
		else {
			reportSpamButton?.visibility = View.GONE
		}

		addToContactsButtonArchive = false

		val user = if (currentUser != null) messagesController.getUser(currentUser!!.id) else null
		var isChatWithAdmin = false

		if (user != null && !TextUtils.isEmpty(chatWithAdmin)) {
			isChatWithAdmin = true
			if (chatWithAdminTextView == null) {
				chatWithAdminTextView = TextView(topChatPanelView!!.context)
				chatWithAdminTextView?.gravity = Gravity.CENTER_VERTICAL
				chatWithAdminTextView?.setPadding(AndroidUtilities.dp(14f), 0, AndroidUtilities.dp(46f), 0)
				chatWithAdminTextView?.background = Theme.createSelectorDrawable(context.getColor(R.color.light_background), 2)

				topChatPanelView?.addView(chatWithAdminTextView, 0, createFrame(LayoutHelper.MATCH_PARENT, 48f, 0, 0f, 0f, 0f, 1f))

				chatWithAdminTextView?.setTextColor(topChatPanelView!!.context.getColor(R.color.text))
				chatWithAdminTextView?.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14f)

				chatWithAdminTextView?.setOnClickListener {
					AlertsCreator.showChatWithAdmin(this@ChatActivity, chatWithAdmin, chatWithAdminChannel, chatWithAdminDate)
				}
			}

			val str = if (chatWithAdminChannel) {
				LocaleController.formatString("ChatWithGroupAdmin", R.string.ChatWithGroupAdmin, user.first_name, chatWithAdmin)
			}
			else {
				LocaleController.formatString("ChatWithChannelAdmin", R.string.ChatWithChannelAdmin, user.first_name, chatWithAdmin)
			}

			reportSpamButton?.gone()
			addToContactsButton?.gone()
			chatWithAdminTextView?.text = AndroidUtilities.replaceTags(str)
		}
		else if (showAddMembersToGroup) {
			addToContactsButton?.visibility = View.VISIBLE
			addToContactsButton?.text = context.getString(R.string.GroupAddMembers).uppercase()
			addToContactsButton?.tag = 4
			addToContactsButton?.setTextColor(context.getColor(R.color.brand))

			Theme.setSelectorDrawableColor(addToContactsButton!!.background, context.getColor(R.color.brand) and 0x19ffffff, true)
		}
		else if (user != null) {
			if (isReplyUser(user)) {
				addToContactsButton?.visibility = View.GONE
			}
			else if (!user.contact && !user.self && showAdd) {
				addContactItem?.visibility = View.VISIBLE
				addContactItem?.setText(context.getString(R.string.AddToContacts))

				addToContactsButton?.visibility = View.VISIBLE

				if (showArchive) {
					addToContactsButtonArchive = true

					addToContactsButton?.text = context.getString(R.string.Unarchive).uppercase(Locale.getDefault())
					addToContactsButton?.tag = 3
				}
				else {
					if (reportSpamButton?.visibility == View.VISIBLE) {
						addToContactsButton?.text = context.getString(R.string.AddContactChat)
					}
					else {
						addToContactsButton?.text = LocaleController.formatString("AddContactFullChat", R.string.AddContactFullChat, getFirstName(user)).uppercase(Locale.getDefault())
					}
				}

				addToContactsButton?.tag = null
				addToContactsButton?.visibility = View.VISIBLE
			}
			else if (showShare && !user.self) {
				addContactItem?.visibility = View.VISIBLE

				addToContactsButton?.visibility = View.VISIBLE

				addContactItem?.setText(context.getString(R.string.ShareMyContactInfo))

				addToContactsButton?.text = context.getString(R.string.ShareMyPhone).uppercase(Locale.getDefault())
				addToContactsButton?.tag = 1
				addToContactsButton?.visibility = View.VISIBLE
			}
			else {
				// MARK: disabled ability to share contact (because we do not have phone numbers)
//				if (!user.contact && !user.self && !show) {
//					addContactItem.setVisibility(View.VISIBLE);
//					addContactItem.setText(getContext().getString(R.string.ShareMyContactInfo));
//					addToContactsButton.setTag(2);
//				}
//				else {

				addContactItem?.visibility = View.GONE

				//				}

				addToContactsButton?.visibility = View.GONE
			}

			reportSpamButton?.text = context.getString(R.string.ReportSpamUser)
		}
		else {
			if (showGeo) {
				reportSpamButton?.text = context.getString(R.string.ReportSpamLocation)
				reportSpamButton?.setTag(R.id.object_tag, 1)
				reportSpamButton?.setTextColor(context.getColor(R.color.brand))

				Theme.setSelectorDrawableColor(reportSpamButton!!.background, context.getColor(R.color.brand) and 0x19ffffff, true)
			}
			else {
				if (showArchive) {
					addToContactsButtonArchive = true

					addToContactsButton?.text = context.getString(R.string.Unarchive).uppercase(Locale.getDefault())
					addToContactsButton?.tag = 3
					addToContactsButton?.visibility = View.VISIBLE

					reportSpamButton?.text = context.getString(R.string.ReportSpam)
				}
				else {
					addToContactsButton?.visibility = View.GONE
					reportSpamButton?.text = context.getString(R.string.ReportSpamAndLeave)
				}

				reportSpamButton?.setTag(R.id.object_tag, null)
				reportSpamButton?.setTextColor(context.getColor(R.color.brand))

				Theme.setSelectorDrawableColor(reportSpamButton!!.background, context.getColor(R.color.brand) and 0x19ffffff, true)
			}

			addContactItem?.visibility = View.GONE
		}

		chatWithAdminTextView?.visibility = if (isChatWithAdmin) View.VISIBLE else View.GONE

		if (!showAiFreeRequests && (userBlocked || addToContactsButton!!.visibility == View.GONE && reportSpamButton!!.visibility == View.GONE && (chatWithAdminTextView == null || chatWithAdminTextView!!.visibility == View.GONE))) {
			show = false
		}

		var topChatPanelHeight: Int

		if (showEmojiStatusReport != null) {
			emojiStatusSpamHint?.visibility = View.VISIBLE
			topViewSeparator1?.visibility = View.VISIBLE
			topViewSeparator2?.visibility = View.VISIBLE

			val text = SpannableStringBuilder(context.getString(R.string.ReportSpamUserEmojiStatusHint))
			val emoji = SpannableString("d")
			var docid: Long? = null

			if (currentUser!!.emoji_status is TL_emojiStatus) {
				docid = (currentUser!!.emoji_status as TL_emojiStatus?)!!.document_id
			}
			else if (currentUser!!.emoji_status is TL_emojiStatusUntil && (currentUser!!.emoji_status as TL_emojiStatusUntil?)!!.until > (System.currentTimeMillis() / 1000).toInt()) {
				docid = (currentUser!!.emoji_status as TL_emojiStatusUntil?)!!.document_id
			}

			if (docid != null) {
				val span = AnimatedEmojiSpan(docid, emojiStatusSpamHint!!.paint.fontMetricsInt)
				span.full = false
				emoji.setSpan(span, 0, emoji.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
			}

			val link = SpannableString(context.getString(R.string.TelegramPremium))

			link.setSpan(object : ClickableSpan() {
				override fun onClick(view: View) {
					presentFragment(PremiumPreviewFragment(null))
				}

				override fun updateDrawState(ds: TextPaint) {
					super.updateDrawState(ds)
					ds.isUnderlineText = false
				}
			}, 0, link.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

			var i = text.toString().indexOf("%1\$s")

			if (i >= 0) {
				text.replace(i, i + 4, emoji)
			}

			i = text.toString().indexOf("%2\$s")

			if (i >= 0) {
				text.replace(i, i + 4, link)
			}

			emojiStatusSpamHint?.text = text
			emojiStatusSpamHint?.measure(MeasureSpec.makeMeasureSpec(AndroidUtilities.displaySize.x - AndroidUtilities.dp(70f), MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec(99999, MeasureSpec.AT_MOST))

			topChatPanelHeight = AndroidUtilities.dp((50 + 16).toFloat()) + emojiStatusSpamHint!!.measuredHeight
		}
		else {
			emojiStatusSpamHint?.visibility = View.GONE
			topViewSeparator1?.visibility = View.GONE
			topViewSeparator2?.visibility = View.GONE

			topChatPanelHeight = AndroidUtilities.dp(50f)
		}

		topChatPanelView?.layoutParams?.height = topChatPanelHeight

		if (showAiFreeRequests) {
			topChatPanelHeight = AndroidUtilities.dp(46f)

			botTopViewContainer?.visibility = View.VISIBLE

			val lastResponse = chatBotController.lastSubscriptionInfo

			if (lastResponse != null) {
				var promptsLeft = 0
				var type: String? = null

				when (lastResponse.realState) {
					ElloRpc.SubscriptionInfoAiBotState.TEXT -> {
						promptsLeft = lastResponse.textTotal
						type = context.getString(R.string.prompt_text)
					}

					ElloRpc.SubscriptionInfoAiBotState.IMAGE -> {
						promptsLeft = lastResponse.imgTotal
						type = context.getString(R.string.prompt_image)
					}

					else -> {
						botTopViewContainer?.gone()
						show = false
					}
				}

				if (show) {
					val topViewText = if (promptsLeft > 0) {
						botFreeBalanceView?.setOnClickListener(null)
						context.getString(R.string.ai_bot_chat_prompts_left, promptsLeft, type, context.resources.getQuantityString(R.plurals.prompts, promptsLeft))
					}
					else {
						botFreeBalanceView?.setOnClickListener {
							presentFragment(AiSubscriptionPlansFragment())
						}

						Html.fromHtml(context.getString(R.string.no_prompts_left, type))
					}

					botFreeBalanceView?.text = topViewText
				}
			}
		}

		if (show) {
			if (topChatPanelView?.tag != null) {
				topChatPanelView?.tag = null
				topChatPanelView?.visibility = View.VISIBLE

				reportSpamViewAnimator?.cancel()
				reportSpamViewAnimator = null

				if (animated) {
					reportSpamViewAnimator = AnimatorSet()

					val animator = ValueAnimator.ofFloat(topChatPanelViewOffset, 0f)

					animator.addUpdateListener {
						topChatPanelViewOffset = it.animatedValue as Float
						invalidateChatListViewTopPadding()
						invalidateMessagesVisiblePart()
					}

					reportSpamViewAnimator?.playTogether(animator)
					reportSpamViewAnimator?.duration = 200

					reportSpamViewAnimator?.addListener(object : AnimatorListenerAdapter() {
						override fun onAnimationEnd(animation: Animator) {
							if (reportSpamViewAnimator != null && reportSpamViewAnimator == animation) {
								reportSpamViewAnimator = null
							}
						}

						override fun onAnimationCancel(animation: Animator) {
							if (reportSpamViewAnimator != null && reportSpamViewAnimator == animation) {
								reportSpamViewAnimator = null
							}
						}
					})

					reportSpamViewAnimator?.start()
				}
				else {
					topChatPanelViewOffset = 0f
					invalidateChatListViewTopPadding()
					invalidateMessagesVisiblePart()
				}
			}
		}
		else {
			if (topChatPanelView?.tag == null) {
				topChatPanelView?.tag = 1

				reportSpamViewAnimator?.cancel()
				reportSpamViewAnimator = null

				if (animated) {
					reportSpamViewAnimator = AnimatorSet()

					val animator = ValueAnimator.ofFloat(topChatPanelViewOffset, -topChatPanelHeight.toFloat())

					animator.addUpdateListener {
						topChatPanelViewOffset = it.animatedValue as Float
						invalidateChatListViewTopPadding()
						invalidateMessagesVisiblePart()
					}

					reportSpamViewAnimator?.playTogether(animator)
					reportSpamViewAnimator?.duration = 200

					reportSpamViewAnimator?.addListener(object : AnimatorListenerAdapter() {
						override fun onAnimationEnd(animation: Animator) {
							if (reportSpamViewAnimator != null && reportSpamViewAnimator == animation) {
								topChatPanelView?.visibility = View.GONE
								reportSpamViewAnimator = null
							}
						}

						override fun onAnimationCancel(animation: Animator) {
							if (reportSpamViewAnimator != null && reportSpamViewAnimator == animation) {
								reportSpamViewAnimator = null
							}
						}
					})

					reportSpamViewAnimator?.start()
				}
				else {
					topChatPanelViewOffset = -topChatPanelHeight.toFloat()
					invalidateChatListViewTopPadding()
					invalidateMessagesVisiblePart()
				}
			}
		}

		checkListViewPaddings()
	}

	fun isAiPromptsDepleted(): Boolean {
		if (!isAiBot()) {
			return false
		}

		val lastSubscriptionInfo = chatBotController.lastSubscriptionInfo

		if (lastSubscriptionInfo != null) {
			var aiPromptsDepleted: String? = null

			val counterLeft = when (lastSubscriptionInfo.realState) {
				ElloRpc.SubscriptionInfoAiBotState.IMAGE -> {
					if (lastSubscriptionInfo.imgTotal <= 0) {
						aiPromptsDepleted = context?.getString(R.string.ai_image_prompt)
					}

					lastSubscriptionInfo.imgTotal
				}

				ElloRpc.SubscriptionInfoAiBotState.TEXT -> {
					if (lastSubscriptionInfo.textTotal <= 0) {
						aiPromptsDepleted = context?.getString(R.string.ai_text_prompt)
					}

					lastSubscriptionInfo.textTotal
				}

				else -> {
					return false
				}
			}

			if (counterLeft <= 0) {
				context?.let {
					val builder = AlertsCreator.createSimpleAlert(it, aiPromptsDepleted)

					builder?.setTitle(null)

					builder?.setTopImage(ResourcesCompat.getDrawable(it.resources, R.drawable.ai_bot_prompts, null)?.mutate()?.apply {
						this.colorFilter = PorterDuffColorFilter(Color.WHITE, PorterDuff.Mode.SRC_IN)
					}, it.getColor(R.color.brand))

					builder?.setPositiveButton(it.getString(R.string.purchase)) { _, _ ->
						presentFragment(AiSubscriptionPlansFragment())
					}

					builder?.setPositiveButtonColor(it.getColor(R.color.purple))

					builder?.setNegativeButton(it.getString(R.string.cancel)) { _, _ ->
						// unused
					}

					builder?.setNegativeButtonColor(it.getColor(R.color.brand))

					builder?.show()
				}

				return true
			}
		}

		return false
	}

	private fun checkListViewPaddings() {
		if (!wasManualScroll && unreadMessageObject != null) {
			val pos = messages.indexOf(unreadMessageObject)

			if (pos >= 0) {
				fixPaddingsInLayout = true
				fragmentView?.requestLayout()
			}
		}
		else {
			if (checkPaddingsRunnable != null) {
				return
			}

			AndroidUtilities.runOnUIThread(Runnable {
				checkPaddingsRunnable = null
				invalidateChatListViewTopPadding()
				invalidateMessagesVisiblePart()
			}.also { checkPaddingsRunnable = it })
		}
	}

	private fun checkRaiseSensors() {
		if (chatActivityEnterView != null && chatActivityEnterView!!.isStickersExpanded) {
			MediaController.getInstance().setAllowStartRecord(false)
		}
		else if (currentChat != null && !canSendMedia(currentChat)) {
			MediaController.getInstance().setAllowStartRecord(false)
		}
		else if (!ApplicationLoader.mainInterfacePaused && (bottomOverlayChat == null || bottomOverlayChat!!.visibility != View.VISIBLE) && (bottomOverlay == null || bottomOverlay!!.visibility != View.VISIBLE) && (searchContainer == null || searchContainer!!.visibility != View.VISIBLE)) {
			MediaController.getInstance().setAllowStartRecord(true)
		}
		else {
			MediaController.getInstance().setAllowStartRecord(false)
		}
	}

	override fun dismissCurrentDialog() {
		if (chatAttachAlert != null && visibleDialog === chatAttachAlert) {
			chatAttachAlert?.photoLayout?.closeCamera(false)
			chatAttachAlert?.dismissInternal()
			chatAttachAlert?.photoLayout?.hideCamera(true)

			return
		}

		super.dismissCurrentDialog()
	}

	override fun setInPreviewMode(value: Boolean) {
		super.setInPreviewMode(value)

		if (currentUser != null && audioCallIconItem != null) {
			val userFull = messagesController.getUserFull(currentUser!!.id)

			if (userFull != null && userFull.phone_calls_available) {
				showAudioCallAsIcon = !inPreviewMode
				audioCallIconItem?.visibility = View.VISIBLE
			}
			else {
				showAudioCallAsIcon = false
				audioCallIconItem?.visibility = View.GONE
			}
		}
		if (avatarContainer != null) {
			avatarContainer?.setOccupyStatusBar(!value)
			avatarContainer?.setTitleExpand(showAudioCallAsIcon)
			avatarContainer?.layoutParams = createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT.toFloat(), Gravity.TOP or Gravity.LEFT, (if (!value) 56 else if (chatMode == MODE_PINNED) 10 else 0).toFloat(), 0f, 40f, 0f)
		}

		chatActivityEnterView?.visibility = if (!value) View.VISIBLE else View.INVISIBLE

		if (actionBar != null) {
			actionBar?.backButtonDrawable = if (!value) ResourcesCompat.getDrawable(context!!.resources, R.drawable.ic_back_arrow, null) else null
			headerItem?.alpha = if (!value) 1.0f else 0.0f
			attachItem?.alpha = if (!value) 1.0f else 0.0f
		}

		if (chatListView != null) {
			val count = chatListView!!.childCount

			for (a in 0 until count) {
				val view = chatListView!!.getChildAt(a)
				var message: MessageObject? = null

				if (view is ChatMessageCell) {
					message = view.getMessageObject()
				}
				else if (view is ChatActionCell) {
					message = view.messageObject
				}

				if (message?.messageOwner?.media_unread == true && message.messageOwner?.mentioned == true) {
					if (!message.isVoice && !message.isRoundVideo) {
						newMentionsCount--

						if (newMentionsCount <= 0) {
							newMentionsCount = 0
							hasAllMentionsLocal = true

							showMentionDownButton(show = false, animated = true)
						}
						else {
							mentiondownButtonCounter?.setText(String.format(Locale.getDefault(), "%d", newMentionsCount))
						}

						messagesController.markMentionMessageAsRead(message.id, if (isChannel(currentChat)) currentChat!!.id else 0, dialogId)

						message.setContentIsRead()
					}

					if (view is ChatMessageCell) {
						view.setHighlighted(false)
						view.setHighlightedAnimated()
					}
				}
			}

			chatListView?.itemAnimator = null
		}

		updateBottomOverlay()
		updateSecretStatus()

		fragmentContextView?.isEnabled = !value
		fragmentLocationContextView?.isEnabled = !value
		pinnedMessageView?.isEnabled = !isInPreviewMode
	}

	override fun onResume() {
		super.onResume()

		checkShowBlur()

		activityResumeTime = System.currentTimeMillis()

		if (openImport && sendMessagesHelper.getImportingHistory(dialogId) != null) {
			val alert = ImportingAlert(parentActivity, null, this)

			alert.setOnHideListener {
				fragmentContextView?.checkImport(false)
			}

			showDialog(alert)

			openImport = false
		}

		checkAdjustResize()

		MediaController.getInstance().startRaiseToEarSensors(this)

		checkRaiseSensors()

		chatAttachAlert?.onResume()
		contentView?.onResume()

		checkChecksHint()
		Bulletin.addDelegate(this, object : Bulletin.Delegate {
			override fun getBottomOffset(tag: Int): Int {
				if (tag == 1) {
					return 0
				}

				var height = if (chatActivityEnterView != null && chatActivityEnterView!!.visibility == View.VISIBLE) {
					if (contentView!!.keyboardHeight < AndroidUtilities.dp(20f) && chatActivityEnterView!!.isPopupShowing || chatActivityEnterView!!.panelAnimationInProgress()) {
						chatActivityEnterView!!.height + chatActivityEnterView!!.emojiPadding
					}
					else {
						chatActivityEnterView!!.height
					}
				}
				else {
					AndroidUtilities.dp(51f)
				}

				if (chatActivityEnterView!!.panelAnimationInProgress()) {
					val translationY = bottomPanelTranslationY - chatActivityEnterView!!.emojiPadding
					height += translationY.toInt()
				}

				height += contentPanTranslation.toInt()

				return height - AndroidUtilities.dp(1.5f)
			}
		}.also {
			bulletinDelegate = it
		})

		checkActionBarMenu(false)

		if (replyImageLocation != null && replyImageView != null) {
			replyImageView?.setImage(ImageLocation.getForObject(replyImageLocation, replyImageLocationObject), "50_50", ImageLocation.getForObject(replyImageThumbLocation, replyImageLocationObject), "50_50_b", null, replyImageSize.toLong(), replyImageCacheType, replyMessage)
		}

		if (pinnedImageLocation != null) {
			val pinnedMessageObject = pinnedMessageObjects[currentPinnedMessageId]
			pinnedMessageImageView[0]?.setImage(ImageLocation.getForObject(pinnedImageLocation, pinnedImageLocationObject), "50_50", ImageLocation.getForObject(pinnedImageThumbLocation, pinnedImageLocationObject), "50_50_b", null, pinnedImageSize.toLong(), pinnedImageCacheType, pinnedMessageObject)
		}

		if (chatMode == 0) {
			notificationsController.setOpenedDialogId(dialogId)
		}

		messagesController.setLastVisibleDialogId(dialogId, chatMode == MODE_SCHEDULED, true)

		if (scrollToTopOnResume) {
			if (scrollToTopUnReadOnResume && scrollToMessage != null) {
				if (chatListView != null) {
					val yOffset: Int
					var bottom = true

					when (scrollToMessagePosition) {
						-9000 -> {
							yOffset = getScrollOffsetForMessage(scrollToMessage!!)
							bottom = false
						}

						-10000 -> {
							yOffset = -AndroidUtilities.dp(11f)
							bottom = false
						}

						else -> {
							yOffset = scrollToMessagePosition
						}
					}

					chatLayoutManager?.scrollToPositionWithOffset(chatAdapter!!.messagesStartRow + messages.indexOf(scrollToMessage), yOffset, bottom)
				}
			}
			else {
				moveScrollToLastMessage(false)
			}

			scrollToTopUnReadOnResume = false
			scrollToTopOnResume = false
			scrollToMessage = null
		}

		paused = false
		pausedOnLastMessage = false

		checkScrollForLoad(false)

		if (wasPaused) {
			wasPaused = false
			chatAdapter?.notifyDataSetChanged(false)
		}

		fixLayout()
		applyDraftMaybe(false)

		if (bottomOverlayChat != null && bottomOverlayChat!!.visibility != View.VISIBLE && !actionBar!!.isSearchFieldVisible) {
			chatActivityEnterView?.setFieldFocused(true)
		}

		chatActivityEnterView?.onResume()

		if (currentUser != null) {
			chatEnterTime = System.currentTimeMillis()
			chatLeaveTime = 0
		}

		if (startVideoEdit != null) {
			AndroidUtilities.runOnUIThread {
				openVideoEditor(startVideoEdit, null)
				startVideoEdit = null
			}
		}

		if (chatListView != null && (chatActivityEnterView == null || !chatActivityEnterView!!.isEditingMessage)) {
			chatListView?.setOnItemLongClickListener(onItemLongClickListener)
			chatListView?.setOnItemClickListener(onItemClickListener)
			chatListView?.isLongClickable = true
		}

		checkBotCommands()
		updateTitle(false)
		showGigagroupConvertAlert()

		if (pullingDownOffset != 0f) {
			pullingDownOffset = 0f
			chatListView?.invalidate()
		}
	}

	fun checkAdjustResize() {
		if (reportType >= 0) {
			AndroidUtilities.requestAdjustNothing(parentActivity, classGuid)
		}
		else {
			AndroidUtilities.requestAdjustResize(parentActivity, classGuid)
		}
	}

	override fun finishFragment() {
		super.finishFragment()
		if (scrimPopupWindow != null) {
			scrimPopupWindow?.setPauseNotifications(false)
			closeMenu()
		}
	}

	private fun startAiBot() {
		if (isChatBotStarted) {
			return
		}

		chatBotController.startChatBot()
	}

	override fun onPause() {
		super.onPause()

		if (scrimPopupWindow != null) {
			scrimPopupWindow?.setPauseNotifications(false)
			closeMenu()
		}

		val replyId = threadId

		messagesController.markDialogAsReadNow(dialogId, replyId)

		MediaController.getInstance().stopRaiseToEarSensors(this, true)

		paused = true
		wasPaused = true

		if (chatMode == 0) {
			notificationsController.setOpenedDialogId(0)
		}

		Bulletin.removeDelegate(this)

		messagesController.setLastVisibleDialogId(dialogId, chatMode == MODE_SCHEDULED, false)

		var draftMessage: CharSequence? = null
		var replyMessage: MessageObject? = null
		var searchWebpage = true

		if (!ignoreAttachOnPause && chatActivityEnterView != null && bottomOverlayChat != null && bottomOverlayChat!!.visibility != View.VISIBLE) {
			chatActivityEnterView?.onPause()
			replyMessage = this.replyMessage
			draftMessage = AndroidUtilities.getTrimmedString(chatActivityEnterView!!.getDraftMessage())
			searchWebpage = chatActivityEnterView!!.isMessageWebPageSearchEnabled
			chatActivityEnterView?.setFieldFocused(false)
		}

		if (chatAttachAlert != null) {
			if (!ignoreAttachOnPause) {
				chatAttachAlert?.onPause()
			}
			else {
				ignoreAttachOnPause = false
			}
		}

		contentView?.onPause()

		if (chatMode == 0) {
			val message = arrayOf(draftMessage)
			val entities = mediaDataController.getEntities(message, currentEncryptedChat == null || AndroidUtilities.getPeerLayerVersion(currentEncryptedChat!!.layer) >= 101)

			mediaDataController.saveDraft(dialogId, threadId, message[0], entities, replyMessage?.messageOwner, !searchWebpage)
			messagesController.cancelTyping(0, dialogId, threadId)

			if (!pausedOnLastMessage && !firstLoading) {
				val editor = MessagesController.getNotificationsSettings(currentAccount).edit()
				var messageId = 0
				var offset = 0

				if (chatLayoutManager != null) {
					var sponsoredMessageFound = false

					for (i in 0 until chatListView!!.childCount) {
						if (chatListView!!.getChildAt(i) is ChatMessageCell && (chatListView!!.getChildAt(i) as ChatMessageCell).getMessageObject()!!.isSponsored) {
							sponsoredMessageFound = true
							break
						}
					}

					val position = chatLayoutManager!!.findFirstVisibleItemPosition()

					if (position != 0 && !sponsoredMessageFound) {
						var holder = chatListView!!.findViewHolderForAdapterPosition(position) as? RecyclerListView.Holder

						if (holder != null) {
							var mid = 0

							if (holder.itemView is ChatMessageCell) {
								mid = (holder.itemView as ChatMessageCell).getMessageObject()!!.id
							}
							else if (holder.itemView is ChatActionCell) {
								mid = (holder.itemView as ChatActionCell).messageObject!!.id
							}

							if (mid == 0) {
								holder = chatListView?.findViewHolderForAdapterPosition(position + 1) as? RecyclerListView.Holder
							}

							var ignore = false
							var count = 0

							for (a in position - 1 downTo chatAdapter!!.messagesStartRow) {
								val num = a - chatAdapter!!.messagesStartRow

								if (num < 0 || num >= messages.size) {
									continue
								}

								val messageObject = messages[num]

								if (messageObject.id == 0) {
									continue
								}

								if ((!messageObject.isOut || messageObject.messageOwner?.from_scheduled == true) && messageObject.isUnread) {
									ignore = true
									messageId = 0
								}

								if (count > 2) {
									break
								}

								count++
							}

							if (holder != null && !ignore) {
								if (holder.itemView is ChatMessageCell) {
									messageId = (holder.itemView as ChatMessageCell).getMessageObject()!!.id
								}
								else if (holder.itemView is ChatActionCell) {
									messageId = (holder.itemView as ChatActionCell).messageObject!!.id
								}

								if (messageId > 0 && currentEncryptedChat == null || messageId < 0 && currentEncryptedChat != null) {
									offset = holder.itemView.bottom - chatListView!!.measuredHeight
									FileLog.d("save offset = $offset for mid $messageId")
								}
								else {
									messageId = 0
								}
							}
						}
					}
				}

				if (messageId != 0) {
					editor.putInt("diditem$dialogId", messageId)
					editor.putInt("diditemo$dialogId", offset)
				}
				else {
					pausedOnLastMessage = true

					editor.remove("diditem$dialogId")
					editor.remove("diditemo$dialogId")
				}

				editor.commit()
			}

			if (currentUser != null) {
				chatLeaveTime = System.currentTimeMillis()
				updateInformationForScreenshotDetector()
			}

			hideUndoViews()
		}

		chatListItemAnimator?.endAnimations()
		chatScrollHelper?.cancel()

		if (AvatarPreviewer.hasVisibleInstance()) {
			AvatarPreviewer.getInstance().close()
		}
	}

	private fun applyDraftMaybe(canClear: Boolean) {
		if (chatActivityEnterView == null || chatMode != 0) {
			return
		}

		val draftMessage = mediaDataController.getDraft(dialogId, threadId)
		val draftReplyMessage = if (draftMessage != null && draftMessage.reply_to_msg_id != 0) mediaDataController.getDraftMessage(dialogId, threadId) else null

		if (chatActivityEnterView!!.fieldText == null) {
			if (draftMessage != null) {
				chatActivityEnterView!!.setWebPage(null, !draftMessage.no_webpage)

				val message: CharSequence

				if (draftMessage.entities.isNotEmpty()) {
					val stringBuilder = SpannableStringBuilder.valueOf(draftMessage.message)

					MediaDataController.sortEntities(draftMessage.entities)

					for (a in draftMessage.entities.indices) {
						when (val entity = draftMessage.entities[a]) {
							is TL_inputMessageEntityMentionName, is TL_messageEntityMentionName -> {
								val userId = if (entity is TL_inputMessageEntityMentionName) {
									entity.userId?.user_id ?: 0L
								}
								else {
									(entity as TL_messageEntityMentionName).userId
								}

								if (entity.offset + entity.length < stringBuilder.length && stringBuilder[entity.offset + entity.length] == ' ') {
									entity.length++
								}

								stringBuilder.setSpan(URLSpanUserMention("" + userId, 3), entity.offset, entity.offset + entity.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
							}

							is TL_messageEntityCode, is TL_messageEntityPre -> {
								val run = TextStyleRun()
								run.styleFlags = run.styleFlags or TextStyleSpan.FLAG_STYLE_MONO
								MediaDataController.addStyleToText(TextStyleSpan(run), entity.offset, entity.offset + entity.length, stringBuilder, true)
							}

							is TL_messageEntityBold -> {
								val run = TextStyleRun()
								run.styleFlags = run.styleFlags or TextStyleSpan.FLAG_STYLE_BOLD
								MediaDataController.addStyleToText(TextStyleSpan(run), entity.offset, entity.offset + entity.length, stringBuilder, true)
							}

							is TL_messageEntityItalic -> {
								val run = TextStyleRun()
								run.styleFlags = run.styleFlags or TextStyleSpan.FLAG_STYLE_ITALIC
								MediaDataController.addStyleToText(TextStyleSpan(run), entity.offset, entity.offset + entity.length, stringBuilder, true)
							}

							is TL_messageEntityStrike -> {
								val run = TextStyleRun()
								run.styleFlags = run.styleFlags or TextStyleSpan.FLAG_STYLE_STRIKE
								MediaDataController.addStyleToText(TextStyleSpan(run), entity.offset, entity.offset + entity.length, stringBuilder, true)
							}

							is TL_messageEntityUnderline -> {
								val run = TextStyleRun()
								run.styleFlags = run.styleFlags or TextStyleSpan.FLAG_STYLE_UNDERLINE
								MediaDataController.addStyleToText(TextStyleSpan(run), entity.offset, entity.offset + entity.length, stringBuilder, true)
							}

							is TL_messageEntityTextUrl -> {
								stringBuilder.setSpan(URLSpanReplacement(entity.url), entity.offset, entity.offset + entity.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
							}

							is TL_messageEntitySpoiler -> {
								val run = TextStyleRun()
								run.styleFlags = run.styleFlags or TextStyleSpan.FLAG_STYLE_SPOILER
								MediaDataController.addStyleToText(TextStyleSpan(run), entity.offset, entity.offset + entity.length, stringBuilder, true)
							}

							is TL_messageEntityCustomEmoji -> {
								var fontMetrics: FontMetricsInt? = null

								try {
									fontMetrics = chatActivityEnterView?.editField?.paint?.fontMetricsInt
								}
								catch (e: Exception) {
									FileLog.e(e)
								}

								val span = if (entity.document != null) {
									AnimatedEmojiSpan(entity.document!!, fontMetrics)
								}
								else {
									AnimatedEmojiSpan(entity.documentId, fontMetrics)
								}

								stringBuilder.setSpan(span, entity.offset, entity.offset + entity.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
							}
						}
					}

					message = stringBuilder
				}
				else {
					message = draftMessage.message
				}

				chatActivityEnterView?.fieldText = message

				if (getArguments()?.getBoolean("hasUrl", false) == true) {
					chatActivityEnterView?.setSelection(draftMessage.message.indexOf('\n') + 1)

					AndroidUtilities.runOnUIThread({
						chatActivityEnterView?.setFieldFocused(true)
						chatActivityEnterView?.openKeyboard()
					}, 700)
				}
			}
		}
		else if (canClear && draftMessage == null) {
			chatActivityEnterView?.fieldText = ""
			hideFieldPanel(true)
		}
		if (replyMessage == null && draftReplyMessage != null) {
			replyMessage = MessageObject(currentAccount, draftReplyMessage, messagesController.users, generateLayout = false, checkMediaExists = false)
			showFieldPanelForReply(replyMessage)
		}
	}

	private fun updateInformationForScreenshotDetector() {
		if (currentUser == null) {
			return
		}

		val visibleMessages: List<Long>
		val messageId = 0

		if (currentEncryptedChat != null) {
			visibleMessages = mutableListOf()

			if (chatListView != null) {
				val count = chatListView!!.childCount

				for (a in 0 until count) {
					val view = chatListView!!.getChildAt(a)
					var `object`: MessageObject? = null

					if (view is ChatMessageCell) {
						`object` = view.getMessageObject()
					}

					if (`object` != null && `object`.id < 0 && `object`.messageOwner?.random_id != 0L) {
						visibleMessages.add(`object`.messageOwner!!.random_id)
					}
				}
			}

			MediaController.getInstance().setLastVisibleMessageIds(currentAccount, chatEnterTime, chatLeaveTime, currentUser, currentEncryptedChat, visibleMessages, messageId)
		}
		else {
			val viewer = SecretMediaViewer.getInstance()
			val messageObject = viewer.currentMessageObject

			if (messageObject != null && !messageObject.isOut) {
				MediaController.getInstance().setLastVisibleMessageIds(currentAccount, viewer.openTime, viewer.closeTime, currentUser, null, null, messageObject.id)
			}
		}
	}

	private fun fixLayoutInternal(): Boolean {
		if (!AndroidUtilities.isTablet() && ApplicationLoader.applicationContext.resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {
			selectedMessagesCountTextView?.setTextSize(18)
		}
		else {
			selectedMessagesCountTextView?.setTextSize(20)
		}

		var newGroups: HashMap<Long?, GroupedMessages?>? = null
		val count = chatListView!!.childCount

		for (a in 0 until count) {
			val child = chatListView!!.getChildAt(a)

			if (child is ChatMessageCell) {
				val groupedMessages = child.currentMessagesGroup

				if (groupedMessages != null && groupedMessages.hasSibling && groupedMessages.messages.isNotEmpty()) {
					if (newGroups == null) {
						newGroups = HashMap()
					}

					if (!newGroups.containsKey(groupedMessages.groupId)) {
						newGroups[groupedMessages.groupId] = groupedMessages

						val messageObject = groupedMessages.messages[groupedMessages.messages.size - 1]
						val idx = messages.indexOf(messageObject)

						if (idx >= 0) {
							chatAdapter?.notifyItemRangeChanged(idx + chatAdapter!!.messagesStartRow, groupedMessages.messages.size)
							chatListView?.itemAnimator = null
						}
					}
				}
			}
		}

		if (AndroidUtilities.isTablet()) {
			actionBar?.backButtonDrawable = ResourcesCompat.getDrawable(ApplicationLoader.applicationContext.resources, R.drawable.ic_back_arrow, null)
			return false
		}

		return true
	}

	private fun fixLayout() {
		avatarContainer?.viewTreeObserver?.addOnPreDrawListener(object : ViewTreeObserver.OnPreDrawListener {
			override fun onPreDraw(): Boolean {
				avatarContainer?.viewTreeObserver?.removeOnPreDrawListener(this)
				return fixLayoutInternal()
			}
		})
	}

	fun maybePlayVisibleVideo(): Boolean {
		if (chatListView == null) {
			return false
		}

		val playingMessage = MediaController.getInstance().playingMessageObject

		if (playingMessage != null && !playingMessage.isVideo) {
			return false
		}

		var visibleMessage: MessageObject? = null
		var visibleAnimation: AnimatedFileDrawable? = null

		if (noSoundHintView?.tag != null) {
			val cell = noSoundHintView?.messageCell

			if (cell != null) {
				val imageReceiver = cell.photoImage

				visibleAnimation = imageReceiver.animation

				if (visibleAnimation != null) {
					visibleMessage = cell.getMessageObject()
					scrollToVideo = cell.top + imageReceiver.imageY2 > chatListView!!.measuredHeight
				}
			}
		}

		if (visibleMessage == null) {
			val count = chatListView?.childCount ?: 0

			for (a in 0 until count) {
				val child = chatListView?.getChildAt(a) as? ChatMessageCell ?: continue
				val messageObject = child.getMessageObject()
				val isRoundVideo = messageObject!!.isRoundVideo

				if (!messageObject.isVideo && !isRoundVideo || messageObject.videoEditedInfo != null) {
					continue
				}

				val imageReceiver = child.photoImage
				val animation = imageReceiver.animation ?: continue
				val top = child.top + imageReceiver.imageY
				val bottom = top + imageReceiver.imageHeight

				if (bottom < 0 || top > chatListView!!.measuredHeight) {
					continue
				}

				if (visibleMessage != null && top < 0) {
					break
				}

				visibleMessage = messageObject
				visibleAnimation = animation

				scrollToVideo = top < 0 || bottom > chatListView!!.measuredHeight

				if (top >= 0 && bottom <= chatListView!!.measuredHeight) {
					break
				}
			}
		}

		if (visibleMessage != null) {
			if (MediaController.getInstance().isPlayingMessage(visibleMessage)) {
				return false
			}

			hideHints(true)

			return if (visibleMessage.isRoundVideo) {
				val result = MediaController.getInstance().playMessage(visibleMessage)
				MediaController.getInstance().setVoiceMessagesPlaylist(if (result) createVoiceMessagesPlaylist(visibleMessage, false) else null, false)
				result
			}
			else {
				SharedConfig.setNoSoundHintShowed(true)

				visibleMessage.audioProgress = visibleAnimation!!.currentProgress
				visibleMessage.audioProgressMs = visibleAnimation.currentProgressMs

				visibleAnimation.stop()

				if (PhotoViewer.isPlayingMessageInPip(visibleMessage)) {
					PhotoViewer.getPipInstance()?.destroyPhotoViewer()
				}

				MediaController.getInstance().playMessage(visibleMessage)
			}
		}

		return false
	}

	override fun onConfigurationChanged(newConfig: Configuration) {
		fixLayout()

		(visibleDialog as? DatePickerDialog)?.dismiss()

		closeMenu()

		if (!AndroidUtilities.isTablet()) {
			if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) {
				if (PhotoViewer.hasInstance() && PhotoViewer.getInstance().isVisible) {
					return
				}

				val message = MediaController.getInstance().playingMessageObject

				if (message != null && message.isVideo) {
					PhotoViewer.getInstance().setParentActivity(this@ChatActivity)

					fileLoader.setLoadingVideoForPlayer(message.document, false)

					MediaController.getInstance().cleanupPlayer(true, true, false, true)

					if (PhotoViewer.getInstance().openPhoto(message, if (message.type != MessageObject.TYPE_COMMON) dialogId else 0, if (message.type != 0) mergeDialogId else 0, photoViewerProvider, false)) {
						PhotoViewer.getInstance().setParentChatActivity(this@ChatActivity)
					}

					hideHints(false)

					MediaController.getInstance().resetGoingToShowMessageObject()
				}
			}
			else if (PhotoViewer.hasInstance() && PhotoViewer.getInstance().isOpenedFullScreenVideo) {
				PhotoViewer.getInstance().injectVideoPlayerToMediaController()
				PhotoViewer.getInstance().closePhoto(false, true)
			}
		}
	}

	private fun createDeleteMessagesAlert(finalSelectedObject: MessageObject?, selectedGroup: GroupedMessages?) {
		createDeleteMessagesAlert(finalSelectedObject, selectedGroup, 1)
	}

	private fun createDeleteMessagesAlert(finalSelectedObject: MessageObject?, finalSelectedGroup: GroupedMessages?, loadParticipant: Int, hideDimAfter: Boolean = false) {
		if (finalSelectedObject == null && selectedMessagesIds[0].size() + selectedMessagesIds[1].size() == 0) {
			return
		}

		AlertsCreator.createDeleteMessagesAlert(this, currentUser, currentChat, currentEncryptedChat, mergeDialogId, finalSelectedObject, selectedMessagesIds, finalSelectedGroup, chatMode == MODE_SCHEDULED, loadParticipant, {
			hideActionMode()
			updatePinnedMessageView(true)
		}, if (hideDimAfter) Runnable { dimBehindView(false) } else null)
	}

	private fun hideActionMode() {
		if (actionBar != null) {
			if (actionBar?.isActionModeShowed != true) {
				return
			}

			actionBar?.hideActionMode()
		}

		cantDeleteMessagesCount = 0
		canEditMessagesCount = 0
		cantForwardMessagesCount = 0
		canSaveMusicCount = 0
		canSaveDocumentsCount = 0
		cantSaveMessagesCount = 0

		if (chatActivityEnterView != null) {
			val editTextCaption = chatActivityEnterView!!.editField

			if (chatActivityEnterView!!.visibility == View.VISIBLE) {
				editTextCaption.requestFocus()
			}
			editTextCaption.setAllowDrawCursor(true)
		}

		textSelectionHelper.clear(true)
		textSelectionHelper.cancelAllAnimators()

		textSelectionHint?.hide()
		chatActivityEnterView?.preventInput = false

		textSelectionHintWasShowed = false
	}

	private fun createMenu(v: View?, single: Boolean, listView: Boolean, x: Float, y: Float): Boolean {
		return createMenu(v, single, listView, x, y, true)
	}

	private fun getMessageCaption(messageObject: MessageObject?, group: GroupedMessages?): CharSequence? {
		if (messageObject == null) {
			return null
		}

		val restrictionReason = MessagesController.getRestrictionReason(messageObject.messageOwner?.restriction_reason)

		if (!restrictionReason.isNullOrEmpty()) {
			return restrictionReason
		}

		if (messageObject.isVoiceTranscriptionOpen && !TranscribeButton.isTranscribing(messageObject)) {
			return messageObject.voiceTranscription
		}

		if (messageObject.caption != null) {
			return messageObject.caption
		}

		if (group == null) {
			return null
		}

		var caption: CharSequence? = null

		for (message in group.messages) {
			if (message.caption != null) {
				if (caption != null) {
					return null
				}

				caption = message.caption
			}
		}

		return caption
	}

	@SuppressLint("ClickableViewAccessibility")
	private fun createMenu(v: View?, single: Boolean, listView: Boolean, x: Float, y: Float, searchGroup: Boolean): Boolean {
		@Suppress("NAME_SHADOWING") var single = single

		if (actionBar!!.isActionModeShowed || reportType >= 0) {
			return false
		}

		if (chatActivityEnterView!!.botCommandsMenuIsShowing()) {
			return false
		}

		val message: MessageObject?
		val primaryMessage: MessageObject?

		when (v) {
			is ChatMessageCell -> {
				message = v.getMessageObject()
				primaryMessage = v.primaryMessageObject
			}

			is ChatActionCell -> {
				message = v.messageObject
				primaryMessage = message
			}

			else -> {
				primaryMessage = null
				message = null
			}
		}

		if (message == null) {
			return false
		}

		if (!single && message.messageOwner?.action is TL_messageActionGiftPremium) {
			return false
		}

		if (message.messageOwner is TLRPC.TL_messageService) {
			return false
		}

		val type = getMessageType(message)

		val context = contentView?.context ?: return false

		if (single) {
			if (message.messageOwner?.action is TL_messageActionPinMessage) {
				if (message.replyMsgId != 0) {
					scrollToMessageId(message.replyMsgId, message.messageOwner!!.id, true, if (message.dialogId == mergeDialogId) 1 else 0, false, 0)
				}
				else {
					Toast.makeText(parentActivity, context.getString(R.string.MessageNotFound), Toast.LENGTH_SHORT).show()
				}

				return true
			}
			else if (message.messageOwner?.action is TL_messageActionPaymentSent && message.replyMessageObject?.isInvoice == true) {
				val req = TL_payments_getPaymentReceipt()
				req.msg_id = message.id
				req.peer = messagesController.getInputPeer(message.messageOwner?.peer_id)

				connectionsManager.sendRequest(req, { response, _ ->
					AndroidUtilities.runOnUIThread {
						if (response is TL_payments_paymentReceipt) {
							presentFragment(PaymentFormActivity(response as TL_payments_paymentReceipt?))
						}
					}
				}, ConnectionsManager.RequestFlagFailOnServerErrors)

				return true
			}
			else if (message.messageOwner?.action is TL_messageActionGroupCall || message.messageOwner?.action is TL_messageActionInviteToGroupCall || message.messageOwner?.action is TL_messageActionGroupCallScheduled) {
				if (parentActivity == null) {
					return false
				}

				val sharedInstance = sharedInstance

				if (sharedInstance != null) {
					if (sharedInstance.groupCall != null && message.messageOwner?.action?.call?.id == sharedInstance.groupCall?.call?.id) {
						if (parentActivity is LaunchActivity) {
							GroupCallActivity.create(parentActivity as LaunchActivity?, AccountInstance.getInstance(currentAccount), null, null, false, null)
						}
						else {
							val intent = Intent(parentActivity, LaunchActivity::class.java).setAction("voip_chat")
							intent.putExtra("currentAccount", VoIPService.sharedInstance!!.getAccount())

							parentActivity!!.startActivity(intent)
						}
					}
					else {
						createGroupCall = getGroupCall() == null
						startCall(currentChat!!, null, createGroupCall, parentActivity, this@ChatActivity, accountInstance)
					}

					return true
				}
				else if (fragmentContextView != null && getGroupCall() != null) {
					if (VoIPService.sharedInstance != null) {
						GroupCallActivity.create(parentActivity as LaunchActivity?, AccountInstance.getInstance(VoIPService.sharedInstance!!.getAccount()), null, null, false, null)
					}
					else {
						val call = getGroupCall() ?: return false
						startCall(messagesController.getChat(call.chatId)!!, null, false, parentActivity, this@ChatActivity, accountInstance)
					}

					return true
				}
				else if (canManageCalls(currentChat)) {
					showGroupCallAlert(this@ChatActivity, currentChat!!, accountInstance)
					return true
				}
			}
			else if (message.messageOwner?.action is TL_messageActionSetChatTheme) {
				showChatThemeBottomSheet()
				return true
			}
		}

		if (message.isSponsored || threadMessageObjects?.contains(message) == true) {
			single = true
		}

		selectedObject = null
		selectedObjectGroup = null
		forwardingMessage = null
		forwardingMessageGroup = null
		selectedObjectToEditCaption = null

		for (a in 1 downTo 0) {
			selectedMessagesCanCopyIds[a].clear()
			selectedMessagesCanStarIds[a].clear()
			selectedMessagesIds[a].clear()
		}

		hideActionMode()

		updatePinnedMessageView(true)

		val groupedMessages = if (searchGroup) {
			getValidGroupedMessage(message)
		}
		else {
			null
		}

		var allowChatActions = true

		var allowPin = if (chatMode == MODE_SCHEDULED || isThreadChat) {
			false
		}
		else if (currentChat != null) {
			message.dialogId != mergeDialogId && canPinMessages(currentChat)
		}
		else if (currentEncryptedChat == null) {
			if (isDeleted(currentUser)) {
				false
			}
			else if (currentUserInfo != null) {
				currentUserInfo!!.can_pin_message
			}
			else {
				false
			}
		}
		else {
			false
		}

		allowPin = allowPin && message.id > 0 && (message.messageOwner?.action == null || message.messageOwner?.action is TL_messageActionEmpty)

		val noforwards = messagesController.isChatNoForwards(currentChat) || message.messageOwner?.noforwards == true
		val allowUnpin = message.dialogId != mergeDialogId && allowPin && (pinnedMessageObjects.containsKey(message.id) || groupedMessages != null && groupedMessages.messages.isNotEmpty() && pinnedMessageObjects.containsKey(groupedMessages.messages[0].id))
		var allowEdit = message.canEditMessage(currentChat) && !chatActivityEnterView!!.hasAudioToSend() && message.dialogId != mergeDialogId

		if (allowEdit && groupedMessages != null) {
			var captionsCount = 0
			var a = 0
			val N = groupedMessages.messages.size

			while (a < N) {
				val messageObject = groupedMessages.messages[a]

				if (a == 0 || !messageObject.caption.isNullOrEmpty()) {
					selectedObjectToEditCaption = messageObject

					if (!messageObject.caption.isNullOrEmpty()) {
						captionsCount++
					}
				}

				a++
			}

			allowEdit = captionsCount < 2
		}

		if (chatMode == MODE_SCHEDULED || threadMessageObjects != null && threadMessageObjects!!.contains(message) || message.isSponsored || type == 1 && message.dialogId == mergeDialogId || message.messageOwner?.action is TL_messageActionSecureValuesSent || currentEncryptedChat == null && message.id < 0 || bottomOverlayChat != null && bottomOverlayChat!!.visibility == View.VISIBLE || currentChat != null && (isNotInChat(currentChat) && !isThreadChat || isChannel(currentChat) && !canPost(currentChat) && !currentChat!!.megagroup || !canSendMessages(currentChat))) {
			allowChatActions = false
		}

		if (single || type < 2 || type == 20) {
			if (parentActivity == null) {
				return false
			}

			val icons = mutableListOf<Int>()
			val items = mutableListOf<CharSequence>()
			val options = mutableListOf<Int>()
			var optionsView: View? = null
			var messageTextToTranslate: CharSequence? = null

			if (message.messageOwner?.action is TL_messageActionSetMessagesTTL && single && (dialogId >= 0 || currentChat != null && canUserDoAdminAction(currentChat, ChatObject.ACTION_DELETE_MESSAGES))) {
				val autoDeletePopupWrapper = AutoDeletePopupWrapper(context, null, object : AutoDeletePopupWrapper.Callback {
					override fun dismiss() {
						scrimPopupWindow?.dismiss()
					}

					override fun setAutoDeleteHistory(time: Int, action: Int) {
						messagesController.setDialogHistoryTTL(dialogId, time)

						if (currentUserInfo != null || currentChatInfo != null) {
							undoView?.showWithAction(dialogId, action, currentUser, if (currentUserInfo != null) currentUserInfo!!.ttl_period else currentChatInfo!!.ttl_period, null, null)
						}
					}
				}, true)

				autoDeletePopupWrapper.updateItems(if (currentUserInfo != null) currentUserInfo!!.ttl_period else currentChatInfo!!.ttl_period)

				optionsView = autoDeletePopupWrapper.windowLayout
			}
			else if (type >= 0 || type == -1 && single && (message.isSending || message.isEditing) && currentEncryptedChat == null) {
				selectedObject = message
				selectedObjectGroup = groupedMessages
				messageTextToTranslate = getMessageCaption(selectedObject, selectedObjectGroup)

				if (messageTextToTranslate == null && selectedObject!!.isPoll) {
					runCatching {
						val poll = (selectedObject?.messageOwner?.media as? TL_messageMediaPoll)?.poll
						val pollText = StringBuilder(poll?.question ?: "").append("\n")

						for (answer in poll!!.answers) {
							pollText.append("\n\uD83D\uDD18 ").append(answer.text)
						}

						messageTextToTranslate = pollText.toString()
					}
				}

				if (messageTextToTranslate == null) {
					messageTextToTranslate = getMessageContent(selectedObject!!, 0, false)
				}

				if (Emoji.fullyConsistsOfEmojis(messageTextToTranslate)) {
					messageTextToTranslate = null
				}

				if (message.isSponsored && !messagesController.premiumLocked) {
					items.add(context.getString(R.string.HideAd))
					options.add(OPTION_HIDE_SPONSORED_MESSAGE)
					icons.add(R.drawable.msg_block2)
				}

				if (type == -1) {
					if ((selectedObject!!.type == MessageObject.TYPE_COMMON || selectedObject!!.isAnimatedEmoji || selectedObject!!.isAnimatedEmojiStickers || getMessageCaption(selectedObject, selectedObjectGroup) != null) && !noforwards) {
						items.add(context.getString(R.string.Copy))
						options.add(OPTION_COPY)
						icons.add(R.drawable.msg_copy)
					}

					items.add(context.getString(R.string.CancelSending))
					options.add(OPTION_CANCEL_SENDING)
					icons.add(R.drawable.msg_delete)
				}
				else if (type == 0) {
					items.add(context.getString(R.string.Retry))
					options.add(OPTION_RETRY)
					icons.add(R.drawable.msg_retry)
					items.add(context.getString(R.string.Delete))
					options.add(OPTION_DELETE)
					icons.add(if (selectedObject?.messageOwner?.ttl_period != 0) R.drawable.msg_delete_auto else R.drawable.msg_delete)
				}
				else if (type == 1) {
					if (currentChat != null) {
						if (allowChatActions) {
							items.add(context.getString(R.string.Reply))
							options.add(OPTION_REPLY)
							icons.add(R.drawable.msg_reply)
						}

						if (!isThreadChat && chatMode != MODE_SCHEDULED && message.hasReplies() && currentChat!!.megagroup && message.canViewThread()) {
							items.add(LocaleController.formatPluralString("ViewReplies", message.repliesCount))
							options.add(OPTION_VIEW_REPLIES_OR_THREAD)
							icons.add(R.drawable.msg_viewreplies)
						}

						if (allowUnpin) {
							items.add(context.getString(R.string.UnpinMessage))
							options.add(OPTION_UNPIN)
							icons.add(R.drawable.msg_unpin)
						}
						else if (allowPin) {
							items.add(context.getString(R.string.PinMessage))
							options.add(OPTION_PIN)
							icons.add(R.drawable.msg_pin)
						}

						if (selectedObject != null && selectedObject!!.contentType == 0 && !messageTextToTranslate.isNullOrEmpty() && !selectedObject!!.isAnimatedEmoji && !selectedObject!!.isDice) {
							items.add(context.getString(R.string.TranslateMessage))
							options.add(OPTION_TRANSLATE)
							icons.add(R.drawable.msg_translate)
						}

						if (message.canEditMessage(currentChat)) {
							items.add(context.getString(R.string.Edit))
							options.add(OPTION_EDIT)
							icons.add(R.drawable.msg_edit)
						}

						if (selectedObject!!.contentType == 0 && !selectedObject!!.isMediaEmptyWebpage && selectedObject!!.id > 0 && !selectedObject!!.isOut && (currentChat != null || currentUser != null && currentUser!!.bot)) {
							items.add(context.getString(R.string.ReportChat))
							options.add(OPTION_REPORT_CHAT)
							icons.add(R.drawable.ic_error)
						}
					}
					else {
						if (selectedObject!!.id > 0 && allowChatActions) {
							items.add(context.getString(R.string.Reply))
							options.add(OPTION_REPLY)
							icons.add(R.drawable.msg_reply)
						}
					}

					if (message.canDeleteMessage(chatMode == MODE_SCHEDULED, currentChat) && (threadMessageObjects == null || !threadMessageObjects!!.contains(message))) {
						items.add(context.getString(R.string.Delete))
						options.add(OPTION_DELETE)
						icons.add(if (selectedObject?.messageOwner?.ttl_period != 0) R.drawable.msg_delete_auto else R.drawable.msg_delete)
					}
				}
				else if (type == 20) {
					items.add(context.getString(R.string.Retry))
					options.add(OPTION_RETRY)
					icons.add(R.drawable.msg_retry)

					if (!noforwards) {
						items.add(context.getString(R.string.Copy))
						options.add(OPTION_COPY)
						icons.add(R.drawable.msg_copy)
					}

					items.add(context.getString(R.string.Delete))
					options.add(OPTION_DELETE)
					icons.add(if (selectedObject?.messageOwner?.ttl_period != 0) R.drawable.msg_delete_auto else R.drawable.msg_delete)
				}
				else {
					if (currentEncryptedChat == null) {
						if (chatMode == MODE_SCHEDULED) {
							items.add(context.getString(R.string.MessageScheduleSend))
							options.add(OPTION_SEND_NOW)
							icons.add(R.drawable.msg_send)
						}

						if (selectedObject?.messageOwner?.action is TL_messageActionPhoneCall) {
							val call = message.messageOwner?.action as? TL_messageActionPhoneCall

							items.add(if ((call?.reason is TL_phoneCallDiscardReasonMissed || call?.reason is TL_phoneCallDiscardReasonBusy) && !message.isOutOwner) context.getString(R.string.CallBack) else context.getString(R.string.CallAgain))
							options.add(OPTION_CALL_AGAIN)
							icons.add(R.drawable.msg_callback)

							if (canRateCall(call)) {
								items.add(context.getString(R.string.CallMessageReportProblem))
								options.add(OPTION_RATE_CALL)
								icons.add(R.drawable.msg_fave)
							}
						}

						if (allowChatActions) {
							items.add(context.getString(R.string.Reply))
							options.add(OPTION_REPLY)
							icons.add(R.drawable.msg_reply)
						}

						if (!selectedObject!!.isSponsored && chatMode != MODE_SCHEDULED && (!selectedObject!!.needDrawBluredPreview() || selectedObject!!.hasExtendedMediaPreview()) && !selectedObject!!.isLiveLocation && selectedObject!!.type != 16 && !noforwards && selectedObject!!.type != MessageObject.TYPE_GIFT_PREMIUM) {
							items.add(context.getString(R.string.Forward))
							options.add(OPTION_FORWARD)
							icons.add(R.drawable.msg_forward)
						}

						if ((selectedObject!!.type == MessageObject.TYPE_COMMON || selectedObject!!.isDice || selectedObject!!.isAnimatedEmoji || selectedObject!!.isAnimatedEmojiStickers || getMessageCaption(selectedObject, selectedObjectGroup) != null) && !noforwards) {
							items.add(context.getString(R.string.Copy))
							options.add(OPTION_COPY)
							icons.add(R.drawable.msg_copy)
						}

						if (!isThreadChat && chatMode != MODE_SCHEDULED && currentChat != null && (currentChat!!.has_link || message.hasReplies()) && currentChat!!.megagroup && message.canViewThread()) {
							if (message.hasReplies()) {
								items.add(LocaleController.formatPluralString("ViewReplies", message.repliesCount))
							}
							else {
								items.add(context.getString(R.string.ViewThread))
							}

							options.add(OPTION_VIEW_REPLIES_OR_THREAD)
							icons.add(R.drawable.msg_viewreplies)
						}

						if (!selectedObject!!.isSponsored && chatMode != MODE_SCHEDULED && isChannel(currentChat) && selectedObject!!.dialogId != mergeDialogId && !currentChat?.username.isNullOrEmpty()) {
							items.add(context.getString(R.string.CopyLink))
							options.add(OPTION_COPY_LINK)
							icons.add(R.drawable.msg_link)
						}

						if (type == 2) {
							if (chatMode != MODE_SCHEDULED) {
								if (selectedObject?.type == MessageObject.TYPE_POLL && !message.isPollClosed) {
									if (message.canUnvote()) {
										items.add(context.getString(R.string.Unvote))
										options.add(OPTION_UNVOTE)
										icons.add(R.drawable.msg_unvote)
									}

									if (!message.isForwarded && (message.isOut && (!isChannel(currentChat) || currentChat!!.megagroup) || isChannel(currentChat) && !currentChat!!.megagroup && (currentChat!!.creator || currentChat!!.admin_rights != null && currentChat!!.admin_rights.edit_messages))) {
										if (message.isQuiz) {
											items.add(context.getString(R.string.StopQuiz))
										}
										else {
											items.add(context.getString(R.string.StopPoll))
										}

										options.add(OPTION_STOP_POLL_OR_QUIZ)
										icons.add(R.drawable.msg_pollstop)
									}
								}
								else if (selectedObject!!.isMusic && !noforwards) {
									items.add(context.getString(R.string.SaveToMusic))
									options.add(OPTION_SAVE_TO_DOWNLOADS_OR_MUSIC)
									icons.add(R.drawable.msg_download)
								}
								else if (selectedObject!!.isDocument() && !noforwards) {
									items.add(context.getString(R.string.SaveToDownloads))
									options.add(OPTION_SAVE_TO_DOWNLOADS_OR_MUSIC)
									icons.add(R.drawable.msg_download)
								}
							}
						}
						else if (type == 3 && !noforwards) {
							if (selectedObject?.messageOwner?.media is TL_messageMediaWebPage && MessageObject.isNewGifDocument(selectedObject?.messageOwner?.media?.webpage?.document)) {
								items.add(context.getString(R.string.SaveToGIFs))
								options.add(OPTION_ADD_TO_GIFS)
								icons.add(R.drawable.msg_gif)
							}
						}
						else if (type == 4) {
							if (!noforwards && !selectedObject!!.hasRevealedExtendedMedia()) {
								if (selectedObject!!.isVideo) {
									if (!selectedObject!!.needDrawBluredPreview()) {
										items.add(context.getString(R.string.SaveToGallery))
										options.add(OPTION_SAVE_TO_GALLERY)
										icons.add(R.drawable.msg_gallery)
										items.add(context.getString(R.string.ShareFile))
										options.add(OPTION_SHARE)
										icons.add(R.drawable.msg_shareout)
									}
								}
								else if (selectedObject!!.isMusic) {
									items.add(context.getString(R.string.SaveToMusic))
									options.add(OPTION_SAVE_TO_DOWNLOADS_OR_MUSIC)
									icons.add(R.drawable.msg_download)
									items.add(context.getString(R.string.ShareFile))
									options.add(OPTION_SHARE)
									icons.add(R.drawable.msg_shareout)
								}
								else if (selectedObject!!.document != null) {
									if (MessageObject.isNewGifDocument(selectedObject!!.document)) {
										items.add(context.getString(R.string.SaveToGIFs))
										options.add(OPTION_ADD_TO_GIFS)
										icons.add(R.drawable.msg_gif)
									}

									items.add(context.getString(R.string.SaveToDownloads))
									options.add(OPTION_SAVE_TO_DOWNLOADS_OR_MUSIC)
									icons.add(R.drawable.msg_download)
									items.add(context.getString(R.string.ShareFile))
									options.add(OPTION_SHARE)
									icons.add(R.drawable.msg_shareout)
								}
								else {
									if (!selectedObject!!.needDrawBluredPreview()) {
										items.add(context.getString(R.string.SaveToGallery))
										options.add(OPTION_SAVE_TO_GALLERY)
										icons.add(R.drawable.msg_gallery)
									}
								}
							}
						}
						else if (type == 5) {
							items.add(context.getString(R.string.ApplyLocalizationFile))
							options.add(OPTION_APPLY_LOCALIZATION_OR_THEME)
							icons.add(R.drawable.msg_language)

							if (!noforwards) {
								items.add(context.getString(R.string.SaveToDownloads))
								options.add(OPTION_SAVE_TO_DOWNLOADS_OR_MUSIC)
								icons.add(R.drawable.msg_download)
								items.add(context.getString(R.string.ShareFile))
								options.add(OPTION_SHARE)
								icons.add(R.drawable.msg_shareout)
							}
						}
						else if (type == 10) {
							items.add(context.getString(R.string.ApplyThemeFile))
							options.add(OPTION_APPLY_LOCALIZATION_OR_THEME)
							icons.add(R.drawable.msg_theme)

							if (!noforwards) {
								items.add(context.getString(R.string.SaveToDownloads))
								options.add(OPTION_SAVE_TO_DOWNLOADS_OR_MUSIC)
								icons.add(R.drawable.msg_download)
								items.add(context.getString(R.string.ShareFile))
								options.add(OPTION_SHARE)
								icons.add(R.drawable.msg_shareout)
							}
						}
						else if (type == 6 && !noforwards && !selectedObject!!.hasRevealedExtendedMedia()) {
							items.add(context.getString(R.string.SaveToGallery))
							options.add(OPTION_SAVE_TO_GALLERY2)
							icons.add(R.drawable.msg_gallery)
							items.add(context.getString(R.string.SaveToDownloads))
							options.add(OPTION_SAVE_TO_DOWNLOADS_OR_MUSIC)
							icons.add(R.drawable.msg_download)
							items.add(context.getString(R.string.ShareFile))
							options.add(OPTION_SHARE)
							icons.add(R.drawable.msg_shareout)
						}
						else if (type == 7) {
							if (selectedObject!!.isMask) {
								items.add(context.getString(R.string.AddToMasks))
								options.add(OPTION_ADD_TO_STICKERS_OR_MASKS)
								icons.add(R.drawable.msg_sticker)
							}
							else {
								items.add(context.getString(R.string.AddToStickers))
								options.add(OPTION_ADD_TO_STICKERS_OR_MASKS)
								icons.add(R.drawable.msg_sticker)
								val document = selectedObject!!.document

								if (!mediaDataController.isStickerInFavorites(document)) {
									if (mediaDataController.canAddStickerToFavorites() && MessageObject.isStickerHasSet(document)) {
										items.add(context.getString(R.string.AddToFavorites))
										options.add(OPTION_ADD_STICKER_TO_FAVORITES)
										icons.add(R.drawable.msg_fave)
									}
								}
								else {
									items.add(context.getString(R.string.DeleteFromFavorites))
									options.add(OPTION_DELETE_STICKER_FROM_FAVORITES)
									icons.add(R.drawable.msg_unfave)
								}
							}
						}
						else if (type == 8) {
							val uid = selectedObject?.messageOwner?.media?.user_id ?: 0L
							var user: User? = null

							if (uid != 0L) {
								user = MessagesController.getInstance(currentAccount).getUser(uid)
							}

							if (user != null && user.id != userConfig.getClientUserId() && contactsController.contactsDict[user.id] == null) {
								items.add(context.getString(R.string.AddContactTitle))
								options.add(OPTION_ADD_CONTACT)
								icons.add(R.drawable.msg_addcontact)
							}

							if (!selectedObject?.messageOwner?.media?.phone_number.isNullOrEmpty()) { // MARK: we use phone number for username, so check if this works properly
								if (!noforwards) {
									items.add(context.getString(R.string.Copy))
									options.add(OPTION_COPY_PHONE_NUMBER)
									icons.add(R.drawable.msg_copy)
								}

								items.add(context.getString(R.string.Call))
								options.add(OPTION_CALL)
								icons.add(R.drawable.msg_callback)
							}
						}
						else if (type == 9) {
							val document = selectedObject!!.document

							if (!mediaDataController.isStickerInFavorites(document)) {
								if (MessageObject.isStickerHasSet(document)) {
									items.add(context.getString(R.string.AddToFavorites))
									options.add(OPTION_ADD_STICKER_TO_FAVORITES)
									icons.add(R.drawable.msg_fave)
								}
							}
							else {
								items.add(context.getString(R.string.DeleteFromFavorites))
								options.add(OPTION_DELETE_STICKER_FROM_FAVORITES)
								icons.add(R.drawable.msg_unfave)
							}
						}

						if (allowUnpin) {
							items.add(context.getString(R.string.UnpinMessage))
							options.add(OPTION_UNPIN)
							icons.add(R.drawable.msg_unpin)
						}
						else if (allowPin) {
							items.add(context.getString(R.string.PinMessage))
							options.add(OPTION_PIN)
							icons.add(R.drawable.msg_pin)
						}

						if (selectedObject != null && selectedObject!!.contentType == 0 && !messageTextToTranslate.isNullOrEmpty() && !selectedObject!!.isAnimatedEmoji && !selectedObject!!.isDice) {
							items.add(context.getString(R.string.TranslateMessage))
							options.add(OPTION_TRANSLATE)
							icons.add(R.drawable.msg_translate)
						}

						if (allowEdit) {
							items.add(context.getString(R.string.Edit))
							options.add(OPTION_EDIT)
							icons.add(R.drawable.msg_edit)
						}

						if (chatMode == MODE_SCHEDULED && selectedObject!!.canEditMessageScheduleTime(currentChat)) {
							items.add(context.getString(R.string.MessageScheduleEditTime))
							options.add(OPTION_EDIT_SCHEDULE_TIME)
							icons.add(R.drawable.msg_calendar2)
						}

						if (chatMode != MODE_SCHEDULED && selectedObject!!.contentType == 0 && selectedObject!!.id > 0 && !selectedObject!!.isOut && (currentChat != null || currentUser != null && currentUser!!.bot)) {
							if (isReplyUser(currentUser)) {
								items.add(context.getString(R.string.BlockContact))
								options.add(OPTION_REPORT_CHAT)
								icons.add(R.drawable.msg_block2)
							}
							else {
								items.add(context.getString(R.string.ReportChat))
								options.add(OPTION_REPORT_CHAT)
								icons.add(R.drawable.ic_error)
							}
						}

						if (message.canDeleteMessage(chatMode == MODE_SCHEDULED, currentChat) && (threadMessageObjects == null || !threadMessageObjects!!.contains(message))) {
							items.add(context.getString(R.string.Delete))
							options.add(OPTION_DELETE)
							icons.add(if (selectedObject?.messageOwner?.ttl_period != 0) R.drawable.msg_delete_auto else R.drawable.msg_delete)
						}
					}
					else {
						if (allowChatActions) {
							items.add(context.getString(R.string.Reply))
							options.add(OPTION_REPLY)
							icons.add(R.drawable.msg_reply)
						}

						if ((selectedObject!!.type == MessageObject.TYPE_COMMON || selectedObject!!.isAnimatedEmoji || selectedObject!!.isAnimatedEmojiStickers || getMessageCaption(selectedObject, selectedObjectGroup) != null) && !noforwards) {
							items.add(context.getString(R.string.Copy))
							options.add(OPTION_COPY)
							icons.add(R.drawable.msg_copy)
						}

						if (!isThreadChat && chatMode != MODE_SCHEDULED && currentChat != null && (currentChat!!.has_link || message.hasReplies()) && currentChat!!.megagroup && message.canViewThread()) {
							if (message.hasReplies()) {
								items.add(LocaleController.formatPluralString("ViewReplies", message.repliesCount))
							}
							else {
								items.add(context.getString(R.string.ViewThread))
							}

							options.add(OPTION_VIEW_REPLIES_OR_THREAD)
							icons.add(R.drawable.msg_viewreplies)
						}

						if (type == 4 && !noforwards && !selectedObject!!.hasRevealedExtendedMedia()) {
							if (selectedObject!!.isVideo) {
								items.add(context.getString(R.string.SaveToGallery))
								options.add(OPTION_SAVE_TO_GALLERY)
								icons.add(R.drawable.msg_gallery)
								items.add(context.getString(R.string.ShareFile))
								options.add(OPTION_SHARE)
								icons.add(R.drawable.msg_shareout)
							}
							else if (selectedObject!!.isMusic) {
								items.add(context.getString(R.string.SaveToMusic))
								options.add(OPTION_SAVE_TO_DOWNLOADS_OR_MUSIC)
								icons.add(R.drawable.msg_download)
								items.add(context.getString(R.string.ShareFile))
								options.add(OPTION_SHARE)
								icons.add(R.drawable.msg_shareout)
							}
							else if (!selectedObject!!.isVideo && selectedObject!!.document != null) {
								items.add(context.getString(R.string.SaveToDownloads))
								options.add(OPTION_SAVE_TO_DOWNLOADS_OR_MUSIC)
								icons.add(R.drawable.msg_download)
								items.add(context.getString(R.string.ShareFile))
								options.add(OPTION_SHARE)
								icons.add(R.drawable.msg_shareout)
							}
							else {
								items.add(context.getString(R.string.SaveToGallery))
								options.add(OPTION_SAVE_TO_GALLERY)
								icons.add(R.drawable.msg_gallery)
							}
						}
						else if (type == 5) {
							items.add(context.getString(R.string.ApplyLocalizationFile))
							options.add(OPTION_APPLY_LOCALIZATION_OR_THEME)
							icons.add(R.drawable.msg_language)
						}
						else if (type == 10) {
							items.add(context.getString(R.string.ApplyThemeFile))
							options.add(OPTION_APPLY_LOCALIZATION_OR_THEME)
							icons.add(R.drawable.msg_theme)
						}
						else if (type == 7) {
							items.add(context.getString(R.string.AddToStickers))
							options.add(OPTION_ADD_TO_STICKERS_OR_MASKS)
							icons.add(R.drawable.msg_sticker)
						}
						else if (type == 8) {
							val uid = selectedObject?.messageOwner?.media?.user_id ?: 0L
							var user: User? = null

							if (uid != 0L) {
								user = MessagesController.getInstance(currentAccount).getUser(uid)
							}

							if (user != null && user.id != userConfig.getClientUserId() && contactsController.contactsDict[user.id] == null) {
								items.add(context.getString(R.string.AddContactTitle))
								options.add(OPTION_ADD_CONTACT)
								icons.add(R.drawable.msg_addcontact)
							}

							if (!selectedObject?.messageOwner?.media?.phone_number.isNullOrEmpty()) {
								if (!noforwards) {
									items.add(context.getString(R.string.Copy))
									options.add(OPTION_COPY_PHONE_NUMBER)
									icons.add(R.drawable.msg_copy)
								}

								items.add(context.getString(R.string.Call))
								options.add(OPTION_CALL)
								icons.add(R.drawable.msg_callback)
							}
						}

						items.add(context.getString(R.string.Delete))
						options.add(OPTION_DELETE)
						icons.add(if (selectedObject?.messageOwner?.ttl_period != 0) R.drawable.msg_delete_auto else R.drawable.msg_delete)
					}
				}
			}

			if (options.isEmpty() && optionsView == null) {
				return false
			}

			if (scrimPopupWindow != null) {
				closeMenu()
				menuDeleteItem = null
				scrimPopupWindowItems = null
				return false
			}

			val waitForLangDetection = AtomicBoolean(false)
			val onLangDetectionDone = AtomicReference<Runnable?>(null)
			val rect = Rect()
			val availableReacts = mediaDataController.enabledReactionsList
			val isReactionsViewAvailable = !isSecretChat && !isInScheduleMode && currentUser == null && message.hasReactions() && (!isChannel(currentChat) || currentChat!!.megagroup) && availableReacts.isNotEmpty() && message.messageOwner!!.originalReactions!!.canSeeList && !message.isSecretMedia

			val isReactionsAvailable = if (currentUser != null) {
				false // MARK: this disables reactions for private chats
			}
			else if (message.isForwardedChannelPost) {
				val chatInfo = messagesController.getChatFull(-message.fromChatId)

				if (chatInfo == null) {
					true
				}
				else {
					!isSecretChat && !isInScheduleMode && message.isReactionsAvailable && chatInfo.available_reactions !is TL_chatReactionsNone && availableReacts.isNotEmpty()
				}
			}
			else {
				!message.isSecretMedia && !isSecretChat && !isInScheduleMode && message.isReactionsAvailable && (currentChatInfo != null && currentChatInfo!!.available_reactions !is TL_chatReactionsNone || currentChatInfo == null && !isChannel(currentChat) || currentUser != null) && availableReacts.isNotEmpty()
			}

			val showMessageSeen = !isReactionsViewAvailable && !isInScheduleMode && currentChat != null && message.isOutOwner && message.isSent && !message.isEditing && !message.isSending && !message.isSendError && !message.isContentUnread && !message.isUnread && ConnectionsManager.getInstance(currentAccount).currentTime - message.messageOwner!!.date < messagesController.chatReadMarkExpirePeriod && (isMegagroup(currentChat) || !isChannel(currentChat)) && currentChatInfo != null && currentChatInfo!!.participants_count <= messagesController.chatReadMarkSizeThreshold && message.messageOwner!!.action !is TL_messageActionChatJoinedByRequest && v is ChatMessageCell
			var flags = 0

			if (isReactionsViewAvailable || showMessageSeen) {
				flags = flags or ActionBarPopupWindowLayout.FLAG_USE_SWIPE_BACK
			}

			val popupLayout = ActionBarPopupWindowLayout(parentActivity!!, R.drawable.popup_fixed_alert, flags)
			popupLayout.minimumWidth = AndroidUtilities.dp(200f)

			val backgroundPaddings = Rect()

			val shadowDrawable = ResourcesCompat.getDrawable(context.resources, R.drawable.popup_fixed_alert, null)?.mutate()
			shadowDrawable?.getPadding(backgroundPaddings)

			popupLayout.setBackgroundColor(context.getColor(R.color.background))

			val messageSeenView: MessageSeenView
			var addGap = false

			if (optionsView == null) {
				if (isReactionsViewAvailable) {
					val reactedView = ReactedHeaderView(context, currentAccount, message)
					var count = 0

					if (message.messageOwner?.originalReactions != null) {
						for (r in message.messageOwner!!.originalReactions!!.results) {
							count += r.count
						}
					}

					val hasHeader = count > 10 && message.messageOwner!!.originalReactions!!.results.size > 1

					val linearLayout = ContainerLinerLayout(context)
					linearLayout.hasHeader = hasHeader
					linearLayout.orientation = LinearLayout.VERTICAL
					linearLayout.layoutParams = FrameLayout.LayoutParams(AndroidUtilities.dp(200f), AndroidUtilities.dp((6 * 48 + if (hasHeader) 44 * 2 + 8 else 44).toFloat()) + if (!hasHeader) 1 else 0)

					val backCell = ActionBarMenuSubItem(parentActivity!!, top = true, bottom = false)
					backCell.setItemHeight(44)
					backCell.setTextAndIcon(context.getString(R.string.Back), R.drawable.msg_arrow_back)
					backCell.textView.setPadding(if (LocaleController.isRTL) 0 else AndroidUtilities.dp(40f), 0, if (LocaleController.isRTL) AndroidUtilities.dp(40f) else 0, 0)

					backCell.setOnClickListener {
						popupLayout.swipeBack?.closeForeground()
					}

					linearLayout.addView(backCell, createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT))

					val foregroundIndex = IntArray(1)
					var reactedUsersListView: ReactedUsersListView? = null

					if (hasHeader) {
						val counters: List<ReactionCount> = message.messageOwner?.originalReactions?.results ?: listOf()

						val tabsView = LinearLayout(context)
						tabsView.orientation = LinearLayout.HORIZONTAL

						val pager = ViewPager(context)
						val tabsScrollView = HorizontalScrollView(context)
						val suppressTabsScroll = AtomicBoolean()
						val showAllReactionsTab = counters.size > 1
						val size = counters.size + if (showAllReactionsTab) 1 else 0

						for (i in 0 until size) {
							val hv = ReactionTabHolderView(context)
							var index = i

							if (showAllReactionsTab) {
								index--
							}

							if (index < 0) {
								hv.setCounter(count)
							}
							else {
								hv.setCounter(currentAccount, counters[index])
							}

							hv.setOnClickListener {
								val from = pager.currentItem

								if (i == from) {
									return@setOnClickListener
								}

								val fv = tabsView.getChildAt(from) as ReactionTabHolderView

								suppressTabsScroll.set(true)

								pager.setCurrentItem(i, true)

								val fSX = tabsScrollView.scrollX.toFloat()
								val tSX = hv.x - (tabsScrollView.width - hv.width) / 2f

								val a = ValueAnimator.ofFloat(0f, 1f).setDuration(150)
								a.interpolator = CubicBezierInterpolator.DEFAULT

								a.addUpdateListener {
									val f = it.animatedValue as Float
									tabsScrollView.scrollX = (fSX + (tSX - fSX) * f).toInt()
									fv.setOutlineProgress(1f - f)
									hv.setOutlineProgress(f)
								}

								a.start()
							}

							tabsView.addView(hv, createFrameRelatively(LayoutHelper.WRAP_CONTENT.toFloat(), LayoutHelper.MATCH_PARENT.toFloat(), Gravity.CENTER_VERTICAL, (if (i == 0) 6 else 0).toFloat(), 6f, 6f, 6f))
						}

						tabsScrollView.isHorizontalScrollBarEnabled = false
						tabsScrollView.addView(tabsView)

						linearLayout.addView(tabsScrollView, createLinear(LayoutHelper.MATCH_PARENT, 44))

						val divider: View = FrameLayout(context)
						divider.setBackgroundResource(R.color.divider)

						linearLayout.addView(divider, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, Theme.dividerPaint.strokeWidth.toInt()))

						val head = AndroidUtilities.dp((44 * 2).toFloat()) + 1
						val cachedViews = SparseArray<ReactedUsersListView>()
						val cachedHeights = SparseIntArray()

						for (i in 0 until counters.size + 1) {
							cachedHeights.put(i, head + AndroidUtilities.dp((ReactedUsersListView.ITEM_HEIGHT_DP * ReactedUsersListView.VISIBLE_ITEMS).toFloat()))
						}

						val finalCount = count

						pager.adapter = object : PagerAdapter() {
							override fun getCount(): Int {
								return size
							}

							override fun isViewFromObject(view: View, `object`: Any): Boolean {
								return view === `object`
							}

							override fun instantiateItem(container: ViewGroup, position: Int): Any {
								val cached = cachedViews[position]

								if (cached != null) {
									container.addView(cached)
									return cached
								}

								var index = position

								if (showAllReactionsTab) {
									index--
								}

								var reactionCount: ReactionCount? = null

								if (index >= 0) {
									reactionCount = counters[index]
								}

								@Suppress("NAME_SHADOWING") val v = ReactedUsersListView(container.context, currentAccount, message, reactionCount, true).setSeenUsers(reactedView.getSeenUsers()).setOnCustomEmojiSelectedListener { _, customEmojiStickerSets ->
									val alert: EmojiPacksAlert = object : EmojiPacksAlert(this@ChatActivity, parentActivity, customEmojiStickerSets) {
										override fun dismiss() {
											super.dismiss()
											dimBehindView(false)
										}
									}

									alert.setCalcMandatoryInsets(isKeyboardVisible)
									alert.setDimBehind(false)
									closeMenu(false)
									showDialog(alert)
								}.setOnProfileSelectedListener { _, userId, _ ->
									// MARK: open profile
									val args = Bundle()
									args.putLong("user_id", userId)
									args.putInt("report_reaction_message_id", message.id)
									args.putLong("report_reaction_from_dialog_id", dialogId)

									val fragment = ProfileActivity(args)

									presentFragment(fragment)

									closeMenu()
								}.setOnHeightChangedListener { _, newHeight ->
									cachedHeights.put(position, head + newHeight)

									if (pager.currentItem == position) {
										popupLayout.swipeBack?.setNewForegroundHeight(foregroundIndex[0], head + newHeight, true)
									}
								}

								if (index < 0) {
									v.setPredictiveCount(finalCount)

									reactedView.setSeenCallback {
										v.setSeenUsers(it)
									}
								}

								container.addView(v)
								cachedViews.put(position, v)

								return v
							}

							override fun destroyItem(container: ViewGroup, position: Int, `object`: Any) {
								container.removeView(`object` as View)
							}
						}

						pager.addOnPageChangeListener(object : OnPageChangeListener {
							override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) {
								if (!suppressTabsScroll.get()) {
									var fX = -1f
									var tX = -1f

									for (i in 0 until tabsView.childCount) {
										val ch = tabsView.getChildAt(i) as ReactionTabHolderView
										ch.setOutlineProgress(if (i == position) 1f - positionOffset else if (i == (position + 1) % size) positionOffset else 0f)

										if (i == position) {
											fX = ch.x - (tabsScrollView.width - ch.width) / 2f
										}

										if (i == position + 1) {
											tX = ch.x - (tabsScrollView.width - ch.width) / 2f
										}
									}

									if (fX != -1f && tX != -1f) {
										tabsScrollView.scrollX = (fX + (tX - fX) * positionOffset).toInt()
									}

									val fromHeight = cachedHeights[position, 0]
									val toHeight = cachedHeights[position + 1, 0]

									popupLayout.swipeBack?.setNewForegroundHeight(foregroundIndex[0], (fromHeight * (1f - positionOffset) + toHeight * positionOffset).toInt(), false)
								}
							}

							override fun onPageSelected(position: Int) {
								val h = cachedHeights[position]
								popupLayout.swipeBack?.setNewForegroundHeight(foregroundIndex[0], h, true)
							}

							override fun onPageScrollStateChanged(state: Int) {
								if (state == ViewPager.SCROLL_STATE_IDLE) {
									suppressTabsScroll.set(false)
								}
							}
						})

						linearLayout.addView(pager, createLinear(LayoutHelper.MATCH_PARENT, 0, 1f))
					}
					else {
						val gap: View = FrameLayout(context)
						gap.setBackgroundColor(context.getColor(R.color.divider))

						linearLayout.addView(gap, createLinear(LayoutHelper.MATCH_PARENT, 8))

						reactedUsersListView = ReactedUsersListView(context, currentAccount, message, null, true).setSeenUsers(reactedView.getSeenUsers()).setOnCustomEmojiSelectedListener { _, customEmojiStickerSets ->
							val alert: EmojiPacksAlert = object : EmojiPacksAlert(this@ChatActivity, parentActivity, customEmojiStickerSets) {
								override fun dismiss() {
									super.dismiss()
									dimBehindView(false)
								}
							}

							alert.setCalcMandatoryInsets(isKeyboardVisible)
							alert.setDimBehind(false)

							closeMenu(false)

							showDialog(alert)
						}.setOnProfileSelectedListener { _, userId, _ ->
							// MARK: open profile
							val args = Bundle()
							args.putLong("user_id", userId)
							args.putInt("report_reaction_message_id", message.id)
							args.putLong("report_reaction_from_dialog_id", dialogId)

							val fragment = ProfileActivity(args)

							presentFragment(fragment)

							closeMenu()
						}.setOnHeightChangedListener { _, newHeight ->
							popupLayout.swipeBack?.setNewForegroundHeight(foregroundIndex[0], AndroidUtilities.dp((44 + 8).toFloat()) + newHeight, true)
						}

						reactedView.setSeenCallback {
							reactedUsersListView.setSeenUsers(it)
						}

						linearLayout.addView(reactedUsersListView, createLinear(LayoutHelper.MATCH_PARENT, 0, 1f))
					}

					foregroundIndex[0] = popupLayout.addViewToSwipeBack(linearLayout)

					val finalReactedUsersListView = reactedUsersListView

					reactedView.setOnClickListener {
						if (finalReactedUsersListView == null || finalReactedUsersListView.isLoaded) {
							popupLayout.swipeBack?.openForeground(foregroundIndex[0])
						}
					}

					popupLayout.addView(reactedView, createLinear(LayoutHelper.MATCH_PARENT, 48))

					addGap = true
				}

				if (showMessageSeen) {
					messageSeenView = MessageSeenView(context, currentAccount, message, currentChat)

					val messageSeenLayout = FrameLayout(context)
					messageSeenLayout.addView(messageSeenView, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT.toFloat()))

					val cell = ActionBarMenuSubItem(context, top = true, bottom = false)
					cell.setItemHeight(44)
					cell.setTextAndIcon(context.getString(R.string.Back), R.drawable.msg_arrow_back)
					cell.textView.setPadding(if (LocaleController.isRTL) 0 else AndroidUtilities.dp(40f), 0, if (LocaleController.isRTL) AndroidUtilities.dp(40f) else 0, 0)

					val backContainer = FrameLayout(context)

					val linearLayout = LinearLayout(context)
					linearLayout.setBackgroundColor(context.getColor(R.color.background))
					linearLayout.orientation = LinearLayout.VERTICAL

					val listView2 = messageSeenView.createListView()

					backContainer.addView(cell)

					linearLayout.addView(backContainer)

					backContainer.setOnClickListener {
						popupLayout.swipeBack?.closeForeground()
					}

					val foregroundIndex = IntArray(1)

					messageSeenView.setOnClickListener {
						if (scrimPopupWindow == null || messageSeenView.users.isEmpty()) {
							return@setOnClickListener
						}

						if (messageSeenView.users.size == 1) {
							val user = messageSeenView.users[0] ?: return@setOnClickListener

							// MARK: open profile
							val args = Bundle()
							args.putLong("user_id", user.id)

							val fragment = ProfileActivity(args)

							presentFragment(fragment)

							closeMenu()

							return@setOnClickListener
						}

						val totalHeight = contentView!!.heightWithKeyboard
						var availableHeight = totalHeight - scrimPopupY - AndroidUtilities.dp((46 + 16).toFloat()) - if (isReactionsAvailable) AndroidUtilities.dp(52f) else 0

						if (SharedConfig.messageSeenHintCount > 0 && contentView!!.keyboardHeight < AndroidUtilities.dp(20f)) {
							availableHeight -= AndroidUtilities.dp(52f)

							val bulletin = BulletinFactory.of(this@ChatActivity).createErrorBulletin(AndroidUtilities.replaceTags(context.getString(R.string.MessageSeenTooltipMessage)))
							bulletin.tag = 1
							bulletin.setDuration(4000)
							bulletin.show()

							SharedConfig.updateMessageSeenHintCount(SharedConfig.messageSeenHintCount - 1)
						}
						else if (contentView!!.keyboardHeight > AndroidUtilities.dp(20f)) {
							availableHeight -= (contentView!!.keyboardHeight / 3f).toInt()
						}

						listView2.requestLayout()
						linearLayout.requestLayout()

						listView2.adapter?.notifyDataSetChanged()
						popupLayout.swipeBack?.openForeground(foregroundIndex[0])
					}

					linearLayout.addView(listView2, createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT))

					listView2.setOnItemClickListener { _, position ->
						val user = messageSeenView.users[position] ?: return@setOnItemClickListener

						// MARK: open profile
						val args = Bundle()
						args.putLong("user_id", user.id)

						val fragment = ProfileActivity(args)

						presentFragment(fragment)
					}

					foregroundIndex[0] = popupLayout.addViewToSwipeBack(linearLayout)

					popupLayout.addView(messageSeenLayout, createLinear(LayoutHelper.MATCH_PARENT, 44))

					addGap = true
				}

				val showRateTranscription = selectedObject != null && selectedObject!!.isVoice && selectedObject!!.messageOwner != null && userConfig.isPremium && !selectedObject?.messageOwner?.voiceTranscription.isNullOrEmpty() && selectedObject?.messageOwner != null && !selectedObject!!.messageOwner!!.voiceTranscriptionRated && selectedObject!!.messageOwner!!.voiceTranscriptionId != 0L && selectedObject!!.messageOwner!!.voiceTranscriptionOpen

				if (!showRateTranscription && message.probablyRingtone() && currentEncryptedChat == null) {
					val cell = ActionBarMenuSubItem(parentActivity!!, top = true, bottom = false)
					cell.minimumWidth = AndroidUtilities.dp(200f)
					cell.setTextAndIcon(context.getString(R.string.SaveForNotifications), R.drawable.msg_tone_add)

					popupLayout.addView(cell)

					cell.setOnClickListener {
						if (mediaDataController.saveToRingtones(message.document)) {
							undoView?.showWithAction(dialogId, UndoView.ACTION_RINGTONE_ADDED, object : Runnable {
								var clicked = false

								override fun run() {
									if (clicked) {
										return
									}

									clicked = true

									presentFragment(NotificationsSettingsActivity())
								}
							})
						}

						closeMenu(true)
					}

					addGap = true
				}

				if (addGap) {
					val gap: View = FrameLayout(context)
					gap.setBackgroundColor(context.getColor(R.color.divider))

					popupLayout.addView(gap, createLinear(LayoutHelper.MATCH_PARENT, 8))
				}

				popupLayout.swipeBack?.setOnClickListener {
					closeMenu()
				}

				if (showRateTranscription) {
					val rateTranscriptionLayout = LinearLayout(context)
					rateTranscriptionLayout.orientation = LinearLayout.VERTICAL

					val rateTranscriptionLayoutParams = createLinear(LayoutHelper.MATCH_PARENT, 89)
					val rateTranscription = FrameLayout(context)

					val gap: View = FrameLayout(context)
					gap.setBackgroundColor(context.getColor(R.color.divider))

					val textView = TextView(context)
					textView.setTextColor(context.getColor(R.color.dark_gray))
					textView.gravity = Gravity.CENTER_HORIZONTAL
					textView.text = context.getString(R.string.RateTranscription)

					rateTranscription.addView(textView, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.TOP, 0f, 12f, 0f, 0f))

					val ratePositively = BooleanArray(1)
					val loading = BooleanArray(1)

					val rateUp = ImageView(context)
					rateUp.background = Theme.createCircleSelectorDrawable(context.getColor(R.color.light_background), 0, 0)

					var drawable = ResourcesCompat.getDrawable(context.resources, R.drawable.msg_rate_up, null)?.mutate()
					drawable?.colorFilter = PorterDuffColorFilter(context.getColor(R.color.brand), PorterDuff.Mode.SRC_IN)
					drawable = CrossfadeDrawable(drawable, CircularProgressDrawable(AndroidUtilities.dp(12f).toFloat(), AndroidUtilities.dp(1.5f).toFloat(), context.getColor(R.color.brand)))

					rateUp.setImageDrawable(drawable)

					rateTranscription.addView(rateUp, createFrame(33, 33f, Gravity.CENTER_HORIZONTAL or Gravity.TOP, -42f, 39f, 0f, 0f))

					val rateDown = ImageView(context)
					rateDown.background = Theme.createCircleSelectorDrawable(context.getColor(R.color.light_background), 0, 0)

					drawable = ResourcesCompat.getDrawable(context.resources, R.drawable.msg_rate_down, null)?.mutate()
					drawable?.colorFilter = PorterDuffColorFilter(context.getColor(R.color.brand), PorterDuff.Mode.SRC_IN)
					drawable = CrossfadeDrawable(drawable, CircularProgressDrawable(AndroidUtilities.dp(12f).toFloat(), AndroidUtilities.dp(1.5f).toFloat(), context.getColor(R.color.brand)))

					rateDown.setImageDrawable(drawable)

					rateTranscription.addView(rateDown, createFrame(33, 33f, Gravity.CENTER_HORIZONTAL or Gravity.TOP, 42f, 39f, 0f, 0f))

					val rate = Runnable {
						if (loading[0]) {
							return@Runnable
						}

						loading[0] = true

						val progressShown = LongArray(1)
						progressShown[0] = -1

						val showProgress = Runnable {
							progressShown[0] = SystemClock.elapsedRealtime()
							val ldrawable = (if (ratePositively[0]) rateUp else rateDown).drawable as CrossfadeDrawable

							val lva = ValueAnimator.ofFloat(0f, 1f)

							lva.addUpdateListener {
								ldrawable.progress = it.animatedValue as Float
							}

							lva.duration = 150
							lva.interpolator = CubicBezierInterpolator.DEFAULT
							lva.start()
						}

						val req = TL_messages_rateTranscribedAudio()
						req.msg_id = selectedObject!!.id
						req.peer = messagesController.getInputPeer(selectedObject?.messageOwner?.peer_id)
						req.transcription_id = selectedObject?.messageOwner?.voiceTranscriptionId ?: 0L
						req.good = ratePositively[0]

						connectionsManager.sendRequest(req) { _, _ ->
							AndroidUtilities.cancelRunOnUIThread(showProgress)

							selectedObject?.messageOwner?.voiceTranscriptionRated = true

							messagesStorage.updateMessageVoiceTranscriptionOpen(selectedObject!!.dialogId, selectedObject!!.id, selectedObject!!.messageOwner)

							AndroidUtilities.runOnUIThread({
								closeMenu()
								BulletinFactory.of(this@ChatActivity).createSimpleBulletin(R.raw.chats_infotip, context.getString(R.string.TranscriptionReportSent)).show()
							}, if (progressShown[0] > 0) max(0, 300 - (SystemClock.elapsedRealtime() - progressShown[0])) else 0)
						}

						AndroidUtilities.runOnUIThread(showProgress, 150)
					}

					rateUp.setOnClickListener {
						ratePositively[0] = true
						rate.run()
					}

					rateDown.setOnClickListener {
						ratePositively[0] = false
						rate.run()
					}

					rateTranscriptionLayout.addView(rateTranscription, createLinear(LayoutHelper.MATCH_PARENT, 81))
					rateTranscriptionLayout.addView(gap, createLinear(LayoutHelper.MATCH_PARENT, 8))

					popupLayout.addView(rateTranscriptionLayout, rateTranscriptionLayoutParams)
				}

				val translateButtonEnabled = MessagesController.getGlobalMainSettings().getBoolean("translate_button", false)

				scrimPopupWindowItems = arrayOfNulls(items.size + if (selectedObject!!.isSponsored) 1 else 0)

				var a = 0
				val N = items.size

				while (a < N) {
					if (a == 0 && selectedObject!!.isSponsored) {
						val cell = ActionBarMenuSubItem(parentActivity!!, top = true, bottom = true)
						cell.setTextAndIcon(context.getString(R.string.SponsoredMessageInfo), R.drawable.msg_info)
						cell.setItemHeight(56)
						cell.setTag(R.id.width_tag, 240)
						cell.setMultiline()

						scrimPopupWindowItems!![scrimPopupWindowItems!!.size - 1] = cell

						popupLayout.addView(cell)

						cell.setOnClickListener {
							if (contentView == null || parentActivity == null) {
								return@setOnClickListener
							}

							val builder = BottomSheet.Builder(context)
							builder.customView = SponsoredMessageInfoView(parentActivity, null)
							builder.show()
						}

						val gap = View(parentActivity)
						gap.minimumWidth = AndroidUtilities.dp(196f)
						gap.tag = 1000
						gap.setTag(R.id.object_tag, 1)

						popupLayout.addView(gap)

						val layoutParams = cell.layoutParams as LinearLayout.LayoutParams

						if (LocaleController.isRTL) {
							layoutParams.gravity = Gravity.RIGHT
						}

						layoutParams.width = LayoutHelper.MATCH_PARENT
						layoutParams.height = AndroidUtilities.dp(6f)

						gap.layoutParams = layoutParams
					}

					val cell = ActionBarMenuSubItem(parentActivity!!, a == 0, a == N - 1)
					cell.minimumWidth = AndroidUtilities.dp(200f)
					cell.setTextAndIcon(items[a], icons[a])

					if (icons[a] == R.drawable.msg_delete) {
						cell.setIconColor(ResourcesCompat.getColor(context.resources, R.color.purple, null))
					}

					val option = options[a]

					if (option == 1 && selectedObject!!.messageOwner!!.ttl_period != 0) {
						menuDeleteItem = cell
						updateDeleteItemRunnable.run()
						cell.setSubtextColor(context.getColor(R.color.dark_gray))
					}

					scrimPopupWindowItems!![a] = cell

					popupLayout.addView(cell)

					val i = a

					cell.setOnClickListener {
						if (selectedObject == null || i >= options.size) {
							return@setOnClickListener
						}

						processSelectedOption(options[i])
					}

					if (option == OPTION_TRANSLATE) {
						val toLang = LocaleController.getInstance().currentLocale.language
						val finalMessageText = messageTextToTranslate

						val onLinkPress = TranslateAlert.OnLinkPress { link ->
							didPressMessageUrl(link, false, selectedObject, if (v is ChatMessageCell) v else null)
							true
						}

						val inputPeer = messagesController.getInputPeer(dialogId)
						val messageId = selectedObject?.messageOwner?.id ?: 0

						if (LanguageDetector.hasSupport()) {
							val fromLang = arrayOf<String?>(null)
							cell.visibility = View.GONE
							waitForLangDetection.set(true)

							LanguageDetector.detectLanguage(finalMessageText.toString(), { lang ->
								fromLang[0] = lang

								if (fromLang[0] != null && (fromLang[0] != toLang || fromLang[0] == "und") && (translateButtonEnabled && !RestrictedLanguagesSelectActivity.getRestrictedLanguages().contains(fromLang[0]) || currentChat != null && (currentChat!!.has_link || currentChat!!.username != null) && ("uk" == fromLang[0] || "ru" == fromLang[0]))) {
									cell.visibility = View.VISIBLE
								}

								waitForLangDetection.set(false)

								onLangDetectionDone.get()?.run()
								onLangDetectionDone.set(null)
							}) {
								FileLog.e("mlkit: failed to detect language in message")

								waitForLangDetection.set(false)

								onLangDetectionDone.get()?.run()
								onLangDetectionDone.set(null)
							}

							cell.setOnClickListener {
								if (selectedObject == null || i >= options.size || parentActivity == null) {
									return@setOnClickListener
								}

								val alert = TranslateAlert.showAlert(parentActivity, this, currentAccount, inputPeer, messageId, fromLang[0], toLang, finalMessageText, noforwards, onLinkPress) { dimBehindView(false) }
								alert.showDim(false)

								closeMenu(false)
							}

							cell.postDelayed({
								if (onLangDetectionDone.get() != null) {
									onLangDetectionDone.getAndSet(null)!!.run()
								}
							}, 250)
						}
						else if (translateButtonEnabled) {
							cell.setOnClickListener {
								if (selectedObject == null || i >= options.size || parentActivity == null) {
									return@setOnClickListener
								}

								val alert = TranslateAlert.showAlert(parentActivity, this, currentAccount, inputPeer, messageId, "und", toLang, finalMessageText, noforwards, onLinkPress) { dimBehindView(false) }
								alert.showDim(false)

								closeMenu(false)
							}
						}
						else {
							cell.visibility = View.GONE
						}
					}

					a++
				}
			}

			val scrimPopupContainerLayout: ChatScrimPopupContainerLayout = object : ChatScrimPopupContainerLayout(context) {
				override fun dispatchKeyEvent(event: KeyEvent): Boolean {
					if (event.keyCode == KeyEvent.KEYCODE_BACK && event.repeatCount == 0) {
						closeMenu()
					}

					return super.dispatchKeyEvent(event)
				}

				override fun dispatchTouchEvent(ev: MotionEvent): Boolean {
					val b = super.dispatchTouchEvent(ev)

					if (ev.action == MotionEvent.ACTION_DOWN && !b) {
						closeMenu()
					}

					return b
				}
			}

			scrimPopupContainerLayout.setOnTouchListener(object : OnTouchListener {
				private val pos = IntArray(2)

				override fun onTouch(v: View, event: MotionEvent): Boolean {
					if (event.actionMasked == MotionEvent.ACTION_DOWN) {
						if (scrimPopupWindow?.isShowing == true) {
							val contentView = scrimPopupWindow!!.contentView

							contentView.getLocationInWindow(pos)

							rect.set(pos[0], pos[1], pos[0] + contentView.measuredWidth, pos[1] + contentView.measuredHeight)

							if (!rect.contains(event.x.toInt(), event.y.toInt())) {
								closeMenu()
							}
						}
					}
					else if (event.actionMasked == MotionEvent.ACTION_OUTSIDE) {
						closeMenu()
					}

					return false
				}
			})

			var reactionsLayout: ReactionsContainerLayout? = null

			if (optionsView != null) {
				scrimPopupContainerLayout.addView(optionsView)
			}
			else {
				reactionsLayout = ReactionsContainerLayout(this@ChatActivity, context, currentAccount)

				if (isReactionsAvailable) {
					val pad = 22
					val sPad = 24

					reactionsLayout.setPadding(AndroidUtilities.dp(4f) + if (LocaleController.isRTL) 0 else sPad, AndroidUtilities.dp(4f), AndroidUtilities.dp(4f) + if (LocaleController.isRTL) sPad else 0, AndroidUtilities.dp(pad.toFloat()))

					val finalReactionsLayout: ReactionsContainerLayout = reactionsLayout

					reactionsLayout.setDelegate(object : ReactionsContainerLayout.ReactionsContainerDelegate {
						override fun onReactionClicked(view: View?, visibleReaction: VisibleReaction?, longpress: Boolean, addToRecent: Boolean) {
							selectReaction(primaryMessage, finalReactionsLayout, view, 0f, 0f, visibleReaction, false, longpress, addToRecent)
						}

						override fun hideMenu() {
							scrimPopupWindow?.dismiss(false)
						}
					})

					val params = createLinear(LayoutHelper.MATCH_PARENT, 52 + pad, Gravity.RIGHT, 0, 50, 0, -20)

					scrimPopupContainerLayout.addView(reactionsLayout, params)
					scrimPopupContainerLayout.setReactionsLayout(reactionsLayout)
					scrimPopupContainerLayout.clipChildren = false

					reactionsLayout.setMessage(message, currentChatInfo)
					reactionsLayout.setTransitionProgress(0f)

					popupLayout.swipeBack?.addOnSwipeBackProgressListener(object : PopupSwipeBackLayout.OnSwipeBackProgressListener {
						var isEnter = true

						override fun onSwipeBackProgress(layout: PopupSwipeBackLayout, toProgress: Float, progress: Float) {
							if (toProgress == 0f && !isEnter) {
								finalReactionsLayout.startEnterAnimation()
								isEnter = true
							}
							else if (toProgress == 1f && isEnter) {
								finalReactionsLayout.alpha = 1f - progress

								if (progress == 1f) {
									isEnter = false
								}
							}
						}
					})
				}

				val showNoForwards = noforwards && message.messageOwner?.action == null && message.isSent && !message.isEditing && chatMode != MODE_SCHEDULED

				scrimPopupContainerLayout.addView(popupLayout, createLinearRelatively(LayoutHelper.WRAP_CONTENT.toFloat(), LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.LEFT, (if (isReactionsAvailable) 16 else 0).toFloat(), 0f, (if (isReactionsAvailable) 36 else 0).toFloat(), 0f))
				scrimPopupContainerLayout.setPopupWindowLayout(popupLayout)

				if (showNoForwards) {
					popupLayout.measure(MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED), MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED))

					val isChannel = isChannel(currentChat) && !currentChat!!.megagroup

					val tv = TextView(context)
					tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14f)
					tv.setTextColor(context.getColor(R.color.text))

					if (messagesController.isChatNoForwards(currentChat)) {
						tv.text = if (isChannel) context.getString(R.string.ForwardsRestrictedInfoChannel)
						else context.getString(R.string.ForwardsRestrictedInfoGroup)
					}
					else {
						if (message.messageOwner?.is_media_sale == true || message.messageOwner?.is_media_sale_info == true) {
							tv.text = context.getString(R.string.ForwardsRestrictedInfoMessage)
						}
						else {
							tv.text = context.getString(R.string.ForwardsRestrictedInfoBot)
						}
					}

					tv.maxWidth = popupLayout.measuredWidth - AndroidUtilities.dp(38f)

					val shadowDrawable2 = ContextCompat.getDrawable(context, R.drawable.popup_fixed_alert)!!.mutate()
					shadowDrawable2.colorFilter = PorterDuffColorFilter(context.getColor(R.color.background), PorterDuff.Mode.MULTIPLY)

					val fl = FrameLayout(context)
					fl.background = shadowDrawable2
					fl.addView(tv, createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT.toFloat(), 0, 11f, 11f, 11f, 11f))

					scrimPopupContainerLayout.addView(fl, createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT, if (isReactionsAvailable) 16 else 0, -8, if (isReactionsAvailable) 36 else 0, 0))
					scrimPopupContainerLayout.applyViewBottom(fl)
				}

				if (message.contentType == 0) {
					val animatedEmojiSpans1 = if (message.messageText is Spanned) (message.messageText as Spanned).getSpans(0, message.messageText?.length ?: 0, AnimatedEmojiSpan::class.java) else null
					val caption = getMessageCaption(selectedObject, selectedObjectGroup)
					val animatedEmojiSpans2 = if (caption is Spanned) caption.getSpans(0, caption.length, AnimatedEmojiSpan::class.java) else null
					val animatedEmojiCount = (animatedEmojiSpans1?.size ?: 0) + (animatedEmojiSpans2?.size ?: 0)

					if (animatedEmojiCount > 0) {
						val stickerSets = mutableListOf<InputStickerSet>()
						val firstCount = animatedEmojiSpans1?.size ?: 0

						for (i in 0 until animatedEmojiCount) {
							val span = if (i < firstCount) animatedEmojiSpans1!![i] else animatedEmojiSpans2!![i - firstCount]

							if (span == null || span.standard) {
								continue
							}

							val document = if (span.document == null) AnimatedEmojiDrawable.findDocument(currentAccount, span.documentId) else span.document
							val stickerSet = MessageObject.getInputStickerSet(document) ?: continue
							var found = false

							for (j in stickerSets.indices) {
								if (stickerSets[j].id == stickerSet.id) {
									found = true
									break
								}
							}

							if (!found) {
								stickerSets.add(stickerSet)
							}
						}

						if (stickerSets.size > 0 && !messagesController.premiumLocked) {
							val gap: View = FrameLayout(context)
							gap.setBackgroundColor(context.getColor(R.color.divider))

							popupLayout.addView(gap, createLinear(LayoutHelper.MATCH_PARENT, 8))

							val button: View = MessageContainsEmojiButton(currentAccount, context, stickerSets, MessageContainsEmojiButton.EMOJI_TYPE)

							button.setOnClickListener {
								val alert: EmojiPacksAlert = object : EmojiPacksAlert(this@ChatActivity, parentActivity, stickerSets) {
									override fun dismiss() {
										super.dismiss()
										dimBehindView(false)
									}
								}

								alert.setCalcMandatoryInsets(isKeyboardVisible)
								alert.setDimBehind(false)

								closeMenu(false)

								showDialog(alert)
							}

							popupLayout.addView(button, createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT))
						}
					}
				}
			}

			val finalReactionsLayout1 = reactionsLayout

			scrimPopupWindow = object : ActionBarPopupWindow(scrimPopupContainerLayout, LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT) {
				override fun dismiss() {
					super.dismiss()

					if (scrimPopupWindow !== this) {
						return
					}

					scrimPopupWindow = null
					menuDeleteItem = null
					scrimPopupWindowItems = null

					chatLayoutManager?.setCanScrollVertically(true)

					if (scrimPopupWindowHideDimOnDismiss) {
						dimBehindView(false)
					}
					else {
						scrimPopupWindowHideDimOnDismiss = true
					}

					chatActivityEnterView?.editField?.setAllowDrawCursor(true)
				}

				override fun dismiss(animated: Boolean) {
					super.dismiss(animated)
					finalReactionsLayout1?.dismissParent(animated)
				}
			}

			scrimPopupWindow?.setPauseNotifications(true)
			scrimPopupWindow?.setDismissAnimationDuration(220)
			scrimPopupWindow?.isOutsideTouchable = true
			scrimPopupWindow?.isClippingEnabled = true
			scrimPopupWindow?.animationStyle = R.style.PopupContextAnimation
			scrimPopupWindow?.isFocusable = true

			scrimPopupContainerLayout.measure(MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(1000f), MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(1000f), MeasureSpec.AT_MOST))

			scrimPopupWindow?.inputMethodMode = PopupWindow.INPUT_METHOD_NOT_NEEDED
			scrimPopupWindow?.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING
			scrimPopupWindow?.contentView?.isFocusableInTouchMode = true

			popupLayout.setFitItems(true)

			var popupX = v!!.left + x.toInt() - scrimPopupContainerLayout.measuredWidth + backgroundPaddings.left - AndroidUtilities.dp(28f)

			if (popupX < AndroidUtilities.dp(6f)) {
				popupX = AndroidUtilities.dp(6f)
			}
			else if (popupX > chatListView!!.measuredWidth - AndroidUtilities.dp(6f) - scrimPopupContainerLayout.measuredWidth) {
				popupX = chatListView!!.measuredWidth - AndroidUtilities.dp(6f) - scrimPopupContainerLayout.measuredWidth
			}

			if (AndroidUtilities.isTablet()) {
				val location = IntArray(2)
				fragmentView!!.getLocationInWindow(location)
				popupX += location[0]
			}

			var totalHeight = contentView!!.height
			val height = scrimPopupContainerLayout.measuredHeight + AndroidUtilities.dp(48f)
			val keyboardHeight = contentView!!.measureKeyboardHeight()

			if (keyboardHeight > AndroidUtilities.dp(20f)) {
				totalHeight += keyboardHeight
			}

			var popupY: Int

			if (height < totalHeight) {
				popupY = (chatListView!!.y + v.top + y).toInt()

				if (height - backgroundPaddings.top - backgroundPaddings.bottom > AndroidUtilities.dp(240f)) {
					popupY += AndroidUtilities.dp(240f) - height
				}

				if (popupY < chatListView!!.y + AndroidUtilities.dp(24f)) {
					popupY = (chatListView!!.y + AndroidUtilities.dp(24f)).toInt()
				}
				else if (popupY > totalHeight - height - AndroidUtilities.dp(8f)) {
					popupY = totalHeight - height - AndroidUtilities.dp(8f)
				}
			}
			else {
				popupY = if (inBubbleMode) 0 else AndroidUtilities.statusBarHeight
			}

			val finalPopupX = popupX

			scrimPopupY = popupY

			val finalPopupY = scrimPopupY

			scrimPopupContainerLayout.setMaxHeight(totalHeight - popupY)

			val finalReactionsLayout = reactionsLayout

			val showMenu = Runnable {
				if (scrimPopupWindow == null || fragmentView == null || scrimPopupWindow?.isShowing == true) {
					return@Runnable
				}

				scrimPopupWindow?.showAtLocation(chatListView!!, Gravity.LEFT or Gravity.TOP, finalPopupX, finalPopupY)

				if (isReactionsAvailable && finalReactionsLayout != null) {
					finalReactionsLayout.startEnterAnimation()
				}

				AndroidUtilities.runOnUIThread({
					val scrimItem = scrimPopupWindowItems?.firstOrNull() ?: return@runOnUIThread
					scrimItem.requestFocus()
					scrimItem.performAccessibilityAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null)
					scrimItem.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_FOCUSED)
				}, 420)
			}

			if (waitForLangDetection.get()) {
				onLangDetectionDone.set(showMenu)
			}
			else {
				showMenu.run()
			}

			chatListView?.stopScroll()
			chatLayoutManager?.setCanScrollVertically(false)

			dimBehindView(v, true)

			hideHints(false)

			topUndoView?.hide(true, 1)
			undoView?.hide(true, 1)
			chatActivityEnterView?.editField?.setAllowDrawCursor(false)

			return true
		}

		if (chatActivityEnterView != null && (chatActivityEnterView!!.isRecordingAudioVideo() || chatActivityEnterView!!.isRecordLocked)) {
			return false
		}

		val actionMode = actionBar!!.createActionMode()

		val item: View? = actionMode.getItem(delete)

		if (item != null) {
			item.visibility = View.VISIBLE
		}

		bottomMessagesActionContainer?.visibility = View.VISIBLE

		val translationY = chatActivityEnterView!!.measuredHeight - AndroidUtilities.dp(51f)

		if (chatActivityEnterView?.visibility == View.VISIBLE) {
			val views = mutableListOf<View>()
			views.add(chatActivityEnterView!!)

			if (mentionContainer?.visibility == View.VISIBLE) {
				views.add(mentionContainer!!)
			}

			if (suggestEmojiPanel?.visibility == View.VISIBLE) {
				views.add(suggestEmojiPanel!!)
			}

			actionBar?.showActionMode(true, bottomMessagesActionContainer, null, views.toTypedArray(), booleanArrayOf(false, true, true), chatListView, translationY)

			(parentActivity as? LaunchActivity)?.hideVisibleActionMode()

			chatActivityEnterView?.editField?.setAllowDrawCursor(false)
		}
		else if (bottomOverlayChat?.visibility == View.VISIBLE) {
			actionBar?.showActionMode(true, bottomMessagesActionContainer, null, arrayOf<View?>(bottomOverlayChat), booleanArrayOf(true), chatListView, translationY)
		}
		else {
			actionBar?.showActionMode(true, bottomMessagesActionContainer, null, null, null, chatListView, translationY)
		}

		closeMenu()

		chatLayoutManager?.setCanScrollVertically(true)

		updatePinnedMessageView(true)

		val animatorSet = AnimatorSet()
		val animators = mutableListOf<Animator>()

		for (a in actionModeViews.indices) {
			val view = actionModeViews[a]
			view.pivotY = (ActionBar.getCurrentActionBarHeight() / 2).toFloat()
			AndroidUtilities.clearDrawableAnimation(view)
			animators.add(ObjectAnimator.ofFloat(view, View.SCALE_Y, 0.1f, 1.0f))
		}

		animatorSet.playTogether(animators)
		animatorSet.duration = 250
		animatorSet.start()
		addToSelectedMessages(message, listView)

		chatActivityEnterView?.preventInput = true

		selectedMessagesCountTextView?.setNumber(selectedMessagesIds[0].size() + selectedMessagesIds[1].size(), false)

		updateVisibleRows()

		chatActivityEnterView?.hideBotCommands()

		return false
	}

	fun closeMenu() {
		closeMenu(true)
	}

	private fun closeMenu(hideDim: Boolean) {
		scrimPopupWindowHideDimOnDismiss = hideDim

		scrimPopupWindow?.dismiss()

		if (!hideDim) {
			scrimViewAlphaAnimator?.removeAllListeners()
			scrimViewAlphaAnimator?.cancel()

			scrimViewAlphaAnimator = ValueAnimator.ofFloat(1f, 0f)

			scrimViewAlphaAnimator?.addUpdateListener {
				scrimViewAlpha = it.animatedValue as Float
				if (contentView != null) {
					contentView?.invalidate()
					chatListView?.invalidate()
				}
			}

			scrimViewAlphaAnimator?.duration = 150
			scrimViewAlphaAnimator?.start()
		}
	}

	private fun selectReaction(primaryMessage: MessageObject?, reactionsLayout: ReactionsContainerLayout?, fromView: View?, x: Float, y: Float, visibleReaction: VisibleReaction?, fromDoubleTap: Boolean, bigEmoji: Boolean, addToRecent: Boolean) {
		if (isInScheduleMode) {
			return
		}

		ReactionsEffectOverlay.removeCurrent(false)

		val added = primaryMessage!!.selectReaction(visibleReaction, bigEmoji, fromDoubleTap)
		var messageIdForCell = primaryMessage.id

		if (groupedMessagesMap[primaryMessage.groupId] != null) {
			val flags = if (primaryMessage.shouldDrawReactionsInLayout()) MessageObject.POSITION_FLAG_BOTTOM or MessageObject.POSITION_FLAG_LEFT else MessageObject.POSITION_FLAG_BOTTOM or MessageObject.POSITION_FLAG_RIGHT
			val messageObject = groupedMessagesMap[primaryMessage.groupId]!!.findMessageWithFlags(flags)

			if (messageObject != null) {
				messageIdForCell = messageObject.id
			}
		}

		val finalMessageIdForCell = messageIdForCell

		if (added && !fromDoubleTap) {
			val cell = findMessageCell(finalMessageIdForCell, true)
			ReactionsEffectOverlay.show(this@ChatActivity, reactionsLayout, cell, fromView, x, y, visibleReaction, currentAccount, if (reactionsLayout != null) (if (bigEmoji) ReactionsEffectOverlay.LONG_ANIMATION else ReactionsEffectOverlay.ONLY_MOVE_ANIMATION) else ReactionsEffectOverlay.SHORT_ANIMATION)
		}

		if (added) {
			if (visibleReaction?.emojicon != null) {
				AndroidUtilities.makeAccessibilityAnnouncement(LocaleController.formatString("AccDescrYouReactedWith", R.string.AccDescrYouReactedWith, visibleReaction.emojicon))
			}
		}

		val visibleReactions = primaryMessage.chosenReactions

		sendMessagesHelper.sendReaction(primaryMessage, visibleReactions, if (added) visibleReaction else null, bigEmoji, addToRecent, this@ChatActivity, Runnable {
			if (updateReactionRunnable != null) {
				updateReactionRunnable = null

				if (fromDoubleTap) {
					doOnIdle {
						AndroidUtilities.runOnUIThread({
							val cell = findMessageCell(finalMessageIdForCell, true)

							if (added) {
								ReactionsEffectOverlay.show(this@ChatActivity, reactionsLayout, cell, null, x, y, visibleReaction, currentAccount, ReactionsEffectOverlay.SHORT_ANIMATION)
								ReactionsEffectOverlay.startAnimation()
							}
						}, 50)
					}
				}
				else {
					doOnIdle {
						var messageToUpdate = primaryMessage
						val messageInDict = messagesDict[0][primaryMessage.id]

						if (messageInDict != null && messageInDict !== primaryMessage) {
							messageToUpdate = messagesDict[0][primaryMessage.id]
							messageToUpdate.messageOwner?.reactions = primaryMessage.messageOwner?.originalReactions
						}

						updateMessageAnimated(messageToUpdate, true)

						ReactionsEffectOverlay.startAnimation()
					}
				}
				closeMenu()
			}
		}.also {
			updateReactionRunnable = it
		})

		if (fromDoubleTap) {
			updateMessageAnimated(primaryMessage, true)
			updateReactionRunnable?.run()
		}

		AndroidUtilities.runOnUIThread(updateReactionRunnable, 50)
	}

	@SuppressLint("NotifyDataSetChanged")
	private fun updateMessageAnimated(message: MessageObject?, updateReactions: Boolean) {
		if (chatAdapter == null) {
			return
		}

		notificationCenter.doOnIdle {
			if (fragmentView == null) {
				return@doOnIdle
			}

			val group = groupedMessagesMap[message!!.groupId]

			if (group != null) {
				chatListItemAnimator?.groupWillChanged(group)

				for (i in group.messages.indices) {
					group.messages[i].forceUpdate = true

					if (updateReactions) {
						group.messages[i].reactionsChanged = true
					}
				}

				chatAdapter?.notifyDataSetChanged(true)
			}
			else {
				val messageInList = messagesDict[0][message.id]
				val index = messages.indexOf(messageInList)

				if (updateReactions) {
					message.forceUpdate = true
					message.reactionsChanged = true
				}

				if (index >= 0) {
					chatAdapter?.notifyItemChanged(chatAdapter!!.messagesStartRow + index)
				}
			}
		}
	}

	fun findMessageCell(id: Int, visibleForUser: Boolean): ChatMessageCell? {
		val chatListView = chatListView ?: return null

		for (child in chatListView.children) {
			if ((child as? ChatMessageCell)?.getMessageObject()?.id == id) {
				if (visibleForUser) {
					val clipTop = chatListViewPadding - chatListViewPaddingVisibleOffset - AndroidUtilities.dp(4f)

					if (child.y + child.measuredHeight < clipTop || child.y > chatListView.measuredHeight - blurredViewBottomOffset) {
						return null
					}
				}

				return child
			}
		}

		return null
	}

	private fun startEditingMessageObject(messageObject: MessageObject?) {
		if (messageObject == null || parentActivity == null) {
			return
		}

		if (searchItem != null && actionBar?.isSearchFieldVisible == true) {
			actionBar?.closeSearchField()
			chatActivityEnterView?.setFieldFocused()
		}

		mentionContainer?.adapter?.setNeedBotContext(false)
		chatActivityEnterView?.visibility = View.VISIBLE

		showFieldPanelForEdit(true, messageObject)
		updateBottomOverlay()
		checkEditTimer()

		chatActivityEnterView?.setAllowStickersAndGifs(needAnimatedEmoji = true, needStickers = false, needGifs = false, waitingForKeyboardOpen = true)

		updatePinnedMessageView(true)
		updateVisibleRows()

		if (!messageObject.scheduled) {
			val req = TL_messages_getMessageEditData()
			req.peer = messagesController.getInputPeer(dialogId)
			req.id = messageObject.id

			editingMessageObjectReqId = connectionsManager.sendRequest(req) { response, _ ->
				AndroidUtilities.runOnUIThread {
					editingMessageObjectReqId = 0

					if (response == null) {
						val parentActivity = parentActivity ?: return@runOnUIThread

						val builder = AlertDialog.Builder(parentActivity)
						builder.setTitle(parentActivity.getString(R.string.AppName))
						builder.setMessage(parentActivity.getString(R.string.EditMessageError))
						builder.setPositiveButton(parentActivity.getString(R.string.OK), null)

						showDialog(builder.create())

						if (chatActivityEnterView != null) {
							chatActivityEnterView?.setEditingMessageObject(null, false)
							hideFieldPanel(true)
						}
					}
				}
			}
		}
		else {
			chatActivityEnterView?.showEditDoneProgress(show = false, animated = true)
		}
	}

	fun setupStickerVibrationAndSound(cell: ChatMessageCell) {
		val message = cell.getMessageObject()
		val document = message!!.document
		var isEmoji: Boolean

		if (message.isAnimatedEmoji.also { isEmoji = it } || MessageObject.isAnimatedStickerDocument(document, currentEncryptedChat == null || message.isOut) && !SharedConfig.loopStickers) {
			val imageReceiver = cell.photoImage
			val drawable = imageReceiver.lottieAnimation

			if (drawable != null) {
				if (isEmoji) {
					var emoji = message.stickerEmoji
					emoji = EmojiAnimationsOverlay.unwrapEmoji(emoji)

					if (EmojiData.isHeartEmoji(emoji)) {
						val pattern = HashMap<Int, Int>()
						pattern[1] = 1
						pattern[13] = 0
						pattern[59] = 1
						pattern[71] = 0
						pattern[128] = 1
						pattern[140] = 0

						drawable.setVibrationPattern(pattern)
					}
					else if (EmojiData.isPeachEmoji(emoji)) {
						val pattern = HashMap<Int, Int>()
						pattern[34] = 1

						drawable.setVibrationPattern(pattern)
					}
					else if (EmojiData.isCoffinEmoji(emoji)) {
						val pattern = HashMap<Int, Int>()
						pattern[24] = 0
						pattern[36] = 0

						drawable.setVibrationPattern(pattern)
					}

					if (message.isAnimatedAnimatedEmoji) {
						drawable.resetVibrationAfterRestart(true)
					}

					if (!drawable.isRunning && emoji != null) {
						val sound = messagesController.emojiSounds[emoji.replace("\uFE0F", "")]

						if (sound != null) {
							mediaController.playEmojiSound(accountInstance, emoji, sound, false)
						}
					}
				}
			}
		}
	}

	fun restartSticker(cell: ChatMessageCell) {
		val message = cell.getMessageObject()
		val document = message!!.document

		if (!message.isAnimatedAnimatedEmoji) {
			setupStickerVibrationAndSound(cell)
		}

		if (message.isAnimatedEmoji || MessageObject.isAnimatedStickerDocument(document, currentEncryptedChat == null || message.isOut) && !SharedConfig.loopStickers) {
			val imageReceiver = cell.photoImage
			val drawable = imageReceiver.lottieAnimation
			drawable?.restart()
		}
	}

	private fun getMessageContent(messageObject: MessageObject, previousUid: Long, name: Boolean): CharSequence {
		val str = SpannableStringBuilder()

		if (name) {
			val fromId = messageObject.fromChatId

			if (previousUid != fromId) {
				if (fromId > 0) {
					val user = messagesController.getUser(fromId)

					if (user != null) {
						str.append(formatName(user.first_name, user.last_name)).append(":\n")
					}
				}
				else if (fromId < 0) {
					val chat = messagesController.getChat(-fromId)

					if (chat != null) {
						str.append(chat.title).append(":\n")
					}
				}
			}
		}

		val restrictionReason = MessagesController.getRestrictionReason(messageObject.messageOwner?.restriction_reason)

		if (!restrictionReason.isNullOrEmpty()) {
			str.append(restrictionReason)
		}
		else if (messageObject.caption != null) {
			str.append(messageObject.caption)
		}
		else {
			str.append(messageObject.messageText)
		}

		return str
	}

	private fun unpinMessage(messageObject: MessageObject?) {
		if (messageObject == null) {
			return
		}

		pinBulletin?.hide(false, 0)

		val objects = mutableListOf<MessageObject>()

		selectedObject?.let {
			objects.add(it)
		}

		val ids = listOf(messageObject.id)
		val oldTotalPinnedCount = totalPinnedMessagesCount

		notificationCenter.postNotificationName(NotificationCenter.didLoadPinnedMessages, dialogId, ids, false, null, null, 0, totalPinnedMessagesCount - 1, pinnedEndReached)

		pinBulletin = BulletinFactory.createUnpinMessageBulletin(this, {
			notificationCenter.postNotificationName(NotificationCenter.didLoadPinnedMessages, dialogId, ids, true, objects, null, 0, oldTotalPinnedCount, pinnedEndReached)
			pinBulletin = null
		}) {
			messagesController.pinMessage(currentChat, currentUser, messageObject.id, unpin = true, oneSide = false, notify = false)
			pinBulletin = null
		}.show()
	}

	fun openReportChat(type: Int) {
		val args = Bundle()

		if (DialogObject.isUserDialog(dialogId)) {
			args.putLong("user_id", dialogId)
		}
		else {
			args.putLong("chat_id", -dialogId)
		}

		args.putInt("report", type)

		val fragment = ChatActivity(args)

		presentFragment(fragment)

		fragment.chatActivityDelegate = object : ChatActivityDelegate {
			override fun onReport() {
				undoView?.showWithAction(0, UndoView.ACTION_REPORT_SENT, null)
			}
		}
	}

	private fun saveMessageToGallery(messageObject: MessageObject) {
		var path = messageObject.messageOwner?.attachPath

		if (!path.isNullOrEmpty()) {
			val temp = File(path)

			if (!temp.exists()) {
				path = null
			}
		}

		if (path.isNullOrEmpty()) {
			path = fileLoader.getPathToMessage(messageObject.messageOwner).toString()
		}

		MediaController.saveFile(path, parentActivity, if (messageObject.isVideo) 1 else 0, null, null)
	}

	private fun processSelectedOption(option: Int) {
		if (selectedObject == null || parentActivity == null) {
			return
		}

		var preserveDim = false

		when (option) {
			OPTION_RETRY -> {
				if (selectedObjectGroup != null) {
					var success = true
					var a = 0

					while (a < selectedObjectGroup!!.messages.size) {
						if (!sendMessagesHelper.retrySendMessage(selectedObjectGroup!!.messages[a], false)) {
							success = false
						}

						a++
					}

					if (success && chatMode == 0) {
						moveScrollToLastMessage(false)
					}
				}
				else {
					if (sendMessagesHelper.retrySendMessage(selectedObject!!, false)) {
						updateVisibleRows()

						if (chatMode == 0) {
							moveScrollToLastMessage(false)
						}
					}
				}
			}

			OPTION_DELETE -> {
				if (parentActivity == null) {
					selectedObject = null
					selectedObjectToEditCaption = null
					selectedObjectGroup = null

					return
				}

				preserveDim = true

				createDeleteMessagesAlert(selectedObject, selectedObjectGroup, 1, true)
			}

			OPTION_FORWARD -> {
				forwardingMessage = selectedObject
				forwardingMessageGroup = selectedObjectGroup

				val args = Bundle()
				args.putBoolean("onlySelect", true)
				args.putInt("dialogsType", 3)
				args.putInt("messagesCount", if (forwardingMessageGroup == null) 1 else forwardingMessageGroup!!.messages.size)
				args.putInt("hasPoll", if (forwardingMessage!!.isPoll) (if (forwardingMessage!!.isPublicPoll) 2 else 1) else 0)
				args.putBoolean("hasInvoice", forwardingMessage!!.isInvoice)

				val fragment = DialogsActivity(args)
				fragment.setDelegate(this)

				presentFragment(fragment)
			}

			OPTION_COPY -> {
				if (selectedObject!!.isDice) {
					AndroidUtilities.addToClipboard(selectedObject!!.diceEmoji)
				}
				else {
					val caption = getMessageCaption(selectedObject, selectedObjectGroup)

					if (caption != null) {
						AndroidUtilities.addToClipboard(caption)
					}
					else {
						AndroidUtilities.addToClipboard(getMessageContent(selectedObject!!, 0, false))
					}
				}

				undoView?.showWithAction(0, UndoView.ACTION_MESSAGE_COPIED, null)
			}

			OPTION_SAVE_TO_GALLERY -> {
				if ((Build.VERSION.SDK_INT <= 28 || BuildVars.NO_SCOPED_STORAGE) && parentActivity?.checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
					parentActivity?.requestPermissions(arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE), 4)

					selectedObject = null
					selectedObjectGroup = null
					selectedObjectToEditCaption = null

					return
				}

				if (selectedObjectGroup != null) {
					val filesAmount = selectedObjectGroup!!.messages.size
					var allPhotos = true
					var allVideos = true
					var a = 0

					while (a < filesAmount) {
						val messageObject = selectedObjectGroup!!.messages[a]

						saveMessageToGallery(messageObject)

						allPhotos = allPhotos and messageObject.isPhoto
						allVideos = allVideos and messageObject.isVideo

						a++
					}

					val fileType = if (allPhotos) {
						FileType.PHOTOS
					}
					else if (allVideos) {
						FileType.VIDEOS
					}
					else {
						FileType.MEDIA
					}

					BulletinFactory.of(this).createDownloadBulletin(fileType, filesAmount).show()
				}
				else {
					saveMessageToGallery(selectedObject!!)

					if (parentActivity != null) {
						BulletinFactory.createSaveToGalleryBulletin(this, selectedObject!!.isVideo).show()
					}
				}
			}

			OPTION_APPLY_LOCALIZATION_OR_THEME -> {
				var locFile: File? = null
				val attachPath = selectedObject?.messageOwner?.attachPath

				if (!attachPath.isNullOrEmpty()) {
					val f = File(attachPath)

					if (f.exists()) {
						locFile = f
					}
				}

				if (locFile == null) {
					val f = fileLoader.getPathToMessage(selectedObject!!.messageOwner)

					if (f.exists()) {
						locFile = f
					}
				}

				if (locFile != null) {
					if (locFile.name.lowercase().endsWith("attheme")) {
						val themeInfo = Theme.applyThemeFile(locFile, selectedObject!!.documentName, null, true)

						if (themeInfo != null) {
							presentFragment(ThemePreviewActivity(themeInfo))
						}
						else {
							scrollToPositionOnRecreate = -1

							if (parentActivity == null) {
								selectedObject = null
								selectedObjectGroup = null
								selectedObjectToEditCaption = null

								return
							}

							val builder = AlertDialog.Builder(parentActivity!!)
							builder.setTitle(context!!.getString(R.string.AppName))
							builder.setMessage(context!!.getString(R.string.IncorrectTheme))
							builder.setPositiveButton(context!!.getString(R.string.OK), null)

							preserveDim = true

							builder.setDimEnabled(false)

							builder.setOnPreDismissListener {
								dimBehindView(false)
							}

							showDialog(builder.create())
						}
					}
					else {
						if (LocaleController.getInstance().applyLanguageFile(locFile, currentAccount)) {
							presentFragment(LanguageSelectActivity())
						}
						else {
							if (parentActivity == null) {
								selectedObject = null
								selectedObjectGroup = null
								selectedObjectToEditCaption = null

								return
							}

							val builder = AlertDialog.Builder(parentActivity!!)
							builder.setTitle(context!!.getString(R.string.AppName))
							builder.setMessage(context!!.getString(R.string.IncorrectLocalization))
							builder.setPositiveButton(context!!.getString(R.string.OK), null)

							preserveDim = true

							builder.setDimEnabled(false)

							builder.setOnPreDismissListener {
								dimBehindView(false)
							}

							showDialog(builder.create())
						}
					}
				}
			}

			OPTION_SHARE -> {
				var path = selectedObject?.messageOwner?.attachPath

				if (!path.isNullOrEmpty()) {
					val temp = File(path)

					if (!temp.exists()) {
						path = null
					}
				}

				if (path.isNullOrEmpty()) {
					path = fileLoader.getPathToMessage(selectedObject?.messageOwner).toString()
				}

				val intent = Intent(Intent.ACTION_SEND)
				intent.type = selectedObject?.document?.mime_type

				val f = File(path)

				if (Build.VERSION.SDK_INT >= 24) {
					try {
						intent.putExtra(Intent.EXTRA_STREAM, FileProvider.getUriForFile(parentActivity!!, ApplicationLoader.applicationId + ".provider", f))
						intent.flags = Intent.FLAG_GRANT_READ_URI_PERMISSION
					}
					catch (ignore: Exception) {
						intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(f))
					}
				}
				else {
					intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(f))
				}

				runCatching {
					parentActivity?.startActivityForResult(Intent.createChooser(intent, context!!.getString(R.string.ShareFile)), 500)
				}
			}

			OPTION_SAVE_TO_GALLERY2 -> {
				var path = selectedObject?.messageOwner?.attachPath

				if (!path.isNullOrEmpty()) {
					val temp = File(path)

					if (!temp.exists()) {
						path = null
					}
				}

				if (path.isNullOrEmpty()) {
					path = fileLoader.getPathToMessage(selectedObject?.messageOwner).toString()
				}

				if ((Build.VERSION.SDK_INT <= 28 || BuildVars.NO_SCOPED_STORAGE) && parentActivity?.checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
					parentActivity?.requestPermissions(arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE), 4)

					selectedObject = null
					selectedObjectGroup = null
					selectedObjectToEditCaption = null

					return
				}

				MediaController.saveFile(path, parentActivity, 0, null, null)

				BulletinFactory.createSaveToGalleryBulletin(this, selectedObject!!.isVideo).show()
			}

			OPTION_REPLY -> {
				showFieldPanelForReply(selectedObject)
			}

			OPTION_ADD_TO_STICKERS_OR_MASKS -> {
				val alert = StickersAlert(parentActivity, this, selectedObject!!.inputStickerSet, null, if (bottomOverlayChat!!.visibility != View.VISIBLE && (currentChat == null || canSendStickers(currentChat))) chatActivityEnterView else null)
				alert.setCalcMandatoryInsets(isKeyboardVisible)

				preserveDim = true

				alert.setDimBehind(false)

				alert.setOnDismissListener(Runnable {
					dimBehindView(false)
				})

				showDialog(alert)
			}

			OPTION_SAVE_TO_DOWNLOADS_OR_MUSIC -> {
				if ((Build.VERSION.SDK_INT <= 28 || BuildVars.NO_SCOPED_STORAGE) && parentActivity?.checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
					parentActivity?.requestPermissions(arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE), 4)

					selectedObject = null
					selectedObjectGroup = null
					selectedObjectToEditCaption = null

					return
				}

				val isMusic = selectedObject?.isMusic == true
				val isDocument = selectedObject?.isDocument() == true

				if (isMusic || isDocument) {
					val messageObjects = selectedObjectGroup?.messages?.toList() ?: selectedObject?.let { listOf(it) }

					MediaController.saveFilesFromMessages(parentActivity, accountInstance, messageObjects) { count ->
						if (parentActivity == null || fragmentView == null) {
							return@saveFilesFromMessages
						}

						if (count > 0) {
							BulletinFactory.of(this).createDownloadBulletin(if (isMusic) FileType.AUDIOS else FileType.UNKNOWNS, count).show()
						}
					}
				}
				else {
					val video = selectedObject!!.isVideo
					val photo = selectedObject!!.isPhoto
					val gif = selectedObject!!.isGif
					var fileName = FileLoader.getDocumentFileName(selectedObject!!.document)

					if (fileName.isNullOrEmpty()) {
						fileName = selectedObject?.fileName
					}

					var path = selectedObject?.messageOwner?.attachPath

					if (!path.isNullOrEmpty()) {
						val temp = File(path)

						if (!temp.exists()) {
							path = null
						}
					}

					if (path.isNullOrEmpty()) {
						path = fileLoader.getPathToMessage(selectedObject?.messageOwner).toString()
					}

					MediaController.saveFile(path, parentActivity, 2, fileName, selectedObject?.document?.mime_type ?: "") {
						if (parentActivity == null) {
							return@saveFile
						}

						val fileType = if (photo) {
							FileType.PHOTO_TO_DOWNLOADS
						}
						else if (video) {
							FileType.VIDEO_TO_DOWNLOADS
						}
						else if (gif) {
							FileType.GIF_TO_DOWNLOADS
						}
						else {
							FileType.UNKNOWN
						}

						BulletinFactory.of(this).createDownloadBulletin(fileType).show()
					}
				}
			}

			OPTION_ADD_TO_GIFS -> {
				val document = selectedObject?.document

				messagesController.saveGif(selectedObject, document)

				if (!showGifHint() && parentActivity != null) {
					BulletinFactory.of(this).createDownloadBulletin(FileType.GIF).show()
				}

				chatActivityEnterView?.addRecentGif(document)
			}

			OPTION_EDIT -> {
				if (selectedObjectToEditCaption != null) {
					startEditingMessageObject(selectedObjectToEditCaption)
				}
				else {
					startEditingMessageObject(selectedObject)
				}

				selectedObject = null
				selectedObjectGroup = null
				selectedObjectToEditCaption = null
			}

			OPTION_PIN -> {
				val mid = if (selectedObjectGroup != null && selectedObjectGroup!!.messages.isNotEmpty()) {
					selectedObjectGroup!!.messages[0].id
				}
				else {
					selectedObject!!.id
				}

				val builder = AlertDialog.Builder(parentActivity!!)
				builder.setTitle(context!!.getString(R.string.PinMessageAlertTitle))

				preserveDim = true

				builder.setDimAlpha(.5f)

				builder.setOnPreDismissListener {
					dimBehindView(false)
				}

				val checks: BooleanArray

				if (currentUser != null) {
					if (currentPinnedMessageId != 0 && mid < currentPinnedMessageId) {
						builder.setMessage(context!!.getString(R.string.PinOldMessageAlert))
					}
					else {
						builder.setMessage(context!!.getString(R.string.PinMessageAlertChat))
					}

					checks = booleanArrayOf(false, false)

					if (!isUserSelf(currentUser)) {
						val frameLayout = FrameLayout(parentActivity!!)

						val cell = CheckBoxCell(parentActivity!!, 1)
						cell.background = Theme.getSelectorDrawable(false)
						cell.setText(LocaleController.formatString("PinAlsoFor", R.string.PinAlsoFor, getFirstName(currentUser)), "", checked = false, divider = false)
						cell.setPadding(if (LocaleController.isRTL) AndroidUtilities.dp(8f) else 0, 0, if (LocaleController.isRTL) 0 else AndroidUtilities.dp(8f), 0)

						frameLayout.addView(cell, createFrame(LayoutHelper.MATCH_PARENT, 48f, Gravity.TOP or Gravity.LEFT, 8f, 0f, 8f, 0f))

						cell.setOnClickListener {
							val cell1 = it as CheckBoxCell
							checks[1] = !checks[1]
							cell1.setChecked(checks[1], true)
						}

						builder.setView(frameLayout)
					}
				}
				else if (isChannel(currentChat) && currentChat!!.megagroup || currentChat != null && !isChannel(currentChat)) {
					if (pinnedMessageIds.isNotEmpty() && mid < pinnedMessageIds[0]) {
						builder.setMessage(context!!.getString(R.string.PinOldMessageAlert))
						checks = booleanArrayOf(false, true)
					}
					else {
						builder.setMessage(context!!.getString(R.string.PinMessageAlert))

						checks = booleanArrayOf(true, true)

						val frameLayout = FrameLayout(parentActivity!!)

						val cell = CheckBoxCell(parentActivity!!, 1)
						cell.background = Theme.getSelectorDrawable(false)
						cell.setText(context!!.getString(R.string.PinNotify), "", checked = true, divider = false)
						cell.setPadding(if (LocaleController.isRTL) AndroidUtilities.dp(8f) else 0, 0, if (LocaleController.isRTL) 0 else AndroidUtilities.dp(8f), 0)

						frameLayout.addView(cell, createFrame(LayoutHelper.MATCH_PARENT, 48f, Gravity.TOP or Gravity.LEFT, 8f, 0f, 8f, 0f))

						cell.setOnClickListener {
							val cell1 = it as CheckBoxCell
							checks[0] = !checks[0]
							cell1.setChecked(checks[0], true)
						}

						builder.setView(frameLayout)
					}
				}
				else {
					if (currentPinnedMessageId != 0 && mid < currentPinnedMessageId) {
						builder.setMessage(context!!.getString(R.string.PinOldMessageAlert))
					}
					else {
						builder.setMessage(context!!.getString(R.string.PinMessageAlertChannel))
					}

					checks = booleanArrayOf(false, true)
				}

				builder.setPositiveButton(context!!.getString(R.string.PinMessage)) { _, _ ->
					messagesController.pinMessage(currentChat, currentUser, mid, false, !checks[1], checks[0])

					val bulletin = BulletinFactory.createPinMessageBulletin(this)
					bulletin.show()

					val view = bulletin.layout

					view?.postDelayed({
						view.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP, HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING)
					}, 550)
				}

				builder.setNegativeButton(context!!.getString(R.string.Cancel), null)

				showDialog(builder.create())
			}

			OPTION_UNPIN -> {
				val messageObject = if (pinnedMessageObjects.containsKey(selectedObject!!.id)) {
					selectedObject
				}
				else if (selectedObjectGroup != null && selectedObjectGroup!!.messages.isNotEmpty()) {
					selectedObjectGroup?.messages?.firstOrNull()
				}
				else {
					selectedObject
				}

				if (chatMode == MODE_PINNED && messages.size == 2) {
					finishFragment()
					chatActivityDelegate?.onUnpin(all = false, hide = false)
				}
				else {
					unpinMessage(messageObject)
				}
			}

			OPTION_ADD_CONTACT -> {
				val args = Bundle()
				args.putLong("user_id", selectedObject!!.messageOwner!!.media!!.user_id)
				args.putString("phone", selectedObject!!.messageOwner!!.media!!.phone_number)
				args.putBoolean("addContact", true)

				presentFragment(ContactAddActivity(args))
			}

			OPTION_COPY_PHONE_NUMBER -> {
				AndroidUtilities.addToClipboard(selectedObject?.messageOwner?.media?.phone_number)
			}

			OPTION_CALL -> {
				(selectedObject?.messageOwner?.media as? TL_messageMediaContact)?.let {
					performVoipCallToContact(it)
				}
			}

			OPTION_CALL_AGAIN -> {
				if (currentUser != null) {
					startCall(currentUser!!, selectedObject!!.isVideoCall, currentUserInfo != null && currentUserInfo!!.video_calls_available, parentActivity!!, messagesController.getUserFull(currentUser!!.id), accountInstance)
				}
			}

			OPTION_RATE_CALL -> {
				showRateAlert(parentActivity!!, (selectedObject?.messageOwner?.action as? TL_messageActionPhoneCall))
			}

			OPTION_ADD_STICKER_TO_FAVORITES -> {
				mediaDataController.addRecentSticker(MediaDataController.TYPE_FAVE, selectedObject, selectedObject!!.document!!, (System.currentTimeMillis() / 1000).toInt(), false)
			}

			OPTION_DELETE_STICKER_FROM_FAVORITES -> {
				mediaDataController.addRecentSticker(MediaDataController.TYPE_FAVE, selectedObject, selectedObject!!.document!!, (System.currentTimeMillis() / 1000).toInt(), true)
			}

			OPTION_COPY_LINK -> run {
				val req = TL_channels_exportMessageLink()

				if (selectedObject === replyMessage && isComments) {
					req.id = replyOriginalMessageId
					req.channel = MessagesController.getInputChannel(replyOriginalChat)
				}
				else {
					req.id = selectedObject!!.id
					req.channel = MessagesController.getInputChannel(currentChat)
					req.thread = isReplyChatComment
				}

				connectionsManager.sendRequest(req) { response, _ ->
					AndroidUtilities.runOnUIThread {
						var link: String? = (response as? TLRPC.TL_exportedMessageLink)?.link

						if (link.isNullOrEmpty()) {
							val sourceChat = if (selectedObject === replyMessage && isComments) {
								replyOriginalChat
							}
							else {
								currentChat
							}

							val username = sourceChat?.username?.takeIf { it.isNotEmpty() }

							if (!username.isNullOrEmpty()) {
								link = "https://${context?.getString(R.string.domain)}/$username/${req.id}"
							}
						}

						if (!link.isNullOrEmpty()) {
							try {
								val clipboard = ApplicationLoader.applicationContext.getSystemService(Context.CLIPBOARD_SERVICE) as? android.content.ClipboardManager
								val clip = ClipData.newPlainText("label", link)
								clipboard?.setPrimaryClip(clip)

								if (BulletinFactory.canShowBulletin(this@ChatActivity)) {
									BulletinFactory.of(this@ChatActivity).createCopyLinkBulletin(!isThreadChat && link.contains("/c/")).show()
								}
							}
							catch (e: Exception) {
								FileLog.e(e)
							}
						}
					}
				}
			}

			OPTION_REPORT_CHAT -> {
				if (isReplyUser(currentUser)) {
					if (selectedObject?.messageOwner?.fwd_from != null) {
						preserveDim = true
						AlertsCreator.showBlockReportSpamReplyAlert(this@ChatActivity, selectedObject, MessageObject.getPeerId(selectedObject?.messageOwner?.fwd_from?.from_id)) { dimBehindView(false) }
					}
				}
				else {
					preserveDim = true
					AlertsCreator.createReportAlert(parentActivity, dialogId, selectedObject!!.id, this@ChatActivity) { dimBehindView(false) }
				}
			}

			OPTION_CANCEL_SENDING -> {
				if (selectedObject?.isEditing == true || selectedObject?.isSending == true && selectedObjectGroup == null) {
					sendMessagesHelper.cancelSendingMessage(selectedObject!!)
				}
				else if (selectedObject?.isSending == true && selectedObjectGroup != null) {
					selectedObjectGroup?.messages?.forEach {
						sendMessagesHelper.cancelSendingMessage(it)
					}
				}
			}

			OPTION_UNVOTE -> {
				val progressDialog = arrayOf<AlertDialog?>(AlertDialog(parentActivity!!, 3))

				val requestId = sendMessagesHelper.sendVote(selectedObject, null) {
					runCatching {
						progressDialog[0]?.dismiss()
					}

					progressDialog[0] = null
				}
				if (requestId != 0) {
					AndroidUtilities.runOnUIThread({
						if (progressDialog[0] == null) {
							return@runOnUIThread
						}

						progressDialog[0]?.setOnCancelListener {
							connectionsManager.cancelRequest(requestId, true)
						}

						showDialog(progressDialog[0])
					}, 500)
				}
			}

			OPTION_STOP_POLL_OR_QUIZ -> run {
				val `object`: MessageObject = selectedObject ?: return@run

				val builder = AlertDialog.Builder(parentActivity!!)

				preserveDim = true

				builder.setDimEnabled(false)

				builder.setOnPreDismissListener {
					dimBehindView(false)
				}

				if (`object`.isQuiz) {
					builder.setTitle(context!!.getString(R.string.StopQuizAlertTitle))
					builder.setMessage(context!!.getString(R.string.StopQuizAlertText))
				}
				else {
					builder.setTitle(context!!.getString(R.string.StopPollAlertTitle))
					builder.setMessage(context!!.getString(R.string.StopPollAlertText))
				}

				builder.setPositiveButton(context!!.getString(R.string.Stop)) { _, _ ->
					var progressDialog: AlertDialog? = AlertDialog(parentActivity!!, 3)
					val req = TL_messages_editMessage()
					val mediaPoll = `object`.messageOwner?.media as TL_messageMediaPoll

					val poll = TL_inputMediaPoll()
					poll.poll = TL_poll()
					poll.poll.id = mediaPoll.poll.id
					poll.poll.question = mediaPoll.poll.question
					poll.poll.answers = mediaPoll.poll.answers
					poll.poll.closed = true

					req.media = poll
					req.peer = messagesController.getInputPeer(dialogId)
					req.id = `object`.id
					req.flags = req.flags or 16384

					val requestId = connectionsManager.sendRequest(req) { response, error ->
						AndroidUtilities.runOnUIThread {
							runCatching {
								progressDialog?.dismiss()
							}

							progressDialog = null
						}

						if (error == null) {
							messagesController.processUpdates(response as Updates?, false)
						}
						else {
							AndroidUtilities.runOnUIThread {
								AlertsCreator.processError(currentAccount, error, this@ChatActivity, req)
							}
						}
					}

					AndroidUtilities.runOnUIThread({
						if (progressDialog == null) {
							return@runOnUIThread
						}

						progressDialog?.setOnCancelListener {
							connectionsManager.cancelRequest(requestId, true)
						}

						showDialog(progressDialog)
					}, 500)
				}

				builder.setNegativeButton(context!!.getString(R.string.Cancel), null)
				showDialog(builder.create())
			}

			OPTION_VIEW_REPLIES_OR_THREAD -> {
				openDiscussionMessageChat(currentChat!!.id, null, selectedObject!!.id, 0, -1, 0, null)
			}

			OPTION_STATISTICS -> {
				presentFragment(MessageStatisticActivity(selectedObject!!))
			}

			OPTION_SEND_NOW -> {
				run {
					if (!checkSlowMode(chatActivityEnterView!!.getSendButton())) {
						if (mediaController.isPlayingMessage(selectedObject)) {
							mediaController.cleanupPlayer(true, true)
						}

						val req = TL_messages_sendScheduledMessages()
						req.peer = messagesController.getInputPeer(this.dialogId)

						if (selectedObjectGroup != null) {
							var a = 0

							while (a < selectedObjectGroup!!.messages.size) {
								req.id.add(selectedObjectGroup!!.messages[a].id)
								a++
							}
						}
						else {
							req.id.add(selectedObject!!.id)
						}

						connectionsManager.sendRequest(req) { response, error ->
							if (error == null) {
								val updates = response as Updates?

								messagesController.processUpdates(updates, false)

								AndroidUtilities.runOnUIThread {
									notificationCenter.postNotificationName(NotificationCenter.messagesDeleted, req.id, -this.dialogId, true, this.dialogId)
								}
							}
							else if (error.text != null) {
								AndroidUtilities.runOnUIThread {
									if (error.text.startsWith("SLOWMODE_WAIT_")) {
										AlertsCreator.showSimpleToast(this@ChatActivity, context!!.getString(R.string.SlowmodeSendError))
									}
									else if (error.text == "CHAT_SEND_MEDIA_FORBIDDEN") {
										AlertsCreator.showSimpleToast(this@ChatActivity, context!!.getString(R.string.AttachMediaRestrictedForever))
									}
									else {
										AlertsCreator.showSimpleToast(this@ChatActivity, error.text)
									}
								}
							}
						}

						return@run
					}
				}

				run {
					val message = selectedObject
					val group = selectedObjectGroup

					AlertsCreator.createScheduleDatePickerDialog(parentActivity, this.dialogId, message!!.messageOwner!!.date.toLong(), { _, scheduleDate ->
						if (group != null && group.messages.isNotEmpty()) {
							SendMessagesHelper.getInstance(currentAccount).editMessage(group.messages[0], null, false, this@ChatActivity, null, scheduleDate)
						}
						else {
							SendMessagesHelper.getInstance(currentAccount).editMessage(message, null, false, this@ChatActivity, null, scheduleDate)
						}
					}, null)?.setOnPreDismissListener {
						dimBehindView(false)
					}?.setDimBehind(false)

					preserveDim = true
				}
			}

			OPTION_EDIT_SCHEDULE_TIME -> run {
				val message: MessageObject = selectedObject ?: return@run
				val group = selectedObjectGroup

				AlertsCreator.createScheduleDatePickerDialog(parentActivity, dialogId, message.messageOwner!!.date.toLong(), { _, scheduleDate ->
					if (group != null && group.messages.isNotEmpty()) {
						SendMessagesHelper.getInstance(currentAccount).editMessage(group.messages[0], null, false, this@ChatActivity, null, scheduleDate)
					}
					else {
						SendMessagesHelper.getInstance(currentAccount).editMessage(message, null, false, this@ChatActivity, null, scheduleDate)
					}
				}, null)?.setOnPreDismissListener {
					dimBehindView(false)
				}?.setDimBehind(false)

				preserveDim = true
			}

			OPTION_HIDE_SPONSORED_MESSAGE -> {
				showDialog(PremiumFeatureBottomSheet(this@ChatActivity, PremiumPreviewFragment.PREMIUM_FEATURE_ADS, true))
			}
		}

		selectedObject = null
		selectedObjectGroup = null
		selectedObjectToEditCaption = null

		closeMenu(!preserveDim)
	}

	private var callToThisUser: Long = 0

	private fun performVoipCallToContact(contact: TL_messageMediaContact) {
		val user = TL_user()
		user.id = contact.user_id

		callToThisUser = contact.user_id

		messagesController.loadFullUser(user, classGuid, true)
	}

	override fun didSelectDialogs(dialogsFragment: DialogsActivity?, dids: List<Long>, message: CharSequence?, param: Boolean) {
		if (forwardingMessage == null && selectedMessagesIds[0].size() == 0 && selectedMessagesIds[1].size() == 0) {
			return
		}

		val fmessages = ArrayList<MessageObject>()

		if (forwardingMessage != null) {
			if (forwardingMessageGroup != null) {
				fmessages.addAll(forwardingMessageGroup!!.messages)
			}
			else {
				fmessages.add(forwardingMessage!!)
			}

			forwardingMessage = null
			forwardingMessageGroup = null
		}
		else {
			for (a in 1 downTo 0) {
				val ids = ArrayList<Int>()

				for (b in 0 until selectedMessagesIds[a].size()) {
					ids.add(selectedMessagesIds[a].keyAt(b))
				}

				ids.sort()

				for (b in ids.indices) {
					val id = ids[b]
					val messageObject = selectedMessagesIds[a][id]

					if (messageObject != null) {
						fmessages.add(messageObject)
					}
				}

				selectedMessagesCanCopyIds[a].clear()
				selectedMessagesCanStarIds[a].clear()
				selectedMessagesIds[a].clear()
			}

			hideActionMode()
			updatePinnedMessageView(true)
			updateVisibleRows()
		}

		if (dids.size > 1 || dids[0] == userConfig.getClientUserId() || message != null) {
			forwardingMessages = null

			hideFieldPanel(false)

			for (a in dids.indices) {
				val did = dids[a]

				if (message != null) {
					sendMessagesHelper.sendMessage(message.toString(), did, null, null, null, true, null, null, null, true, 0, null, updateStickersOrder = false, isMediaSale = false, mediaSaleHash = null)
				}

				sendMessagesHelper.sendMessage(fmessages, did, forwardFromMyName = false, hideCaption = false, notify = true, scheduleDate = 0)
			}

			dialogsFragment?.finishFragment()

			if (dids.size == 1) {
				undoView?.showWithAction(dids[0], UndoView.ACTION_FWD_MESSAGES, fmessages.size)
			}
			else {
				undoView?.showWithAction(0, UndoView.ACTION_FWD_MESSAGES, fmessages.size, dids.size, null, null)
			}
		}
		else {
			val did = dids[0]

			if (did != dialogId || chatMode == MODE_PINNED) {
				val args = Bundle()
				args.putBoolean("scrollToTopOnResume", scrollToTopOnResume)

				if (DialogObject.isEncryptedDialog(did)) {
					args.putInt("enc_id", DialogObject.getEncryptedChatId(did))
				}
				else {
					if (DialogObject.isUserDialog(did)) {
						args.putLong("user_id", did)
					}
					else {
						args.putLong("chat_id", -did)
					}

					if (!messagesController.checkCanOpenChat(args, dialogsFragment)) {
						return
					}
				}

				addToPulledDialogsMyself()

				val chatActivity = ChatActivity(args)

				if (presentFragment(chatActivity, true)) {
					chatActivity.showFieldPanelForForward(true, fmessages)

					if (!AndroidUtilities.isTablet()) {
						removeSelfFromStack()
					}
				}
				else {
					dialogsFragment?.finishFragment()
				}
			}
			else {
				dialogsFragment?.finishFragment()

				moveScrollToLastMessage(false)
				showFieldPanelForForward(true, fmessages)

				if (AndroidUtilities.isTablet()) {
					hideActionMode()
					updatePinnedMessageView(true)
				}

				updateVisibleRows()
			}
		}
	}

	fun checkRecordLocked(forceCloseOnDiscard: Boolean): Boolean {
		if (chatActivityEnterView != null && chatActivityEnterView?.isRecordLocked == true) {
			val builder = AlertDialog.Builder(parentActivity!!)

			if (chatActivityEnterView?.isInVideoMode == true) {
				builder.setTitle(context!!.getString(R.string.DiscardVideoMessageTitle))
				builder.setMessage(context!!.getString(R.string.DiscardVideoMessageDescription))
			}
			else {
				builder.setTitle(context!!.getString(R.string.DiscardVoiceMessageTitle))
				builder.setMessage(context!!.getString(R.string.DiscardVoiceMessageDescription))
			}

			builder.setPositiveButton(context!!.getString(R.string.DiscardVoiceMessageAction)) { _, _ ->
				if (chatActivityEnterView != null) {
					if (forceCloseOnDiscard) {
						finishFragment()
					}
					else {
						chatActivityEnterView?.cancelRecordingAudioVideo()
					}
				}
			}

			builder.setNegativeButton(context!!.getString(R.string.Continue), null)

			showDialog(builder.create())

			return true
		}

		return false
	}

	override fun onBackPressed(): Boolean {
		if (ContentPreviewViewer.getInstance().isVisible) {
			ContentPreviewViewer.getInstance().closeWithMenu()
			return false
		}
		else if (forwardingPreviewView != null && forwardingPreviewView?.isShowing == true) {
			forwardingPreviewView?.dismiss(true)
			return false
		}
		else if (messagesSearchListView?.tag != null) {
			showMessagesSearchListView(false)
			return false
		}
		else if (scrimPopupWindow != null) {
			closeMenu()
			return false
		}
		else if (checkRecordLocked(false)) {
			return false
		}
		else if (textSelectionHelper.isSelectionMode) {
			textSelectionHelper.clear()
			return false
		}
		else if (actionBar != null && actionBar?.isActionModeShowed == true) {
			clearSelectionMode()
			return false
		}
		else if (chatActivityEnterView != null && chatActivityEnterView?.isPopupShowing == true) {
			return !chatActivityEnterView!!.hidePopup(true)
		}
		else if (chatActivityEnterView != null && chatActivityEnterView!!.hasBotWebView() && chatActivityEnterView!!.botCommandsMenuIsShowing() && chatActivityEnterView!!.onBotWebViewBackPressed()) {
			return false
		}
		else if (chatActivityEnterView != null && chatActivityEnterView!!.botCommandsMenuIsShowing()) {
			chatActivityEnterView!!.hideBotCommands()
			return false
		}

		if (backToPreviousFragment != null) {
			parentLayout?.fragmentsStack?.add(parentLayout!!.fragmentsStack.size - 1, backToPreviousFragment)
			backToPreviousFragment = null
		}

		return true
	}

	private fun clearSelectionMode() {
		for (a in 1 downTo 0) {
			selectedMessagesIds[a].clear()
			selectedMessagesCanCopyIds[a].clear()
			selectedMessagesCanStarIds[a].clear()
		}

		hideActionMode()
		updatePinnedMessageView(true)
		updateVisibleRows()
	}

	fun onListItemAnimatorTick() {
		invalidateMessagesVisiblePart()

		if (scrimView != null) {
			fragmentView?.invalidate()
		}
	}

	fun setThreadMessages(messageObjects: List<MessageObject>, originalChat: Chat?, originalMessage: Int, maxInboxReadId: Int, maxOutboxReadId: Int) {
		threadMessageObjects = messageObjects
		threadMessage = threadMessageObjects?.lastOrNull()
		replyMessage = threadMessage
		threadMaxInboxReadId = maxInboxReadId
		threadMaxOutboxReadId = maxOutboxReadId
		replyMaxReadId = max(1, maxInboxReadId)
		threadId = threadMessage?.id ?: 0
		replyOriginalMessageId = originalMessage
		replyOriginalChat = originalChat
		isComments = replyMessage?.messageOwner?.fwd_from != null && replyMessage?.messageOwner?.fwd_from?.channel_post != 0
	}

	fun setHighlightMessageId(id: Int) {
		highlightMessageId = id
	}

	val isThreadChat: Boolean
		get() = threadMessage != null

	val isReplyChatComment: Boolean
		get() = threadMessage != null && isComments

	private fun updateVisibleRows() {
		val chatListView = chatListView ?: return

		// var lastVisibleItem = RecyclerView.NO_POSITION
		// int top = 0;

		if (!wasManualScroll && unreadMessageObject != null) {
			val n = chatListView.childCount

			for (i in 0 until n) {
				val child = chatListView.getChildAt(i)

				if (child is ChatMessageCell && child.getMessageObject() === unreadMessageObject) {
					val unreadMessageIndex = messages.indexOf(unreadMessageObject)

					if (unreadMessageIndex >= 0) {
						// lastVisibleItem = chatAdapter!!.messagesStartRow + messages.indexOf(unreadMessageObject)
						// top = chatListView.getMeasuredHeight() - child.getBottom() - chatListView.getPaddingBottom();
					}

					break
				}
			}
		}

		val count = chatListView.childCount
		// MessageObject editingMessageObject = chatActivityEnterView != null ? chatActivityEnterView.getEditingMessageObject() : null;
		val linkedChatId = currentChatInfo?.linked_chat_id ?: 0

		for (a in 0 until count) {
			val view = chatListView.getChildAt(a)

			if (view is ChatMessageCell) {
				val messageObject = view.getMessageObject()
				var disableSelection = false
				var selected = false

				if (actionBar!!.isActionModeShowed || reportType >= 0) {
					view.setCheckBoxVisible(threadMessageObjects == null || !threadMessageObjects!!.contains(messageObject), true)

					val idx = if (messageObject!!.dialogId == dialogId) 0 else 1

					if (selectedMessagesIds[idx].indexOfKey(messageObject.id) >= 0) {
						setCellSelectionBackground(messageObject, view, idx, true)
						selected = true
					}
					else {
						view.setDrawSelectionBackground(false)
						view.setChecked(checked = false, allChecked = false, animated = true)
					}

					disableSelection = true
				}
				else {
					view.setDrawSelectionBackground(false)
					view.setCheckBoxVisible(visible = false, animated = true)
					view.setChecked(checked = false, allChecked = false, animated = true)
				}

				if (!view.getMessageObject()!!.deleted || view.linkedChatId != linkedChatId) {
					view.setIsUpdating(true)
					view.linkedChatId = if (currentChatInfo != null) currentChatInfo!!.linked_chat_id else 0
					view.setMessageObject(view.getMessageObject(), view.currentMessagesGroup, view.isPinnedBottom, view.isPinnedTop)
					view.setIsUpdating(false)
				}

				if (view !== scrimView) {
					view.setCheckPressed(!disableSelection, disableSelection && selected)
				}

				view.setHighlighted(highlightMessageId != Int.MAX_VALUE && messageObject != null && messageObject.id == highlightMessageId)

				if (highlightMessageId != Int.MAX_VALUE) {
					startMessageUnselect()
				}

				if (searchContainer != null && searchContainer!!.visibility == View.VISIBLE && mediaDataController.isMessageFound(messageObject!!.id, messageObject.dialogId == mergeDialogId) && mediaDataController.lastSearchQuery != null) {
					view.setHighlightedText(mediaDataController.lastSearchQuery)
				}
				else {
					view.setHighlightedText(null)
				}

				view.setSpoilersSuppressed(chatListView.scrollState != RecyclerView.SCROLL_STATE_IDLE)
			}
			else if (view is ChatActionCell) {
				val actionMessageObject = view.messageObject!!

				view.setMessageObject(actionMessageObject, collapseForDate = messagesByDays[actionMessageObject.dateKey]?.filter { it.messageOwner?.action == null }.isNullOrEmpty())
				view.setSpoilersSuppressed(chatListView.scrollState != RecyclerView.SCROLL_STATE_IDLE)
			}
		}
	}

	private fun checkEditTimer() {
		if (chatActivityEnterView == null) {
			return
		}

		val messageObject = chatActivityEnterView!!.editingMessageObject

		if (messageObject == null || messageObject.scheduled) {
			return
		}

		if (currentUser != null && currentUser!!.self) {
			return
		}

		val dt = if (messageObject.canEditMessageAnytime(currentChat)) 6 * 60 else messagesController.maxEditTime + 5 * 60 - abs(connectionsManager.currentTime - messageObject.messageOwner!!.date)

		if (dt > 0) {
			if (dt <= 5 * 60) {
				replyObjectTextView?.setText(LocaleController.formatString("TimeToEdit", R.string.TimeToEdit, AndroidUtilities.formatShortDuration(dt)))
			}

			AndroidUtilities.runOnUIThread({
				checkEditTimer()
			}, 1000)
		}
		else {
			chatActivityEnterView?.onEditTimeExpired()
			replyObjectTextView?.setText(LocaleController.formatString("TimeToEditExpired", R.string.TimeToEditExpired))
		}
	}

	private fun createVoiceMessagesPlaylist(startMessageObject: MessageObject?, playingUnreadMedia: Boolean): ArrayList<MessageObject?> {
		val messageObjects = ArrayList<MessageObject?>()
		messageObjects.add(startMessageObject)

		val messageId = startMessageObject!!.id

		if (messageId != 0) {
			for (a in messages.indices.reversed()) {
				val messageObject = messages[a]

				if (messageObject.dialogId == mergeDialogId && startMessageObject.dialogId != mergeDialogId) {
					continue
				}

				if ((currentEncryptedChat == null && messageObject.id > messageId || currentEncryptedChat != null && messageObject.id < messageId) && (messageObject.isVoice || messageObject.isRoundVideo) && (!playingUnreadMedia || messageObject.isContentUnread && !messageObject.isOut)) {
					messageObjects.add(messageObject)
				}
			}
		}

		return messageObjects
	}

	private fun alertUserOpenError(message: MessageObject) {
		val parentActivity = parentActivity ?: return

		val builder = AlertDialog.Builder(parentActivity)
		builder.setTitle(context!!.getString(R.string.AppName))
		builder.setPositiveButton(context!!.getString(R.string.OK), null)

		if (message.type == 3) {
			builder.setMessage(parentActivity.getString(R.string.NoPlayerInstalled))
		}
		else {
			builder.setMessage(LocaleController.formatString("NoHandleAppInstalled", R.string.NoHandleAppInstalled, message.document?.mime_type))
		}

		showDialog(builder.create())
	}

	private fun openSearchWithText(text: String?) {
		if (!actionBar!!.isSearchFieldVisible) {
			AndroidUtilities.updateViewVisibilityAnimated(avatarContainer, false, 0.95f, true)

			headerItem?.gone()
			attachItem?.gone()
			editTextItem?.gone()

			if (threadId == 0) {
				searchItem?.visibility = View.VISIBLE
			}

			if (showSearchAsIcon) {
				searchIconItem?.visibility = View.GONE
			}
			if (showAudioCallAsIcon) {
				audioCallIconItem?.visibility = View.GONE
			}

			searchItemVisible = true

			updateSearchButtons(0, 0, -1)
			updateBottomOverlay()
		}

		if (threadId == 0 && !isReplyUser(currentUser)) {
			openSearchKeyboard = text == null
			searchItem?.openSearch(openSearchKeyboard)
		}

		if (text != null) {
			searchItem?.setSearchFieldText(text, false)
			mediaDataController.searchMessagesInChat(text, dialogId, mergeDialogId, classGuid, 0, threadId, searchingUserMessages, searchingChatMessages)
		}

		updatePinnedMessageView(true)
	}

	override fun didSelectLocation(location: MessageMedia, locationType: Int, notify: Boolean, scheduleDate: Int) {
		sendMessagesHelper.sendMessage(location, dialogId, replyMessage, threadMessage, null, null, notify, scheduleDate, false, null)

		if (chatMode == 0) {
			moveScrollToLastMessage(false)
		}

		if (locationType == LocationActivity.LOCATION_TYPE_SEND || locationType == LocationActivity.LOCATION_TYPE_SEND_WITH_LIVE) {
			afterMessageSend()
		}

		if (paused) {
			scrollToTopOnResume = true
		}
	}

	val isEditingMessageMedia: Boolean
		get() = chatAttachAlert?.editingMessageObject != null

	val isSecretChat: Boolean
		get() = currentEncryptedChat != null

	fun canScheduleMessage(): Boolean {
		// MARK: remove this and uncomment following line to enable messages scheduling
		return false
		// return currentEncryptedChat == null && (bottomOverlayChat == null || bottomOverlayChat.getVisibility() != View.VISIBLE) && !isThreadChat();
	}

	val isInScheduleMode: Boolean
		get() = chatMode == MODE_SCHEDULED

	fun allowGroupPhotos(): Boolean {
		return !isEditingMessageMedia
	}

	fun getGroupCall(): ChatObject.Call? {
		return if (chatMode == 0 && groupCall != null && groupCall!!.call is TL_groupCall) groupCall else null
	}

	fun sendAudio(audios: ArrayList<MessageObject>, caption: CharSequence?, notify: Boolean, scheduleDate: Int) {
		fillEditingMediaWithCaption(caption, null)
		prepareSendingAudioDocuments(accountInstance, audios, caption, dialogId, replyMessage, threadMessage, editingMessageObject, notify, scheduleDate, false, null)
		afterMessageSend()
	}

	fun sendContact(user: User?, notify: Boolean, scheduleDate: Int) {
		sendMessagesHelper.sendMessage(user, dialogId, replyMessage, threadMessage, null, null, notify, scheduleDate, false, null)
		afterMessageSend()
	}

	fun sendPoll(poll: TL_messageMediaPoll?, params: HashMap<String, String>?, notify: Boolean, scheduleDate: Int) {
		sendMessagesHelper.sendMessage(poll, dialogId, replyMessage, threadMessage, null, params, notify, scheduleDate, false, null)
		afterMessageSend()
	}

	fun sendMedia(photoEntry: PhotoEntry?, videoEditedInfo: VideoEditedInfo?, notify: Boolean, scheduleDate: Int, forceDocument: Boolean) {
		if (photoEntry == null) {
			return
		}

		fillEditingMediaWithCaption(photoEntry.caption, photoEntry.entities)

		if (photoEntry.isVideo) {
			if (videoEditedInfo != null) {
				prepareSendingVideo(accountInstance, photoEntry.path, videoEditedInfo, dialogId, replyMessage, threadMessage, photoEntry.caption, photoEntry.entities, photoEntry.ttl, editingMessageObject, notify, scheduleDate, forceDocument, false, null)
			}
			else {
				prepareSendingVideo(accountInstance, photoEntry.path, null, dialogId, replyMessage, threadMessage, photoEntry.caption, photoEntry.entities, photoEntry.ttl, editingMessageObject, notify, scheduleDate, forceDocument, false, null)
			}
		}
		else {
			if (photoEntry.imagePath != null) {
				prepareSendingPhoto(accountInstance, photoEntry.imagePath, photoEntry.thumbPath, null, dialogId, replyMessage, threadMessage, photoEntry.caption, photoEntry.entities, photoEntry.stickers, null, photoEntry.ttl, editingMessageObject, videoEditedInfo, notify, scheduleDate, forceDocument, false, null)
			}
			else if (photoEntry.path != null) {
				prepareSendingPhoto(accountInstance, photoEntry.path, photoEntry.thumbPath, null, dialogId, replyMessage, threadMessage, photoEntry.caption, photoEntry.entities, photoEntry.stickers, null, photoEntry.ttl, editingMessageObject, videoEditedInfo, notify, scheduleDate, forceDocument, false, null)
			}
		}

		afterMessageSend()
	}

	fun showOpenGameAlert(game: TL_game, messageObject: MessageObject?, urlStr: String?, ask: Boolean, uid: Long) {
		val user = messagesController.getUser(uid)

		if (ask) {
			val parentActivity = parentActivity ?: return
			val builder = AlertDialog.Builder(parentActivity)
			builder.setTitle(parentActivity.getString(R.string.AppName))

			val name = if (user != null) {
				formatName(user.first_name, user.last_name)
			}
			else {
				""
			}

			builder.setMessage(LocaleController.formatString("BotPermissionGameAlert", R.string.BotPermissionGameAlert, name))

			builder.setPositiveButton(parentActivity.getString(R.string.OK)) { _, _ ->
				showOpenGameAlert(game, messageObject, urlStr, false, uid)
				MessagesController.getNotificationsSettings(currentAccount).edit().putBoolean("askgame_$uid", false).commit()
			}

			builder.setNegativeButton(parentActivity.getString(R.string.Cancel), null)

			showDialog(builder.create())
		}
		else {
			if (!AndroidUtilities.isTablet() && WebviewActivity.supportWebview()) {
				if (parentLayout!!.fragmentsStack[parentLayout!!.fragmentsStack.size - 1] === this) {
					presentFragment(WebviewActivity(urlStr, user?.username ?: "", game.title, game.short_name, messageObject))
				}
			}
			else {
				WebviewActivity.openGameInBrowser(urlStr, messageObject, parentActivity, game.short_name, user?.username ?: "")
			}
		}
	}

	private fun processLoadedDiscussionMessage(discussionMessage: TL_messages_discussionMessage?, history: messages_Messages?, maxReadId: Int, fallbackMessage: MessageObject?, req: TL_messages_getDiscussionMessage, originalChat: Chat?, highlightMsgId: Int, originalMessage: MessageObject?) {
		@Suppress("NAME_SHADOWING") var history = history
		val thisCommentLoadingMessageId = commentLoadingMessageId

		if (history != null) {
			if (maxReadId != 1 && maxReadId != 0 && discussionMessage != null && maxReadId != discussionMessage.read_inbox_max_id && highlightMsgId <= 0) {
				history = null
			}
			else if (history.messages.isNotEmpty() && discussionMessage != null && discussionMessage.messages.isNotEmpty()) {
				val message = history.messages.first()
				val replyId = message.reply_to?.reply_to_top_id?.takeIf { it != 0 } ?: message.reply_to?.reply_to_msg_id ?: 0

				if (replyId != discussionMessage.messages?.lastOrNull()?.id) {
					history = null
				}
			}
		}

		val arrayList = mutableListOf<MessageObject>()

		if (discussionMessage != null) {
			for (message in discussionMessage.messages) {
				if (message is TL_messageEmpty) {
					continue
				}

				message.isThreadMessage = true

				arrayList.add(MessageObject(UserConfig.selectedAccount, message, generateLayout = true, checkMediaExists = true))
			}
		}

		if (arrayList.isNotEmpty() && discussionMessage != null) {
			val args = Bundle()

			val dialogId = arrayList.first().dialogId

			args.putLong("chat_id", -dialogId)
			args.putInt("message_id", max(1, discussionMessage.read_inbox_max_id))
			args.putInt("unread_count", discussionMessage.unread_count)
			args.putBoolean("historyPreloaded", history != null)

			val chatActivity = ChatActivity(args)
			chatActivity.setThreadMessages(arrayList, originalChat, req.msg_id, discussionMessage.read_inbox_max_id, discussionMessage.read_outbox_max_id)

			if (highlightMsgId != 0) {
				chatActivity.highlightMessageId = highlightMsgId
			}

			if (chatActivity.threadMessage?.messageOwner?.replies != null) {
				originalMessage?.messageOwner?.replies?.replies = chatActivity.threadMessage?.messageOwner?.replies?.replies
			}

			if (originalMessage?.messageOwner?.originalReactions != null) {
				chatActivity.threadMessage?.messageOwner?.reactions = originalMessage.messageOwner?.originalReactions
			}

			val chatOpened = AtomicBoolean(false)

			val openCommentsChat = Runnable {
				if (chatOpened.get() || thisCommentLoadingMessageId != commentLoadingMessageId || !isFullyVisible || isFinishing) {
					return@Runnable
				}

				chatOpened.set(true)

				AndroidUtilities.runOnUIThread({
					commentLoadingMessageId = 0
					chatListView?.invalidateViews()
				}, 200)

				presentFragment(chatActivity)

				if (isKeyboardVisible && !chatActivity.hideKeyboardOnShow()) {
					chatActivity.chatActivityEnterView?.editField?.requestFocus()
				}
			}

			if (history != null) {
				var fnid = 0

				if (history.messages.isNotEmpty()) {
					for (a in history.messages.indices.reversed()) {
						val message = history.messages[a]

						if (message.id > maxReadId && !message.out) {
							fnid = message.id
							break
						}
					}
				}

				val historyFinal: messages_Messages = history
				val fnidFinal = fnid
				val commentsClassGuid = chatActivity.getClassGuid()

				val observer = object : NotificationCenterDelegate {
					override fun didReceivedNotification(id: Int, account: Int, vararg args: Any?) {
						if (id == NotificationCenter.messagesDidLoad && args[10] as Int == commentsClassGuid) {
							openCommentsChat.run()

							AndroidUtilities.runOnUIThread({
								chatActivity.didReceivedNotification(id, account, *args)
							}, 50)

							notificationCenter.removeObserver(this, NotificationCenter.messagesDidLoad)
						}
					}
				}

				notificationCenter.addObserver(observer, NotificationCenter.messagesDidLoad)

				Utilities.stageQueue.postRunnable {
					messagesController.processLoadedMessages(historyFinal, historyFinal.messages.size, dialogId, 0, 30, if (highlightMsgId > 0) highlightMsgId else maxReadId, 0, false, commentsClassGuid, fnidFinal, 0, 0, 0, if (highlightMsgId > 0) 3 else 2, true, 0, arrayList[arrayList.size - 1].id, 1, false, 0, true)
				}
			}
			else {
				openCommentsChat.run()
			}
		}
		else {
			commentLoadingMessageId = 0
			chatListView?.invalidateViews()

			if (fallbackMessage != null) {
				openOriginalReplyChat(fallbackMessage)
			}
			else {
				parentActivity?.let {
					BulletinFactory.of(this).createErrorBulletin(it.getString(R.string.ChannelPostDeleted)).show()
				}
			}
		}
	}

	private fun openDiscussionMessageChat(chatId: Long, originalMessage: MessageObject?, messageId: Int?, linkedChatId: Long, maxReadId: Int, highlightMsgId: Int, fallbackMessage: MessageObject?) {
		if (messageId == null) {
			return
		}

		val chat = messagesController.getChat(chatId)

		val req = TL_messages_getDiscussionMessage()
		req.peer = MessagesController.getInputPeer(chat)
		req.msg_id = messageId

		FileLog.d("getDiscussionMessage chat = " + chat!!.id + " msg_id = " + messageId)

		commentLoadingMessageId = 0
		savedDiscussionMessage = null
		savedNoDiscussion = false
		savedNoHistory = false
		savedHistory = null

		chatListView?.invalidateViews()

		if (commentMessagesRequestId != -1) {
			connectionsManager.cancelRequest(commentMessagesRequestId, false)
		}

		if (commentRequestId != -1) {
			connectionsManager.cancelRequest(commentRequestId, false)
		}

		commentLoadingMessageId = fallbackMessage?.id ?: messageId

		chatListView?.invalidateViews()

		val guid1 = ++commentLoadingGuid

		commentRequestId = connectionsManager.sendRequest(req) { response, _ ->
			val runnable = Runnable {
				if (guid1 != commentLoadingGuid) {
					return@Runnable
				}

				commentRequestId = -1

				if (response is TL_messages_discussionMessage) {
					savedDiscussionMessage = response
					messagesController.putUsers(savedDiscussionMessage?.users, false)
					messagesController.putChats(savedDiscussionMessage?.chats, false)
				}
				else {
					savedNoDiscussion = true
				}

				val msgs = mutableListOf<Message>()
				val savedDiscussionMessageMessages = savedDiscussionMessage?.messages

				if (savedDiscussionMessageMessages != null) {
					for (message in savedDiscussionMessageMessages) {
						if (message is TL_messageEmpty) {
							continue
						}

						msgs.add(message)
					}
				}

				if (msgs.isNotEmpty()) {
					val message = msgs.first()

					val getReplies = TL_messages_getReplies()
					getReplies.peer = messagesController.getInputPeer(message.peer_id)
					getReplies.msg_id = message.id
					getReplies.offset_date = 0
					getReplies.limit = 30

					if (highlightMsgId > 0) {
						getReplies.offset_id = highlightMsgId
						getReplies.add_offset = -getReplies.limit / 2
					}
					else {
						getReplies.offset_id = if (maxReadId == 0) 1 else maxReadId
						getReplies.add_offset = -getReplies.limit + 10
					}

					val guid2 = ++commentMessagesLoadingGuid

					commentMessagesRequestId = connectionsManager.sendRequest(getReplies) { response2, error2 ->
						AndroidUtilities.runOnUIThread {
							doOnIdle {
								if (guid2 != commentMessagesLoadingGuid) {
									return@doOnIdle
								}

								commentMessagesRequestId = -1

								if (response2 != null) {
									savedHistory = response2 as? messages_Messages
								}
								else {
									if ("CHANNEL_PRIVATE" == error2?.text) {
										parentActivity?.let {
											val builder = AlertDialog.Builder(it)
											builder.setTitle(it.getString(R.string.AppName))
											builder.setMessage(it.getString(R.string.JoinByPeekChannelText))
											builder.setPositiveButton(it.getString(R.string.OK), null)

											showDialog(builder.create())
										}

										commentLoadingMessageId = 0

										chatListView?.invalidateViews()

										return@doOnIdle
									}

									savedNoHistory = true
								}

								processLoadedDiscussionMessage(savedDiscussionMessage, savedHistory, maxReadId, fallbackMessage, req, chat, highlightMsgId, originalMessage)
							}
						}
					}
				}
				else {
					savedNoHistory = true
					processLoadedDiscussionMessage(savedDiscussionMessage, savedHistory, maxReadId, fallbackMessage, req, chat, highlightMsgId, originalMessage)
				}
			}

			AndroidUtilities.runOnUIThread {
				doOnIdle(runnable)
			}
		}

		connectionsManager.bindRequestToGuid(commentRequestId, classGuid)
	}

	private fun openOriginalReplyChat(messageObject: MessageObject?) {
		if (isUserSelf(currentUser) && messageObject?.messageOwner?.fwd_from?.saved_from_peer?.user_id == currentUser?.id) {
			scrollToMessageId(messageObject!!.messageOwner!!.fwd_from!!.saved_from_msg_id, messageObject.id, true, 0, true, 0)
			return
		}

		val args = Bundle()

		if (messageObject!!.messageOwner!!.fwd_from!!.saved_from_peer.channel_id != 0L) {
			args.putLong("chat_id", messageObject.messageOwner!!.fwd_from!!.saved_from_peer.channel_id)
		}
		else if (messageObject.messageOwner!!.fwd_from!!.saved_from_peer.chat_id != 0L) {
			args.putLong("chat_id", messageObject.messageOwner!!.fwd_from!!.saved_from_peer.chat_id)
		}
		else if (messageObject.messageOwner!!.fwd_from!!.saved_from_peer.user_id != 0L) {
			args.putLong("user_id", messageObject.messageOwner!!.fwd_from!!.saved_from_peer.user_id)
		}

		args.putInt("message_id", messageObject.messageOwner!!.fwd_from!!.saved_from_msg_id)

		if (messagesController.checkCanOpenChat(args, this@ChatActivity)) {
			presentFragment(ChatActivity(args))
		}
	}

	fun showRequestUrlAlert(request: TL_urlAuthResultRequest, buttonReq: TL_messages_requestUrlAuth, url: String, ask: Boolean) {
		val parentActivity = parentActivity ?: return

		val builder = AlertDialog.Builder(parentActivity)
		builder.setTitle(parentActivity.getString(R.string.OpenUrlTitle))

		val format = parentActivity.getString(R.string.OpenUrlAlert2)
		var index = format.indexOf("%")
		var stringBuilder = SpannableStringBuilder(String.format(format, url))

		if (index >= 0) {
			stringBuilder.setSpan(URLSpan(url), index, index + url.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
		}

		builder.setMessage(stringBuilder)
		builder.setMessageTextViewClickable(false)
		builder.setNegativeButton(parentActivity.getString(R.string.Cancel), null)

		val cells = arrayOfNulls<CheckBoxCell>(2)

		val linearLayout = LinearLayout(parentActivity)
		linearLayout.orientation = LinearLayout.VERTICAL

		val selfUser = userConfig.getCurrentUser()

		for (a in 0 until if (request.request_write_access) 2 else 1) {
			cells[a] = CheckBoxCell(parentActivity, 5)
			cells[a]?.background = Theme.getSelectorDrawable(false)
			cells[a]?.setMultiline(true)
			cells[a]?.tag = a

			if (a == 0) {
				stringBuilder = AndroidUtilities.replaceTags(LocaleController.formatString("OpenUrlOption1", R.string.OpenUrlOption1, request.domain, formatName(selfUser!!.first_name, selfUser.last_name)))
				index = TextUtils.indexOf(stringBuilder, request.domain)

				if (index >= 0) {
					stringBuilder.setSpan(URLSpan(""), index, index + request.domain.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
				}

				cells[a]?.setText(stringBuilder, "", checked = true, divider = false)
			}
			else {
				cells[a]?.setText(AndroidUtilities.replaceTags(LocaleController.formatString("OpenUrlOption2", R.string.OpenUrlOption2, getFirstName(request.bot))), "", checked = true, divider = false)
			}

			cells[a]?.setPadding(if (LocaleController.isRTL) AndroidUtilities.dp(16f) else AndroidUtilities.dp(8f), 0, if (LocaleController.isRTL) AndroidUtilities.dp(8f) else AndroidUtilities.dp(16f), 0)

			linearLayout.addView(cells[a], createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT))

			cells[a]?.setOnClickListener {
				if (!it.isEnabled) {
					return@setOnClickListener
				}

				val num = it.tag as Int

				cells[num]?.setChecked(!cells[num]!!.isChecked, true)

				if (num == 0 && cells[1] != null) {
					if (cells[num]!!.isChecked) {
						cells[1]!!.isEnabled = true
					}
					else {
						cells[1]!!.setChecked(checked = false, animated = true)
						cells[1]!!.isEnabled = false
					}
				}
			}
		}

		builder.setCustomViewOffset(12)
		builder.setView(linearLayout)

		builder.setPositiveButton(parentActivity.getString(R.string.Open)) { _, _ ->
			if (!cells[0]!!.isChecked) {
				Browser.openUrl(parentActivity, url, false)
			}
			else {
				val progressDialog = arrayOf<AlertDialog?>(AlertDialog(parentActivity, 3))
				val req = TL_messages_acceptUrlAuth()

				if (buttonReq.url != null) {
					req.url = buttonReq.url
					req.flags = req.flags or 4
				}
				else {
					req.button_id = buttonReq.button_id
					req.msg_id = buttonReq.msg_id
					req.peer = buttonReq.peer
					req.flags = req.flags or 2
				}

				if (request.request_write_access) {
					req.write_allowed = cells[1]!!.isChecked
				}

				runCatching {
					progressDialog[0]?.dismiss()
				}

				progressDialog[0] = null

				val requestId = connectionsManager.sendRequest(req) { response, _ ->
					AndroidUtilities.runOnUIThread {
						if (response is TL_urlAuthResultAccepted) {
							Browser.openUrl(parentActivity, response.url, false)
						}
						else if (response is TL_urlAuthResultDefault) {
							Browser.openUrl(parentActivity, url, false)
						}
						else if (buttonReq.url != null) {
							AlertsCreator.showOpenUrlAlert(this@ChatActivity, buttonReq.url, false, ask)
						}
					}
				}

				AndroidUtilities.runOnUIThread({
					if (progressDialog[0] == null) {
						return@runOnUIThread
					}

					progressDialog[0]?.setOnCancelListener {
						connectionsManager.cancelRequest(requestId, true)
					}

					showDialog(progressDialog[0])
				}, 500)
			}
		}

		showDialog(builder.create())
	}

	private fun removeMessageObject(messageObject: MessageObject?) {
		val index = messages.indexOf(messageObject)

		if (index == -1) {
			return
		}

		messages.removeAt(index)

		chatAdapter?.notifyItemRemoved(chatAdapter!!.messagesStartRow + index)
	}

	fun openVCard(user: User?, vcard: String?, first_name: String?, last_name: String?) {
		try {
			var f = AndroidUtilities.getSharingDirectory()
			f.mkdirs()

			f = File(f, "vcard.vcf")

			FileWriter(f).use {
				BufferedWriter(it).use { writer ->
					writer.write(vcard)
				}
			}

			showDialog(PhonebookShareAlert(this, null, user, null, f, first_name, last_name))
		}
		catch (e: Exception) {
			FileLog.e(e)
		}
	}

	private fun setCellSelectionBackground(message: MessageObject?, messageCell: ChatMessageCell, idx: Int, animated: Boolean) {
		var groupedMessages = getValidGroupedMessage(message)

		if (groupedMessages != null) {
			var hasUnselected = false

			for (a in groupedMessages.messages.indices) {
				if (selectedMessagesIds[idx].indexOfKey(groupedMessages.messages[a].id) < 0) {
					hasUnselected = true
					break
				}
			}

			if (!hasUnselected) {
				groupedMessages = null
			}
		}

		messageCell.setDrawSelectionBackground(groupedMessages == null)
		messageCell.setChecked(true, groupedMessages == null, animated)
	}

	private fun openClickableLink(url: CharacterStyle?, str: String, longPress: Boolean, cell: ChatMessageCell?, messageObject: MessageObject?) {
		if (longPress) {
			val builder = BottomSheet.Builder(parentActivity, false)
			var timestamp = -1

			if (str.startsWith("video?")) {
				timestamp = Utilities.parseInt(str)
			}

			if (timestamp >= 0) {
				builder.setTitle(AndroidUtilities.formatDuration(timestamp, false))
			}
			else {
				var formattedUrl: String? = str

				try {
					formattedUrl = URLDecoder.decode(str.replace("\\+".toRegex(), "%2b"), "UTF-8")
				}
				catch (e: Exception) {
					FileLog.e(e)
				}

				builder.setTitle(formattedUrl)
				builder.setTitleMultipleLines(true)
			}

			val finalTimestamp = timestamp
			val noforwards = messagesController.isChatNoForwards(currentChat) || messageObject?.messageOwner?.noforwards == true

			builder.setItems(if (noforwards) arrayOf<CharSequence>(context!!.getString(R.string.Open)) else arrayOf<CharSequence>(context!!.getString(R.string.Open), context!!.getString(R.string.Copy))) { _, which ->
				if (which == 0) {
					if (str.startsWith("video?")) {
						didPressMessageUrl(url, false, messageObject, cell)
					}
					else {
						openClickableLink(url, str, false, cell, messageObject)
					}
				}
				else if (which == 1) {
					if (str.startsWith("video?") && messageObject != null && !messageObject.scheduled) {
						var messageObject1: MessageObject = messageObject
						val isMedia = messageObject.isVideo || messageObject.isRoundVideo || messageObject.isVoice || messageObject.isMusic

						if (!isMedia && messageObject.replyMessageObject != null) {
							messageObject1 = messageObject.replyMessageObject!!
						}

						var dialogId = messageObject1.dialogId
						var messageId = messageObject1.id
						var link: String? = null

						if (messageObject1.messageOwner?.fwd_from != null) {
							if (messageObject1.messageOwner?.fwd_from?.saved_from_peer != null) {
								dialogId = MessageObject.getPeerId(messageObject1.messageOwner?.fwd_from?.saved_from_peer)
								messageId = messageObject1.messageOwner!!.fwd_from!!.saved_from_msg_id
							}
							else if (messageObject1.messageOwner?.fwd_from?.from_id != null) {
								dialogId = MessageObject.getPeerId(messageObject1.messageOwner?.fwd_from?.from_id)
								messageId = messageObject1.messageOwner!!.fwd_from!!.channel_post
							}
						}

						if (DialogObject.isChatDialog(dialogId)) {
							val currentChat = MessagesController.getInstance(currentAccount).getChat(-dialogId)

							if (currentChat?.username != null) {
								val domainUrl = String.format(Locale.getDefault(), "https://%s/", ApplicationLoader.applicationContext.getString(R.string.domain))
								link = domainUrl + currentChat.username + "/" + messageId + "?t=" + finalTimestamp
							}
						}
						else {
							val user = MessagesController.getInstance(currentAccount).getUser(dialogId)

							if (user?.username != null) {
								val domainUrl = String.format(Locale.getDefault(), "https://%s/", ApplicationLoader.applicationContext.getString(R.string.domain))
								link = domainUrl + user.username + "/" + messageId + "?t=" + finalTimestamp
							}
						}

						if (link == null) {
							return@setItems
						}

						AndroidUtilities.addToClipboard(link)
					}
					else {
						AndroidUtilities.addToClipboard(str)
					}

					if (str.startsWith("@")) {
						undoView?.showWithAction(0, UndoView.ACTION_USERNAME_COPIED, null)
					}
					else if (str.startsWith("#") || str.startsWith("$")) {
						undoView?.showWithAction(0, UndoView.ACTION_HASHTAG_COPIED, null)
					}
					else {
						undoView?.showWithAction(0, UndoView.ACTION_LINK_COPIED, null)
					}
				}
			}

			builder.setOnPreDismissListener {
				cell?.resetPressedLink(-1)
			}

			showDialog(builder.create())
		}
		else {
			if (str.startsWith("@")) {
				val username = str.substring(1).lowercase()

				if (currentChat != null && !TextUtils.isEmpty(currentChat!!.username) && username == currentChat!!.username.lowercase() || currentUser != null && !TextUtils.isEmpty(currentUser!!.username) && username == currentUser!!.username!!.lowercase()) {
					val args = Bundle()

					if (currentChat != null) {
						args.putLong("chat_id", currentChat!!.id)
					}
					else if (currentUser != null) {
						args.putLong("user_id", currentUser!!.id)

						if (currentEncryptedChat != null) {
							args.putLong("dialog_id", dialogId)
						}
					}

					// MARK: open profile
					val fragment = ProfileActivity(args, avatarContainer!!.sharedMediaPreloader)
					fragment.setPlayProfileAnimation(1)
					fragment.setChatInfo(currentChatInfo)
					fragment.userInfo = currentUserInfo

					presentFragment(fragment)
				}
				else {
					messagesController.openByUserName(username, this@ChatActivity, 0)
				}
			}
			else if (str.startsWith("#") || str.startsWith("$")) {
				if (isChannel(currentChat)) {
					if (chatMode == MODE_SCHEDULED || chatMode == MODE_PINNED) {
						chatActivityDelegate?.openSearch(str)
						finishFragment()
					}
					else {
						openSearchWithText(str)
					}
				}
				else {
					val fragment = DialogsActivity(null)
					fragment.setSearchString(str)
					presentFragment(fragment)
				}
			}
			else {
				processExternalUrl(0, str, false)
			}
		}
	}

	private fun processExternalUrl(type: Int, url: String?, forceAlert: Boolean) {
		try {
			if (!url.isNullOrEmpty()) {
				val uri = Uri.parse(url)

				if (uri != null) {
					val host = uri.host?.lowercase() ?: ""

					if ((currentEncryptedChat == null || messagesController.secretWebpagePreview == 1) && messagesController.authDomains?.contains(host) == true) {
						sendMessagesHelper.requestUrlAuth(url, this, type == 0 || type == 2)
						return
					}
				}
			}
		}
		catch (e: Exception) {
			FileLog.e(e)
		}

		if (forceAlert || AndroidUtilities.shouldShowUrlInAlert(url)) {
			if (!url.isNullOrEmpty()) {
				if (type == 0 || type == 2) {
					AlertsCreator.showOpenUrlAlert(this@ChatActivity, url, punycode = true, tryTelegraph = true, ask = true)
				}
				else if (type == 1) {
					AlertsCreator.showOpenUrlAlert(this@ChatActivity, url, punycode = true, tryTelegraph = true, ask = false)
				}
			}
		}
		else {
			when (type) {
				0 -> Browser.openUrl(parentActivity, url)
				1 -> Browser.openUrl(parentActivity, url, inlineReturn == 0L, false)
				2 -> Browser.openUrl(parentActivity, url, inlineReturn == 0L)
			}
		}
	}

	private fun didPressMessageUrl(url: CharacterStyle?, longPress: Boolean, messageObject: MessageObject?, cell: ChatMessageCell?) {
		@Suppress("NAME_SHADOWING") var messageObject = messageObject
		@Suppress("NAME_SHADOWING") var cell = cell

		if (url == null || parentActivity == null) {
			return
		}

		val noforwards = messagesController.isChatNoForwards(currentChat) || messageObject?.messageOwner?.noforwards == true

		if (url is URLSpanMono) {
			if (!noforwards) {
				url.copyToClipboard()
				undoView?.showWithAction(0, UndoView.ACTION_TEXT_COPIED, null)
			}

			if (longPress && cell != null) {
				cell.resetPressedLink(-1)
			}
		}
		else if (url is URLSpanUserMention) {
			val user = messagesController.getUser(Utilities.parseLong(url.url))

			if (user != null) {
				MessagesController.openChatOrProfileWith(user, null, this@ChatActivity, 0, false)
			}

			if (longPress && cell != null) {
				cell.resetPressedLink(-1)
			}
		}
		else if (url is URLSpanNoUnderline) {
			val str = url.url

			if (messageObject != null && str.startsWith("/")) {
				if (URLSpanBotCommand.enabled) {
					chatActivityEnterView?.setCommand(messageObject, str, longPress, currentChat != null && currentChat!!.megagroup)

					if (!longPress && chatActivityEnterView!!.fieldText == null) {
						hideFieldPanel(false)
					}
				}

				if (longPress && cell != null) {
					cell.resetPressedLink(-1)
				}
			}
			else if (messageObject != null && str.startsWith("video") && !longPress) {
				val seekTime = Utilities.parseInt(str)
				val webPage: WebPage?

				if (messageObject.isYouTubeVideo) {
					webPage = messageObject.messageOwner?.media?.webpage
				}
				else if (messageObject.replyMessageObject?.isYouTubeVideo == true) {
					webPage = messageObject.replyMessageObject?.messageOwner?.media?.webpage
					messageObject = messageObject.replyMessageObject
				}
				else {
					webPage = null
				}

				if (webPage != null) {
					EmbedBottomSheet.show(this@ChatActivity, messageObject, photoViewerProvider, webPage.site_name, webPage.title, webPage.url, webPage.embed_url, webPage.embed_width, webPage.embed_height, seekTime, isKeyboardVisible)
				}
				else {
					if (!messageObject!!.isVideo && messageObject.replyMessageObject != null) {
						val obj = messagesDict[if (messageObject.replyMessageObject?.dialogId == dialogId) 0 else 1][messageObject.replyMessageObject!!.id]
						cell = null
						messageObject = obj ?: messageObject.replyMessageObject
					}

					messageObject?.forceSeekTo = seekTime / (messageObject?.duration?.toFloat()?.takeIf { it > 0 } ?: 1f)

					openPhotoViewerForMessage(cell, messageObject)
				}
			}
			else if (messageObject != null && str.startsWith("audio")) {
				val seekTime = Utilities.parseInt(str)

				if (!messageObject.isMusic && messageObject.replyMessageObject != null) {
					messageObject = messagesDict[if (messageObject.replyMessageObject?.dialogId == dialogId) 0 else 1][messageObject.replyMessageObject!!.id]
				}

				val progress = seekTime / messageObject!!.duration.toFloat()
				val mediaController = mediaController

				if (mediaController.isPlayingMessage(messageObject)) {
					messageObject.audioProgress = progress
					mediaController.seekToProgress(messageObject, progress)

					if (mediaController.isMessagePaused) {
						mediaController.playMessage(messageObject)
					}
				}
				else {
					messageObject.forceSeekTo = seekTime / messageObject.duration.toFloat()
					mediaController.playMessage(messageObject)
				}

				if (longPress && cell != null) {
					cell.resetPressedLink(-1)
				}
			}
			else if (str.startsWith("card:")) {
				val finalCell = cell
				val number = str.substring(5)
				val progressDialog = arrayOf<AlertDialog?>(AlertDialog(parentActivity!!, 3))

				val req = TL_payments_getBankCardData()
				req.number = number

				val requestId = connectionsManager.sendRequest(req, { response, _ ->
					AndroidUtilities.runOnUIThread {
						runCatching {
							progressDialog[0]?.dismiss()
						}

						progressDialog[0] = null

						if (response is TL_payments_bankCardData) {
							if (parentActivity == null) {
								return@runOnUIThread
							}

							val builder = BottomSheet.Builder(parentActivity, false)
							val arrayList = ArrayList<CharSequence>()
							var a = 0
							val N = response.open_urls.size

							while (a < N) {
								arrayList.add(response.open_urls[a].name)
								a++
							}

							arrayList.add(context!!.getString(R.string.CopyCardNumber))

							builder.setTitle(response.title)

							builder.setItems(arrayList.toTypedArray()) { _, which ->
								if (which < response.open_urls.size) {
									Browser.openUrl(parentActivity, response.open_urls[which].url, inlineReturn == 0L, false)
								}
								else {
									AndroidUtilities.addToClipboard(number)
									Toast.makeText(ApplicationLoader.applicationContext, context!!.getString(R.string.CardNumberCopied), Toast.LENGTH_SHORT).show()
								}
							}

							builder.setOnPreDismissListener {
								finalCell?.resetPressedLink(-1)
							}

							showDialog(builder.create())
						}
						else {
							finalCell?.resetPressedLink(-1)
						}
					}
				}, null, null, 0, messagesController.webFileDatacenterId, ConnectionsManager.ConnectionTypeGeneric, true)

				AndroidUtilities.runOnUIThread({
					if (progressDialog[0] == null) {
						return@runOnUIThread
					}

					progressDialog[0]?.setOnCancelListener {
						connectionsManager.cancelRequest(requestId, true)
						finalCell?.resetPressedLink(-1)
					}

					showDialog(progressDialog[0])
				}, 500)
			}
			else {
				openClickableLink(url, str, longPress, cell, messageObject)
			}
		}
		else {
			val urlFinal = (url as URLSpan).url

			if (longPress) {
				val finalCell = cell
				val builder = BottomSheet.Builder(parentActivity, false)
				var formattedUrl = urlFinal

				try {
					formattedUrl = URLDecoder.decode(urlFinal!!.replace("\\+".toRegex(), "%2b"), "UTF-8")
				}
				catch (e: Exception) {
					FileLog.e(e)
				}

				builder.setTitle(formattedUrl)
				builder.setTitleMultipleLines(true)
				builder.setItems(if (noforwards) arrayOf<CharSequence>(context!!.getString(R.string.Open)) else arrayOf<CharSequence>(context!!.getString(R.string.Open), context!!.getString(R.string.Copy))) { _, which ->
					if (which == 0) {
						processExternalUrl(1, urlFinal, false)
					}
					else if (which == 1) {
						var url1 = urlFinal
						var tel = false
						var mail = false

						if (url1.startsWith("mailto:")) {
							url1 = url1.substring(7)
							mail = true
						}
						else if (url1.startsWith("tel:")) {
							url1 = url1.substring(4)
							tel = true
						}

						AndroidUtilities.addToClipboard(url1)

						if (mail) {
							undoView?.showWithAction(0, UndoView.ACTION_EMAIL_COPIED, null)
						}
						else if (tel) {
							undoView?.showWithAction(0, UndoView.ACTION_PHONE_COPIED, null)
						}
						else {
							undoView?.showWithAction(0, UndoView.ACTION_LINK_COPIED, null)
						}
					}
				}

				builder.setOnPreDismissListener {
					finalCell?.resetPressedLink(-1)
				}

				showDialog(builder.create())
			}
			else {
				var forceAlert = url is URLSpanReplacement

				if (url is URLSpanReplacement && (urlFinal == null || !urlFinal.startsWith("mailto:")) || AndroidUtilities.shouldShowUrlInAlert(urlFinal)) {
					if (openLinkInternally(urlFinal, messageObject?.id ?: 0)) {
						return
					}

					forceAlert = true
				}
				else {
					if (messageObject != null && messageObject.messageOwner?.media is TL_messageMediaWebPage && messageObject.messageOwner?.media?.webpage != null && messageObject.messageOwner?.media?.webpage?.cached_page != null) {
						val lowerUrl = urlFinal?.lowercase() ?: ""
						val lowerUrl2 = messageObject.messageOwner?.media?.webpage?.url?.lowercase() ?: ""
						val domainUrl = String.format(Locale.getDefault(), "%s/iv", ApplicationLoader.applicationContext.getString(R.string.domain))

						if ((lowerUrl.contains("www.ello.team/blog") || Browser.isTelegraphUrl(lowerUrl, false) || lowerUrl.contains(domainUrl)) && (lowerUrl.contains(lowerUrl2) || lowerUrl2.contains(lowerUrl))) {
							ArticleViewer.getInstance().setParentActivity(parentActivity, this@ChatActivity)
							ArticleViewer.getInstance().open(messageObject)
							return
						}
					}

					if (openLinkInternally(urlFinal, messageObject?.id ?: 0)) {
						return
					}
				}

				if (Browser.urlMustNotHaveConfirmation(urlFinal)) {
					forceAlert = false
				}

				processExternalUrl(2, urlFinal, forceAlert)
			}
		}
	}

	fun openPhotoViewerForMessage(cell: ChatMessageCell?, message: MessageObject?) {
		if (message == null) {
			return
		}

		@Suppress("NAME_SHADOWING") val cell = cell ?: (chatListView?.children?.find { (it as? ChatMessageCell)?.getMessageObject()?.equals(message) == true } as? ChatMessageCell)

		if (message.isVideo) {
			sendSecretMessageRead(message, true)
		}

		PhotoViewer.getInstance().setParentActivity(this)

		val playingObject = MediaController.getInstance().playingMessageObject

		if (cell != null && playingObject != null && playingObject.isVideo) {
			fileLoader.setLoadingVideoForPlayer(playingObject.document, false)

			if (playingObject.equals(message)) {
				val animation = cell.photoImage.animation
				val videoTextureView = videoTextureView

				if (animation != null && videoTextureView != null && videoPlayerContainer?.tag != null) {
					val bitmap = animation.animatedBitmap

					if (bitmap != null) {
						try {
							val src = videoTextureView.getBitmap(bitmap.width, bitmap.height)
							val canvas = Canvas(bitmap)
							canvas.drawBitmap(src!!, 0f, 0f, null)
							src.recycle()
						}
						catch (e: Throwable) {
							FileLog.e(e)
						}
					}
				}
			}

			MediaController.getInstance().cleanupPlayer(true, true, false, playingObject.equals(message))
		}

		if (chatMode == MODE_SCHEDULED && (message.isVideo || message.type == MessageObject.TYPE_PHOTO)) {
			PhotoViewer.getInstance().setParentChatActivity(this@ChatActivity)

			val arrayList = ArrayList<MessageObject?>()

			messages.forEach {
				if (it.isVideo || it.type == MessageObject.TYPE_PHOTO) {
					arrayList.add(0, it)
				}
			}

			PhotoViewer.getInstance().openPhoto(arrayList, arrayList.indexOf(message), dialogId, 0, photoViewerProvider)
		}
		else {
			PhotoViewer.getInstance().openPhoto(message, this@ChatActivity, if (message.type != MessageObject.TYPE_COMMON) dialogId else 0, if (message.type != MessageObject.TYPE_COMMON) mergeDialogId else 0, photoViewerProvider)
		}

		hideHints(false)

		MediaController.getInstance().resetGoingToShowMessageObject()
	}

	private fun updateMessageListAccessibilityVisibility() {
		if (currentEncryptedChat != null) {
			return
		}

		chatListView?.importantForAccessibility = if (mentionContainer != null && mentionContainer!!.isOpen || scrimPopupWindow != null && scrimPopupWindow!!.isShowing) View.IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS else View.IMPORTANT_FOR_ACCESSIBILITY_AUTO
	}

	private fun markSponsoredAsRead(`object`: MessageObject?) {
		if (!`object`!!.isSponsored || `object`.viewsReloaded) {
			return
		}

		`object`.viewsReloaded = true

		val req = TL_channels_viewSponsoredMessage()
		req.channel = MessagesController.getInputChannel(currentChat)
		req.random_id = `object`.sponsoredId

		connectionsManager.sendRequest(req)

		messagesController.markSponsoredAsRead(dialogId, `object`)
	}

	override fun canBeginSlide(): Boolean {
		return swipeBackEnabled && chatActivityEnterView!!.swipeToBackEnabled() && pullingDownOffset == 0f
	}

	override fun isSwipeBackEnabled(event: MotionEvent): Boolean {
		return swipeBackEnabled
	}

	private fun openLinkInternally(urlFinal: String?, fromMessageId: Int): Boolean {
		if (currentChat == null || urlFinal == null) {
			return false
		}

		if (urlFinal.startsWith("elloapp:privatepost") || urlFinal.startsWith("elloapp://privatepost")) {
			val urlTmp = urlFinal.replace("elloapp:privatepost", "elloapp://ello.team").replace("elloapp://privatepost", "elloapp://ello.team")
			val data = Uri.parse(urlTmp)
			val messageId = Utilities.parseInt(data.getQueryParameter("post"))
			val channelId = Utilities.parseLong(data.getQueryParameter("channel"))
			val threadId = Utilities.parseInt(data.getQueryParameter("thread"))

			if (channelId == currentChat!!.id && messageId != 0) {
				if (threadId != 0) {
					openDiscussionMessageChat(currentChat!!.id, null, threadId, 0, -1, 0, null)
				}
				else {
					showScrollToMessageError = true

					if (chatMode == MODE_PINNED) {
						chatActivityDelegate?.openReplyMessage(messageId)
						finishFragment()
					}
					else {
						scrollToMessageId(messageId, fromMessageId, true, 0, false, 0)
					}
				}

				return true
			}
		}
		else if (currentChat?.username != null) {
			val username = currentChat?.username?.lowercase()

			if (publicMsgUrlPattern == null) {
				publicMsgUrlPattern = Pattern.compile(String.format(Locale.getDefault(), "(https://)?%s/([0-9a-zA-Z_]+)/([0-9]+)", ApplicationLoader.applicationContext.getString(R.string.domain)))
				voiceChatUrlPattern = Pattern.compile(String.format(Locale.getDefault(), "(https://)?%s/([0-9a-zA-Z_]+)\\?(voicechat+)", ApplicationLoader.applicationContext.getString(R.string.domain)))
			}

			var matcher = publicMsgUrlPattern!!.matcher(urlFinal)

			if (matcher.find(2) && matcher.find(3) && username != null && username == matcher.group(2)?.lowercase()) {
				val data = Uri.parse(urlFinal)
				val threadId = Utilities.parseInt(data.getQueryParameter("thread"))
				val commentId = Utilities.parseInt(data.getQueryParameter("comment"))

				if (threadId != 0 || commentId != 0) {
					return false
				}
				else {
					val messageId = matcher.group(3)?.toInt() ?: return false

					showScrollToMessageError = true

					if (chatMode == MODE_PINNED) {
						chatActivityDelegate?.openReplyMessage(messageId)
						finishFragment()
					}
					else {
						startFromVideoTimestamp = getTimestampFromLink(data)

						if (startFromVideoTimestamp >= 0) {
							startFromVideoMessageId = messageId
						}

						scrollToMessageId(messageId, fromMessageId, true, 0, false, 0)
					}
				}

				return true
			}
			else if (urlFinal.startsWith("elloapp:resolve") || urlFinal.startsWith("elloapp://resolve")) {
				val urlTmp = urlFinal.replace("elloapp:resolve", "elloapp://ello.team").replace("elloapp://resolve", "elloapp://ello.team")
				val data = Uri.parse(urlTmp)
				val usernameE = data.getQueryParameter("domain")!!.lowercase()
				val messageId = Utilities.parseInt(data.getQueryParameter("post"))
				val threadId = Utilities.parseInt(data.getQueryParameter("thread"))
				val commentId = Utilities.parseInt(data.getQueryParameter("comment"))

				if (username == usernameE && messageId != 0) {
					return if (threadId != 0 || commentId != 0) {
						false
					}
					else {
						if (chatMode == MODE_PINNED) {
							chatActivityDelegate?.openReplyMessage(messageId)
							finishFragment()
						}
						else {
							scrollToMessageId(messageId, fromMessageId, true, 0, false, 0)
						}

						true
					}
				}
			}
			else {
				matcher = voiceChatUrlPattern!!.matcher(urlFinal)

				try {
					if (matcher.find(2) && matcher.find(3) && username == matcher.group(2)?.lowercase()) {
						val data = Uri.parse(urlFinal)
						val voicechat = data.getQueryParameter("voicechat")

						if (!TextUtils.isEmpty(voicechat)) {
							voiceChatHash = voicechat
							checkGroupCallJoin(true)

							return true
						}
					}
				}
				catch (e: Exception) {
					FileLog.e(e)
				}
			}
		}
		else {
			if (privateMsgUrlPattern == null) {
				privateMsgUrlPattern = Pattern.compile(String.format(Locale.getDefault(), "(https://)?%s/c/([0-9]+)/([0-9]+)", ApplicationLoader.applicationContext.getString(R.string.domain)))
			}

			val matcher = privateMsgUrlPattern!!.matcher(urlFinal)

			if (matcher.find(2) && matcher.find(3)) {
				val channelId = matcher.group(2)?.toLong() ?: 0L
				val messageId = matcher.group(3)?.toInt() ?: 0

				if (channelId == currentChat!!.id && messageId != 0) {
					val data = Uri.parse(urlFinal)
					val threadId = Utilities.parseInt(data.getQueryParameter("thread"))
					val commentId = Utilities.parseInt(data.getQueryParameter("comment"))

					return if (threadId != 0 || commentId != 0) {
						false
					}
					else {
						showScrollToMessageError = true

						if (chatMode == MODE_PINNED) {
							chatActivityDelegate?.openReplyMessage(messageId)
							finishFragment()
						}
						else {
							scrollToMessageId(messageId, fromMessageId, true, 0, false, 0)
						}

						true
					}
				}
			}
		}

		return false
	}

	override fun setInMenuMode(value: Boolean) {
		super.setInMenuMode(value)
		actionBar?.createMenu()?.visibility = if (inMenuMode) View.GONE else View.VISIBLE
	}

	fun setPreloadedSticker(preloadedSticker: TLRPC.Document?, historyEmpty: Boolean) {
		preloadedGreetingsSticker = preloadedSticker
		forceHistoryEmpty = historyEmpty
	}

	override fun onCustomTransitionAnimation(isOpen: Boolean, callback: Runnable): AnimatorSet? {
		if (isOpen && fromPullingDownTransition && getParentLayout()!!.fragmentsStack.size > 1) {
			val previousFragment = getParentLayout()!!.fragmentsStack[getParentLayout()!!.fragmentsStack.size - 2]

			if (previousFragment is ChatActivity) {
				wasManualScroll = true

				previousFragment.setTransitionToChatActivity(this)

				fragmentView?.alpha = 0f

				contentView?.setSkipBackgroundDrawing(true)

				avatarContainer?.translationY = AndroidUtilities.dp(8f).toFloat()
				avatarContainer?.avatarImageView?.alpha = 0f
				avatarContainer?.avatarImageView?.translationY = -AndroidUtilities.dp(8f).toFloat()

				toPullingDownTransition = true

				val valueAnimator = ValueAnimator.ofFloat(0f, 1f)

				chatActivityEnterView?.measure(MeasureSpec.makeMeasureSpec(AndroidUtilities.displaySize.x, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(999999, MeasureSpec.AT_MOST))

				bottomOverlay?.measure(MeasureSpec.makeMeasureSpec(AndroidUtilities.displaySize.x, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(999999, MeasureSpec.AT_MOST))

				val currentBottom = max(if (chatActivityEnterView == null) 0 else chatActivityEnterView!!.measuredHeight, if (bottomOverlay == null) 0 else bottomOverlay!!.measuredHeight)
				val prevBottom = max(if (previousFragment.chatActivityEnterView == null) 0 else previousFragment.chatActivityEnterView!!.measuredHeight, if (bottomOverlay == null) 0 else bottomOverlay!!.measuredHeight)

				pullingBottomOffset = -(prevBottom - currentBottom).toFloat()

				val useAlphaForContextView = previousFragment.fragmentContextView!!.measuredHeight != fragmentContextView!!.measuredHeight

				valueAnimator.addUpdateListener {
					val progress = it.animatedValue as Float

					previousFragment.setTransitionToChatProgress(progress)

					var y = AndroidUtilities.dp(8f) * (1f - progress)

					avatarContainer?.translationY = y
					avatarContainer?.avatarImageView?.translationY = -y

					y = -AndroidUtilities.dp(8f) * progress

					previousFragment.avatarContainer?.translationY = y
					previousFragment.avatarContainer?.avatarImageView?.translationY = -y

					avatarContainer?.avatarImageView?.scaleX = 0.8f + 0.2f * progress
					avatarContainer?.avatarImageView?.scaleY = 0.8f + 0.2f * progress
					avatarContainer?.avatarImageView?.alpha = progress

					previousFragment.avatarContainer?.avatarImageView?.scaleX = 0.8f + 0.2f * (1f - progress)
					previousFragment.avatarContainer?.avatarImageView?.scaleY = 0.8f + 0.2f * (1f - progress)
					previousFragment.avatarContainer?.avatarImageView?.alpha = 1f - progress

					previousFragment.chatActivityEnterView?.translationY = -pullingBottomOffset * progress
					previousFragment.bottomOverlay?.translationY = -pullingBottomOffset * progress

					if (useAlphaForContextView) {
						previousFragment.fragmentContextView?.alpha = 1f - progress
					}

					previousFragment.pinnedMessageView?.alpha = 1f - progress
					previousFragment.topChatPanelView?.alpha = 1f - progress
				}

				updateChatListViewTopPadding()

				fragmentTransition = AnimatorSet()

				fragmentTransition?.addListener(object : AnimatorListenerAdapter() {
					var index = 0

					override fun onAnimationStart(animation: Animator) {
						super.onAnimationStart(animation)
						index = notificationCenter.setAnimationInProgress(index, null)
					}

					override fun onAnimationEnd(animation: Animator) {
						fragmentOpened = true
						fragmentBeginToShow = true
						fragmentTransition = null

						AndroidUtilities.runOnUIThread({
							notificationCenter.onAnimationFinish(index)
						}, 32)

						super.onAnimationEnd(animation)

						contentView?.invalidate()
						contentView?.setSkipBackgroundDrawing(false)

						toPullingDownTransition = false

						previousFragment.setTransitionToChatProgress(0f)
						previousFragment.setTransitionToChatActivity(null)

						fragmentView?.alpha = 1f

						callback.run()

						avatarContainer?.translationY = 0f

						previousFragment.avatarContainer?.translationY = 0f
						previousFragment.avatarContainer?.avatarImageView?.translationY = 0f

						avatarContainer?.avatarImageView?.scaleX = 1f
						avatarContainer?.avatarImageView?.scaleY = 1f
						avatarContainer?.avatarImageView?.alpha = 1f

						previousFragment.avatarContainer?.avatarImageView?.scaleX = 1f
						previousFragment.avatarContainer?.avatarImageView?.scaleY = 1f
						previousFragment.avatarContainer?.avatarImageView?.alpha = 1f

						previousFragment.pinnedMessageView?.alpha = 1f
						previousFragment.topChatPanelView?.alpha = 1f
					}
				})

				fragmentTransition?.duration = 300
				fragmentTransition?.interpolator = CubicBezierInterpolator.DEFAULT
				fragmentTransition?.playTogether(valueAnimator)

				AndroidUtilities.runOnUIThread(fragmentTransitionRunnable, 200)

				return fragmentTransition
			}
		}

		return null
	}

	private fun setTransitionToChatActivity(chatActivity: ChatActivity?) {
		pullingDownAnimateToActivity = chatActivity
	}

	private fun setTransitionToChatProgress(p: Float) {
		pullingDownAnimateProgress = p
		fragmentView?.invalidate()
		chatListView?.invalidate()
	}

	private fun showChatThemeBottomSheet() {
		chatThemeBottomSheet = ChatThemeBottomSheet(this@ChatActivity)

		chatListView?.setOnInterceptTouchListener { true }

		setChildrenEnabled(contentView, false)

		showDialog(chatThemeBottomSheet) {
			chatThemeBottomSheet = null
			chatListView?.setOnInterceptTouchListener(null)
			setChildrenEnabled(contentView, true)
			ChatThemeController.clearWallpaperThumbImages()
		}
	}

	private fun setChildrenEnabled(view: View?, isEnabled: Boolean) {
		if (view is ViewGroup) {
			for (i in 0 until view.childCount) {
				setChildrenEnabled(view.getChildAt(i), isEnabled)
			}
		}

		if (view !== chatListView && view !== contentView) {
			view?.isEnabled = isEnabled
		}
	}

	private fun checkThemeEmoticon() {
		if (!fragmentOpened) {
			return
		}

		var emoticon: String? = null

		if (currentUserInfo != null) {
			emoticon = currentUserInfo?.theme_emoticon
		}

		if (emoticon == null && currentChatInfo != null) {
			emoticon = currentChatInfo?.theme_emoticon
		}

		setChatThemeEmoticon(emoticon)
	}

	private fun setChatThemeEmoticon(emoticon: String?) {
		ChatThemeController.getInstance(currentAccount).setDialogTheme(dialogId, emoticon, false)

		if (!emoticon.isNullOrEmpty()) {
			ChatThemeController.requestChatTheme(emoticon) {
				// unused
			}
		}
		else {
//			themeDelegate.setCurrentTheme(null, openAnimationStartTime != 0, null);
		}
	}

	override fun allowPresentFragment(): Boolean {
		return !inPreviewMode
	}

	override fun hideKeyboardOnShow(): Boolean {
		return if (threadMessage?.repliesCount == 0 && canSendMessages(currentChat)) {
			false
		}
		else {
			super.hideKeyboardOnShow()
		}
	}

	fun getGroup(id: Long): GroupedMessages? {
		return groupedMessagesMap[id]
	}

	private interface ChatActivityDelegate {
		fun openReplyMessage(mid: Int) {}
		fun openSearch(text: String?) {}
		fun onUnpin(all: Boolean, hide: Boolean) {}
		fun onReport() {}
	}

	private class PinnedMessageButton(context: Context) : AppCompatTextView(context) {
		init {
			isSingleLine = true
			setLines(1)
			maxLines = 1
			ellipsize = TextUtils.TruncateAt.END
			setTextColor(context.getColor(R.color.white))
			background = Theme.AdaptiveRipple.filledRect(context.getColor(R.color.brand), 16f)
			setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14f)
			typeface = Theme.TYPEFACE_BOLD
			gravity = Gravity.CENTER
			setPadding(AndroidUtilities.dp(14f), 0, AndroidUtilities.dp(14f), 0)
		}

		override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
			super.onMeasure(MeasureSpec.makeMeasureSpec(min(MeasureSpec.getSize(widthMeasureSpec), (AndroidUtilities.displaySize.x * 0.45f).toInt()), MeasureSpec.AT_MOST), heightMeasureSpec)
		}
	}

	private inner class TrackingWidthSimpleTextView(context: Context) : SimpleTextView(context) {
		var trackWidth = true

		override fun createLayout(width: Int): Boolean {
			val result = super.createLayout(width)

			if (trackWidth && visibility == VISIBLE) {
				pinnedCounterTextViewX = textWidth + AndroidUtilities.dp(4f)
				pinnedCounterTextView?.translationX = pinnedCounterTextViewX.toFloat()
			}

			return result
		}
	}

	inner class ChatActivityAdapter(private val mContext: Context) : AnimatableAdapter() {
		val isBot = currentUser?.bot == true
		var isFrozen = false
		val frozenMessages = mutableListOf<MessageObject>()
		private var rowCount = 0
		var botInfoRow = -5
		private var botInfoEmptyRow = -5
		var loadingUpRow = -5
		var loadingDownRow = -5
		var messagesStartRow = 0
		var messagesEndRow = 0

		init {
			setHasStableIds(true)
		}

		fun updateRowsSafe() {
			val prevRowCount = rowCount
			val prevBotInfoRow = botInfoRow
			val prevLoadingUpRow = loadingUpRow
			val prevLoadingDownRow = loadingDownRow
			val prevMessagesStartRow = messagesStartRow
			val prevMessagesEndRow = messagesEndRow

			updateRowsInternal()

			if (prevRowCount != rowCount || prevBotInfoRow != botInfoRow || prevLoadingUpRow != loadingUpRow || prevLoadingDownRow != loadingDownRow || prevMessagesStartRow != messagesStartRow || prevMessagesEndRow != messagesEndRow) {
				notifyDataSetChanged(false)
			}
		}

		fun updateRowsInternal() {
			rowCount = 0

			val messages = if (isFrozen) frozenMessages else messages

			if (messages.isNotEmpty()) {
				loadingDownRow = if ((!forwardEndReached[0] || mergeDialogId != 0L && !forwardEndReached[1]) && !hideForwardEndReached) {
					rowCount++
				}
				else {
					-5
				}

				messagesStartRow = rowCount
				rowCount += messages.size
				messagesEndRow = rowCount

				botInfoRow = if ((isReplyUser(currentUser) || currentUser != null && currentUser!!.bot && !MessagesController.isSupportUser(currentUser) && chatMode == 0) && endReached[0]) {
					rowCount++
				}
				else {
					-5
				}

				loadingUpRow = if (!endReached[0] || mergeDialogId != 0L && !endReached[1]) {
					rowCount++
				}
				else {
					-5
				}
			}
			else {
				loadingUpRow = -5
				loadingDownRow = -5
				messagesStartRow = -5
				messagesEndRow = -5

				botInfoRow = if (isReplyUser(currentUser) || currentUser != null && currentUser!!.bot && currentUser!!.id != BuildConfig.AI_BOT_ID && !MessagesController.isSupportUser(currentUser) && chatMode == 0) {
					rowCount++
				}
				else {
					-5
				}
			}
		}

		override fun getItemCount(): Int {
			botInfoEmptyRow = -5

			if (clearingHistory) {
				if (currentUser != null && currentUser!!.bot && currentUser!!.id != BuildConfig.AI_BOT_ID && chatMode == 0 && (botInfo.size() > 0 && (botInfo[currentUser!!.id]!!.description != null || botInfo[currentUser!!.id]!!.description_photo != null || botInfo[currentUser!!.id]!!.description_document != null) || isReplyUser(currentUser))) {
					botInfoEmptyRow = 0
					return 1
				}

				return 0
			}

			return rowCount
		}

		override fun getItemId(position: Int): Long {
			if (clearingHistory) {
				if (position == botInfoEmptyRow) {
					return 1
				}
			}

			val messages = if (isFrozen) frozenMessages else messages

			when (position) {
				in messagesStartRow until messagesEndRow -> {
					return messages[position - messagesStartRow].stableId.toLong()
				}

				botInfoRow, botInfoEmptyRow -> {
					return 1
				}

				loadingUpRow -> {
					return 2
				}

				loadingDownRow -> {
					return 3
				}

				else -> {
					return 4
				}
			}
		}

		override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
			var view: View? = null

			if (viewType == 0) {
				if (chatMessageCellsCache.isNotEmpty()) {
					view = chatMessageCellsCache[0]
					chatMessageCellsCache.removeAt(0)
				}
				else {
					view = ChatMessageCell(mContext)
				}

				val chatMessageCell = view as? ChatMessageCell
				chatMessageCell?.shouldCheckVisibleOnScreen = true

				chatMessageCell?.delegate = object : ChatMessageCellDelegate {
					override fun didPressHint(cell: ChatMessageCell, type: Int) {
						@Suppress("NAME_SHADOWING") var cell = cell

						if (type == 0) {
							val media = cell.getMessageObject()?.messageOwner?.media as? TL_messageMediaPoll
							showPollSolution(cell.getMessageObject(), media?.results)
						}
						else if (type == 1) {
							var messageObject = cell.getMessageObject()

							if (messageObject?.messageOwner?.fwd_from == null || messageObject.messageOwner?.fwd_from?.psa_type.isNullOrEmpty()) {
								return
							}

							var text: CharSequence? = LocaleController.getString("PsaMessageInfo_" + messageObject.messageOwner?.fwd_from?.psa_type)

							if (text.isNullOrEmpty()) {
								text = mContext.getString(R.string.PsaMessageInfoDefault)
							}

							val stringBuilder = SpannableStringBuilder(text)

							MessageObject.addLinks(false, stringBuilder)

							val group = cell.currentMessagesGroup

							if (group != null) {
								var a = 0
								val N = group.posArray.size

								while (a < N) {
									val pos = group.posArray[a]

									if (pos.flags and MessageObject.POSITION_FLAG_LEFT != 0) {
										val m = group.messages[a]

										if (m !== messageObject) {
											messageObject = m

											val count = chatListView!!.childCount

											for (b in 0 until count) {
												@Suppress("NAME_SHADOWING") val view = chatListView?.getChildAt(b) as? ChatMessageCell ?: continue
												val c = view

												if (messageObject == c.getMessageObject()) {
													cell = c
												}
											}
										}

										break
									}

									a++
								}
							}

							showInfoHint(messageObject, stringBuilder, 1)
						}

						cell.showHintButton(show = false, animated = true, type = type)
					}

					override fun shouldDrawThreadProgress(cell: ChatMessageCell): Boolean {
						val group = cell.currentMessagesGroup

						val message = if (group != null && group.messages.isNotEmpty()) {
							group.messages[0]
						}
						else {
							cell.getMessageObject()
						}

						return if (message == null) {
							false
						}
						else {
							message.id == commentLoadingMessageId
						}
					}

					override fun didPressSideButton(cell: ChatMessageCell) {
						if (parentActivity == null) {
							return
						}

						chatActivityEnterView?.closeKeyboard()

						val messageObject = cell.getMessageObject() ?: return

						if (chatMode == MODE_PINNED) {
							chatActivityDelegate?.openReplyMessage(messageObject.id)
							finishFragment()
						}
						else if ((isReplyUser(currentUser) || isUserSelf(currentUser)) && messageObject.messageOwner?.fwd_from?.saved_from_peer != null) {
							if (isReplyUser(currentUser) && messageObject.messageOwner?.reply_to != null && messageObject.messageOwner?.reply_to?.reply_to_top_id != 0) {
								openDiscussionMessageChat(messageObject.messageOwner!!.reply_to!!.reply_to_peer_id.channel_id, null, messageObject.messageOwner!!.reply_to!!.reply_to_top_id, 0, -1, messageObject.messageOwner!!.fwd_from!!.saved_from_msg_id, messageObject)
							}
							else {
								openOriginalReplyChat(messageObject)
							}
						}
						else {
							var arrayList: List<MessageObject>? = null

							if (messageObject.groupId != 0L) {
								val groupedMessages = groupedMessagesMap[messageObject.groupId]

								if (groupedMessages != null) {
									arrayList = groupedMessages.messages
								}
							}

							if (arrayList == null) {
								arrayList = listOf(messageObject)
							}

							showDialog(object : ShareAlert(mContext, this@ChatActivity, arrayList, null, null, isChannel(currentChat), null, null, false, false) {
								override fun dismissInternal() {
									super.dismissInternal()

									AndroidUtilities.requestAdjustResize(parentActivity, classGuid)

									if (chatActivityEnterView?.visibility == View.VISIBLE) {
										fragmentView?.requestLayout()
									}
								}

								override fun onSend(dids: LongSparseArray<TLRPC.Dialog>, count: Int) {
									if (dids.size() == 1) {
										undoView?.showWithAction(dids.valueAt(0).id, UndoView.ACTION_FWD_MESSAGES, count)
									}
									else {
										undoView?.showWithAction(0, UndoView.ACTION_FWD_MESSAGES, count, dids.size(), null, null)
									}
								}
							})

							AndroidUtilities.setAdjustResizeToNothing(parentActivity, classGuid)

							fragmentView?.requestLayout()
						}
					}

					override fun needPlayMessage(messageObject: MessageObject): Boolean {
						if (messageObject.isVoice || messageObject.isRoundVideo) {
							val result = MediaController.getInstance().playMessage(messageObject)
							MediaController.getInstance().setVoiceMessagesPlaylist(if (result) createVoiceMessagesPlaylist(messageObject, false) else null, false)
							return result
						}
						else if (messageObject.isMusic) {
							return MediaController.getInstance().setPlaylist(messages, messageObject, mergeDialogId)
						}

						return false
					}

					override fun videoTimerReached() {
						showNoSoundHint()
					}

					override fun didPressTime(cell: ChatMessageCell) {
						undoView!!.showWithAction(dialogId, UndoView.ACTION_IMPORT_INFO, null)
					}

					override fun didPressChannelAvatar(cell: ChatMessageCell, chat: Chat?, postId: Int, touchX: Float, touchY: Float) {
						if (chat == null) {
							return
						}

						if (actionBar!!.isActionModeShowed || reportType >= 0) {
							processRowSelect(cell, true, touchX, touchY)
							return
						}

						openChat(cell, chat, postId)
					}

					override fun didPressHiddenForward(cell: ChatMessageCell) {
						if (cell.getMessageObject()!!.isImportedForward) {
							didPressTime(cell)
							return
						}

						showForwardHint(cell)
					}

					override fun didPressOther(cell: ChatMessageCell, otherX: Float, otherY: Float) {
						val messageObject = cell.getMessageObject()

						if (messageObject?.type == 16) {
							if (currentUser != null) {
								startCall(currentUser!!, messageObject.isVideoCall, currentUserInfo != null && currentUserInfo!!.video_calls_available, parentActivity!!, messagesController.getUserFull(currentUser!!.id), accountInstance)
							}
						}
						else {
							createMenu(cell, single = true, listView = false, x = otherX, y = otherY, searchGroup = messageObject?.isMusic == true)
						}
					}

					override fun didPressUserAvatar(cell: ChatMessageCell, user: User, touchX: Float, touchY: Float) {
						if (actionBar!!.isActionModeShowed || reportType >= 0) {
							processRowSelect(cell, true, touchX, touchY)
							return
						}

						openProfile(user)
					}

					override fun didLongPressUserAvatar(cell: ChatMessageCell, user: User, touchX: Float, touchY: Float): Boolean {
						if (isAvatarPreviewerEnabled) {
							val enableMention = currentChat != null && (bottomOverlayChat == null || bottomOverlayChat!!.visibility != View.VISIBLE) && (bottomOverlay == null || bottomOverlay!!.visibility != View.VISIBLE)

							val menuItems = arrayOfNulls<AvatarPreviewer.MenuItem>(2 + if (enableMention) 1 else 0)
							menuItems[0] = AvatarPreviewer.MenuItem.OPEN_PROFILE
							menuItems[1] = AvatarPreviewer.MenuItem.SEND_MESSAGE

							if (enableMention) {
								menuItems[2] = AvatarPreviewer.MenuItem.MENTION
							}

							val userFull = messagesController.getUserFull(user.id)

							val data = if (userFull != null) {
								AvatarPreviewer.Data.of(userFull, *menuItems)
							}
							else {
								AvatarPreviewer.Data.of(user, classGuid, *menuItems)
							}

							if (AvatarPreviewer.canPreview(data)) {
								AvatarPreviewer.getInstance().show(fragmentView as? ViewGroup, data) { item ->
									when (item) {
										AvatarPreviewer.MenuItem.SEND_MESSAGE -> {
											openDialog(cell, user)
										}

										AvatarPreviewer.MenuItem.OPEN_PROFILE -> {
											openProfile(user)
										}

										AvatarPreviewer.MenuItem.MENTION -> {
											appendMention(user)
										}

										else -> {
											// unused
										}
									}
								}

								return true
							}
						}

						return false
					}

					private fun appendMention(user: User) {
						val chatActivityEnterView = chatActivityEnterView ?: return
						val sb: SpannableStringBuilder
						val text = chatActivityEnterView.fieldText

						if (text != null) {
							sb = SpannableStringBuilder(text)

							if (text[text.length - 1] != ' ') {
								sb.append(" ")
							}
						}
						else {
							sb = SpannableStringBuilder()
						}

						if (sb.isNotEmpty() && sb[sb.length - 1] != ' ') {
							sb.append(' ')
						}

						if (user.username != null) {
							sb.append("@").append(user.username).append(" ")
						}
						else {
							val name = getFirstName(user, false)

							val spannable: Spannable = SpannableString("$name ")
							spannable.setSpan(URLSpanUserMention("" + user.id, 3), 0, spannable.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

							sb.append(spannable)
						}

						chatActivityEnterView.fieldText = sb

						AndroidUtilities.runOnUIThread({
							chatActivityEnterView.openKeyboard()
						}, 200)
					}

					override fun didLongPressChannelAvatar(cell: ChatMessageCell, chat: Chat, postId: Int, touchX: Float, touchY: Float): Boolean {
						if (isAvatarPreviewerEnabled) {
							var menuItems = arrayOf<AvatarPreviewer.MenuItem?>(AvatarPreviewer.MenuItem.OPEN_PROFILE)

							if (currentChat == null || currentChat!!.id != chat.id || isThreadChat) {
								menuItems = menuItems.copyOf(2)
								menuItems[1] = if (chat.broadcast) AvatarPreviewer.MenuItem.OPEN_CHANNEL else AvatarPreviewer.MenuItem.OPEN_GROUP
							}

							val chatFull = messagesController.getChatFull(chat.id)

							val data = if (chatFull != null) {
								AvatarPreviewer.Data.of(chat, chatFull, *menuItems)
							}
							else {
								AvatarPreviewer.Data.of(chat, classGuid, *menuItems)
							}

							if (AvatarPreviewer.canPreview(data)) {
								AvatarPreviewer.getInstance().show(fragmentView as ViewGroup?, data) { item: AvatarPreviewer.MenuItem? ->
									when (item) {
										AvatarPreviewer.MenuItem.OPEN_PROFILE -> {
											openProfile(chat)
										}

										AvatarPreviewer.MenuItem.OPEN_GROUP, AvatarPreviewer.MenuItem.OPEN_CHANNEL -> {
											openChat(cell, chat, 0)
										}

										else -> {
											// unused
										}
									}
								}

								return true
							}
						}
						return false
					}

					private fun openProfile(user: User?) {
						if (user != null && user.id != userConfig.getClientUserId()) {
							if (user.is_public) {
								val args = Bundle()
								args.putLong("user_id", user.id)

								val fragment = ProfileActivity(args)
								fragment.setPlayProfileAnimation(if (currentUser != null && currentUser!!.id == user.id) 1 else 0)

								AndroidUtilities.setAdjustResizeToNothing(parentActivity, classGuid)

								presentFragment(fragment)
							}
							else {
								val request = userCheckHasDialog(user.id)

								val req = connectionsManager.sendRequest(request) { response, _ ->
									var allowed = false

									if (response is TL_biz_dataRaw) {
										val s = String(response.data, StandardCharsets.UTF_8)
										var richVerifyResponse: RichVerifyResponse? = null

										try {
											richVerifyResponse = Gson().fromJson(s, RichVerifyResponse::class.java)
										}
										catch (e: Exception) {
											FileLog.e(e)
										}

										if (richVerifyResponse != null && richVerifyResponse.status) {
											AndroidUtilities.runOnUIThread {
												val args = Bundle()
												args.putLong("user_id", user.id)

												val fragment = ProfileActivity(args)
												fragment.setPlayProfileAnimation(if (currentUser?.id == user.id) 1 else 0)

												AndroidUtilities.setAdjustResizeToNothing(parentActivity, classGuid)

												presentFragment(fragment)
											}

											allowed = true
										}
									}
									if (!allowed) {
										AndroidUtilities.runOnUIThread {
											Toast.makeText(mContext, R.string.you_cannot_open_this_chat, Toast.LENGTH_SHORT).show()
										}
									}
								}
								connectionsManager.bindRequestToGuid(req, classGuid)
							}
						}
					}

					private fun openProfile(chat: Chat?) {
						if (chat != null) {
							val args = Bundle()
							args.putLong("chat_id", chat.id)

							presentFragment(ProfileActivity(args))
						}
					}

					private fun openDialog(cell: ChatMessageCell, user: User?) {
						if (user != null) {
							val args = Bundle()
							args.putLong("user_id", user.id)

							if (messagesController.checkCanOpenChat(args, this@ChatActivity, cell.getMessageObject())) {
								if (user.is_public) {
									presentFragment(ChatActivity(args))
								}
								else {
									val request = userCheckHasDialog(user.id)
									val req = connectionsManager.sendRequest(request) { response, _ ->
										var allowed = false

										if (response is TL_biz_dataRaw) {
											val s = String(response.data, StandardCharsets.UTF_8)
											var richVerifyResponse: RichVerifyResponse? = null

											try {
												richVerifyResponse = Gson().fromJson(s, RichVerifyResponse::class.java)
											}
											catch (e: Exception) {
												FileLog.e(e)
											}

											if (richVerifyResponse?.status == true) {
												AndroidUtilities.runOnUIThread {
													presentFragment(ChatActivity(args))
												}

												allowed = true
											}
										}

										if (!allowed) {
											AndroidUtilities.runOnUIThread {
												Toast.makeText(mContext, R.string.you_cannot_open_this_chat, Toast.LENGTH_SHORT).show()
											}
										}
									}

									connectionsManager.bindRequestToGuid(req, classGuid)
								}
							}
						}
					}

					private fun openChat(cell: ChatMessageCell, chat: Chat, postId: Int) {
						if (currentChat != null && chat.id == currentChat!!.id) {
							scrollToMessageId(postId, cell.getMessageObject()!!.id, true, 0, true, 0)
						}
						else if (currentChat == null || chat.id != currentChat!!.id || isThreadChat) {
							val args = Bundle()
							args.putLong("chat_id", chat.id)

							if (postId != 0) {
								args.putInt("message_id", postId)
							}

							if (messagesController.checkCanOpenChat(args, this@ChatActivity, cell.getMessageObject())) {
								presentFragment(ChatActivity(args))
							}
						}
					}

					private val isAvatarPreviewerEnabled: Boolean
						get() = isUserSelf(currentUser) || currentChat != null && (!isChannel(currentChat) || currentChat!!.megagroup)

					override fun didPressBotButton(cell: ChatMessageCell, button: KeyboardButton) {
						if (parentActivity == null || bottomOverlayChat!!.visibility == View.VISIBLE && button !is TL_keyboardButtonSwitchInline && button !is TL_keyboardButtonCallback && button !is TL_keyboardButtonGame && button !is TL_keyboardButtonUrl && button !is TL_keyboardButtonBuy && button !is TL_keyboardButtonUrlAuth && button !is TL_keyboardButtonUserProfile) {
							return
						}

						if (isAiBot()) {
							if (!chatBotController.userSettingsUpdated) {
								updateChatBotTopPanel()
							}
						}

						chatActivityEnterView?.didPressedBotButton(button, cell.getMessageObject(), cell.getMessageObject())
					}

					override fun needShowPremiumFeatures(source: String) {
						presentFragment(PremiumPreviewFragment(source))
					}

					override fun didLongPressBotButton(cell: ChatMessageCell, button: KeyboardButton) {
						if (parentActivity == null || bottomOverlayChat!!.visibility == View.VISIBLE && button !is TL_keyboardButtonSwitchInline && button !is TL_keyboardButtonCallback && button !is TL_keyboardButtonGame && button !is TL_keyboardButtonUrl && button !is TL_keyboardButtonBuy && button !is TL_keyboardButtonUrlAuth && button !is TL_keyboardButtonUserProfile) {
							return
						}

						if (button is TL_keyboardButtonUrl) {
							openClickableLink(null, button.url, true, cell, cell.getMessageObject())

							runCatching {
								cell.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS, HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING)
							}
						}
					}

					override fun didPressReaction(cell: ChatMessageCell, reaction: ReactionCount?, longpress: Boolean) {
						val parentActivity = parentActivity ?: return

						if (longpress) {
							if (!isChannelAndNotMegaGroup(currentChat) || dialogId >= 0) {
								cell.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS)

								val scrimPopupContainerLayout = object : FrameLayout(parentActivity) {
									override fun dispatchKeyEvent(event: KeyEvent): Boolean {
										if (event.keyCode == KeyEvent.KEYCODE_BACK && event.repeatCount == 0) {
											closeMenu()
										}

										return super.dispatchKeyEvent(event)
									}

									override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
										var h = min(MeasureSpec.getSize(heightMeasureSpec), AndroidUtilities.dp((ReactedUsersListView.VISIBLE_ITEMS * ReactedUsersListView.ITEM_HEIGHT_DP).toFloat()))

										if (h == 0) {
											h = AndroidUtilities.dp((ReactedUsersListView.VISIBLE_ITEMS * ReactedUsersListView.ITEM_HEIGHT_DP).toFloat())
										}

										super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(h, MeasureSpec.AT_MOST))
									}
								}

								scrimPopupContainerLayout.layoutParams = createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat())
								val backgroundPaddings = Rect()

								val shadowDrawable2 = ContextCompat.getDrawable(parentActivity, R.drawable.popup_fixed_alert)!!.mutate()
								shadowDrawable2.colorFilter = PorterDuffColorFilter(context!!.getColor(R.color.background), PorterDuff.Mode.MULTIPLY)
								shadowDrawable2.getPadding(backgroundPaddings)
								scrimPopupContainerLayout.background = shadowDrawable2

								val button = cell.getReactionButton(fromTLReaction(reaction?.reaction)) ?: return
								// val bottom = (cell.reactionsLayoutInBubble.y + button.y + AndroidUtilities.dp(28f)).toFloat()
								val left = (cell.reactionsLayoutInBubble.x + button.x).toFloat()
								val loc = IntArray(2)

								cell.getLocationInWindow(loc)

								scrimPopupContainerLayout.addView(ReactedUsersListView(parentActivity, currentAccount, cell.primaryMessageObject!!, reaction, false).setOnCustomEmojiSelectedListener { _, customEmojiStickerSets ->
									val alert: EmojiPacksAlert = object : EmojiPacksAlert(this@ChatActivity, parentActivity, customEmojiStickerSets) {
										override fun dismiss() {
											super.dismiss()
											dimBehindView(false)
										}
									}

									alert.setCalcMandatoryInsets(isKeyboardVisible)
									alert.setDimBehind(false)

									closeMenu(false)

									showDialog(alert)
								}.setOnProfileSelectedListener { _, userId, _ ->
									// MARK: open profile
									val args = Bundle()
									args.putLong("user_id", userId)
									args.putInt("report_reaction_message_id", cell.getMessageObject()!!.id)
									args.putLong("report_reaction_from_dialog_id", dialogId)

									val fragment = ProfileActivity(args)

									presentFragment(fragment)

									closeMenu()
								}, createFrame(240, LayoutHelper.WRAP_CONTENT.toFloat()))

								scrimPopupWindow = object : ActionBarPopupWindow(scrimPopupContainerLayout, LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT) {
									override fun dismiss() {
										super.dismiss()

										if (scrimPopupWindow !== this) {
											return
										}

										scrimPopupWindow = null
										menuDeleteItem = null
										scrimPopupWindowItems = null
										chatLayoutManager?.setCanScrollVertically(true)

										if (scrimPopupWindowHideDimOnDismiss) {
											dimBehindView(false)
										}
										else {
											scrimPopupWindowHideDimOnDismiss = true
										}

										chatActivityEnterView?.editField?.setAllowDrawCursor(true)
									}
								}

								scrimPopupWindow?.setPauseNotifications(true)
								scrimPopupWindow?.setDismissAnimationDuration(220)
								scrimPopupWindow?.isOutsideTouchable = true
								scrimPopupWindow?.isClippingEnabled = true
								scrimPopupWindow?.animationStyle = R.style.PopupContextAnimation
								scrimPopupWindow?.isFocusable = true

								scrimPopupContainerLayout.measure(MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(1000f), MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(1000f), MeasureSpec.AT_MOST))

								scrimPopupWindow?.inputMethodMode = PopupWindow.INPUT_METHOD_NOT_NEEDED
								scrimPopupWindow?.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED
								scrimPopupWindow?.contentView?.isFocusableInTouchMode = true

								var totalHeight = contentView?.height ?: 0
								val height = scrimPopupContainerLayout.measuredHeight
								val keyboardHeight = contentView?.measureKeyboardHeight() ?: 0

								if (keyboardHeight > AndroidUtilities.dp(20f)) {
									totalHeight += keyboardHeight
								}

								var popupX = (left - AndroidUtilities.dp(28f)).toInt()
								popupX = max(AndroidUtilities.dp(6f), min(chatListView!!.measuredWidth - AndroidUtilities.dp(6f) - scrimPopupContainerLayout.measuredWidth, popupX))

								if (AndroidUtilities.isTablet()) {
									val location = IntArray(2)
									fragmentView?.getLocationInWindow(location)
									popupX += location[0]
								}

								val popupY = if (height < totalHeight) {
									if (height < totalHeight / 2f && chatListView!!.y + cell.y + cell.reactionsLayoutInBubble.y + button.y > totalHeight / 2f) {
										(chatListView!!.y + cell.y + cell.reactionsLayoutInBubble.y + button.y - height).toInt()
									}
									else {
										(chatListView!!.y + cell.y + cell.reactionsLayoutInBubble.y + button.y + button.height).toInt()
									}
								}
								else {
									if (inBubbleMode) 0 else AndroidUtilities.statusBarHeight
								}

								scrimPopupWindow?.showAtLocation(chatListView!!, Gravity.LEFT or Gravity.TOP, popupX, popupY.also { scrimPopupY = it })
								chatListView?.stopScroll()
								chatLayoutManager?.setCanScrollVertically(false)

								scrimViewReaction = (reaction?.reaction as? TL_reactionEmoji)?.emoticon

								dimBehindView(cell, true)
								hideHints(false)

								topUndoView?.hide(true, 1)
								undoView?.hide(true, 1)
								chatActivityEnterView?.editField?.setAllowDrawCursor(false)
							}
						}
						else if (reaction != null) {
							val visibleReaction = fromTLReaction(reaction.reaction)
							selectReaction(cell.primaryMessageObject, null, null, 0f, 0f, visibleReaction, fromDoubleTap = false, bigEmoji = false, addToRecent = false)
						}
					}

					override fun didPressVoteButtons(cell: ChatMessageCell, buttons: ArrayList<TL_pollAnswer>, showCount: Int, x: Int, y: Int) {
						@Suppress("NAME_SHADOWING") var x = x
						@Suppress("NAME_SHADOWING") var y = y

						if (showCount >= 0 || buttons.isEmpty()) {
							if (parentActivity == null) {
								return
							}

							if (pollHintView == null) {
								pollHintView = HintView(parentActivity, HintView.TYPE_POLL_VOTE)
								pollHintView?.alpha = 0.0f
								pollHintView?.visibility = View.INVISIBLE

								val index = contentView!!.indexOfChild(chatActivityEnterView)

								if (index == -1) {
									return
								}

								contentView?.addView(pollHintView, index + 1, createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT.toFloat(), Gravity.LEFT or Gravity.TOP, 19f, 0f, 19f, 0f))
							}

							if (buttons.isEmpty() && showCount < 0) {
								val pollButtons = cell.pollButtons
								var lastDiff = 0f
								var a = 0
								val N = pollButtons.size

								while (a < N) {
									val button = pollButtons[a]

									lastDiff = cell.y + button.y - AndroidUtilities.dp(4f) - chatListViewPadding
									pollHintX = button.x + AndroidUtilities.dp(13.3f)
									pollHintY = button.y - AndroidUtilities.dp(6f) + y

									if (lastDiff > 0) {
										lastDiff = 0f
										x = pollHintX
										y = pollHintY
										break
									}

									a++
								}

								if (lastDiff != 0f) {
									chatListView?.smoothScrollBy(0, lastDiff.toInt())
									pollHintCell = cell
									return
								}
							}

							pollHintView?.showForMessageCell(cell, showCount, x, y, true)
						}
						else {
							sendMessagesHelper.sendVote(cell.getMessageObject(), buttons, null)
						}
					}

					override fun didPressCancelSendButton(cell: ChatMessageCell) {
						val message = cell.getMessageObject() ?: return

						if (message.messageOwner?.send_state != 0) {
							sendMessagesHelper.cancelSendingMessage(message)
						}
					}

					override fun didLongPress(cell: ChatMessageCell, x: Float, y: Float) {
						createMenu(cell, single = false, listView = false, x = x, y = y)
						startMultiselect(chatListView?.getChildAdapterPosition(cell))
					}

					override fun canPerformActions(): Boolean {
						return actionBar != null && !actionBar!!.isActionModeShowed && reportType < 0 && !inPreviewMode
					}

					override fun didPressUrl(cell: ChatMessageCell, url: CharacterStyle, longPress: Boolean) {
						didPressMessageUrl(url, longPress, cell.getMessageObject(), cell)
					}

					override fun didPressAnimatedEmoji(span: AnimatedEmojiSpan?): Boolean {
						if (span == null || span.standard) {
							return false
						}

						val documentId = span.getDocumentId()
						val document = (if (span.document == null) AnimatedEmojiDrawable.findDocument(currentAccount, documentId) else span.document) ?: return false
						val inputStickerSet = MessageObject.getInputStickerSet(document) ?: return false
						val set = MediaDataController.getInstance(currentAccount).getStickerSet(inputStickerSet, false)

						if (set?.set == null) {
							return false
						}

						BulletinFactory.of(this@ChatActivity).createEmojiBulletin(document, AndroidUtilities.replaceTags(LocaleController.formatString("MessageContainsEmojiPackSingle", R.string.MessageContainsEmojiPackSingle, set.set.title)), context!!.getString(R.string.ViewAction)) {
							val inputSets = ArrayList<InputStickerSet>(1)
							inputSets.add(inputStickerSet)
							val alert = EmojiPacksAlert(this@ChatActivity, parentActivity, inputSets)
							alert.setCalcMandatoryInsets(isKeyboardVisible)
							showDialog(alert)
						}.show()

						return true
					}

					override fun didPressExtendedMediaPreview(cell: ChatMessageCell, button: KeyboardButton) {
						sendMessagesHelper.sendCallback(true, cell.getMessageObject(), button, this@ChatActivity)
					}

					override fun needOpenWebView(message: MessageObject, url: String, title: String, description: String, originalUrl: String, w: Int, h: Int) {
						try {
							EmbedBottomSheet.show(this@ChatActivity, message, photoViewerProvider, title, description, originalUrl, url, w, h, isKeyboardVisible)
						}
						catch (e: Throwable) {
							FileLog.e(e)
						}
					}

					override fun didPressReplyMessage(cell: ChatMessageCell, id: Int) {
						if (isReplyUser(currentUser)) {
							didPressSideButton(cell)
							return
						}

						val messageObject = cell.getMessageObject()

						if (chatMode == MODE_PINNED || chatMode == MODE_SCHEDULED) {
							chatActivityDelegate!!.openReplyMessage(id)
							finishFragment()
						}
						else {
							scrollToMessageId(id, messageObject!!.id, true, if (messageObject.dialogId == mergeDialogId) 1 else 0, true, 0)
						}
					}

					override fun didPressViaBotNotInline(cell: ChatMessageCell, botId: Long) {
						val args = Bundle()
						args.putLong("user_id", botId)

						if (messagesController.checkCanOpenChat(args, this@ChatActivity, cell.getMessageObject())) {
							presentFragment(ChatActivity(args))
						}
					}

					override fun didPressViaBot(cell: ChatMessageCell, username: String?) {
						if (bottomOverlayChat?.visibility == View.VISIBLE || bottomOverlay?.visibility == View.VISIBLE) {
							return
						}

						if (!username.isNullOrEmpty()) {
							chatActivityEnterView?.fieldText = "@$username "
							chatActivityEnterView?.openKeyboard()
						}
					}

					override fun didStartVideoStream(message: MessageObject) {
						if (message.isVideo) {
							sendSecretMessageRead(message, true)
						}
					}

					override fun needReloadPolls() {
						invalidateMessagesVisiblePart()
					}

					override fun didPressImage(cell: ChatMessageCell, x: Float, y: Float) {
						val message = cell.getMessageObject() ?: return

						message.putInDownloadsStore = true

						if (message.isSendError) {
							createMenu(cell, single = false, listView = false, x = x, y = y)
							return
						}
						else if (message.isSending) {
							return
						}

						if (message.isDice) {
							undoView?.showWithAction(0, if (chatActivityEnterView!!.visibility == View.VISIBLE && bottomOverlay!!.visibility != View.VISIBLE) UndoView.ACTION_DICE_INFO else UndoView.ACTION_DICE_NO_SEND_INFO, message.diceEmoji, null) {
								sendMessagesHelper.sendMessage(message.diceEmoji, dialogId, replyMessage, threadMessage, null, false, null, null, null, true, 0, null, updateStickersOrder = false, isMediaSale = false, mediaSaleHash = null)
							}
						}
						else if (message.isAnimatedEmoji && (!message.isAnimatedAnimatedEmoji || emojiAnimationsOverlay!!.supports(MessageObject.findAnimatedEmojiEmoticon(message.document)) && currentUser != null) || message.isPremiumSticker) {
							restartSticker(cell)
							emojiAnimationsOverlay?.onTapItem(cell, this@ChatActivity, true)
							chatListView?.cancelClickRunnables(false)
						}
						else if (message.needDrawBluredPreview()) {
							val action = sendSecretMessageRead(message, false)

							cell.invalidate()

							SecretMediaViewer.getInstance().setParentActivity(parentActivity)
							SecretMediaViewer.getInstance().openMedia(message, photoViewerProvider, action)
						}
						else if (MessageObject.isAnimatedEmoji(message.document) && MessageObject.getInputStickerSet(message.document) != null) {
							val inputSets = ArrayList<InputStickerSet>(1)
							inputSets.add(MessageObject.getInputStickerSet(message.document)!!)

							val alert = EmojiPacksAlert(this@ChatActivity, parentActivity, inputSets)
							alert.setCalcMandatoryInsets(isKeyboardVisible)

							showDialog(alert)
						}
						else if (message.inputStickerSet != null) {
							val alert = StickersAlert(parentActivity, this@ChatActivity, message.inputStickerSet, null, if (bottomOverlayChat!!.visibility != View.VISIBLE && (currentChat == null || canSendStickers(currentChat))) chatActivityEnterView else null)
							alert.setCalcMandatoryInsets(isKeyboardVisible)
							showDialog(alert)
						}
						else if (message.isVideo || message.type == MessageObject.TYPE_PHOTO || message.type == MessageObject.TYPE_COMMON && !message.isWebpageDocument || message.isGif) {
							openPhotoViewerForMessage(cell, message)
						}
						else if (message.type == MessageObject.TYPE_VIDEO) {
							sendSecretMessageRead(message, true)

							try {
								var f: File? = null
								val attachPath = message.messageOwner?.attachPath

								if (!attachPath.isNullOrEmpty()) {
									f = File(attachPath)
								}

								if (f == null || !f.exists()) {
									f = fileLoader.getPathToMessage(message.messageOwner)
								}

								val intent = Intent(Intent.ACTION_VIEW)

								if (Build.VERSION.SDK_INT >= 24) {
									intent.flags = Intent.FLAG_GRANT_READ_URI_PERMISSION
									intent.setDataAndType(FileProvider.getUriForFile(parentActivity!!, ApplicationLoader.applicationId + ".provider", f), "video/mp4")
								}
								else {
									intent.setDataAndType(Uri.fromFile(f), "video/mp4")
								}

								parentActivity?.startActivityForResult(intent, 500)
							}
							catch (e: Exception) {
								FileLog.e(e)
								alertUserOpenError(message)
							}
						}
						else if (message.type == MessageObject.TYPE_GEO) {
							if (!AndroidUtilities.isMapsInstalled(this@ChatActivity)) {
								return
							}

							if (message.isLiveLocation) {
								val fragment = LocationActivity(if (currentChat == null || canSendMessages(currentChat) || currentChat!!.megagroup) 2 else LocationActivity.LOCATION_TYPE_LIVE_VIEW)
								fragment.setDelegate(this@ChatActivity)
								fragment.setMessageObject(message)

								presentFragment(fragment)
							}
							else {
								val fragment = LocationActivity(if (currentEncryptedChat == null) 3 else 0)
								fragment.setDelegate(this@ChatActivity)
								fragment.setMessageObject(message)

								presentFragment(fragment)
							}
						}
						else if (message.type == 9 || message.type == MessageObject.TYPE_COMMON) {
							if (message.documentName?.lowercase()?.endsWith("attheme") == true) {
								var locFile: File? = null
								val attachPath = message.messageOwner?.attachPath

								if (!attachPath.isNullOrEmpty()) {
									val f = File(attachPath)

									if (f.exists()) {
										locFile = f
									}
								}

								if (locFile == null) {
									val f = fileLoader.getPathToMessage(message.messageOwner)

									if (f.exists()) {
										locFile = f
									}
								}

								val themeInfo = Theme.applyThemeFile(locFile, message.documentName, null, true)

								scrollToPositionOnRecreate = if (themeInfo != null) {
									presentFragment(ThemePreviewActivity(themeInfo))
									return
								}
								else {
									-1
								}
							}

							var handled = false

							if (message.canPreviewDocument()) {
								PhotoViewer.getInstance().setParentActivity(this@ChatActivity)
								PhotoViewer.getInstance().openPhoto(message, this@ChatActivity, if (message.type != 0) dialogId else 0, if (message.type != 0) mergeDialogId else 0, photoViewerProvider)
								handled = true
							}

							if (!handled) {
								try {
									AndroidUtilities.openForView(message, parentActivity)
								}
								catch (e: Exception) {
									FileLog.e(e)
									alertUserOpenError(message)
								}
							}
						}
					}

					override fun didPressInstantButton(cell: ChatMessageCell, type: Int) {
						val messageObject = cell.getMessageObject()

						if (type == 8) {
							PollVotesAlert.showForPoll(this@ChatActivity, messageObject)
						}
						else if (type == 0) {
							if (messageObject?.messageOwner?.media?.webpage?.cached_page != null) {
								ArticleViewer.getInstance().setParentActivity(parentActivity, this@ChatActivity)
								ArticleViewer.getInstance().open(messageObject)
							}
						}
						else if (type == 5) {
							val uid = messageObject!!.messageOwner!!.media!!.user_id
							var user: User? = null

							if (uid != 0L) {
								user = MessagesController.getInstance(currentAccount).getUser(uid)
							}

							openVCard(user, messageObject.messageOwner!!.media!!.vcard, messageObject.messageOwner!!.media!!.first_name, messageObject.messageOwner!!.media!!.last_name)
						}
						else {
							if (messageObject!!.isSponsored) {
								val args = Bundle()

								if (messageObject.sponsoredChatInvite != null) {
									showDialog(JoinGroupAlert(mContext, messageObject.sponsoredChatInvite, messageObject.sponsoredChatInviteHash!!, this@ChatActivity))
								}
								else {
									val peerId = MessageObject.getPeerId(messageObject.messageOwner?.from_id)

									if (peerId < 0) {
										args.putLong("chat_id", -peerId)
									}
									else {
										args.putLong("user_id", peerId)
									}

									if (messageObject.sponsoredChannelPost != 0) {
										args.putInt("message_id", messageObject.sponsoredChannelPost)
									}

									if (messageObject.botStartParam != null) {
										args.putString("inline_query", messageObject.botStartParam)
									}

									if (messagesController.checkCanOpenChat(args, this@ChatActivity)) {
										presentFragment(ChatActivity(args))
									}
								}
							}
							else if (messageObject.messageOwner?.media?.webpage != null) {
								if (!openLinkInternally(messageObject.messageOwner?.media?.webpage?.url, messageObject.id)) {
									Browser.openUrl(parentActivity, messageObject.messageOwner?.media?.webpage?.url)
								}
							}
						}
					}

					override fun didPressCommentButton(cell: ChatMessageCell) {
						val group = cell.currentMessagesGroup

						val message = if (group != null && group.messages.isNotEmpty()) {
							group.messages[0]
						}
						else {
							cell.getMessageObject()
						}

						val maxReadId: Int
						val linkedChatId: Long

						if (message?.messageOwner?.replies != null) {
							maxReadId = message.messageOwner!!.replies!!.read_max_id
							linkedChatId = message.messageOwner!!.replies!!.channel_id
						}
						else {
							maxReadId = -1
							linkedChatId = 0
						}

						openDiscussionMessageChat(currentChat!!.id, message, message?.id, linkedChatId, maxReadId, 0, null)
					}

					override fun getAdminRank(uid: Long): String? {
						return if (isChannel(currentChat) && currentChat!!.megagroup) {
							messagesController.getAdminRank(currentChat!!.id, uid)
						}
						else {
							null
						}
					}

					override fun shouldRepeatSticker(message: MessageObject): Boolean {
						return !alreadyPlayedStickers.containsKey(message)
					}

					override fun setShouldNotRepeatSticker(message: MessageObject) {
						alreadyPlayedStickers[message] = true
					}

					override fun getTextSelectionHelper(): ChatListTextSelectionHelper {
						return this@ChatActivity.textSelectionHelper
					}

					override fun hasSelectedMessages(): Boolean {
						return selectedMessagesIds[0].size() + selectedMessagesIds[1].size() > 0
					}

					override fun onDiceFinished() {
						if (fireworksOverlay?.isStarted == true) {
							return
						}

						fireworksOverlay?.start()
						fireworksOverlay?.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP, HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING)
					}

					override fun getPinchToZoomHelper(): PinchToZoomHelper? {
						return this@ChatActivity.pinchToZoomHelper
					}

					override fun keyboardIsOpened(): Boolean {
						return contentView!!.keyboardHeight + chatEmojiViewPadding >= AndroidUtilities.dp(20f)
					}

					override fun isLandscape(): Boolean {
						return contentView!!.measuredWidth > contentView!!.measuredHeight
					}

					override fun invalidateBlur() {
						contentView?.invalidateBlur()
					}

					override fun canDrawOutboundsContent(): Boolean {
						return false
					}

					override fun onAccessibilityAction(action: Int, arguments: Bundle): Boolean {
						if (action == AccessibilityNodeInfo.ACTION_CLICK || action == R.id.acc_action_small_button || action == R.id.acc_action_msg_options) {
							if (inPreviewMode && allowExpandPreviewByClick) {
								parentLayout?.expandPreviewFragment()
								return true
							}

							return !canPerformActions()
						}

						return false
					}
				}

				if (currentEncryptedChat == null) {
					chatMessageCell?.setAllowAssistant(true)
				}
			}
			else if (viewType == 1) {
				view = object : ChatActionCell(mContext, true) {
					override fun onInitializeAccessibilityNodeInfo(info: AccessibilityNodeInfo) {
						super.onInitializeAccessibilityNodeInfo(info)
						// if alpha == 0, then visibleToUser == false, so we need to override it
						// to keep accessibility working correctly
						info.isVisibleToUser = true
					}
				}

				(view as ChatActionCell).setInvalidateColors(true)

				(view as ChatActionCell).setDelegate(object : ChatActionCellDelegate {
					override fun needOpenInviteLink(invite: TL_chatInviteExported?) {
						// unused
					}

					override fun didOpenPremiumGift(cell: ChatActionCell?, giftOption: TL_premiumGiftOption?, animateConfetti: Boolean) {
						showDialog(PremiumPreviewBottomSheet(this@ChatActivity, currentAccount, currentUser, GiftTier(giftOption)).setAnimateConfetti(animateConfetti).setOutboundGift(cell!!.messageObject!!.isOut))
					}

					override fun needShowEffectOverlay(cell: ChatActionCell?, document: TLRPC.Document?, videoSize: VideoSize?) {
						emojiAnimationsOverlay?.showAnimationForActionCell(cell, document, videoSize)
					}

					override fun didClickImage(cell: ChatActionCell?) {
						val message = cell!!.messageObject

						PhotoViewer.getInstance().setParentActivity(this@ChatActivity)

						val photoSize = FileLoader.getClosestPhotoSizeWithSize(message?.photoThumbs, 640)

						if (photoSize != null) {
							val imageLocation = ImageLocation.getForPhoto(photoSize, message?.messageOwner?.action?.photo)
							PhotoViewer.getInstance().openPhoto(photoSize.location, imageLocation, photoViewerProvider)
						}
						else {
							PhotoViewer.getInstance().openPhoto(message, null, 0, 0, photoViewerProvider)
						}
					}

					override fun didLongPress(cell: ChatActionCell?, x: Float, y: Float): Boolean {
						return createMenu(cell, single = false, listView = false, x = x, y = y)
					}

					override fun needOpenUserProfile(uid: Long) {
						if (uid < 0) {
							val args = Bundle()
							args.putLong("chat_id", -uid)

							if (messagesController.checkCanOpenChat(args, this@ChatActivity)) {
								presentFragment(ChatActivity(args))
							}
						}
						else if (uid != userConfig.getClientUserId()) {
							// MARK: open profile
							val args = Bundle()
							args.putLong("user_id", uid)

							if (currentEncryptedChat != null && uid == currentUser!!.id) {
								args.putLong("dialog_id", dialogId)
							}

							val fragment = ProfileActivity(args)

							fragment.setPlayProfileAnimation(if (currentUser?.id == uid) 1 else 0)

							presentFragment(fragment)
						}
					}

					override fun didPressReplyMessage(cell: ChatActionCell?, id: Int) {
						val messageObject = cell?.messageObject ?: return
						scrollToMessageId(id, messageObject.id, true, if (messageObject.dialogId == mergeDialogId) 1 else 0, true, 0)
					}

					override fun didPressBotButton(messageObject: MessageObject?, button: KeyboardButton?) {
						if (parentActivity == null || bottomOverlayChat!!.visibility == View.VISIBLE && button !is TL_keyboardButtonSwitchInline && button !is TL_keyboardButtonCallback && button !is TL_keyboardButtonGame && button !is TL_keyboardButtonUrl && button !is TL_keyboardButtonBuy && button !is TL_keyboardButtonUrlAuth && button !is TL_keyboardButtonUserProfile) {
							return
						}

						FileLog.d("aibot didPressedBotButton2")
						chatActivityEnterView?.didPressedBotButton(button, messageObject, messageObject)
					}
				})
			}
			else if (viewType == 2) {
				view = ChatUnreadCell(mContext)
			}
			else if (viewType == 3) {
				view = BotHelpCell(mContext)

				view.setDelegate { url ->
					if (url.startsWith("@")) {
						messagesController.openByUserName(url.substring(1), this@ChatActivity, 0)
					}
					else if (url.startsWith("#") || url.startsWith("$")) {
						val fragment = DialogsActivity(null)
						fragment.setSearchString(url)
						presentFragment(fragment)
					}
					else if (url.startsWith("/")) {
						chatActivityEnterView?.setCommand(null, url, longPress = false, username = false)

						if (chatActivityEnterView?.fieldText == null) {
							hideFieldPanel(false)
						}
					}
					else {
						processExternalUrl(0, url, false)
					}
				}
			}
			else if (viewType == 4) {
				view = ChatLoadingCell(mContext, contentView!!)
			}

			view?.layoutParams = RecyclerView.LayoutParams(RecyclerView.LayoutParams.MATCH_PARENT, RecyclerView.LayoutParams.WRAP_CONTENT)

			return RecyclerListView.Holder(view!!)
		}

		override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
			if (position == botInfoRow || position == botInfoEmptyRow) {
				botHelpCell = holder.itemView as BotHelpCell
				val helpView = botHelpCell

				if (showBotHelpCell) {
					helpView?.visible()
				}
				else {
					helpView?.gone()
				}

				if (isReplyUser(currentUser)) {
					helpView?.setText(false, context!!.getString(R.string.RepliesChatInfo))
				}
				else {
					val mBotInfo = if (botInfo.size() != 0) botInfo[currentUser!!.id] else null
					helpView?.setText(true, mBotInfo?.description, if (mBotInfo != null) if (mBotInfo.description_document != null) mBotInfo.description_document else mBotInfo.description_photo else null, mBotInfo)
				}
			}
			else if (position == loadingDownRow || position == loadingUpRow) {
				val loadingCell = holder.itemView as ChatLoadingCell
				loadingCell.setProgressVisible(loadsCount > 1)
			}
			else if (position in messagesStartRow until messagesEndRow) {
				val messages = if (isFrozen) frozenMessages else messages
				val message = messages[position - messagesStartRow]
				val view = holder.itemView

				if (view is ChatMessageCell) {
					val groupedMessages = getValidGroupedMessage(message)

					view.isChat = currentChat != null || isUserSelf(currentUser) || isReplyUser(currentUser)
					view.isBot = currentUser != null && currentUser!!.bot
					view.isMegagroup = isChannel(currentChat) && currentChat!!.megagroup
					view.isThreadChat = threadId != 0
					view.hasDiscussion = chatMode != MODE_SCHEDULED && isChannel(currentChat) && currentChat!!.has_link && !currentChat!!.megagroup
					view.isPinned = chatMode == 0 && (pinnedMessageObjects.containsKey(message.id) || groupedMessages != null && groupedMessages.messages.isNotEmpty() && pinnedMessageObjects.containsKey(groupedMessages.messages[0].id))
					view.linkedChatId = if (chatMode != MODE_SCHEDULED && currentChatInfo != null) currentChatInfo!!.linked_chat_id else 0
					view.isRepliesChat = isReplyUser(currentUser)
					view.isPinnedChat = chatMode == MODE_PINNED

					var pinnedBottom = false
					var pinnedBottomByGroup = false
					var pinnedTop = false
					var pinnedTopByGroup = false
					val prevPosition: Int
					val nextPosition: Int

					if (groupedMessages != null) {
						val pos = groupedMessages.positions[message]

						if (pos != null) {
							if (groupedMessages.isDocuments) {
								prevPosition = position + groupedMessages.posArray.indexOf(pos) + 1
								nextPosition = position - groupedMessages.posArray.size + groupedMessages.posArray.indexOf(pos)
							}
							else {
								if (pos.flags and MessageObject.POSITION_FLAG_TOP != 0) {
									prevPosition = position + groupedMessages.posArray.indexOf(pos) + 1
								}
								else {
									pinnedTop = true
									pinnedTopByGroup = true
									prevPosition = -100
								}

								if (pos.flags and MessageObject.POSITION_FLAG_BOTTOM != 0) {
									nextPosition = position - groupedMessages.posArray.size + groupedMessages.posArray.indexOf(pos)
								}
								else {
									pinnedBottom = true
									pinnedBottomByGroup = true
									nextPosition = -100
								}
							}
						}
						else {
							prevPosition = -100
							nextPosition = -100
						}
					}
					else {
						nextPosition = position - 1
						prevPosition = position + 1
					}

					val nextType = getItemViewType(nextPosition)
					val prevType = getItemViewType(prevPosition)

					if (message.messageOwner?.reply_markup !is TL_replyInlineMarkup && nextType == holder.itemViewType) {
						val nextMessage = messages[nextPosition - messagesStartRow]

						pinnedBottom = nextMessage.isOutOwner == message.isOutOwner && abs(nextMessage.messageOwner!!.date - message.messageOwner!!.date) <= 5 * 60

						if (pinnedBottom) {
							if (message.isImportedForward || nextMessage.isImportedForward) {
								pinnedBottom = if (message.isImportedForward && nextMessage.isImportedForward) {
									if (abs(nextMessage.messageOwner!!.fwd_from!!.date - message.messageOwner!!.fwd_from!!.date) <= 5 * 60) {
										if (nextMessage.messageOwner!!.fwd_from!!.from_name != null && message.messageOwner!!.fwd_from!!.from_name != null) {
											nextMessage.messageOwner!!.fwd_from!!.from_name == message.messageOwner!!.fwd_from!!.from_name
										}
										else if (nextMessage.messageOwner!!.fwd_from!!.from_id != null && message.messageOwner!!.fwd_from!!.from_id != null) {
											MessageObject.getPeerId(nextMessage.messageOwner?.fwd_from?.from_id) == MessageObject.getPeerId(message.messageOwner?.fwd_from?.from_id)
										}
										else {
											false
										}
									}
									else {
										false
									}
								}
								else {
									false
								}
							}
							else if (currentChat != null) {
								val fromId = nextMessage.fromChatId

								pinnedBottom = (fromId == message.fromChatId)

								if (!pinnedBottomByGroup && pinnedBottom && fromId < 0 && currentChat!!.megagroup) {
									pinnedBottom = false
								}
							}
							else if (isUserSelf(currentUser) || isReplyUser(currentUser)) {
								pinnedBottom = if (message.isPrivateForward || nextMessage.isPrivateForward) {
									false
								}
								else {
									nextMessage.senderId == message.senderId
								}
							}
						}
					}

					if (prevType == holder.itemViewType) {
						val prevMessage = messages[prevPosition - messagesStartRow]

						pinnedTop = prevMessage.messageOwner?.reply_markup !is TL_replyInlineMarkup && prevMessage.isOutOwner == message.isOutOwner && abs(prevMessage.messageOwner!!.date - message.messageOwner!!.date) <= 5 * 60

						if (pinnedTop) {
							if (message.isImportedForward || prevMessage.isImportedForward) {
								pinnedTop = if (message.isImportedForward && prevMessage.isImportedForward) {
									if (abs(message.messageOwner!!.fwd_from!!.date - prevMessage.messageOwner!!.fwd_from!!.date) <= 5 * 60) {
										if (prevMessage.messageOwner!!.fwd_from!!.from_name != null && message.messageOwner!!.fwd_from!!.from_name != null) {
											prevMessage.messageOwner!!.fwd_from!!.from_name == message.messageOwner!!.fwd_from!!.from_name
										}
										else if (prevMessage.messageOwner!!.fwd_from!!.from_id != null && message.messageOwner!!.fwd_from!!.from_id != null) {
											MessageObject.getPeerId(prevMessage.messageOwner?.fwd_from?.from_id) == MessageObject.getPeerId(message.messageOwner?.fwd_from?.from_id)
										}
										else {
											false
										}
									}
									else {
										false
									}
								}
								else {
									false
								}
							}
							else if (currentChat != null) {
								val fromId = prevMessage.fromChatId

								pinnedTop = (fromId == message.fromChatId) && message.isImportedForward != true && prevMessage.isImportedForward != true

								if (!pinnedTopByGroup && pinnedTop && fromId < 0 && currentChat!!.megagroup) {
									pinnedTop = false
								}
							}
							else if (isUserSelf(currentUser) || isReplyUser(currentUser)) {
								pinnedTop = if (message.isPrivateForward == true || prevMessage.isPrivateForward == true) {
									false
								}
								else {
									prevMessage.senderId == message.senderId
								}
							}
						}
					}

					if (isChannel(currentChat) && currentChat!!.megagroup && message.fromChatId <= 0 && message.messageOwner!!.fwd_from != null && message.messageOwner!!.fwd_from!!.saved_from_peer is TL_peerChannel) {
						if (!pinnedTopByGroup) {
							pinnedTop = false
						}

						if (!pinnedBottomByGroup) {
							pinnedBottom = false
						}
					}

					view.setMessageObject(message, groupedMessages, pinnedBottom, pinnedTop)
					view.setSpoilersSuppressed(chatListView?.scrollState != RecyclerView.SCROLL_STATE_IDLE)
					view.setHighlighted(highlightMessageId != Int.MAX_VALUE && message.id == highlightMessageId)

					if (highlightMessageId != Int.MAX_VALUE) {
						startMessageUnselect()
					}

					var index: Int

					if (animatingMessageObjects.indexOf(message).also { index = it } != -1) {
						var applyAnimation = false

						if (message.type == MessageObject.TYPE_ROUND_VIDEO && instantCameraView?.textureView != null) {
							applyAnimation = true

							view.viewTreeObserver.addOnPreDrawListener(object : ViewTreeObserver.OnPreDrawListener {
								override fun onPreDraw(): Boolean {
									val pipRoundVideoView = PipRoundVideoView.getInstance()
									pipRoundVideoView?.showTemporary(true)

									view.viewTreeObserver.removeOnPreDrawListener(this)

									val imageReceiver = view.photoImage
									val w = imageReceiver.imageWidth
									val rect = instantCameraView!!.cameraRect
									val scale = w / rect.width
									@Suppress("NAME_SHADOWING") val position = IntArray(2)

									view.transitionParams.ignoreAlpha = true
									view.alpha = 0.0f
									view.timeAlpha = 0.0f
									view.getLocationOnScreen(position)

									position[0] += (imageReceiver.imageX - view.getAnimationOffsetX()).toInt()
									position[1] += (imageReceiver.imageY - view.translationY).toInt()

									val cameraContainer = instantCameraView!!.cameraContainer
									cameraContainer.pivotX = 0.0f
									cameraContainer.pivotY = 0.0f

									val animatorSet = AnimatorSet()

									cameraContainer.setImageReceiver(imageReceiver)

									instantCameraView?.cancelBlur()

									val allAnimators = AnimatorSet()

									animatorSet.playTogether(ObjectAnimator.ofFloat(cameraContainer, View.SCALE_X, scale), ObjectAnimator.ofFloat(cameraContainer, View.SCALE_Y, scale), ObjectAnimator.ofFloat(cameraContainer, View.TRANSLATION_Y, position[1] - rect.y), ObjectAnimator.ofFloat(instantCameraView!!.switchButtonView, View.ALPHA, 0.0f), ObjectAnimator.ofInt(instantCameraView!!.paint, AnimationProperties.PAINT_ALPHA, 0), ObjectAnimator.ofFloat(instantCameraView!!.muteImageView, View.ALPHA, 0.0f))
									animatorSet.interpolator = CubicBezierInterpolator.EASE_OUT_QUINT

									val o = ObjectAnimator.ofFloat(cameraContainer, View.TRANSLATION_X, position[0] - rect.x)
									o.interpolator = CubicBezierInterpolator.DEFAULT

									allAnimators.playTogether(o, animatorSet)
									allAnimators.startDelay = 120
									allAnimators.duration = 180

									instantCameraView?.setIsMessageTransition(true)

									allAnimators.addListener(object : AnimatorListenerAdapter() {
										override fun onAnimationEnd(animation: Animator) {
											view.alpha = 1.0f
											view.transitionParams.ignoreAlpha = false

											val ALPHA: Property<ChatMessageCell, Float> = object : AnimationProperties.FloatProperty<ChatMessageCell>("alpha") {
												override fun setValue(`object`: ChatMessageCell, value: Float) {
													`object`.timeAlpha = value
												}

												override operator fun get(`object`: ChatMessageCell): Float {
													return `object`.timeAlpha
												}
											}

											@Suppress("NAME_SHADOWING") val animatorSet = AnimatorSet()
											animatorSet.playTogether(ObjectAnimator.ofFloat(cameraContainer, View.ALPHA, 0.0f), ObjectAnimator.ofFloat(view, ALPHA, 1.0f))
											animatorSet.duration = 100
											animatorSet.interpolator = DecelerateInterpolator()

											animatorSet.addListener(object : AnimatorListenerAdapter() {
												override fun onAnimationEnd(animation: Animator) {
													instantCameraView?.setIsMessageTransition(false)
													instantCameraView?.hideCamera(true)
													instantCameraView?.visibility = View.INVISIBLE
												}
											})

											animatorSet.start()
										}
									})

									allAnimators.start()

									return true
								}
							})
						}
						else if (message.isAnyKindOfSticker == true && !message.isAnimatedEmojiStickers) {
							applyAnimation = true

							view.viewTreeObserver.addOnPreDrawListener(object : ViewTreeObserver.OnPreDrawListener {
								override fun onPreDraw(): Boolean {
									view.viewTreeObserver.removeOnPreDrawListener(this)

									val sendAnimationData = view.getMessageObject()!!.sendAnimationData ?: return true

									animateSendingViews.add(view)

									val imageReceiver = view.photoImage
									val w = imageReceiver.imageWidth
									val scale = sendAnimationData.width / w
									@Suppress("NAME_SHADOWING") val position = IntArray(2)

									view.transitionParams.ignoreAlpha = true
									view.getLocationInWindow(position)

									position[1] -= view.translationY.toInt()

									if (chatActivityEnterView!!.isTopViewVisible) {
										position[1] += AndroidUtilities.dp(48f)
									}

									val allAnimators = AnimatorSet()

									val param1: Property<SendAnimationData, Float> = object : AnimationProperties.FloatProperty<SendAnimationData>("p1") {
										override fun setValue(`object`: SendAnimationData, value: Float) {
											`object`.currentScale = value
										}

										override operator fun get(`object`: SendAnimationData): Float {
											return `object`.currentScale
										}
									}

									val param2: Property<SendAnimationData, Float> = object : AnimationProperties.FloatProperty<SendAnimationData>("p2") {
										override fun setValue(`object`: SendAnimationData, value: Float) {
											`object`.currentX = value
											fragmentView?.invalidate()
										}

										override operator fun get(`object`: SendAnimationData): Float {
											return `object`.currentX
										}
									}

									val param3: Property<SendAnimationData, Float> = object : AnimationProperties.FloatProperty<SendAnimationData>("p3") {
										override fun setValue(`object`: SendAnimationData, value: Float) {
											`object`.currentY = value
											fragmentView?.invalidate()
										}

										override operator fun get(`object`: SendAnimationData): Float {
											return `object`.currentY
										}
									}

									val animatorSet = AnimatorSet()
									animatorSet.playTogether(ObjectAnimator.ofFloat(sendAnimationData, param1, scale, 1.0f), ObjectAnimator.ofFloat(sendAnimationData, param3, sendAnimationData.y, position[1] + imageReceiver.centerY))
									animatorSet.interpolator = ChatListItemAnimator.DEFAULT_INTERPOLATOR

									val o = ObjectAnimator.ofFloat(sendAnimationData, param2, sendAnimationData.x, position[0] + imageReceiver.centerX)
									o.interpolator = CubicBezierInterpolator.EASE_OUT_QUINT

									allAnimators.playTogether(o, animatorSet)
									allAnimators.duration = ChatListItemAnimator.DEFAULT_DURATION

									allAnimators.addListener(object : AnimatorListenerAdapter() {
										override fun onAnimationEnd(animation: Animator) {
											animateSendingViews.remove(view)

											if (fragmentView != null) {
												fragmentView?.invalidate()
												chatListView?.invalidate()
											}

											view.alpha = 1.0f
											view.transitionParams.ignoreAlpha = false
										}
									})

									allAnimators.start()

									val ALPHA: Property<SendAnimationData, Float> = object : AnimationProperties.FloatProperty<SendAnimationData>("alpha") {
										override fun setValue(`object`: SendAnimationData, value: Float) {
											`object`.timeAlpha = value
											fragmentView?.invalidate()
										}

										override operator fun get(`object`: SendAnimationData): Float {
											return `object`.timeAlpha
										}
									}

									val animatorSet2 = AnimatorSet()
									animatorSet2.playTogether(ObjectAnimator.ofFloat(sendAnimationData, ALPHA, 0.0f, 1.0f))
									animatorSet2.duration = 100
									animatorSet2.startDelay = 150
									animatorSet2.interpolator = DecelerateInterpolator()
									animatorSet2.start()

									return true
								}
							})
						}

						if (applyAnimation || chatListItemAnimator == null) {
							animatingMessageObjects.removeAt(index)
							chatActivityEnterView?.startMessageTransition()
							chatActivityEnterView?.hideTopView(true)
						}
					}

					if (animatingDocuments.isNotEmpty() && animatingDocuments.containsKey(message.document)) {
						animatingDocuments.remove(message.document)
						chatListItemAnimator?.onGreetingStickerTransition(holder, greetingsViewContainer)
					}
				}
				else if (view is ChatActionCell) {
					view.setMessageObject(message, collapseForDate = messagesByDays[message.dateKey]?.hasServiceMessagesOnly() == true)
					view.alpha = 1.0f
					view.setSpoilersSuppressed(chatListView?.scrollState != RecyclerView.SCROLL_STATE_IDLE)
				}
				else if (view is ChatUnreadCell) {
					view.setText(mContext.getString(R.string.UnreadMessages))
					createUnreadMessageAfterId = 0
				}
			}
		}

		override fun getItemViewType(position: Int): Int {
			if (clearingHistory) {
				if (position == botInfoEmptyRow) {
					return 3
				}
			}

			if (position in messagesStartRow until messagesEndRow) {
				val messages = if (isFrozen) frozenMessages else messages
				return messages[position - messagesStartRow].contentType
			}
			else if (position == botInfoRow) {
				return 3
			}

			return 4
		}

		override fun onViewAttachedToWindow(holder: RecyclerView.ViewHolder) {
			if (holder.itemView is ChatMessageCell || holder.itemView is ChatActionCell) {
				val view = holder.itemView

				holder.itemView.viewTreeObserver.addOnPreDrawListener(object : ViewTreeObserver.OnPreDrawListener {
					override fun onPreDraw(): Boolean {
						view.viewTreeObserver.removeOnPreDrawListener(this)
						val height = chatListView!!.measuredHeight
						val top = view.top
						val viewTop = if (top >= 0) 0 else -top
						var viewBottom = view.measuredHeight

						if (viewBottom > height) {
							viewBottom = viewTop + height
						}

						val recyclerChatViewHeight = contentView!!.heightWithKeyboard - (if (inPreviewMode) 0
						else AndroidUtilities.dp(48f)) - chatListView!!.top
						var keyboardOffset = contentView!!.keyboardHeight

						if (keyboardOffset < AndroidUtilities.dp(20f) && chatActivityEnterView!!.isPopupShowing || chatActivityEnterView!!.panelAnimationInProgress()) {
							keyboardOffset = chatActivityEnterView!!.emojiPadding
						}

						if (holder.itemView is ChatMessageCell) {
							val chatMessageCell = view as ChatMessageCell
							chatMessageCell.setVisiblePart(viewTop, viewBottom - viewTop, recyclerChatViewHeight, keyboardOffset.toFloat(), view.getY() + (if (isKeyboardVisible) chatListView!!.top else actionBar!!.measuredHeight) - contentView!!.backgroundTranslationY, contentView!!.measuredWidth, contentView!!.backgroundSizeY, blurredViewTopOffset, blurredViewBottomOffset)
							markSponsoredAsRead(chatMessageCell.getMessageObject())
						}
						else if (holder.itemView is ChatActionCell) {
							if (actionBar != null && contentView != null) {
								(view as ChatActionCell).setVisiblePart(view.getY() + (if (isKeyboardVisible) chatListView!!.top else actionBar!!.measuredHeight) - contentView!!.backgroundTranslationY, contentView!!.backgroundSizeY)
							}
						}

						return true
					}
				})
			}

			if (holder.itemView is ChatMessageCell) {
				val messageCell = holder.itemView

				val message = messageCell.getMessageObject()

				messageCell.showHintButton(show = true, animated = false, type = -1)

				if (hintMessageObject == message) {
					messageCell.showHintButton(show = false, animated = false, type = hintMessageType)
				}

				if (message?.isAnimatedEmoji == true) {
					val emoji = message.stickerEmoji

					if (emoji != null) {
						val sound = messagesController.emojiSounds[emoji.replace("\uFE0F", "")]

						if (sound != null) {
							mediaController.playEmojiSound(accountInstance, emoji, sound, true)
						}
					}
				}

				var selected = false
				var disableSelection = false

				if (actionBar!!.isActionModeShowed || reportType >= 0) {
					messageCell.setCheckBoxVisible(threadMessageObjects == null || !threadMessageObjects!!.contains(message), false)

					val idx = if (message?.dialogId == dialogId) 0 else 1

					if (selectedMessagesIds[idx].indexOfKey(message?.id ?: 0) >= 0) {
						setCellSelectionBackground(message, messageCell, idx, false)
						selected = true
					}
					else {
						messageCell.setDrawSelectionBackground(false)
						messageCell.setChecked(checked = false, allChecked = false, animated = false)
					}
					disableSelection = true
				}
				else {
					messageCell.setDrawSelectionBackground(false)
					messageCell.setChecked(checked = false, allChecked = false, animated = false)
					messageCell.setCheckBoxVisible(visible = false, animated = false)
				}

				messageCell.setCheckPressed(!disableSelection, disableSelection && selected)

				if (searchContainer != null && searchContainer!!.visibility == View.VISIBLE && mediaDataController.isMessageFound(message!!.id, message.dialogId == mergeDialogId) && mediaDataController.lastSearchQuery != null) {
					messageCell.setHighlightedText(mediaDataController.lastSearchQuery)
				}
				else {
					messageCell.setHighlightedText(null)
				}

				if (!inPreviewMode || !messageCell.isHighlighted()) {
					messageCell.setHighlighted(highlightMessageId != Int.MAX_VALUE && messageCell.getMessageObject()!!.id == highlightMessageId)

					if (highlightMessageId != Int.MAX_VALUE) {
						startMessageUnselect()
					}
				}
			}

			val position = holder.adapterPosition

			if (position in messagesStartRow until messagesEndRow) {
				val messages = if (isFrozen) frozenMessages else messages
				val message = messages[position - messagesStartRow]
				val view = holder.itemView

				if (message.messageOwner != null && message.messageOwner?.media_unread == true && message.messageOwner?.mentioned == true) {
					if (!inPreviewMode && chatMode == 0) {
						if (!message.isVoice && !message.isRoundVideo) {
							newMentionsCount--

							if (newMentionsCount <= 0) {
								newMentionsCount = 0
								hasAllMentionsLocal = true
								showMentionDownButton(show = false, animated = true)
							}
							else {
								mentiondownButtonCounter?.setText(String.format(Locale.getDefault(), "%d", newMentionsCount))
							}

							messagesController.markMentionMessageAsRead(message.id, if (isChannel(currentChat)) currentChat!!.id else 0, dialogId)

							message.setContentIsRead()
						}
					}

					if (view is ChatMessageCell) {
						if (inPreviewMode) {
							view.setHighlighted(true)
						}
						else {
							view.setHighlightedAnimated()
						}
					}
				}
			}
		}

		fun updateRowAtPosition(index: Int) {
			if (chatLayoutManager == null || isFrozen) {
				return
			}

			var lastVisibleItem = RecyclerView.NO_POSITION
			var top = 0

			if (!wasManualScroll && unreadMessageObject != null) {
				val n = chatListView!!.childCount

				for (i in 0 until n) {
					val child = chatListView!!.getChildAt(i)

					if (child is ChatMessageCell && child.getMessageObject() === unreadMessageObject) {
						val unreadMessageIndex = messages.indexOf(unreadMessageObject)

						if (unreadMessageIndex >= 0) {
							lastVisibleItem = messagesStartRow + messages.indexOf(unreadMessageObject)
							top = chatListView!!.measuredHeight - child.getBottom() - chatListView!!.paddingBottom
						}

						break
					}
				}
			}

			notifyItemChanged(index)

			if (lastVisibleItem != RecyclerView.NO_POSITION) {
				chatLayoutManager?.scrollToPositionWithOffset(lastVisibleItem, top)
			}
		}

		fun invalidateRowWithMessageObject(messageObject: MessageObject?) {
			chatListView?.children?.forEach {
				if (it is ChatMessageCell) {
					if (it.getMessageObject() === messageObject) {
						it.invalidate()
						return
					}
				}
			}
		}

		fun updateRowWithMessageObject(messageObject: MessageObject?, allowInPlace: Boolean): View? {
			if (allowInPlace) {
				chatListView?.children?.forEach {
					if (it is ChatMessageCell) {
						if (it.getMessageObject() === messageObject && !it.isAdminLayoutChanged()) {
							it.setMessageObject(messageObject, it.currentMessagesGroup, it.isPinnedBottom, it.isPinnedTop)
							return it
						}
					}
				}
			}

			val messages = if (isFrozen) frozenMessages else messages
			val index = messages.indexOf(messageObject)

			if (index == -1) {
				return null
			}

			updateRowAtPosition(index + messagesStartRow)

			return null
		}

		fun notifyDataSetChanged(animated: Boolean) {
			if (animated && fragmentOpened) {
				if (chatListView?.itemAnimator !== chatListItemAnimator) {
					chatListView?.itemAnimator = chatListItemAnimator
				}
			}
			else {
				chatListView?.itemAnimator = null
			}

			updateRowsInternal()

			try {
				super.notifyDataSetChanged()
			}
			catch (e: Exception) {
				FileLog.e(e)
			}
		}

		override fun notifyDataSetChanged() {
			notifyDataSetChanged(false)
		}

		override fun notifyItemChanged(position: Int) {
			if (!fragmentBeginToShow) {
				chatListView?.itemAnimator = null
			}
			else if (chatListView?.itemAnimator !== chatListItemAnimator) {
				chatListView?.itemAnimator = chatListItemAnimator
			}

			updateRowsInternal()

			try {
				super.notifyItemChanged(position)
			}
			catch (e: Exception) {
				FileLog.e(e)
			}
		}

		override fun notifyItemRangeChanged(positionStart: Int, itemCount: Int) {
			if (!fragmentBeginToShow) {
				chatListView?.itemAnimator = null
			}
			else if (chatListView?.itemAnimator !== chatListItemAnimator) {
				chatListView?.itemAnimator = chatListItemAnimator
			}

			updateRowsInternal()

			try {
				super.notifyItemRangeChanged(positionStart, itemCount)
			}
			catch (e: Exception) {
				FileLog.e(e)
			}
		}

		override fun notifyItemInserted(position: Int) {
			if (!fragmentBeginToShow) {
				chatListView?.itemAnimator = null
			}
			else if (chatListView!!.itemAnimator !== chatListItemAnimator) {
				chatListView?.itemAnimator = chatListItemAnimator
			}

			updateRowsInternal()

			try {
				super.notifyItemInserted(position)
			}
			catch (e: Exception) {
				FileLog.e(e)
			}
		}

		override fun notifyItemMoved(fromPosition: Int, toPosition: Int) {
			if (!fragmentBeginToShow) {
				chatListView?.itemAnimator = null
			}
			else if (chatListView?.itemAnimator !== chatListItemAnimator) {
				chatListView?.itemAnimator = chatListItemAnimator
			}

			updateRowsInternal()

			try {
				super.notifyItemMoved(fromPosition, toPosition)
			}
			catch (e: Exception) {
				FileLog.e(e)
			}
		}

		override fun notifyItemRangeInserted(positionStart: Int, itemCount: Int) {
			if (!fragmentBeginToShow) {
				chatListView?.itemAnimator = null
			}
			else if (chatListView?.itemAnimator !== chatListItemAnimator) {
				chatListView?.itemAnimator = chatListItemAnimator
			}

			updateRowsInternal()

			if (positionStart == 1 && itemCount > 0) {
				val lastPosition = positionStart + itemCount

				if (lastPosition in messagesStartRow until messagesEndRow) {
					val m1 = messages[lastPosition - messagesStartRow]
					val m2 = messages[lastPosition - messagesStartRow - 1]

					if (currentChat != null && m1.fromChatId == m2.fromChatId || currentUser != null && m1.isOutOwner == m2.isOutOwner) {
						notifyItemChanged(positionStart)
					}
				}
			}

			try {
				super.notifyItemRangeInserted(positionStart, itemCount)
			}
			catch (e: Exception) {
				FileLog.e(e)
			}
		}

		override fun notifyItemRemoved(position: Int) {
			if (!fragmentBeginToShow) {
				chatListView?.itemAnimator = null
			}
			else if (chatListView?.itemAnimator !== chatListItemAnimator) {
				chatListView?.itemAnimator = chatListItemAnimator
			}

			updateRowsInternal()

			try {
				super.notifyItemRemoved(position)
			}
			catch (e: Exception) {
				FileLog.e(e)
			}
		}

		override fun notifyItemRangeRemoved(positionStart: Int, itemCount: Int) {
			if (!fragmentBeginToShow) {
				chatListView?.itemAnimator = null
			}
			else if (chatListView?.itemAnimator !== chatListItemAnimator) {
				chatListView?.itemAnimator = chatListItemAnimator
			}

			updateRowsInternal()

			try {
				super.notifyItemRangeRemoved(positionStart, itemCount)
			}
			catch (e: Exception) {
				FileLog.e(e)
			}
		}

		override fun isEnabled(holder: RecyclerView.ViewHolder): Boolean {
			return false
		}
	}

	private fun updateChatBotTopPanel() {
		if (!isAiBot()) {
			return
		}

		mainScope.launch {
			updateTopPanel(true)
		}
	}

	inner class ChatScrollCallback : RecyclerAnimationScrollHelper.AnimationCallback() {
		var scrollTo: MessageObject? = null
		var lastItemOffset = 0
		var lastBottom = false
		var lastPadding = 0

		override fun onStartAnimation() {
			super.onStartAnimation()
			scrollCallbackAnimationIndex = notificationCenter.setAnimationInProgress(scrollCallbackAnimationIndex, allowedNotificationsDuringChatListAnimations)

			if (pinchToZoomHelper?.isInOverlayMode == true) {
				pinchToZoomHelper?.finishZoom()
			}
		}

		override fun onEndAnimation() {
			if (scrollTo != null) {
				chatAdapter?.updateRowsSafe()

				val lastItemPosition = chatAdapter!!.messagesStartRow + messages.indexOf(scrollTo)

				if (lastItemPosition >= 0) {
					chatLayoutManager?.scrollToPositionWithOffset(lastItemPosition, (lastItemOffset + lastPadding - chatListViewPadding).toInt(), lastBottom)
				}
			}
			else {
				chatAdapter?.updateRowsSafe()
				chatLayoutManager?.scrollToPositionWithOffset(0, 0, true)
			}

			scrollTo = null
			checkTextureViewPosition = true

			// chatListView.getOnScrollListener().onScrolled(chatListView, 0, chatScrollHelper.getScrollDirection() == RecyclerAnimationScrollHelper.SCROLL_DIRECTION_DOWN ? 1 : -1);

			updateVisibleRows()

			AndroidUtilities.runOnUIThread {
				notificationCenter.onAnimationFinish(scrollCallbackAnimationIndex)
			}
		}

		override fun recycleView(view: View) {
			if (view is ChatMessageCell) {
				chatMessageCellsCache.add(view)
			}
		}
	}

	companion object {
		const val MODE_SCHEDULED = 1
		const val MODE_PINNED = 2
		private const val OPTION_RETRY = 0
		private const val OPTION_DELETE = 1
		private const val OPTION_FORWARD = 2
		private const val OPTION_COPY = 3
		private const val OPTION_SAVE_TO_GALLERY = 4
		private const val OPTION_APPLY_LOCALIZATION_OR_THEME = 5
		private const val OPTION_SHARE = 6
		private const val OPTION_SAVE_TO_GALLERY2 = 7
		private const val OPTION_REPLY = 8
		private const val OPTION_ADD_TO_STICKERS_OR_MASKS = 9
		private const val OPTION_SAVE_TO_DOWNLOADS_OR_MUSIC = 10
		private const val OPTION_ADD_TO_GIFS = 11
		private const val OPTION_EDIT = 12
		private const val OPTION_PIN = 13
		private const val OPTION_UNPIN = 14
		private const val OPTION_ADD_CONTACT = 15
		private const val OPTION_COPY_PHONE_NUMBER = 16
		private const val OPTION_CALL = 17
		private const val OPTION_CALL_AGAIN = 18
		private const val OPTION_RATE_CALL = 19
		private const val OPTION_ADD_STICKER_TO_FAVORITES = 20
		private const val OPTION_DELETE_STICKER_FROM_FAVORITES = 21
		private const val OPTION_COPY_LINK = 22
		private const val OPTION_REPORT_CHAT = 23
		private const val OPTION_CANCEL_SENDING = 24
		private const val OPTION_UNVOTE = 25
		private const val OPTION_STOP_POLL_OR_QUIZ = 26
		private const val OPTION_VIEW_REPLIES_OR_THREAD = 27
		private const val OPTION_STATISTICS = 28
		private const val OPTION_TRANSLATE = 29
		private const val OPTION_TRANSCRIBE = 30
		private const val OPTION_HIDE_SPONSORED_MESSAGE = 31
		private const val OPTION_SEND_NOW = 100
		private const val OPTION_EDIT_SCHEDULE_TIME = 102
		private val allowedNotificationsDuringChatListAnimations = intArrayOf(NotificationCenter.messagesRead, NotificationCenter.threadMessagesRead, NotificationCenter.commentsRead, NotificationCenter.messagesReadEncrypted, NotificationCenter.messagesReadContent, NotificationCenter.didLoadPinnedMessages, NotificationCenter.newDraftReceived, NotificationCenter.updateMentionsCount, NotificationCenter.didUpdateConnectionState, NotificationCenter.updateInterfaces, NotificationCenter.updateDefaultSendAsPeer, NotificationCenter.closeChats, NotificationCenter.chatInfoCantLoad, NotificationCenter.userInfoDidLoad, NotificationCenter.pinnedInfoDidLoad, NotificationCenter.didSetNewWallpapper)
		private const val copy = 10
		private const val forward = 11
		private const val delete = 12
		private const val chat_enc_timer = 13
		private const val chat_menu_attach = 14
		private const val clear_history = 15
		private const val delete_chat = 16
		private const val share_contact = 17
		private const val mute = 18
		private const val report = 21
		private const val star = 22
		private const val edit = 23
		private const val add_shortcut = 24
		private const val save_to = 25
		private const val auto_delete_timer = 26
		private const val change_colors = 27
		private const val bot_help = 30
		private const val bot_settings = 31
		private const val call = 32
		private const val video_call = 33
		const val attach_photo = 0
		const val attach_gallery = 1
		const val attach_video = 2
		private const val text_bold = 50
		private const val text_italic = 51
		private const val text_mono = 52
		private const val text_link = 53
		private const val text_regular = 54
		private const val text_strike = 55
		private const val text_underline = 56
		private const val text_spoiler = 57
		private const val search = 40
		private const val id_chat_compose_panel = 1000
		var publicMsgUrlPattern: Pattern? = null
		var voiceChatUrlPattern: Pattern? = null
		var privateMsgUrlPattern: Pattern? = null
		private var lastStableId = 10
		private var replacingChatActivity = false
		private const val REGENERATE = "regenerate"
		const val MAX_VISIBLE_LENGTH = 130

		fun isClickableLink(str: String): Boolean {
			return str.startsWith("https://") || str.startsWith("@") || str.startsWith("#") || str.startsWith("$") || str.startsWith("video?")
		}
	}
}
