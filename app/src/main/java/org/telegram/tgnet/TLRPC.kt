/*
 * This is the source code of Ello for Android.
 * It is licensed under GNU GPL v. 2 or later.
 * You should have received a copy of the license in this archive (see LICENSE).
 *
 * Copyright Ello 2023-2025.
 */
package org.telegram.tgnet

import org.telegram.messenger.FileLog

class Vector: TLObject() {
    @JvmField
    val objects = mutableListOf<Any>()

    companion object {
        val CONSTRUCTOR = 0x1cb5c415u.toInt()
    }
}

object TLRPC {
	const val MESSAGE_FLAG_FWD = 0x00000004
	const val MESSAGE_FLAG_HAS_FROM_ID = 0x00000100
	const val MESSAGE_FLAG_HAS_VIEWS = 0x00000400
	const val MESSAGE_FLAG_HAS_MEDIA = 0x00000200
	const val MESSAGE_FLAG_REPLY = 0x00000008
	const val MESSAGE_FLAG_EDITED = 0x00008000
	const val MESSAGE_FLAG_HAS_BOT_ID = 0x00000800
	const val MESSAGE_FLAG_HAS_ENTITIES = 0x00000080
	const val MESSAGE_FLAG_HAS_MARKUP = 0x00000040

	const val CHAT_FLAG_IS_PUBLIC = 0x00000040
	
	const val PAY_TYPE_NONE = 0 // free
	const val PAY_TYPE_BASE = 1 // one-time purchase
	const val PAY_TYPE_SUBSCRIBE = 2 // subscription

	const val LAYER = 147
	
	abstract class Bool: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
				val result = when (constructor) {
					TLBoolFalse.CONSTRUCTOR -> TLBoolFalse()
					TLBoolTrue.CONSTRUCTOR -> TLBoolTrue()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in Bool")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLBoolFalse: Bool() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xbc799737u.toInt()
		}
	}
	
	open class TLBoolTrue: Bool() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x997275b5u.toInt()
		}
	}
	
	open class TLAuthResetAuthorizations: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9fab0d1au.toInt()
		}
	}
	
	open class TLAuthBindTempAuthKey: TLObject() {
		@JvmField var permAuthKeyId = 0L
		@JvmField var nonce = 0L
		@JvmField var expiresAt = 0
		@JvmField var encryptedMessage: ByteArray? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(permAuthKeyId)
			stream.writeInt64(nonce)
			stream.writeInt32(expiresAt)
			stream.writeByteArray(encryptedMessage)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcdd42a05u.toInt()
		}
	}
	
	open class TLAuthCancelCode: TLObject() {
		@JvmField var phoneNumber: String? = null
		@JvmField var phoneCodeHash: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phoneNumber)
			stream.writeString(phoneCodeHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1f040578u.toInt()
		}
	}
	
	open class TLAuthDropTempAuthKeys: TLObject() {
		@JvmField val exceptAuthKeys = mutableListOf<Long>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(exceptAuthKeys.size)
			exceptAuthKeys.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x8e48a188u.toInt()
		}
	}
	
	open class TLAuthCheckRecoveryPassword: TLObject() {
		@JvmField var code: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(code)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd36bf79u.toInt()
		}
	}
	
	open class TLAccountRegisterDevice: TLObject() {
		@JvmField var flags = 0
		@JvmField var noMuted = false
		@JvmField var tokenType = 0
		@JvmField var token: String? = null
		@JvmField var appSandbox = false
		@JvmField var secret: ByteArray? = null
		@JvmField val otherUids = mutableListOf<Long>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (noMuted) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(tokenType)
			stream.writeString(token)
			stream.writeBool(appSandbox)
			stream.writeByteArray(secret)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(otherUids.size)
			otherUids.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xec86017au.toInt()
		}
	}
	
	open class TLAccountUnregisterDevice: TLObject() {
		@JvmField var tokenType = 0
		@JvmField var token: String? = null
		@JvmField val otherUids = mutableListOf<Long>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(tokenType)
			stream.writeString(token)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(otherUids.size)
			otherUids.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x6a0d3206u.toInt()
		}
	}
	
	open class TLAccountUpdateNotifySettings: TLObject() {
		@JvmField var peer: InputNotifyPeer? = null
		@JvmField var settings: TLInputPeerNotifySettings? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			settings?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x84be5b93u.toInt()
		}
	}
	
	open class TLAccountResetNotifySettings: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xdb7e1747u.toInt()
		}
	}
	
	open class TLAccountUpdateStatus: TLObject() {
		@JvmField var offline = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeBool(offline)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6628562cu.toInt()
		}
	}
	
	open class TLAccountReportPeer: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var reason: ReportReason? = null
		@JvmField var message: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			reason?.serializeToStream(stream)
			stream.writeString(message)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc5ba3d86u.toInt()
		}
	}
	
	open class TLAccountCheckUsername: TLObject() {
		@JvmField var username: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(username)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2714d86cu.toInt()
		}
	}
	
	open class TLAccountDeleteAccount: TLObject() {
		@JvmField var flags = 0
		@JvmField var reason: String? = null
		@JvmField var password: InputCheckPasswordSRP? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (password != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeString(reason)
			if ((flags and 1) != 0) {
				password?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa2c0cf74u.toInt()
		}
	}
	
	open class TLAccountSetAccountTTL: TLObject() {
		@JvmField var ttl: TLAccountDaysTTL? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			ttl?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2442485eu.toInt()
		}
	}
	
	open class TLAccountUpdateDeviceLocked: TLObject() {
		@JvmField var period = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(period)
		}
	
		companion object {
			val CONSTRUCTOR = 0x38df3532u.toInt()
		}
	}
	
	open class TLAccountResetAuthorization: TLObject() {
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdf77f3bcu.toInt()
		}
	}
	
	open class TLAccountUpdatePasswordSettings: TLObject() {
		@JvmField var password: InputCheckPasswordSRP? = null
		@JvmField var newSettings: TLAccountPasswordInputSettings? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			password?.serializeToStream(stream)
			newSettings?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa59b102fu.toInt()
		}
	}
	
	open class TLAccountConfirmPhone: TLObject() {
		@JvmField var phoneCodeHash: String? = null
		@JvmField var phoneCode: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phoneCodeHash)
			stream.writeString(phoneCode)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5f2178c3u.toInt()
		}
	}
	
	open class TLAccountResetWebAuthorization: TLObject() {
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2d01b9efu.toInt()
		}
	}
	
	open class TLAccountResetWebAuthorizations: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x682d2594u.toInt()
		}
	}
	
	open class TLAccountDeleteSecureValue: TLObject() {
		@JvmField val types = mutableListOf<SecureValueType>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(types.size)
			types.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xb880bc4bu.toInt()
		}
	}
	
	open class TLAccountAcceptAuthorization: TLObject() {
		@JvmField var botId = 0L
		@JvmField var scope: String? = null
		@JvmField var publicKey: String? = null
		@JvmField val valueHashes = mutableListOf<TLSecureValueHash>()
		@JvmField var credentials: TLSecureCredentialsEncrypted? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(botId)
			stream.writeString(scope)
			stream.writeString(publicKey)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(valueHashes.size)
			valueHashes.forEach { it.serializeToStream(stream) }
			credentials?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf3ed4c73u.toInt()
		}
	}
	
	open class TLAccountVerifyPhone: TLObject() {
		@JvmField var phoneNumber: String? = null
		@JvmField var phoneCodeHash: String? = null
		@JvmField var phoneCode: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phoneNumber)
			stream.writeString(phoneCodeHash)
			stream.writeString(phoneCode)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4dd3a7f6u.toInt()
		}
	}
	
	open class TLAccountFinishTakeoutSession: TLObject() {
		@JvmField var flags = 0
		@JvmField var success = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (success) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1d2652eeu.toInt()
		}
	}
	
	open class TLAccountConfirmPasswordEmail: TLObject() {
		@JvmField var code: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(code)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8fdf1920u.toInt()
		}
	}
	
	open class TLAccountResendPasswordEmail: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x7a7f2a15u.toInt()
		}
	}
	
	open class TLAccountCancelPasswordEmail: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc1cbd5b6u.toInt()
		}
	}
	
	open class TLAccountGetContactSignUpNotification: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9f07c728u.toInt()
		}
	}
	
	open class TLAccountSetContactSignUpNotification: TLObject() {
		@JvmField var silent = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeBool(silent)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcff43f61u.toInt()
		}
	}
	
	open class TLAccountSaveWallPaper: TLObject() {
		@JvmField var wallpaper: InputWallPaper? = null
		@JvmField var unsave = false
		@JvmField var settings: TLWallPaperSettings? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			wallpaper?.serializeToStream(stream)
			stream.writeBool(unsave)
			settings?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6c5a5b37u.toInt()
		}
	}
	
	open class TLAccountInstallWallPaper: TLObject() {
		@JvmField var wallpaper: InputWallPaper? = null
		@JvmField var settings: TLWallPaperSettings? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			wallpaper?.serializeToStream(stream)
			settings?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfeed5769u.toInt()
		}
	}
	
	open class TLAccountResetWallPapers: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xbb3b9804u.toInt()
		}
	}
	
	open class TLAccountSaveAutoDownloadSettings: TLObject() {
		@JvmField var flags = 0
		@JvmField var low = false
		@JvmField var high = false
		@JvmField var settings: TLAutoDownloadSettings? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (low) flags or 1 else flags and 1.inv()
			flags = if (high) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			settings?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x76f36233u.toInt()
		}
	}
	
	open class TLAccountSaveTheme: TLObject() {
		@JvmField var theme: InputTheme? = null
		@JvmField var unsave = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			theme?.serializeToStream(stream)
			stream.writeBool(unsave)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf257106cu.toInt()
		}
	}
	
	open class TLAccountInstallTheme: TLObject() {
		@JvmField var flags = 0
		@JvmField var dark = false
		@JvmField var theme: InputTheme? = null
		@JvmField var format: String? = null
		@JvmField var baseTheme: BaseTheme? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (dark) flags or 1 else flags and 1.inv()
			flags = if (theme != null) flags or 2 else flags and 2.inv()
			flags = if (format != null) flags or 4 else flags and 4.inv()
			flags = if (baseTheme != null) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			if ((flags and 2) != 0) {
				theme?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(format)
			}
	
			if ((flags and 8) != 0) {
				baseTheme?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc727bb3bu.toInt()
		}
	}
	
	open class TLAccountSetContentSettings: TLObject() {
		@JvmField var flags = 0
		@JvmField var sensitiveEnabled = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (sensitiveEnabled) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb574b16bu.toInt()
		}
	}
	
	open class TLAccountReportProfilePhoto: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var photoId: InputPhoto? = null
		@JvmField var reason: ReportReason? = null
		@JvmField var message: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			photoId?.serializeToStream(stream)
			reason?.serializeToStream(stream)
			stream.writeString(message)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfa8cc6f5u.toInt()
		}
	}
	
	open class TLAccountDeclinePasswordReset: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x4c9409f6u.toInt()
		}
	}
	
	open class TLAccountSetAuthorizationTTL: TLObject() {
		@JvmField var authorizationTtlDays = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(authorizationTtlDays)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbf899aa0u.toInt()
		}
	}
	
	open class TLAccountChangeAuthorizationSettings: TLObject() {
		@JvmField var flags = 0
		@JvmField var hash = 0L
		@JvmField var encryptedRequestsDisabled = false
		@JvmField var callRequestsDisabled = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (encryptedRequestsDisabled) flags or 1 else flags and 1.inv()
			flags = if (callRequestsDisabled) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(hash)
			if ((flags and 1) != 0) {
				stream.writeBool(encryptedRequestsDisabled)
			}
	
			if ((flags and 2) != 0) {
				stream.writeBool(callRequestsDisabled)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x40f48462u.toInt()
		}
	}
	
	open class TLAccountUpdateEmojiStatus: TLObject() {
		@JvmField var emojiStatus: EmojiStatus? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			emojiStatus?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfbd3de6bu.toInt()
		}
	}
	
	open class TLAccountClearRecentEmojiStatuses: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x18201aaeu.toInt()
		}
	}
	
	open class TLAccountCheckAvailabilityEmail: TLObject() {
		@JvmField var email: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(email)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9a91366cu.toInt()
		}
	}
	
	open class TLUsersSetSecureValueErrors: TLObject() {
		@JvmField var id: InputUser? = null
		@JvmField val errors = mutableListOf<SecureValueError>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			id?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(errors.size)
			errors.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x90c894b5u.toInt()
		}
	}
	
	open class TLContactsDeleteByPhones: TLObject() {
		@JvmField val phones = mutableListOf<String>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(phones.size)
			phones.forEach { stream.writeString(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x1013fd9eu.toInt()
		}
	}
	
	open class TLContactsBlock: TLObject() {
		@JvmField var id: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			id?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x68cc1411u.toInt()
		}
	}
	
	open class TLContactsUnblock: TLObject() {
		@JvmField var id: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			id?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbea65d50u.toInt()
		}
	}
	
	open class TLContactsResetTopPeerRating: TLObject() {
		@JvmField var category: TopPeerCategory? = null
		@JvmField var peer: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			category?.serializeToStream(stream)
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1ae373acu.toInt()
		}
	}
	
	open class TLContactsResetSaved: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x879537f1u.toInt()
		}
	}
	
	open class TLContactsToggleTopPeers: TLObject() {
		@JvmField var enabled = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeBool(enabled)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8514bddau.toInt()
		}
	}
	
	open class TLContactsGetContactSignUpNotification: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9f07c728u.toInt()
		}
	}
	
	open class TLMessagesReportReaction: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var id = 0
		@JvmField var reactionPeer: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(id)
			reactionPeer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3f64c076u.toInt()
		}
	}
	
	open class TLMessagesClearRecentReactions: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9dfeefb4u.toInt()
		}
	}
	
	open class TLMessagesSetTyping: TLObject() {
		@JvmField var flags = 0
		@JvmField var peer: InputPeer? = null
		@JvmField var topMsgId = 0
		@JvmField var action: SendMessageAction? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (topMsgId != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(topMsgId)
			}
	
			action?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x58943ee2u.toInt()
		}
	}
	
	open class TLMessagesReportSpam: TLObject() {
		@JvmField var peer: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcf1592dbu.toInt()
		}
	}
	
	open class TLMessagesReport: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField val id = mutableListOf<Int>()
		@JvmField var reason: ReportReason? = null
		@JvmField var message: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { stream.writeInt32(it) }
			reason?.serializeToStream(stream)
			stream.writeString(message)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8953ab4eu.toInt()
		}
	}
	
	open class TLMessagesDiscardEncryption: TLObject() {
		@JvmField var flags = 0
		@JvmField var deleteHistory = false
		@JvmField var chatId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (deleteHistory) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(chatId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf393aea0u.toInt()
		}
	}
	
	open class TLMessagesSetEncryptedTyping: TLObject() {
		@JvmField var peer: TLInputEncryptedChat? = null
		@JvmField var typing = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeBool(typing)
		}
	
		companion object {
			val CONSTRUCTOR = 0x791451edu.toInt()
		}
	}
	
	open class TLMessagesReadEncryptedHistory: TLObject() {
		@JvmField var peer: TLInputEncryptedChat? = null
		@JvmField var maxDate = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(maxDate)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7f4b690au.toInt()
		}
	}
	
	open class TLMessagesReportEncryptedSpam: TLObject() {
		@JvmField var peer: TLInputEncryptedChat? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4b0c8c0fu.toInt()
		}
	}
	
	open class TLMessagesUninstallStickerSet: TLObject() {
		@JvmField var stickerset: InputStickerSet? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stickerset?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf96e55deu.toInt()
		}
	}
	
	open class TLMessagesEditChatAdmin: TLObject() {
		@JvmField var chatId = 0L
		@JvmField var userId: InputUser? = null
		@JvmField var isAdmin = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(chatId)
			userId?.serializeToStream(stream)
			stream.writeBool(isAdmin)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa85bd1c2u.toInt()
		}
	}
	
	open class TLMessagesReorderStickerSets: TLObject() {
		@JvmField var flags = 0
		@JvmField var masks = false
		@JvmField var emojis = false
		@JvmField val order = mutableListOf<Long>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (masks) flags or 1 else flags and 1.inv()
			flags = if (emojis) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(order.size)
			order.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x78337739u.toInt()
		}
	}
	
	open class TLMessagesSaveGif: TLObject() {
		@JvmField var id: InputDocument? = null
		@JvmField var unsave = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			id?.serializeToStream(stream)
			stream.writeBool(unsave)
		}
	
		companion object {
			val CONSTRUCTOR = 0x327a30cbu.toInt()
		}
	}
	
	open class TLMessagesSetInlineBotResults: TLObject() {
		@JvmField var flags = 0
		@JvmField var gallery = false
		@JvmField var isPrivate = false
		@JvmField var queryId = 0L
		@JvmField val results = mutableListOf<InputBotInlineResult>()
		@JvmField var cacheTime = 0
		@JvmField var nextOffset: String? = null
		@JvmField var switchPm: TLInlineBotSwitchPM? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (gallery) flags or 1 else flags and 1.inv()
			flags = if (isPrivate) flags or 2 else flags and 2.inv()
			flags = if (nextOffset != null) flags or 4 else flags and 4.inv()
			flags = if (switchPm != null) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(queryId)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(results.size)
			results.forEach { it.serializeToStream(stream) }
			stream.writeInt32(cacheTime)
			if ((flags and 4) != 0) {
				stream.writeString(nextOffset)
			}
	
			if ((flags and 8) != 0) {
				switchPm?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xeb5ea206u.toInt()
		}
	}
	
	open class TLMessagesEditInlineBotMessage: TLObject() {
		@JvmField var flags = 0
		@JvmField var noWebpage = false
		@JvmField var id: InputBotInlineMessageID? = null
		@JvmField var message: String? = null
		@JvmField var media: InputMedia? = null
		@JvmField var replyMarkup: ReplyMarkup? = null
		@JvmField val entities = mutableListOf<MessageEntity>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (noWebpage) flags or 2 else flags and 2.inv()
			flags = if (message != null) flags or 2048 else flags and 2048.inv()
			flags = if (media != null) flags or 16384 else flags and 16384.inv()
			flags = if (replyMarkup != null) flags or 4 else flags and 4.inv()
			flags = if (entities.isNotEmpty()) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			id?.serializeToStream(stream)
			if ((flags and 2048) != 0) {
				stream.writeString(message)
			}
	
			if ((flags and 16384) != 0) {
				media?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x83557dbau.toInt()
		}
	}
	
	open class TLMessagesSetBotCallbackAnswer: TLObject() {
		@JvmField var flags = 0
		@JvmField var alert = false
		@JvmField var queryId = 0L
		@JvmField var message: String? = null
		@JvmField var url: String? = null
		@JvmField var cacheTime = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (alert) flags or 2 else flags and 2.inv()
			flags = if (message != null) flags or 1 else flags and 1.inv()
			flags = if (url != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(queryId)
			if ((flags and 1) != 0) {
				stream.writeString(message)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(url)
			}
	
			stream.writeInt32(cacheTime)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd58f130au.toInt()
		}
	}
	
	open class TLMessagesSaveDraft: TLObject() {
		@JvmField var flags = 0
		@JvmField var noWebpage = false
		@JvmField var replyToMsgId = 0
		@JvmField var peer: InputPeer? = null
		@JvmField var message: String? = null
		@JvmField val entities = mutableListOf<MessageEntity>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (noWebpage) flags or 2 else flags and 2.inv()
			flags = if (replyToMsgId != 0) flags or 1 else flags and 1.inv()
			flags = if (entities.isNotEmpty()) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeInt32(replyToMsgId)
			}
	
			peer?.serializeToStream(stream)
			stream.writeString(message)
			if ((flags and 8) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xbc39e14bu.toInt()
		}
	}
	
	open class TLMessagesReadFeaturedStickers: TLObject() {
		@JvmField val id = mutableListOf<Long>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x5b118126u.toInt()
		}
	}
	
	open class TLMessagesSaveRecentSticker: TLObject() {
		@JvmField var flags = 0
		@JvmField var attached = false
		@JvmField var id: InputDocument? = null
		@JvmField var unsave = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (attached) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			id?.serializeToStream(stream)
			stream.writeBool(unsave)
		}
	
		companion object {
			val CONSTRUCTOR = 0x392718f8u.toInt()
		}
	}
	
	open class TLMessagesClearRecentStickers: TLObject() {
		@JvmField var flags = 0
		@JvmField var attached = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (attached) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8999602du.toInt()
		}
	}
	
	open class TLMessagesSetInlineGameScore: TLObject() {
		@JvmField var flags = 0
		@JvmField var editMessage = false
		@JvmField var force = false
		@JvmField var id: InputBotInlineMessageID? = null
		@JvmField var userId: InputUser? = null
		@JvmField var score = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (editMessage) flags or 1 else flags and 1.inv()
			flags = if (force) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			id?.serializeToStream(stream)
			userId?.serializeToStream(stream)
			stream.writeInt32(score)
		}
	
		companion object {
			val CONSTRUCTOR = 0x15ad9f64u.toInt()
		}
	}
	
	open class TLMessagesToggleDialogPin: TLObject() {
		@JvmField var flags = 0
		@JvmField var pinned = false
		@JvmField var peer: InputDialogPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (pinned) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa731e257u.toInt()
		}
	}
	
	open class TLMessagesReorderPinnedDialogs: TLObject() {
		@JvmField var flags = 0
		@JvmField var force = false
		@JvmField var folderId = 0
		@JvmField val order = mutableListOf<InputDialogPeer>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (force) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(folderId)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(order.size)
			order.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x3b1adf37u.toInt()
		}
	}
	
	open class TLMessagesSetBotShippingResults: TLObject() {
		@JvmField var flags = 0
		@JvmField var queryId = 0L
		@JvmField var error: String? = null
		@JvmField val shippingOptions = mutableListOf<TLShippingOption>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (error != null) flags or 1 else flags and 1.inv()
			flags = if (shippingOptions.isNotEmpty()) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(queryId)
			if ((flags and 1) != 0) {
				stream.writeString(error)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(shippingOptions.size)
			shippingOptions.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe5f672fau.toInt()
		}
	}
	
	open class TLMessagesSetBotPrecheckoutResults: TLObject() {
		@JvmField var flags = 0
		@JvmField var success = false
		@JvmField var queryId = 0L
		@JvmField var error: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (success) flags or 2 else flags and 2.inv()
			flags = if (error != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(queryId)
			if ((flags and 1) != 0) {
				stream.writeString(error)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9c2dd95u.toInt()
		}
	}
	
	open class TLMessagesFaveSticker: TLObject() {
		@JvmField var id: InputDocument? = null
		@JvmField var unfave = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			id?.serializeToStream(stream)
			stream.writeBool(unfave)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb9ffc55bu.toInt()
		}
	}
	
	open class TLMessagesMarkDialogUnread: TLObject() {
		@JvmField var flags = 0
		@JvmField var unread = false
		@JvmField var peer: InputDialogPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (unread) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc286d98fu.toInt()
		}
	}
	
	open class TLMessagesClearAllDrafts: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x7e58ee9cu.toInt()
		}
	}
	
	open class TLMessagesEditChatAbout: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var about: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeString(about)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdef60797u.toInt()
		}
	}
	
	open class TLMessagesHidePeerSettingsBar: TLObject() {
		@JvmField var peer: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4facb138u.toInt()
		}
	}
	
	open class TLMessagesToggleStickerSets: TLObject() {
		@JvmField var flags = 0
		@JvmField var uninstall = false
		@JvmField var archive = false
		@JvmField var unarchive = false
		@JvmField val stickersets = mutableListOf<InputStickerSet>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (uninstall) flags or 1 else flags and 1.inv()
			flags = if (archive) flags or 2 else flags and 2.inv()
			flags = if (unarchive) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(stickersets.size)
			stickersets.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xb5052feau.toInt()
		}
	}
	
	open class TLMessagesUpdateDialogFilter: TLObject() {
		@JvmField var flags = 0
		@JvmField var id = 0
		@JvmField var filter: DialogFilter? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (filter != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(id)
			if ((flags and 1) != 0) {
				filter?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1ad4a04au.toInt()
		}
	}
	
	open class TLMessagesUpdateDialogFiltersOrder: TLObject() {
		@JvmField val order = mutableListOf<Int>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(order.size)
			order.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xc563c1e4u.toInt()
		}
	}
	
	open class TLMessagesReadDiscussion: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var msgId = 0
		@JvmField var readMaxId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
			stream.writeInt32(readMaxId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf731a9f4u.toInt()
		}
	}
	
	open class TLMessagesDeleteChat: TLObject() {
		@JvmField var chatId = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(chatId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5bd0ee50u.toInt()
		}
	}
	
	open class TLMessagesStartHistoryImport: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var importId = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt64(importId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb43df344u.toInt()
		}
	}
	
	open class TLMessagesDeleteRevokedExportedChatInvites: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var adminId: InputUser? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			adminId?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x56987bd5u.toInt()
		}
	}
	
	open class TLMessagesDeleteExportedChatInvite: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var link: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeString(link)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd464a42bu.toInt()
		}
	}
	
	open class TLMessagesSaveDefaultSendAs: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var sendAs: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			sendAs?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xccfddf96u.toInt()
		}
	}
	
	open class TLMessagesSetDefaultReaction: TLObject() {
		@JvmField var reaction: Reaction? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			reaction?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4f47a016u.toInt()
		}
	}
	
	open class TLMessagesToggleBotInAttachMenu: TLObject() {
		@JvmField var bot: InputUser? = null
		@JvmField var enabled = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			bot?.serializeToStream(stream)
			stream.writeBool(enabled)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1aee33afu.toInt()
		}
	}
	
	open class TLMessagesProlongWebView: TLObject() {
		@JvmField var flags = 0
		@JvmField var silent = false
		@JvmField var peer: InputPeer? = null
		@JvmField var bot: InputUser? = null
		@JvmField var queryId = 0L
		@JvmField var replyToMsgId = 0
		@JvmField var sendAs: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (silent) flags or 32 else flags and 32.inv()
			flags = if (replyToMsgId != 0) flags or 1 else flags and 1.inv()
			flags = if (sendAs != null) flags or 8192 else flags and 8192.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			bot?.serializeToStream(stream)
			stream.writeInt64(queryId)
			if ((flags and 1) != 0) {
				stream.writeInt32(replyToMsgId)
			}
	
			if ((flags and 8192) != 0) {
				sendAs?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xea5fbcceu.toInt()
		}
	}
	
	open class TLMessagesRateTranscribedAudio: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var msgId = 0
		@JvmField var transcriptionId = 0L
		@JvmField var good = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
			stream.writeInt64(transcriptionId)
			stream.writeBool(good)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7f1d072fu.toInt()
		}
	}
	
	open class TLUploadSaveFilePart: TLObject() {
		@JvmField var fileId = 0L
		@JvmField var filePart = 0
		@JvmField var bytes: NativeByteBuffer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(fileId)
			stream.writeInt32(filePart)
			stream.writeByteBuffer(bytes)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb304a621u.toInt()
		}
	}
	
	open class TLUploadSaveBigFilePart: TLObject() {
		@JvmField var fileId = 0L
		@JvmField var filePart = 0
		@JvmField var fileTotalParts = 0
		@JvmField var bytes: NativeByteBuffer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(fileId)
			stream.writeInt32(filePart)
			stream.writeInt32(fileTotalParts)
			stream.writeByteBuffer(bytes)
		}
	
		companion object {
			val CONSTRUCTOR = 0xde7b673du.toInt()
		}
	}
	
	open class TLHelpSetBotUpdatesStatus: TLObject() {
		@JvmField var pendingUpdatesCount = 0
		@JvmField var message: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(pendingUpdatesCount)
			stream.writeString(message)
		}
	
		companion object {
			val CONSTRUCTOR = 0xec22cfcdu.toInt()
		}
	}
	
	open class TLHelpAcceptTermsOfService: TLObject() {
		@JvmField var id: TLDataJSON? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			id?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xee72f79au.toInt()
		}
	}
	
	open class TLHelpSaveAppLog: TLObject() {
		@JvmField val events = mutableListOf<TLInputAppEvent>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(events.size)
			events.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x6f02f748u.toInt()
		}
	}
	
	open class TLHelpHidePromoData: TLObject() {
		@JvmField var peer: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1e251c95u.toInt()
		}
	}
	
	open class TLHelpDismissSuggestion: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var suggestion: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeString(suggestion)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf50dbaa1u.toInt()
		}
	}
	
	open class TLChannelsReadHistory: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var maxId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeInt32(maxId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcc104937u.toInt()
		}
	}
	
	open class TLChannelsReportSpam: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var participant: InputPeer? = null
		@JvmField val id = mutableListOf<Int>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			participant?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xf44a8315u.toInt()
		}
	}
	
	open class TLChannelsCheckUsername: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var username: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeString(username)
		}
	
		companion object {
			val CONSTRUCTOR = 0x10e6bd2cu.toInt()
		}
	}
	
	open class TLChannelsUpdateUsername: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var username: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeString(username)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3514b3deu.toInt()
		}
	}
	
	open class TLChannelsSetStickers: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var stickerset: InputStickerSet? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stickerset?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xea8ca4f9u.toInt()
		}
	}
	
	open class TLChannelsReadMessageContents: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField val id = mutableListOf<Int>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xeab5dc38u.toInt()
		}
	}
	
	open class TLChannelsSetDiscussionGroup: TLObject() {
		@JvmField var broadcast: InputChannel? = null
		@JvmField var group: InputChannel? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			broadcast?.serializeToStream(stream)
			group?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x40582bb2u.toInt()
		}
	}
	
	open class TLChannelsEditLocation: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var geoPoint: InputGeoPoint? = null
		@JvmField var address: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			geoPoint?.serializeToStream(stream)
			stream.writeString(address)
		}
	
		companion object {
			val CONSTRUCTOR = 0x58e63f6du.toInt()
		}
	}
	
	open class TLChannelsViewSponsoredMessage: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var randomId: ByteArray? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeByteArray(randomId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbeaedb94u.toInt()
		}
	}
	
	open class TLBotsAnswerWebhookJSONQuery: TLObject() {
		@JvmField var queryId = 0L
		@JvmField var data: TLDataJSON? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(queryId)
			data?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe6213f4du.toInt()
		}
	}
	
	open class TLBotsSetBotCommands: TLObject() {
		@JvmField var scope: BotCommandScope? = null
		@JvmField var langCode: String? = null
		@JvmField val commands = mutableListOf<TLBotCommand>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			scope?.serializeToStream(stream)
			stream.writeString(langCode)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(commands.size)
			commands.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x517165au.toInt()
		}
	}
	
	open class TLBotsResetBotCommands: TLObject() {
		@JvmField var scope: BotCommandScope? = null
		@JvmField var langCode: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			scope?.serializeToStream(stream)
			stream.writeString(langCode)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3d8de0f9u.toInt()
		}
	}
	
	open class TLBotsSetBotMenuButton: TLObject() {
		@JvmField var userId: InputUser? = null
		@JvmField var button: BotMenuButton? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			userId?.serializeToStream(stream)
			button?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4504d54fu.toInt()
		}
	}
	
	open class TLBotsSetBotBroadcastDefaultAdminRights: TLObject() {
		@JvmField var adminRights: TLChatAdminRights? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			adminRights?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x788464e1u.toInt()
		}
	}
	
	open class TLBotsSetBotGroupDefaultAdminRights: TLObject() {
		@JvmField var adminRights: TLChatAdminRights? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			adminRights?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x925ec9eau.toInt()
		}
	}
	
	open class TLStickersCheckShortName: TLObject() {
		@JvmField var shortName: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(shortName)
		}
	
		companion object {
			val CONSTRUCTOR = 0x284b3639u.toInt()
		}
	}
	
	open class TLPhoneReceivedCall: TLObject() {
		@JvmField var peer: TLInputPhoneCall? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x17d54f61u.toInt()
		}
	}
	
	open class TLPhoneSaveCallDebug: TLObject() {
		@JvmField var peer: TLInputPhoneCall? = null
		@JvmField var debug: TLDataJSON? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			debug?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x277add7eu.toInt()
		}
	}
	
	open class TLPhoneSendSignalingData: TLObject() {
		@JvmField var peer: TLInputPhoneCall? = null
		@JvmField var data: ByteArray? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeByteArray(data)
		}
	
		companion object {
			val CONSTRUCTOR = 0xff7a9383u.toInt()
		}
	}
	
	open class TLPhoneSaveDefaultGroupCallJoinAs: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var joinAs: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			joinAs?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x575e1f8cu.toInt()
		}
	}
	
	open class TLPhoneSaveCallLog: TLObject() {
		@JvmField var peer: TLInputPhoneCall? = null
		@JvmField var file: InputFile? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			file?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x41248786u.toInt()
		}
	}
	
	open class TLChatlistsDeleteExportedInvite: TLObject() {
		@JvmField var chatlist: TLInputChatlist? = null
		@JvmField var slug: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			chatlist?.serializeToStream(stream)
			stream.writeString(slug)
		}
	
		companion object {
			val CONSTRUCTOR = 0x719c5c5eu.toInt()
		}
	}
	
	open class TLHelpTest: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc0e202f7u.toInt()
		}
	}
	
	open class TLPaymentsCanPurchasePremium: TLObject() {
		@JvmField var purpose: InputStorePaymentPurpose? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			purpose?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9fc19eb6u.toInt()
		}
	}
	
	open class TLGatewaySendDataToGateway: TLObject() {
		@JvmField var authKeyId = 0L
		@JvmField var sessionId = 0L
		@JvmField var payload: ByteArray? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Bool? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Bool.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(authKeyId)
			stream.writeInt64(sessionId)
			stream.writeByteArray(payload)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8b296aafu.toInt()
		}
	}
	
	open class TLTrue: TLObject() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3fedd339u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLTrue? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLTrue")
					}
					else {
						null
					}
				}
	
				val result = TLTrue()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLError: TLObject() {
		@JvmField var code = 0
		@JvmField var text: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			code = stream.readInt32(exception)
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(code)
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc4b9f9bbu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLError? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLError")
					}
					else {
						null
					}
				}
	
				val result = TLError()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLNull: TLObject() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x56730bccu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLNull? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLNull")
					}
					else {
						null
					}
				}
	
				val result = TLNull()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLVoid: TLObject() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1c084438u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLVoid? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLVoid")
					}
					else {
						null
					}
				}
	
				val result = TLVoid()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class PrivacyRule: TLObject() {
		@JvmField val users = mutableListOf<Long>()
		@JvmField val chats = mutableListOf<Long>()
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PrivacyRule? {
				val result = when (constructor) {
					TLPrivacyValueAllowContacts.CONSTRUCTOR -> TLPrivacyValueAllowContacts()
					TLPrivacyValueAllowAll.CONSTRUCTOR -> TLPrivacyValueAllowAll()
					TLPrivacyValueAllowUsers.CONSTRUCTOR -> TLPrivacyValueAllowUsers()
					TLPrivacyValueDisallowContacts.CONSTRUCTOR -> TLPrivacyValueDisallowContacts()
					TLPrivacyValueDisallowAll.CONSTRUCTOR -> TLPrivacyValueDisallowAll()
					TLPrivacyValueDisallowUsers.CONSTRUCTOR -> TLPrivacyValueDisallowUsers()
					TLPrivacyValueAllowChatParticipants.CONSTRUCTOR -> TLPrivacyValueAllowChatParticipants()
					TLPrivacyValueDisallowChatParticipants.CONSTRUCTOR -> TLPrivacyValueDisallowChatParticipants()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in PrivacyRule")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPrivacyValueAllowContacts: PrivacyRule() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xfffe1bacu.toInt()
		}
	}
	
	open class TLPrivacyValueAllowAll: PrivacyRule() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x65427b82u.toInt()
		}
	}
	
	open class TLPrivacyValueAllowUsers: PrivacyRule() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xb8905fb2u.toInt()
		}
	}
	
	open class TLPrivacyValueDisallowContacts: PrivacyRule() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf888fa1au.toInt()
		}
	}
	
	open class TLPrivacyValueDisallowAll: PrivacyRule() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8b73e763u.toInt()
		}
	}
	
	open class TLPrivacyValueDisallowUsers: PrivacyRule() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xe4621141u.toInt()
		}
	}
	
	open class TLPrivacyValueAllowChatParticipants: PrivacyRule() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				chats.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x6b134e8eu.toInt()
		}
	}
	
	open class TLPrivacyValueDisallowChatParticipants: PrivacyRule() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				chats.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x41c87565u.toInt()
		}
	}
	
	abstract class InputFileLocation: TLObject() {
		@JvmField var localId = 0
		@JvmField var stickerset: InputStickerSet? = null
		@JvmField var secret = 0L
		@JvmField var big = false
		@JvmField var peer: InputPeer? = null
		@JvmField var flags = 0
		@JvmField var volumeId = 0L
		@JvmField var id = 0L
		@JvmField var accessHash = 0L
		@JvmField var thumbSize: String? = null
		@JvmField var fileReference: ByteArray? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputFileLocation? {
				val result = when (constructor) {
					TLInputPeerPhotoFileLocationLegacy.CONSTRUCTOR -> TLInputPeerPhotoFileLocationLegacy()
					TLInputStickerSetThumbLegacy.CONSTRUCTOR -> TLInputStickerSetThumbLegacy()
					TLInputFileLocation.CONSTRUCTOR -> TLInputFileLocation()
					TLInputEncryptedFileLocation.CONSTRUCTOR -> TLInputEncryptedFileLocation()
					TLInputDocumentFileLocation.CONSTRUCTOR -> TLInputDocumentFileLocation()
					TLInputSecureFileLocation.CONSTRUCTOR -> TLInputSecureFileLocation()
					TLInputTakeoutFileLocation.CONSTRUCTOR -> TLInputTakeoutFileLocation()
					TLInputPhotoFileLocation.CONSTRUCTOR -> TLInputPhotoFileLocation()
					TLInputPhotoLegacyFileLocation.CONSTRUCTOR -> TLInputPhotoLegacyFileLocation()
					TLInputPeerPhotoFileLocation.CONSTRUCTOR -> TLInputPeerPhotoFileLocation()
					TLInputStickerSetThumb.CONSTRUCTOR -> TLInputStickerSetThumb()
					TLInputGroupCallStream.CONSTRUCTOR -> TLInputGroupCallStream()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputFileLocation")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputPeerPhotoFileLocationLegacy: InputFileLocation() {
						
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			big = (flags and 1) != 0
			peer = InputPeer.deserialize(stream, stream.readInt32(exception), exception)
			volumeId = stream.readInt64(exception)
			localId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (big) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt64(volumeId)
			stream.writeInt32(localId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x27d69997u.toInt()
		}
	}
	
	open class TLInputStickerSetThumbLegacy: InputFileLocation() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			stickerset = InputStickerSet.deserialize(stream, stream.readInt32(exception), exception)
			volumeId = stream.readInt64(exception)
			localId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stickerset?.serializeToStream(stream)
			stream.writeInt64(volumeId)
			stream.writeInt32(localId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdbaeae9u.toInt()
		}
	}
	
	open class TLInputFileLocation: InputFileLocation() {
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			volumeId = stream.readInt64(exception)
			localId = stream.readInt32(exception)
			secret = stream.readInt64(exception)
			fileReference = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(volumeId)
			stream.writeInt32(localId)
			stream.writeInt64(secret)
			stream.writeByteArray(fileReference)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdfdaabe1u.toInt()
		}
	}
	
	open class TLInputEncryptedFileLocation: InputFileLocation() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf5235d55u.toInt()
		}
	}
	
	open class TLInputDocumentFileLocation: InputFileLocation() {
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			fileReference = stream.readByteArray(exception) ?: return
			thumbSize = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeByteArray(fileReference)
			stream.writeString(thumbSize)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbad07584u.toInt()
		}
	}
	
	open class TLInputSecureFileLocation: InputFileLocation() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcbc7ee28u.toInt()
		}
	}
	
	open class TLInputTakeoutFileLocation: InputFileLocation() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x29be5899u.toInt()
		}
	}
	
	open class TLInputPhotoFileLocation: InputFileLocation() {
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			fileReference = stream.readByteArray(exception) ?: return
			thumbSize = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeByteArray(fileReference)
			stream.writeString(thumbSize)
		}
	
		companion object {
			val CONSTRUCTOR = 0x40181ffeu.toInt()
		}
	}
	
	open class TLInputPhotoLegacyFileLocation: InputFileLocation() {
							
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			fileReference = stream.readByteArray(exception) ?: return
			volumeId = stream.readInt64(exception)
			localId = stream.readInt32(exception)
			secret = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeByteArray(fileReference)
			stream.writeInt64(volumeId)
			stream.writeInt32(localId)
			stream.writeInt64(secret)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd83466f3u.toInt()
		}
	}
	
	open class TLInputPeerPhotoFileLocation: InputFileLocation() {
					@JvmField var photoId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			big = (flags and 1) != 0
			peer = InputPeer.deserialize(stream, stream.readInt32(exception), exception)
			photoId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (big) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt64(photoId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x37257e99u.toInt()
		}
	}
	
	open class TLInputStickerSetThumb: InputFileLocation() {
			@JvmField var thumbVersion = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			stickerset = InputStickerSet.deserialize(stream, stream.readInt32(exception), exception)
			thumbVersion = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stickerset?.serializeToStream(stream)
			stream.writeInt32(thumbVersion)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9d84f3dbu.toInt()
		}
	}
	
	open class TLInputGroupCallStream: InputFileLocation() {
			@JvmField var call: TLInputGroupCall? = null
		@JvmField var timeMs = 0L
		@JvmField var scale = 0
		@JvmField var videoChannel = 0
		@JvmField var videoQuality = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			call = TLInputGroupCall.deserialize(stream, stream.readInt32(exception), exception)
			timeMs = stream.readInt64(exception)
			scale = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				videoChannel = stream.readInt32(exception)
			}
		
			if ((flags and 1) != 0) {
				videoQuality = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (videoChannel != 0) flags or 1 else flags and 1.inv()
			flags = if (videoQuality != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			call?.serializeToStream(stream)
			stream.writeInt64(timeMs)
			stream.writeInt32(scale)
			if ((flags and 1) != 0) {
				stream.writeInt32(videoChannel)
			}
	
			if ((flags and 1) != 0) {
				stream.writeInt32(videoQuality)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x598a92au.toInt()
		}
	}
	
	abstract class InputPeer: TLObject() {
		@JvmField var userId = 0L
		@JvmField var peer: InputPeer? = null
		@JvmField var channelId = 0L
		@JvmField var msgId = 0
		@JvmField var accessHash = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputPeer? {
				val result = when (constructor) {
					TLInputPeerEmpty.CONSTRUCTOR -> TLInputPeerEmpty()
					TLInputPeerSelf.CONSTRUCTOR -> TLInputPeerSelf()
					TLInputPeerChat.CONSTRUCTOR -> TLInputPeerChat()
					TLInputPeerUser.CONSTRUCTOR -> TLInputPeerUser()
					TLInputPeerChannel.CONSTRUCTOR -> TLInputPeerChannel()
					TLInputPeerUserFromMessage.CONSTRUCTOR -> TLInputPeerUserFromMessage()
					TLInputPeerChannelFromMessage.CONSTRUCTOR -> TLInputPeerChannelFromMessage()
					TLInputPeerUsername.CONSTRUCTOR -> TLInputPeerUsername()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputPeer")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputPeerEmpty: InputPeer() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x7f3b18eau.toInt()
		}
	}
	
	open class TLInputPeerSelf: InputPeer() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x7da07ec9u.toInt()
		}
	}
	
	open class TLInputPeerChat: InputPeer() {
		@JvmField var chatId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			chatId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(chatId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x35a95cb9u.toInt()
		}
	}
	
	open class TLInputPeerUser: InputPeer() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdde8a54cu.toInt()
		}
	}
	
	open class TLInputPeerChannel: InputPeer() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			channelId = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(channelId)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x27bcbbfcu.toInt()
		}
	}
	
	open class TLInputPeerUserFromMessage: InputPeer() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = InputPeer.deserialize(stream, stream.readInt32(exception), exception)
			msgId = stream.readInt32(exception)
			userId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
			stream.writeInt64(userId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa87b0a1cu.toInt()
		}
	}
	
	open class TLInputPeerChannelFromMessage: InputPeer() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = InputPeer.deserialize(stream, stream.readInt32(exception), exception)
			msgId = stream.readInt32(exception)
			channelId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
			stream.writeInt64(channelId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbd2a0840u.toInt()
		}
	}
	
	open class TLInputPeerUsername: InputPeer() {
		@JvmField var username: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			username = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(username)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe24dd166u.toInt()
		}
	}
	
	abstract class InputUser: TLObject() {
		@JvmField var userId = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputUser? {
				val result = when (constructor) {
					TLInputUserEmpty.CONSTRUCTOR -> TLInputUserEmpty()
					TLInputUserSelf.CONSTRUCTOR -> TLInputUserSelf()
					TLInputUser.CONSTRUCTOR -> TLInputUser()
					TLInputUserFromMessage.CONSTRUCTOR -> TLInputUserFromMessage()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputUser")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputUserEmpty: InputUser() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb98886cfu.toInt()
		}
	}
	
	open class TLInputUserSelf: InputUser() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf7c1b13fu.toInt()
		}
	}
	
	open class TLInputUser: InputUser() {
			@JvmField var accessHash = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf21158c6u.toInt()
		}
	}
	
	open class TLInputUserFromMessage: InputUser() {
		@JvmField var peer: InputPeer? = null
		@JvmField var msgId = 0
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = InputPeer.deserialize(stream, stream.readInt32(exception), exception)
			msgId = stream.readInt32(exception)
			userId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
			stream.writeInt64(userId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1da448e2u.toInt()
		}
	}
	
	open class TLInputContact: TLObject() {
		@JvmField var clientId = 0L
		@JvmField var phone: String? = null
		@JvmField var firstName: String? = null
		@JvmField var lastName: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			clientId = stream.readInt64(exception)
			phone = stream.readString(exception) ?: return
			firstName = stream.readString(exception) ?: return
			lastName = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(clientId)
			stream.writeString(phone)
			stream.writeString(firstName)
			stream.writeString(lastName)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf392b7f4u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLInputContact? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLInputContact")
					}
					else {
						null
					}
				}
	
				val result = TLInputContact()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class InputFile: TLObject() {
		@JvmField var parts = 0
		@JvmField var id = 0L
		@JvmField var name: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputFile? {
				val result = when (constructor) {
					TLInputFile.CONSTRUCTOR -> TLInputFile()
					TLInputFileBig.CONSTRUCTOR -> TLInputFileBig()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputFile")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputFile: InputFile() {
					@JvmField var md5Checksum: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			parts = stream.readInt32(exception)
			name = stream.readString(exception) ?: return
			md5Checksum = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt32(parts)
			stream.writeString(name)
			stream.writeString(md5Checksum)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf52ff27fu.toInt()
		}
	}
	
	open class TLInputFileBig: InputFile() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			parts = stream.readInt32(exception)
			name = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt32(parts)
			stream.writeString(name)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfa4f0bb5u.toInt()
		}
	}
	
	abstract class InputMedia: TLObject() {
		@JvmField var title: String? = null
		@JvmField var url: String? = null
		@JvmField var flags = 0
		@JvmField val stickers = mutableListOf<InputDocument>()
		@JvmField var ttlSeconds = 0
		@JvmField var geoPoint: InputGeoPoint? = null
		@JvmField var file: InputFile? = null
		@JvmField var provider: String? = null
		@JvmField var spoiler = false
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputMedia? {
				val result = when (constructor) {
					TLInputMediaEmpty.CONSTRUCTOR -> TLInputMediaEmpty()
					TLInputMediaUploadedPhoto.CONSTRUCTOR -> TLInputMediaUploadedPhoto()
					TLInputMediaPhoto.CONSTRUCTOR -> TLInputMediaPhoto()
					TLInputMediaGeoPoint.CONSTRUCTOR -> TLInputMediaGeoPoint()
					TLInputMediaContact.CONSTRUCTOR -> TLInputMediaContact()
					TLInputMediaUploadedDocument.CONSTRUCTOR -> TLInputMediaUploadedDocument()
					TLInputMediaDocument.CONSTRUCTOR -> TLInputMediaDocument()
					TLInputMediaVenue.CONSTRUCTOR -> TLInputMediaVenue()
					TLInputMediaPhotoExternal.CONSTRUCTOR -> TLInputMediaPhotoExternal()
					TLInputMediaDocumentExternal.CONSTRUCTOR -> TLInputMediaDocumentExternal()
					TLInputMediaGame.CONSTRUCTOR -> TLInputMediaGame()
					TLInputMediaInvoice.CONSTRUCTOR -> TLInputMediaInvoice()
					TLInputMediaGeoLive.CONSTRUCTOR -> TLInputMediaGeoLive()
					TLInputMediaPoll.CONSTRUCTOR -> TLInputMediaPoll()
					TLInputMediaDice.CONSTRUCTOR -> TLInputMediaDice()
					TLInputMediaBizDataRaw.CONSTRUCTOR -> TLInputMediaBizDataRaw()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputMedia")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputMediaEmpty: InputMedia() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9664f57fu.toInt()
		}
	}
	
	open class TLInputMediaUploadedPhoto: InputMedia() {
						
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			spoiler = (flags and 4) != 0
			file = InputFile.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = InputDocument.deserialize(stream, stream.readInt32(exception), exception) ?: return
					stickers.add(obj)
				}
			}
		
			if ((flags and 2) != 0) {
				ttlSeconds = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (spoiler) flags or 4 else flags and 4.inv()
			flags = if (ttlSeconds != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			file?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(stickers.size)
			stickers.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(ttlSeconds)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1e287d04u.toInt()
		}
	}
	
	open class TLInputMediaPhoto: InputMedia() {
				@JvmField var id: InputPhoto? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			spoiler = (flags and 2) != 0
			id = InputPhoto.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				ttlSeconds = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (spoiler) flags or 2 else flags and 2.inv()
			flags = if (ttlSeconds != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			id?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(ttlSeconds)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb3ba0635u.toInt()
		}
	}
	
	open class TLInputMediaGeoPoint: InputMedia() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			geoPoint = InputGeoPoint.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			geoPoint?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf9c44144u.toInt()
		}
	}
	
	open class TLInputMediaContact: InputMedia() {
		@JvmField var phoneNumber: String? = null
		@JvmField var firstName: String? = null
		@JvmField var lastName: String? = null
		@JvmField var vcard: String? = null
		@JvmField var userId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			phoneNumber = stream.readString(exception) ?: return
			firstName = stream.readString(exception) ?: return
			lastName = stream.readString(exception) ?: return
			vcard = stream.readString(exception) ?: return
			userId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phoneNumber)
			stream.writeString(firstName)
			stream.writeString(lastName)
			stream.writeString(vcard)
			stream.writeInt64(userId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf8ab7dfbu.toInt()
		}
	}
	
	open class TLInputMediaUploadedDocument: InputMedia() {
			@JvmField var nosoundVideo = false
		@JvmField var forceFile = false
				@JvmField var thumb: InputFile? = null
		@JvmField var mimeType: String? = null
		@JvmField val attributes = mutableListOf<DocumentAttribute>()
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			nosoundVideo = (flags and 8) != 0
			forceFile = (flags and 16) != 0
			spoiler = (flags and 32) != 0
			file = InputFile.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 4) != 0) {
				thumb = InputFile.deserialize(stream, stream.readInt32(exception), exception)
			}
			mimeType = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = DocumentAttribute.deserialize(stream, stream.readInt32(exception), exception) ?: return
				attributes.add(obj)
			}
		
			if ((flags and 1) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = InputDocument.deserialize(stream, stream.readInt32(exception), exception) ?: return
					stickers.add(obj)
				}
			}
		
			if ((flags and 2) != 0) {
				ttlSeconds = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (nosoundVideo) flags or 8 else flags and 8.inv()
			flags = if (forceFile) flags or 16 else flags and 16.inv()
			flags = if (spoiler) flags or 32 else flags and 32.inv()
			flags = if (thumb != null) flags or 4 else flags and 4.inv()
			flags = if (ttlSeconds != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			file?.serializeToStream(stream)
			if ((flags and 4) != 0) {
				thumb?.serializeToStream(stream)
			}
	
			stream.writeString(mimeType)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(attributes.size)
			attributes.forEach { it.serializeToStream(stream) }
			if ((flags and 1) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(stickers.size)
			stickers.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(ttlSeconds)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x5b38c6c1u.toInt()
		}
	}
	
	open class TLInputMediaDocument: InputMedia() {
				@JvmField var id: InputDocument? = null
			@JvmField var query: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			spoiler = (flags and 4) != 0
			id = InputDocument.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				ttlSeconds = stream.readInt32(exception)
			}
		
			if ((flags and 2) != 0) {
				query = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (spoiler) flags or 4 else flags and 4.inv()
			flags = if (ttlSeconds != 0) flags or 1 else flags and 1.inv()
			flags = if (query != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			id?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(ttlSeconds)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(query)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x33473058u.toInt()
		}
	}
	
	open class TLInputMediaVenue: InputMedia() {
				@JvmField var address: String? = null
			@JvmField var venueId: String? = null
		@JvmField var venueType: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			geoPoint = InputGeoPoint.deserialize(stream, stream.readInt32(exception), exception)
			title = stream.readString(exception) ?: return
			address = stream.readString(exception) ?: return
			provider = stream.readString(exception) ?: return
			venueId = stream.readString(exception) ?: return
			venueType = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			geoPoint?.serializeToStream(stream)
			stream.writeString(title)
			stream.writeString(address)
			stream.writeString(provider)
			stream.writeString(venueId)
			stream.writeString(venueType)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc13d1c11u.toInt()
		}
	}
	
	open class TLInputMediaPhotoExternal: InputMedia() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			url = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				ttlSeconds = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (ttlSeconds != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeString(url)
			if ((flags and 1) != 0) {
				stream.writeInt32(ttlSeconds)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe5bbfe1au.toInt()
		}
	}
	
	open class TLInputMediaDocumentExternal: InputMedia() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			url = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				ttlSeconds = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (ttlSeconds != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeString(url)
			if ((flags and 1) != 0) {
				stream.writeInt32(ttlSeconds)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xfb52dc99u.toInt()
		}
	}
	
	open class TLInputMediaGame: InputMedia() {
		@JvmField var id: InputGame? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = InputGame.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			id?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd33f43f3u.toInt()
		}
	}
	
	open class TLInputMediaInvoice: InputMedia() {
				@JvmField var description: String? = null
		@JvmField var photo: TLInputWebDocument? = null
		@JvmField var invoice: TLInvoice? = null
		@JvmField var payload: ByteArray? = null
			@JvmField var providerData: TLDataJSON? = null
		@JvmField var startParam: String? = null
		@JvmField var extendedMedia: InputMedia? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			title = stream.readString(exception) ?: return
			description = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				photo = TLInputWebDocument.deserialize(stream, stream.readInt32(exception), exception)
			}
			invoice = TLInvoice.deserialize(stream, stream.readInt32(exception), exception)
			payload = stream.readByteArray(exception) ?: return
			provider = stream.readString(exception) ?: return
			providerData = TLDataJSON.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 2) != 0) {
				startParam = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				extendedMedia = InputMedia.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (photo != null) flags or 1 else flags and 1.inv()
			flags = if (startParam != null) flags or 2 else flags and 2.inv()
			flags = if (extendedMedia != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeString(title)
			stream.writeString(description)
			if ((flags and 1) != 0) {
				photo?.serializeToStream(stream)
			}
	
			invoice?.serializeToStream(stream)
			stream.writeByteArray(payload)
			stream.writeString(provider)
			providerData?.serializeToStream(stream)
			if ((flags and 2) != 0) {
				stream.writeString(startParam)
			}
	
			if ((flags and 4) != 0) {
				extendedMedia?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8eb5a6d5u.toInt()
		}
	}
	
	open class TLInputMediaGeoLive: InputMedia() {
			@JvmField var stopped = false
			@JvmField var heading = 0
		@JvmField var period = 0
		@JvmField var proximityNotificationRadius = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			stopped = (flags and 1) != 0
			geoPoint = InputGeoPoint.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 4) != 0) {
				heading = stream.readInt32(exception)
			}
		
			if ((flags and 2) != 0) {
				period = stream.readInt32(exception)
			}
		
			if ((flags and 8) != 0) {
				proximityNotificationRadius = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (stopped) flags or 1 else flags and 1.inv()
			flags = if (heading != 0) flags or 4 else flags and 4.inv()
			flags = if (period != 0) flags or 2 else flags and 2.inv()
			flags = if (proximityNotificationRadius != 0) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			geoPoint?.serializeToStream(stream)
			if ((flags and 4) != 0) {
				stream.writeInt32(heading)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(period)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt32(proximityNotificationRadius)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x971fa843u.toInt()
		}
	}
	
	open class TLInputMediaPoll: InputMedia() {
			@JvmField var poll: TLPoll? = null
		@JvmField val correctAnswers = mutableListOf<ByteArray>()
		@JvmField var solution: String? = null
		@JvmField val solutionEntities = mutableListOf<MessageEntity>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			poll = TLPoll.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = stream.readByteArray(exception) ?: return
					correctAnswers.add(obj)
				}
			}
		
			if ((flags and 2) != 0) {
				solution = stream.readString(exception) ?: return
			}
		
			if ((flags and 2) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
					solutionEntities.add(obj)
				}
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (solution != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			poll?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(correctAnswers.size)
			correctAnswers.forEach { stream.writeByteArray(it) }
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(solution)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(solutionEntities.size)
			solutionEntities.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf94e5f1u.toInt()
		}
	}
	
	open class TLInputMediaDice: InputMedia() {
		@JvmField var emoticon: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			emoticon = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(emoticon)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe66fbf7bu.toInt()
		}
	}
	
	open class TLInputMediaBizDataRaw: InputMedia() {
		@JvmField var bizData: TLBizDataRaw? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			bizData = TLBizDataRaw.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			bizData?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9ed56a3du.toInt()
		}
	}
	
	abstract class InputChatPhoto: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputChatPhoto? {
				val result = when (constructor) {
					TLInputChatPhotoEmpty.CONSTRUCTOR -> TLInputChatPhotoEmpty()
					TLInputChatUploadedPhoto.CONSTRUCTOR -> TLInputChatUploadedPhoto()
					TLInputChatPhoto.CONSTRUCTOR -> TLInputChatPhoto()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputChatPhoto")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputChatPhotoEmpty: InputChatPhoto() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1ca48f57u.toInt()
		}
	}
	
	open class TLInputChatUploadedPhoto: InputChatPhoto() {
		@JvmField var flags = 0
		@JvmField var file: InputFile? = null
		@JvmField var video: InputFile? = null
		@JvmField var videoStartTs = 0.0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				file = InputFile.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				video = InputFile.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 4) != 0) {
				videoStartTs = stream.readDouble(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (file != null) flags or 1 else flags and 1.inv()
			flags = if (video != null) flags or 2 else flags and 2.inv()
			flags = if (videoStartTs != 0.0) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				file?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				video?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				stream.writeDouble(videoStartTs)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc642724eu.toInt()
		}
	}
	
	open class TLInputChatPhoto: InputChatPhoto() {
		@JvmField var id: InputPhoto? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = InputPhoto.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			id?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8953ad37u.toInt()
		}
	}
	
	abstract class InputGeoPoint: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputGeoPoint? {
				val result = when (constructor) {
					TLInputGeoPointEmpty.CONSTRUCTOR -> TLInputGeoPointEmpty()
					TLInputGeoPoint.CONSTRUCTOR -> TLInputGeoPoint()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputGeoPoint")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputGeoPointEmpty: InputGeoPoint() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe4c123d6u.toInt()
		}
	}
	
	open class TLInputGeoPoint: InputGeoPoint() {
		@JvmField var flags = 0
		@JvmField var lat = 0.0
		@JvmField var lon = 0.0
		@JvmField var accuracyRadius = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			lat = stream.readDouble(exception)
			lon = stream.readDouble(exception)
		
			if ((flags and 1) != 0) {
				accuracyRadius = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (accuracyRadius != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeDouble(lat)
			stream.writeDouble(lon)
			if ((flags and 1) != 0) {
				stream.writeInt32(accuracyRadius)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x48222fafu.toInt()
		}
	}
	
	abstract class InputPhoto: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputPhoto? {
				val result = when (constructor) {
					TLInputPhotoEmpty.CONSTRUCTOR -> TLInputPhotoEmpty()
					TLInputPhoto.CONSTRUCTOR -> TLInputPhoto()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputPhoto")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputPhotoEmpty: InputPhoto() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1cd7bf0du.toInt()
		}
	}
	
	open class TLInputPhoto: InputPhoto() {
		@JvmField var id = 0L
		@JvmField var accessHash = 0L
		@JvmField var fileReference: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			fileReference = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeByteArray(fileReference)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3bb3b94au.toInt()
		}
	}
	
	abstract class Genre: TLObject() {
		@JvmField var genre: String? = null
		@JvmField var id = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Genre? {
				val result = when (constructor) {
					TLChannelGenre.CONSTRUCTOR -> TLChannelGenre()
					TLChannelGenreLayer3.CONSTRUCTOR -> TLChannelGenreLayer3()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in Genre")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChannelGenre: Genre() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			genre = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeString(genre)
		}
	
		companion object {
			val CONSTRUCTOR = 0x031c13acu.toInt()
		}
	}
	
	open class TLChannelGenreLayer3: Genre() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			genre = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeString(genre)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbc6af579u.toInt()
		}
	}
	
	abstract class Genres: TLObject() {
		@JvmField val genres = mutableListOf<Genre>()
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Genres? {
				val result = when (constructor) {
					TLChannelGenres.CONSTRUCTOR -> TLChannelGenres()
					TLChannelGenresLayer3.CONSTRUCTOR -> TLChannelGenresLayer3()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in Genres")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChannelGenres: Genres() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Genre.deserialize(stream, stream.readInt32(exception), exception) ?: return
				genres.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(genres.size)
			genres.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x3b0fd83bu.toInt()
		}
	}
	
	open class TLChannelGenresLayer3: Genres() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Genre.deserialize(stream, stream.readInt32(exception), exception) ?: return
				genres.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(genres.size)
			genres.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xd239e055u.toInt()
		}
	}
	
	open class TLChannelsGetGenres: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Genres? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Genres.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x45965741u.toInt()
		}
	}
	
	abstract class FeedsHistoryMessages: TLObject() {
		@JvmField val messages = mutableListOf<Message>()
		@JvmField val chats = mutableListOf<Chat>()
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): FeedsHistoryMessages? {
				val result = when (constructor) {
					TLFeedsHistoryMessages.CONSTRUCTOR -> TLFeedsHistoryMessages()
					TLHistoryMessages.CONSTRUCTOR -> TLHistoryMessages()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in FeedsHistoryMessages")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLFeedsHistoryMessages: FeedsHistoryMessages() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Message.deserialize(stream, stream.readInt32(exception), exception) ?: return
				messages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x3baa102au.toInt()
		}
	}
	
	open class TLHistoryMessages: FeedsHistoryMessages() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Message.deserialize(stream, stream.readInt32(exception), exception) ?: return
				messages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x4985b72eu.toInt()
		}
	}
	
	open class TLFeedsReadHistory: TLObject() {
		@JvmField var page = 0
		@JvmField var limit = 0
		@JvmField var flags = 0
		@JvmField var isExplore = false
		@JvmField var isExploreOld = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): FeedsHistoryMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return FeedsHistoryMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (isExplore) flags or 1 else flags and 1.inv()
			flags = if (isExploreOld) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(page)
			stream.writeInt32(limit)
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3baa1029u.toInt()
		}
	}
	
	abstract class HelpAppConfig: TLObject() {
		@JvmField var config: JSONValue? = null
		@JvmField var hash: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpAppConfig? {
				val result = when (constructor) {
					TLAppConfig.CONSTRUCTOR -> TLAppConfig()
					TLAppConfigLayer3.CONSTRUCTOR -> TLAppConfigLayer3()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in HelpAppConfig")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLAppConfig: HelpAppConfig() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			hash = stream.readString(exception) ?: return
			config = JSONValue.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(hash)
			config?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x14f4f574u.toInt()
		}
	}
	
	open class TLAppConfigLayer3: HelpAppConfig() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			hash = stream.readString(exception) ?: return
			config = JSONValue.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(hash)
			config?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9be21425u.toInt()
		}
	}
	
	open class TLHelpAppConfigNotModified: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpAppConfig? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return HelpAppConfig.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x7cde641du.toInt()
		}
	}
	
	open class TLHelpAppConfig: TLObject() {
		@JvmField var hash = 0
		@JvmField var config: JSONValue? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpAppConfig? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return HelpAppConfig.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(hash)
			config?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdd18782eu.toInt()
		}
	}
	
	abstract class MessagesForumTopics: TLObject() {
		@JvmField val topics = mutableListOf<TLForumTopic>()
		@JvmField var flags = 0
		@JvmField var count = 0
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val messages = mutableListOf<Message>()
		@JvmField var orderByCreateDate = false
		@JvmField var pts = 0
		@JvmField val users = mutableListOf<User>()
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesForumTopics? {
				val result = when (constructor) {
					TLMessagesForumTopics.CONSTRUCTOR -> TLMessagesForumTopics()
					TLMessagesForumTopicsLayer3.CONSTRUCTOR -> TLMessagesForumTopicsLayer3()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesForumTopics")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesForumTopics: MessagesForumTopics() {
									
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			orderByCreateDate = (flags and 1) != 0
			count = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLForumTopic.deserialize(stream, stream.readInt32(exception), exception) ?: return
				topics.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Message.deserialize(stream, stream.readInt32(exception), exception) ?: return
				messages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
			pts = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (orderByCreateDate) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(count)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(topics.size)
			topics.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
			stream.writeInt32(pts)
		}
	
		companion object {
			val CONSTRUCTOR = 0x367617d3u.toInt()
		}
	}
	
	open class TLMessagesForumTopicsLayer3: MessagesForumTopics() {
									
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			orderByCreateDate = (flags and 1) != 0
			count = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLForumTopic.deserialize(stream, stream.readInt32(exception), exception) ?: return
				topics.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Message.deserialize(stream, stream.readInt32(exception), exception) ?: return
				messages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
			pts = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (orderByCreateDate) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(count)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(topics.size)
			topics.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
			stream.writeInt32(pts)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcc8bdcb7u.toInt()
		}
	}
	
	open class TLChannelsGetForumTopics: TLObject() {
		@JvmField var flags = 0
		@JvmField var channel: InputChannel? = null
		@JvmField var q: String? = null
		@JvmField var offsetDate = 0
		@JvmField var offsetId = 0
		@JvmField var offsetTopic = 0
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesForumTopics? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesForumTopics.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (q != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			channel?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeString(q)
			}
	
			stream.writeInt32(offsetDate)
			stream.writeInt32(offsetId)
			stream.writeInt32(offsetTopic)
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0xde560d1u.toInt()
		}
	}
	
	open class TLChannelsGetForumTopicsByID: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField val topics = mutableListOf<Int>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesForumTopics? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesForumTopics.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(topics.size)
			topics.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xb0831eb9u.toInt()
		}
	}
	
	abstract class Peer: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Peer? {
				val result = when (constructor) {
					TLPeerUser.CONSTRUCTOR -> TLPeerUser()
					TLPeerChat.CONSTRUCTOR -> TLPeerChat()
					TLPeerChannel.CONSTRUCTOR -> TLPeerChannel()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in Peer")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPeerUser: Peer() {
		@JvmField var userId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x59511722u.toInt()
		}
	}
	
	open class TLPeerChat: Peer() {
		@JvmField var chatId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			chatId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(chatId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x36c6019au.toInt()
		}
	}
	
	open class TLPeerChannel: Peer() {
		@JvmField var channelId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			channelId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(channelId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa2a5371eu.toInt()
		}
	}
	
	abstract class StorageFileType: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): StorageFileType? {
				val result = when (constructor) {
					TLStorageFileUnknown.CONSTRUCTOR -> TLStorageFileUnknown()
					TLStorageFilePartial.CONSTRUCTOR -> TLStorageFilePartial()
					TLStorageFileJpeg.CONSTRUCTOR -> TLStorageFileJpeg()
					TLStorageFileGif.CONSTRUCTOR -> TLStorageFileGif()
					TLStorageFilePng.CONSTRUCTOR -> TLStorageFilePng()
					TLStorageFilePdf.CONSTRUCTOR -> TLStorageFilePdf()
					TLStorageFileMp3.CONSTRUCTOR -> TLStorageFileMp3()
					TLStorageFileMov.CONSTRUCTOR -> TLStorageFileMov()
					TLStorageFileMp4.CONSTRUCTOR -> TLStorageFileMp4()
					TLStorageFileWebp.CONSTRUCTOR -> TLStorageFileWebp()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in StorageFileType")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLStorageFileUnknown: StorageFileType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xaa963b05u.toInt()
		}
	}
	
	open class TLStorageFilePartial: StorageFileType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x40bc6f52u.toInt()
		}
	}
	
	open class TLStorageFileJpeg: StorageFileType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x7efe0eu.toInt()
		}
	}
	
	open class TLStorageFileGif: StorageFileType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xcae1aadfu.toInt()
		}
	}
	
	open class TLStorageFilePng: StorageFileType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa4f63c0u.toInt()
		}
	}
	
	open class TLStorageFilePdf: StorageFileType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xae1e508du.toInt()
		}
	}
	
	open class TLStorageFileMp3: StorageFileType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x528a0677u.toInt()
		}
	}
	
	open class TLStorageFileMov: StorageFileType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x4b09ebbcu.toInt()
		}
	}
	
	open class TLStorageFileMp4: StorageFileType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb3cea0e4u.toInt()
		}
	}
	
	open class TLStorageFileWebp: StorageFileType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1081464cu.toInt()
		}
	}
	
	abstract class User: TLObject() {
		@JvmField var lastName: String? = null
		@JvmField var verified = false
		@JvmField var flags = 0
		@JvmField var id = 0L
		@JvmField var firstName: String? = null
		@JvmField var username: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): User? {
				val result = when (constructor) {
					TLUserEmpty.CONSTRUCTOR -> TLUserEmpty()
					TLUser.CONSTRUCTOR -> TLUser()
					TLAccountUpdateVerified.CONSTRUCTOR -> TLAccountUpdateVerified()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in User")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLUserEmpty: User() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd3bc4b7au.toInt()
		}
	}
	
	open class TLUser: User() {
			@JvmField var business = false
		@JvmField var isPublic = false
		@JvmField var isSelf = false
		@JvmField var contact = false
		@JvmField var mutualContact = false
		@JvmField var deleted = false
		@JvmField var bot = false
		@JvmField var botChatHistory = false
		@JvmField var botNochats = false
			@JvmField var restricted = false
		@JvmField var min = false
		@JvmField var botInlineGeo = false
		@JvmField var support = false
		@JvmField var scam = false
		@JvmField var applyMinPhoto = false
		@JvmField var fake = false
		@JvmField var botAttachMenu = false
		@JvmField var premium = false
		@JvmField var attachMenuEnabled = false
			@JvmField var accessHash = 0L
					@JvmField var phone: String? = null
		@JvmField var photo: UserProfilePhoto? = null
		@JvmField var status: UserStatus? = null
		@JvmField var botInfoVersion = 0
		@JvmField val restrictionReason = mutableListOf<TLRestrictionReason>()
		@JvmField var botInlinePlaceholder: String? = null
		@JvmField var langCode: String? = null
		@JvmField var emojiStatus: EmojiStatus? = null
		@JvmField var botDescription: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			business = (flags and 128) != 0
			isPublic = (flags and 256) != 0
			isSelf = (flags and 1024) != 0
			contact = (flags and 2048) != 0
			mutualContact = (flags and 4096) != 0
			deleted = (flags and 8192) != 0
			bot = (flags and 16384) != 0
			botChatHistory = (flags and 32768) != 0
			botNochats = (flags and 65536) != 0
			verified = (flags and 131072) != 0
			restricted = (flags and 262144) != 0
			min = (flags and 1048576) != 0
			botInlineGeo = (flags and 2097152) != 0
			support = (flags and 8388608) != 0
			scam = (flags and 16777216) != 0
			applyMinPhoto = (flags and 33554432) != 0
			fake = (flags and 67108864) != 0
			botAttachMenu = (flags and 134217728) != 0
			premium = (flags and 268435456) != 0
			attachMenuEnabled = (flags and 536870912) != 0
			id = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {
				accessHash = stream.readInt64(exception)
			}
		
			if ((flags and 2) != 0) {
				firstName = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				lastName = stream.readString(exception) ?: return
			}
		
			if ((flags and 8) != 0) {
				username = stream.readString(exception) ?: return
			}
		
			if ((flags and 16) != 0) {
				phone = stream.readString(exception) ?: return
			}
		
			if ((flags and 32) != 0) {
				photo = UserProfilePhoto.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 64) != 0) {
				status = UserStatus.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 16384) != 0) {
				botInfoVersion = stream.readInt32(exception)
			}
		
			if ((flags and 262144) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLRestrictionReason.deserialize(stream, stream.readInt32(exception), exception) ?: return
					restrictionReason.add(obj)
				}
			}
		
			if ((flags and 524288) != 0) {
				botInlinePlaceholder = stream.readString(exception) ?: return
			}
		
			if ((flags and 4194304) != 0) {
				langCode = stream.readString(exception) ?: return
			}
		
			if ((flags and 1073741824) != 0) {
				emojiStatus = EmojiStatus.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 512) != 0) {
				botDescription = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (business) flags or 128 else flags and 128.inv()
			flags = if (isPublic) flags or 256 else flags and 256.inv()
			flags = if (isSelf) flags or 1024 else flags and 1024.inv()
			flags = if (contact) flags or 2048 else flags and 2048.inv()
			flags = if (mutualContact) flags or 4096 else flags and 4096.inv()
			flags = if (deleted) flags or 8192 else flags and 8192.inv()
			flags = if (bot) flags or 16384 else flags and 16384.inv()
			flags = if (botChatHistory) flags or 32768 else flags and 32768.inv()
			flags = if (botNochats) flags or 65536 else flags and 65536.inv()
			flags = if (verified) flags or 131072 else flags and 131072.inv()
			flags = if (restricted) flags or 262144 else flags and 262144.inv()
			flags = if (min) flags or 1048576 else flags and 1048576.inv()
			flags = if (botInlineGeo) flags or 2097152 else flags and 2097152.inv()
			flags = if (support) flags or 8388608 else flags and 8388608.inv()
			flags = if (scam) flags or 16777216 else flags and 16777216.inv()
			flags = if (applyMinPhoto) flags or 33554432 else flags and 33554432.inv()
			flags = if (fake) flags or 67108864 else flags and 67108864.inv()
			flags = if (botAttachMenu) flags or 134217728 else flags and 134217728.inv()
			flags = if (premium) flags or 268435456 else flags and 268435456.inv()
			flags = if (attachMenuEnabled) flags or 536870912 else flags and 536870912.inv()
			flags = if (accessHash != 0L) flags or 1 else flags and 1.inv()
			flags = if (firstName != null) flags or 2 else flags and 2.inv()
			flags = if (lastName != null) flags or 4 else flags and 4.inv()
			flags = if (username != null) flags or 8 else flags and 8.inv()
			flags = if (phone != null) flags or 16 else flags and 16.inv()
			flags = if (photo != null) flags or 32 else flags and 32.inv()
			flags = if (status != null) flags or 64 else flags and 64.inv()
			flags = if (botInfoVersion != 0) flags or 16384 else flags and 16384.inv()
			flags = if (botInlinePlaceholder != null) flags or 524288 else flags and 524288.inv()
			flags = if (langCode != null) flags or 4194304 else flags and 4194304.inv()
			flags = if (emojiStatus != null) flags or 1073741824 else flags and 1073741824.inv()
			flags = if (botDescription != null) flags or 512 else flags and 512.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			if ((flags and 1) != 0) {
				stream.writeInt64(accessHash)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(firstName)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(lastName)
			}
	
			if ((flags and 8) != 0) {
				stream.writeString(username)
			}
	
			if ((flags and 16) != 0) {
				stream.writeString(phone)
			}
	
			if ((flags and 32) != 0) {
				photo?.serializeToStream(stream)
			}
	
			if ((flags and 64) != 0) {
				status?.serializeToStream(stream)
			}
	
			if ((flags and 16384) != 0) {
				stream.writeInt32(botInfoVersion)
			}
	
			if ((flags and 262144) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(restrictionReason.size)
			restrictionReason.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 524288) != 0) {
				stream.writeString(botInlinePlaceholder)
			}
	
			if ((flags and 4194304) != 0) {
				stream.writeString(langCode)
			}
	
			if ((flags and 1073741824) != 0) {
				emojiStatus?.serializeToStream(stream)
			}
	
			if ((flags and 512) != 0) {
				stream.writeString(botDescription)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x5d99adeeu.toInt()
		}
	}
	
	open class TLAccountUpdateVerified: User() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			id = stream.readInt64(exception)
			verified = (flags and 1) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (verified) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9aafe50eu.toInt()
		}
	}
	
	open class TLAccountUpdateProfile: TLObject() {
		@JvmField var flags = 0
		@JvmField var firstName: String? = null
		@JvmField var lastName: String? = null
		@JvmField var about: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): User? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return User.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (firstName != null) flags or 1 else flags and 1.inv()
			flags = if (lastName != null) flags or 2 else flags and 2.inv()
			flags = if (about != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeString(firstName)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(lastName)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(about)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x78515775u.toInt()
		}
	}
	
	open class TLAccountUpdateUsername: TLObject() {
		@JvmField var username: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): User? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return User.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(username)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3e0bdd7cu.toInt()
		}
	}
	
	open class TLAccountChangePhone: TLObject() {
		@JvmField var phoneNumber: String? = null
		@JvmField var phoneCodeHash: String? = null
		@JvmField var phoneCode: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): User? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return User.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phoneNumber)
			stream.writeString(phoneCodeHash)
			stream.writeString(phoneCode)
		}
	
		companion object {
			val CONSTRUCTOR = 0x70c32edbu.toInt()
		}
	}
	
	open class TLUsersGetMe: TLObject() {
		@JvmField var id = 0L
		@JvmField var token: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): User? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return User.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeString(token)
		}
	
		companion object {
			val CONSTRUCTOR = 0x908143b6u.toInt()
		}
	}
	
	abstract class UserProfilePhoto: TLObject() {
		@JvmField var dcId = 0
		@JvmField var flags = 0
		@JvmField var photoId = 0L
		@JvmField var strippedThumb: ByteArray? = null
		@JvmField var hasVideo = false
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): UserProfilePhoto? {
				val result = when (constructor) {
					TLUserProfilePhotoEmpty.CONSTRUCTOR -> TLUserProfilePhotoEmpty()
					TLUserProfilePhoto.CONSTRUCTOR -> TLUserProfilePhoto()
					TLUserProfilePhotoLayer127.CONSTRUCTOR -> TLUserProfilePhotoLayer127()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in UserProfilePhoto")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLUserProfilePhotoEmpty: UserProfilePhoto() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x4f11bae1u.toInt()
		}
	}
	
	open class TLUserProfilePhoto: UserProfilePhoto() {
						
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			hasVideo = (flags and 1) != 0
			photoId = stream.readInt64(exception)
		
			if ((flags and 2) != 0) {
				strippedThumb = stream.readByteArray(exception) ?: return
			}
			dcId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (hasVideo) flags or 1 else flags and 1.inv()
			flags = if (strippedThumb != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(photoId)
			if ((flags and 2) != 0) {
				stream.writeByteArray(strippedThumb)
			}
	
			stream.writeInt32(dcId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x82d1f706u.toInt()
		}
	}
	
	open class TLUserProfilePhotoLayer127: TLUserProfilePhoto() {
					@JvmField var photoSmall: FileLocation? = null
		@JvmField var photoBig: FileLocation? = null
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			hasVideo = (flags and 1) != 0
			photoId = stream.readInt64(exception)
			photoSmall = FileLocation.deserialize(stream, stream.readInt32(exception), exception)
			photoBig = FileLocation.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 2) != 0) {
				strippedThumb = stream.readByteArray(exception) ?: return
			}
			dcId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (hasVideo) flags or 1 else flags and 1.inv()
			flags = if (strippedThumb != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(photoId)
			photoSmall?.serializeToStream(stream)
			photoBig?.serializeToStream(stream)
			if ((flags and 2) != 0) {
				stream.writeByteArray(strippedThumb)
			}
	
			stream.writeInt32(dcId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcc656077u.toInt()
		}
	}
	
	abstract class UserStatus: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): UserStatus? {
				val result = when (constructor) {
					TLUserStatusEmpty.CONSTRUCTOR -> TLUserStatusEmpty()
					TLUserStatusOnline.CONSTRUCTOR -> TLUserStatusOnline()
					TLUserStatusOffline.CONSTRUCTOR -> TLUserStatusOffline()
					TLUserStatusRecently.CONSTRUCTOR -> TLUserStatusRecently()
					TLUserStatusLastWeek.CONSTRUCTOR -> TLUserStatusLastWeek()
					TLUserStatusLastMonth.CONSTRUCTOR -> TLUserStatusLastMonth()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in UserStatus")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLUserStatusEmpty: UserStatus() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9d05049u.toInt()
		}
	}
	
	open class TLUserStatusOnline: UserStatus() {
		@JvmField var expires = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			expires = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(expires)
		}
	
		companion object {
			val CONSTRUCTOR = 0xedb93949u.toInt()
		}
	}
	
	open class TLUserStatusOffline: UserStatus() {
		@JvmField var wasOnline = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			wasOnline = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(wasOnline)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8c703fu.toInt()
		}
	}
	
	open class TLUserStatusRecently: UserStatus() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe26f42f1u.toInt()
		}
	}
	
	open class TLUserStatusLastWeek: UserStatus() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x7bf09fcu.toInt()
		}
	}
	
	open class TLUserStatusLastMonth: UserStatus() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x77ebc742u.toInt()
		}
	}
	
	abstract class Chat: TLObject() {
		@JvmField var flags2 = 0
		@JvmField var signatures = false
		@JvmField var hasGeo = false
		@JvmField var adult = false
		@JvmField var endDate = 0L
		@JvmField var username: String? = null
		@JvmField var genre: String? = null
		@JvmField var hasLink = false
		@JvmField var recommended = false
		@JvmField var creator = false
		@JvmField var slowmodeEnabled = false
		@JvmField var broadcast = false
		@JvmField var megagroup = false
		@JvmField var joinRequest = false
		@JvmField var subGenre: String? = null
		@JvmField var restricted = false
		@JvmField var startDate = 0L
		@JvmField var scam = false
		@JvmField var left = false
		@JvmField var photo: ChatPhoto? = null
		@JvmField var verified = false
		@JvmField var title: String? = null
		@JvmField var hideFromChatList = false
		@JvmField var min = false
		@JvmField var cost = 0.0
		@JvmField var id = 0L
		@JvmField var joinToSend = false
		@JvmField var bannedRights: TLChatBannedRights? = null
		@JvmField var defaultBannedRights: TLChatBannedRights? = null
		@JvmField var participantsCount = 0
		@JvmField var adminRights: TLChatAdminRights? = null
		@JvmField var callActive = false
		@JvmField var showHistory = false
		@JvmField val restrictionReason = mutableListOf<TLRestrictionReason>()
		@JvmField var flags = 0
		@JvmField var date = 0
		@JvmField var payType = 0
		@JvmField var fake = false
		@JvmField var category: String? = null
		@JvmField var country: String? = null
		@JvmField var accessHash = 0L
		@JvmField var gigagroup = false
		@JvmField var noforwards = false
		@JvmField var callNotEmpty = false
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Chat? {
				val result = when (constructor) {
					TLChatEmpty.CONSTRUCTOR -> TLChatEmpty()
					TLChat.CONSTRUCTOR -> TLChat()
					TLChatForbidden.CONSTRUCTOR -> TLChatForbidden()
					TLChannel.CONSTRUCTOR -> TLChannel()
					TLChannelForbidden.CONSTRUCTOR -> TLChannelForbidden()
					TLChannelLayer3.CONSTRUCTOR -> TLChannelLayer3()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in Chat")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChatEmpty: Chat() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0x29562865u.toInt()
		}
	}
	
	open class TLChat: Chat() {
					@JvmField var deactivated = false
										@JvmField var version = 0
			@JvmField var migratedTo: InputChannel? = null
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			creator = (flags and 1) != 0
			left = (flags and 4) != 0
			deactivated = (flags and 32) != 0
			callActive = (flags and 8388608) != 0
			callNotEmpty = (flags and 16777216) != 0
			noforwards = (flags and 33554432) != 0
			id = stream.readInt64(exception)
			title = stream.readString(exception) ?: return
			photo = ChatPhoto.deserialize(stream, stream.readInt32(exception), exception)
			participantsCount = stream.readInt32(exception)
			date = stream.readInt32(exception)
			version = stream.readInt32(exception)
		
			if ((flags and 67108864) != 0) {
				username = stream.readString(exception) ?: return
			}
		
			if ((flags and 64) != 0) {
				migratedTo = InputChannel.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 16384) != 0) {
				adminRights = TLChatAdminRights.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 262144) != 0) {
				defaultBannedRights = TLChatBannedRights.deserialize(stream, stream.readInt32(exception), exception)
			}
			showHistory = (flags and 16) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (creator) flags or 1 else flags and 1.inv()
			flags = if (left) flags or 4 else flags and 4.inv()
			flags = if (deactivated) flags or 32 else flags and 32.inv()
			flags = if (callActive) flags or 8388608 else flags and 8388608.inv()
			flags = if (callNotEmpty) flags or 16777216 else flags and 16777216.inv()
			flags = if (noforwards) flags or 33554432 else flags and 33554432.inv()
			flags = if (username != null) flags or 67108864 else flags and 67108864.inv()
			flags = if (migratedTo != null) flags or 64 else flags and 64.inv()
			flags = if (adminRights != null) flags or 16384 else flags and 16384.inv()
			flags = if (defaultBannedRights != null) flags or 262144 else flags and 262144.inv()
			flags = if (showHistory) flags or 16 else flags and 16.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeString(title)
			photo?.serializeToStream(stream)
			stream.writeInt32(participantsCount)
			stream.writeInt32(date)
			stream.writeInt32(version)
			if ((flags and 67108864) != 0) {
				stream.writeString(username)
			}
	
			if ((flags and 64) != 0) {
				migratedTo?.serializeToStream(stream)
			}
	
			if ((flags and 16384) != 0) {
				adminRights?.serializeToStream(stream)
			}
	
			if ((flags and 262144) != 0) {
				defaultBannedRights?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x41cbf256u.toInt()
		}
	}
	
	open class TLChatForbidden: Chat() {
						
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			title = stream.readString(exception) ?: return
			hideFromChatList = (flags2 and 4) != 0
		
			if ((flags2 and 2048) != 0) {
				genre = stream.readString(exception) ?: return
			}
		
			if ((flags2 and 4096) != 0) {
				subGenre = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags2 = if (hideFromChatList) flags2 or 4 else flags2 and 4.inv()
			flags2 = if (genre != null) flags2 or 2048 else flags2 and 2048.inv()
			flags2 = if (subGenre != null) flags2 or 4096 else flags2 and 4096.inv()
	
			stream.writeInt64(id)
			stream.writeString(title)
			if ((flags2 and 2048) != 0) {
				stream.writeString(genre)
			}
	
			if ((flags2 and 4096) != 0) {
				stream.writeString(subGenre)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x6592a1a7u.toInt()
		}
	}
	
	open class TLChannel: Chat() {
																																													
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			flags2 = stream.readInt32(exception)
			hideFromChatList = (flags2 and 4) != 0
			creator = (flags and 1) != 0
			left = (flags and 4) != 0
			broadcast = (flags and 32) != 0
			verified = (flags and 128) != 0
			megagroup = (flags and 256) != 0
			restricted = (flags and 512) != 0
			signatures = (flags and 2048) != 0
			min = (flags and 4096) != 0
			scam = (flags and 524288) != 0
			hasLink = (flags and 1048576) != 0
			hasGeo = (flags and 2097152) != 0
			slowmodeEnabled = (flags and 4194304) != 0
			callActive = (flags and 8388608) != 0
			callNotEmpty = (flags and 16777216) != 0
			fake = (flags and 33554432) != 0
			gigagroup = (flags and 67108864) != 0
			noforwards = (flags and 134217728) != 0
			joinToSend = (flags and 268435456) != 0
			joinRequest = (flags and 536870912) != 0
			adult = (flags and 65536) != 0
			showHistory = (flags and 16) != 0
			id = stream.readInt64(exception)
		
			if ((flags and 8192) != 0) {
				accessHash = stream.readInt64(exception)
			}
			title = stream.readString(exception) ?: return
		
			if ((flags and 64) != 0) {
				username = stream.readString(exception) ?: return
			}
			photo = ChatPhoto.deserialize(stream, stream.readInt32(exception), exception)
			date = stream.readInt32(exception)
		
			if ((flags and 512) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLRestrictionReason.deserialize(stream, stream.readInt32(exception), exception) ?: return
					restrictionReason.add(obj)
				}
			}
		
			if ((flags and 16384) != 0) {
				adminRights = TLChatAdminRights.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 32768) != 0) {
				bannedRights = TLChatBannedRights.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 262144) != 0) {
				defaultBannedRights = TLChatBannedRights.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 131072) != 0) {
				participantsCount = stream.readInt32(exception)
			}
		
			if ((flags and 1073741824) != 0) {
				payType = stream.readInt32(exception)
			}
		
			if ((flags and 1073741824) != 0) {
				cost = stream.readDouble(exception)
			}
		
			if ((flags and 1024) != 0) {
				category = stream.readString(exception) ?: return
			}
		
			if ((flags and 1024) != 0) {
				country = stream.readString(exception) ?: return
			}
		
			if ((flags and 8) != 0) {
				startDate = stream.readInt64(exception)
			}
		
			if ((flags and 8) != 0) {
				endDate = stream.readInt64(exception)
			}
		
			if ((flags2 and 2048) != 0) {
				genre = stream.readString(exception) ?: return
			}
		
			if ((flags2 and 4096) != 0) {
				subGenre = stream.readString(exception) ?: return
			}
			recommended = (flags2 and 16384) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags2 = if (hideFromChatList) flags2 or 4 else flags2 and 4.inv()
			flags = if (creator) flags or 1 else flags and 1.inv()
			flags = if (left) flags or 4 else flags and 4.inv()
			flags = if (broadcast) flags or 32 else flags and 32.inv()
			flags = if (verified) flags or 128 else flags and 128.inv()
			flags = if (megagroup) flags or 256 else flags and 256.inv()
			flags = if (restricted) flags or 512 else flags and 512.inv()
			flags = if (signatures) flags or 2048 else flags and 2048.inv()
			flags = if (min) flags or 4096 else flags and 4096.inv()
			flags = if (scam) flags or 524288 else flags and 524288.inv()
			flags = if (hasLink) flags or 1048576 else flags and 1048576.inv()
			flags = if (hasGeo) flags or 2097152 else flags and 2097152.inv()
			flags = if (slowmodeEnabled) flags or 4194304 else flags and 4194304.inv()
			flags = if (callActive) flags or 8388608 else flags and 8388608.inv()
			flags = if (callNotEmpty) flags or 16777216 else flags and 16777216.inv()
			flags = if (fake) flags or 33554432 else flags and 33554432.inv()
			flags = if (gigagroup) flags or 67108864 else flags and 67108864.inv()
			flags = if (noforwards) flags or 134217728 else flags and 134217728.inv()
			flags = if (joinToSend) flags or 268435456 else flags and 268435456.inv()
			flags = if (joinRequest) flags or 536870912 else flags and 536870912.inv()
			flags = if (adult) flags or 65536 else flags and 65536.inv()
			flags = if (showHistory) flags or 16 else flags and 16.inv()
			flags = if (accessHash != 0L) flags or 8192 else flags and 8192.inv()
			flags = if (username != null) flags or 64 else flags and 64.inv()
			flags = if (adminRights != null) flags or 16384 else flags and 16384.inv()
			flags = if (bannedRights != null) flags or 32768 else flags and 32768.inv()
			flags = if (defaultBannedRights != null) flags or 262144 else flags and 262144.inv()
			flags = if (participantsCount != 0) flags or 131072 else flags and 131072.inv()
			flags = if (payType != 0) flags or 1073741824 else flags and 1073741824.inv()
			flags = if (cost != 0.0) flags or 1073741824 else flags and 1073741824.inv()
			flags = if (category != null) flags or 1024 else flags and 1024.inv()
			flags = if (country != null) flags or 1024 else flags and 1024.inv()
			flags = if (startDate != 0L) flags or 8 else flags and 8.inv()
			flags = if (endDate != 0L) flags or 8 else flags and 8.inv()
			flags2 = if (genre != null) flags2 or 2048 else flags2 and 2048.inv()
			flags2 = if (subGenre != null) flags2 or 4096 else flags2 and 4096.inv()
			flags2 = if (recommended) flags2 or 16384 else flags2 and 16384.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(flags2)
			stream.writeInt64(id)
			if ((flags and 8192) != 0) {
				stream.writeInt64(accessHash)
			}
	
			stream.writeString(title)
			if ((flags and 64) != 0) {
				stream.writeString(username)
			}
	
			photo?.serializeToStream(stream)
			stream.writeInt32(date)
			if ((flags and 512) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(restrictionReason.size)
			restrictionReason.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 16384) != 0) {
				adminRights?.serializeToStream(stream)
			}
	
			if ((flags and 32768) != 0) {
				bannedRights?.serializeToStream(stream)
			}
	
			if ((flags and 262144) != 0) {
				defaultBannedRights?.serializeToStream(stream)
			}
	
			if ((flags and 131072) != 0) {
				stream.writeInt32(participantsCount)
			}
	
			if ((flags and 1073741824) != 0) {
				stream.writeInt32(payType)
			}
	
			if ((flags and 1073741824) != 0) {
				stream.writeDouble(cost)
			}
	
			if ((flags and 1024) != 0) {
				stream.writeString(category)
			}
	
			if ((flags and 1024) != 0) {
				stream.writeString(country)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt64(startDate)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt64(endDate)
			}
	
			if ((flags2 and 2048) != 0) {
				stream.writeString(genre)
			}
	
			if ((flags2 and 4096) != 0) {
				stream.writeString(subGenre)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8261ac61u.toInt()
		}
	}
	
	open class TLChannelForbidden: Chat() {
								@JvmField var untilDate = 0
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			broadcast = (flags and 32) != 0
			megagroup = (flags and 256) != 0
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			title = stream.readString(exception) ?: return
		
			if ((flags and 65536) != 0) {
				untilDate = stream.readInt32(exception)
			}
		
			if ((flags and 1073741824) != 0) {
				payType = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (broadcast) flags or 32 else flags and 32.inv()
			flags = if (megagroup) flags or 256 else flags and 256.inv()
			flags = if (untilDate != 0) flags or 65536 else flags and 65536.inv()
			flags = if (payType != 0) flags or 1073741824 else flags and 1073741824.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeString(title)
			if ((flags and 65536) != 0) {
				stream.writeInt32(untilDate)
			}
	
			if ((flags and 1073741824) != 0) {
				stream.writeInt32(payType)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x17d493d5u.toInt()
		}
	}
	
	open class TLChannelLayer3: Chat() {
																																													
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			flags2 = stream.readInt32(exception)
			hideFromChatList = (flags2 and 4) != 0
			creator = (flags and 1) != 0
			left = (flags and 4) != 0
			broadcast = (flags and 32) != 0
			verified = (flags and 128) != 0
			megagroup = (flags and 256) != 0
			restricted = (flags and 512) != 0
			signatures = (flags and 2048) != 0
			min = (flags and 4096) != 0
			scam = (flags and 524288) != 0
			hasLink = (flags and 1048576) != 0
			hasGeo = (flags and 2097152) != 0
			slowmodeEnabled = (flags and 4194304) != 0
			callActive = (flags and 8388608) != 0
			callNotEmpty = (flags and 16777216) != 0
			fake = (flags and 33554432) != 0
			gigagroup = (flags and 67108864) != 0
			noforwards = (flags and 134217728) != 0
			joinToSend = (flags and 268435456) != 0
			joinRequest = (flags and 536870912) != 0
			adult = (flags and 65536) != 0
			showHistory = (flags and 16) != 0
			id = stream.readInt64(exception)
		
			if ((flags and 8192) != 0) {
				accessHash = stream.readInt64(exception)
			}
			title = stream.readString(exception) ?: return
		
			if ((flags and 64) != 0) {
				username = stream.readString(exception) ?: return
			}
			photo = ChatPhoto.deserialize(stream, stream.readInt32(exception), exception)
			date = stream.readInt32(exception)
		
			if ((flags and 512) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLRestrictionReason.deserialize(stream, stream.readInt32(exception), exception) ?: return
					restrictionReason.add(obj)
				}
			}
		
			if ((flags and 16384) != 0) {
				adminRights = TLChatAdminRights.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 32768) != 0) {
				bannedRights = TLChatBannedRights.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 262144) != 0) {
				defaultBannedRights = TLChatBannedRights.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 131072) != 0) {
				participantsCount = stream.readInt32(exception)
			}
		
			if ((flags and 1073741824) != 0) {
				payType = stream.readInt32(exception)
			}
		
			if ((flags and 1073741824) != 0) {
				cost = stream.readDouble(exception)
			}
		
			if ((flags and 1024) != 0) {
				category = stream.readString(exception) ?: return
			}
		
			if ((flags and 1024) != 0) {
				country = stream.readString(exception) ?: return
			}
		
			if ((flags and 8) != 0) {
				startDate = stream.readInt64(exception)
			}
		
			if ((flags and 8) != 0) {
				endDate = stream.readInt64(exception)
			}
		
			if ((flags2 and 2048) != 0) {
				genre = stream.readString(exception) ?: return
			}
		
			if ((flags2 and 4096) != 0) {
				subGenre = stream.readString(exception) ?: return
			}
			recommended = (flags2 and 16384) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags2 = if (hideFromChatList) flags2 or 4 else flags2 and 4.inv()
			flags = if (creator) flags or 1 else flags and 1.inv()
			flags = if (left) flags or 4 else flags and 4.inv()
			flags = if (broadcast) flags or 32 else flags and 32.inv()
			flags = if (verified) flags or 128 else flags and 128.inv()
			flags = if (megagroup) flags or 256 else flags and 256.inv()
			flags = if (restricted) flags or 512 else flags and 512.inv()
			flags = if (signatures) flags or 2048 else flags and 2048.inv()
			flags = if (min) flags or 4096 else flags and 4096.inv()
			flags = if (scam) flags or 524288 else flags and 524288.inv()
			flags = if (hasLink) flags or 1048576 else flags and 1048576.inv()
			flags = if (hasGeo) flags or 2097152 else flags and 2097152.inv()
			flags = if (slowmodeEnabled) flags or 4194304 else flags and 4194304.inv()
			flags = if (callActive) flags or 8388608 else flags and 8388608.inv()
			flags = if (callNotEmpty) flags or 16777216 else flags and 16777216.inv()
			flags = if (fake) flags or 33554432 else flags and 33554432.inv()
			flags = if (gigagroup) flags or 67108864 else flags and 67108864.inv()
			flags = if (noforwards) flags or 134217728 else flags and 134217728.inv()
			flags = if (joinToSend) flags or 268435456 else flags and 268435456.inv()
			flags = if (joinRequest) flags or 536870912 else flags and 536870912.inv()
			flags = if (adult) flags or 65536 else flags and 65536.inv()
			flags = if (showHistory) flags or 16 else flags and 16.inv()
			flags = if (accessHash != 0L) flags or 8192 else flags and 8192.inv()
			flags = if (username != null) flags or 64 else flags and 64.inv()
			flags = if (adminRights != null) flags or 16384 else flags and 16384.inv()
			flags = if (bannedRights != null) flags or 32768 else flags and 32768.inv()
			flags = if (defaultBannedRights != null) flags or 262144 else flags and 262144.inv()
			flags = if (participantsCount != 0) flags or 131072 else flags and 131072.inv()
			flags = if (payType != 0) flags or 1073741824 else flags and 1073741824.inv()
			flags = if (cost != 0.0) flags or 1073741824 else flags and 1073741824.inv()
			flags = if (category != null) flags or 1024 else flags and 1024.inv()
			flags = if (country != null) flags or 1024 else flags and 1024.inv()
			flags = if (startDate != 0L) flags or 8 else flags and 8.inv()
			flags = if (endDate != 0L) flags or 8 else flags and 8.inv()
			flags2 = if (genre != null) flags2 or 2048 else flags2 and 2048.inv()
			flags2 = if (subGenre != null) flags2 or 4096 else flags2 and 4096.inv()
			flags2 = if (recommended) flags2 or 16384 else flags2 and 16384.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(flags2)
			stream.writeInt64(id)
			if ((flags and 8192) != 0) {
				stream.writeInt64(accessHash)
			}
	
			stream.writeString(title)
			if ((flags and 64) != 0) {
				stream.writeString(username)
			}
	
			photo?.serializeToStream(stream)
			stream.writeInt32(date)
			if ((flags and 512) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(restrictionReason.size)
			restrictionReason.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 16384) != 0) {
				adminRights?.serializeToStream(stream)
			}
	
			if ((flags and 32768) != 0) {
				bannedRights?.serializeToStream(stream)
			}
	
			if ((flags and 262144) != 0) {
				defaultBannedRights?.serializeToStream(stream)
			}
	
			if ((flags and 131072) != 0) {
				stream.writeInt32(participantsCount)
			}
	
			if ((flags and 1073741824) != 0) {
				stream.writeInt32(payType)
			}
	
			if ((flags and 1073741824) != 0) {
				stream.writeDouble(cost)
			}
	
			if ((flags and 1024) != 0) {
				stream.writeString(category)
			}
	
			if ((flags and 1024) != 0) {
				stream.writeString(country)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt64(startDate)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt64(endDate)
			}
	
			if ((flags2 and 2048) != 0) {
				stream.writeString(genre)
			}
	
			if ((flags2 and 4096) != 0) {
				stream.writeString(subGenre)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc939c9d0u.toInt()
		}
	}
	
	abstract class ChatFull: TLObject() {
		@JvmField var flags2 = 0
		@JvmField var notifySettings: PeerNotifySettings? = null
		@JvmField var canSetLocation = false
		@JvmField var unreadCount = 0
		@JvmField var blocked = false
		@JvmField var call: TLInputGroupCall? = null
		@JvmField var readOutboxMaxId = 0
		@JvmField var canDeleteChannel = false
		@JvmField var chatPhoto: Photo? = null
		@JvmField var requestsPending = 0
		@JvmField var username: String? = null
		@JvmField var folderId = 0
		@JvmField var canSetStickers = false
		@JvmField val pendingSuggestions = mutableListOf<String>()
		@JvmField var readInboxMaxId = 0
		@JvmField var location: ChannelLocation? = null
		@JvmField var slowmodeSeconds = 0
		@JvmField var ttlPeriod = 0
		@JvmField var participants: ChatParticipants? = null
		@JvmField val recentRequesters = mutableListOf<Long>()
		@JvmField var pts = 0
		@JvmField var about: String? = null
		@JvmField var availableReactions: ChatReactions? = null
		@JvmField var canSetUsername = false
		@JvmField var kickedCount = 0
		@JvmField var onlineCount = 0
		@JvmField var linkedChatId = 0L
		@JvmField var statsDc = 0
		@JvmField var stickerset: TLStickerSet? = null
		@JvmField var id = 0L
		@JvmField var canViewParticipants = false
		@JvmField var hiddenPrehistory = false
		@JvmField var adminsCount = 0
		@JvmField val botInfo = mutableListOf<TLBotInfo>()
		@JvmField var participantsCount = 0
		@JvmField var canViewStats = false
		@JvmField var flags = 0
		@JvmField var hasScheduled = false
		@JvmField var defaultSendAs: Peer? = null
		@JvmField var groupcallDefaultJoinAs: Peer? = null
		@JvmField var pinnedMsgId = 0
		@JvmField var availableMinId = 0
		@JvmField var category: String? = null
		@JvmField var country: String? = null
		@JvmField var slowmodeNextSendDate = 0
		@JvmField var themeEmoticon: String? = null
		@JvmField var exportedInvite: ExportedChatInvite? = null
		@JvmField var inviterId: Long = 0L
		@JvmField var invitesCount: Int = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChatFull? {
				val result = when (constructor) {
					TLChatFull.CONSTRUCTOR -> TLChatFull()
					TLChannelFull.CONSTRUCTOR -> TLChannelFull()
					TLChatFullLayer3.CONSTRUCTOR -> TLChatFullLayer3()
					TLChannelFullLayer3.CONSTRUCTOR -> TLChannelFullLayer3()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ChatFull")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChatFull: ChatFull() {
																					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			canSetUsername = (flags and 128) != 0
			hasScheduled = (flags and 256) != 0
			id = stream.readInt64(exception)
			about = stream.readString(exception) ?: return
			participants = ChatParticipants.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 4) != 0) {
				chatPhoto = Photo.deserialize(stream, stream.readInt32(exception), exception)
			}
			notifySettings = PeerNotifySettings.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 8192) != 0) {
				exportedInvite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 8) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLBotInfo.deserialize(stream, stream.readInt32(exception), exception) ?: return
					botInfo.add(obj)
				}
			}
		
			if ((flags and 64) != 0) {
				pinnedMsgId = stream.readInt32(exception)
			}
		
			if ((flags and 2048) != 0) {
				folderId = stream.readInt32(exception)
			}
		
			if ((flags and 4096) != 0) {
				call = TLInputGroupCall.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 16384) != 0) {
				ttlPeriod = stream.readInt32(exception)
			}
		
			if ((flags and 32768) != 0) {
				groupcallDefaultJoinAs = Peer.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 65536) != 0) {
				themeEmoticon = stream.readString(exception) ?: return
			}
		
			if ((flags and 131072) != 0) {
				requestsPending = stream.readInt32(exception)
			}
		
			if ((flags and 131072) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = stream.readInt64(exception)
					recentRequesters.add(obj)
				}
			}
		
			if ((flags and 262144) != 0) {
				availableReactions = ChatReactions.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 1024) != 0) {
				username = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (canSetUsername) flags or 128 else flags and 128.inv()
			flags = if (hasScheduled) flags or 256 else flags and 256.inv()
			flags = if (chatPhoto != null) flags or 4 else flags and 4.inv()
			flags = if (exportedInvite != null) flags or 8192 else flags and 8192.inv()
			flags = if (pinnedMsgId != 0) flags or 64 else flags and 64.inv()
			flags = if (folderId != 0) flags or 2048 else flags and 2048.inv()
			flags = if (call != null) flags or 4096 else flags and 4096.inv()
			flags = if (ttlPeriod != 0) flags or 16384 else flags and 16384.inv()
			flags = if (groupcallDefaultJoinAs != null) flags or 32768 else flags and 32768.inv()
			flags = if (themeEmoticon != null) flags or 65536 else flags and 65536.inv()
			flags = if (requestsPending != 0) flags or 131072 else flags and 131072.inv()
			flags = if (availableReactions != null) flags or 262144 else flags and 262144.inv()
			flags = if (username != null) flags or 1024 else flags and 1024.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeString(about)
			participants?.serializeToStream(stream)
			if ((flags and 4) != 0) {
				chatPhoto?.serializeToStream(stream)
			}
	
			notifySettings?.serializeToStream(stream)
			if ((flags and 8192) != 0) {
				exportedInvite?.serializeToStream(stream)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(botInfo.size)
			botInfo.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 64) != 0) {
				stream.writeInt32(pinnedMsgId)
			}
	
			if ((flags and 2048) != 0) {
				stream.writeInt32(folderId)
			}
	
			if ((flags and 4096) != 0) {
				call?.serializeToStream(stream)
			}
	
			if ((flags and 16384) != 0) {
				stream.writeInt32(ttlPeriod)
			}
	
			if ((flags and 32768) != 0) {
				groupcallDefaultJoinAs?.serializeToStream(stream)
			}
	
			if ((flags and 65536) != 0) {
				stream.writeString(themeEmoticon)
			}
	
			if ((flags and 131072) != 0) {
				stream.writeInt32(requestsPending)
			}
	
			if ((flags and 131072) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(recentRequesters.size)
			recentRequesters.forEach { stream.writeInt64(it) }
			}
	
			if ((flags and 262144) != 0) {
				availableReactions?.serializeToStream(stream)
			}
	
			if ((flags and 1024) != 0) {
				stream.writeString(username)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc9d31138u.toInt()
		}
	}
	
	open class TLChannelFull: ChatFull() {
																												@JvmField var payType = 0
		@JvmField var cost = 0.0
																				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			canViewParticipants = (flags and 8) != 0
			canSetUsername = (flags and 64) != 0
			canSetStickers = (flags and 128) != 0
			hiddenPrehistory = (flags and 1024) != 0
			canSetLocation = (flags and 65536) != 0
			hasScheduled = (flags and 524288) != 0
			canViewStats = (flags and 1048576) != 0
			blocked = (flags and 4194304) != 0
			flags2 = stream.readInt32(exception)
			canDeleteChannel = (flags2 and 1) != 0
			id = stream.readInt64(exception)
			about = stream.readString(exception) ?: return
			category = stream.readString(exception) ?: return
			country = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				participantsCount = stream.readInt32(exception)
			}
		
			if ((flags and 2) != 0) {
				adminsCount = stream.readInt32(exception)
			}
		
			if ((flags and 4) != 0) {
				kickedCount = stream.readInt32(exception)
			}
		
			if ((flags and 8192) != 0) {
				onlineCount = stream.readInt32(exception)
			}
			readInboxMaxId = stream.readInt32(exception)
			readOutboxMaxId = stream.readInt32(exception)
			unreadCount = stream.readInt32(exception)
			chatPhoto = Photo.deserialize(stream, stream.readInt32(exception), exception)
			notifySettings = PeerNotifySettings.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 8388608) != 0) {
				exportedInvite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLBotInfo.deserialize(stream, stream.readInt32(exception), exception) ?: return
				botInfo.add(obj)
			}
		
			if ((flags and 16) != 0) {
				payType = stream.readInt32(exception)
			}
		
			if ((flags and 16) != 0) {
				cost = stream.readDouble(exception)
			}
		
			if ((flags and 32) != 0) {
				pinnedMsgId = stream.readInt32(exception)
			}
		
			if ((flags and 256) != 0) {
				stickerset = TLStickerSet.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 512) != 0) {
				availableMinId = stream.readInt32(exception)
			}
		
			if ((flags and 2048) != 0) {
				folderId = stream.readInt32(exception)
			}
		
			if ((flags and 16384) != 0) {
				linkedChatId = stream.readInt64(exception)
			}
		
			if ((flags and 32768) != 0) {
				location = ChannelLocation.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 131072) != 0) {
				slowmodeSeconds = stream.readInt32(exception)
			}
		
			if ((flags and 262144) != 0) {
				slowmodeNextSendDate = stream.readInt32(exception)
			}
		
			if ((flags and 4096) != 0) {
				statsDc = stream.readInt32(exception)
			}
			pts = stream.readInt32(exception)
		
			if ((flags and 2097152) != 0) {
				call = TLInputGroupCall.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 16777216) != 0) {
				ttlPeriod = stream.readInt32(exception)
			}
		
			if ((flags and 33554432) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = stream.readString(exception) ?: return
					pendingSuggestions.add(obj)
				}
			}
		
			if ((flags and 67108864) != 0) {
				groupcallDefaultJoinAs = Peer.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 134217728) != 0) {
				themeEmoticon = stream.readString(exception) ?: return
			}
		
			if ((flags and 268435456) != 0) {
				requestsPending = stream.readInt32(exception)
			}
		
			if ((flags and 268435456) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = stream.readInt64(exception)
					recentRequesters.add(obj)
				}
			}
		
			if ((flags and 536870912) != 0) {
				defaultSendAs = Peer.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 1073741824) != 0) {
				availableReactions = ChatReactions.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (canViewParticipants) flags or 8 else flags and 8.inv()
			flags = if (canSetUsername) flags or 64 else flags and 64.inv()
			flags = if (canSetStickers) flags or 128 else flags and 128.inv()
			flags = if (hiddenPrehistory) flags or 1024 else flags and 1024.inv()
			flags = if (canSetLocation) flags or 65536 else flags and 65536.inv()
			flags = if (hasScheduled) flags or 524288 else flags and 524288.inv()
			flags = if (canViewStats) flags or 1048576 else flags and 1048576.inv()
			flags = if (blocked) flags or 4194304 else flags and 4194304.inv()
			flags2 = if (canDeleteChannel) flags2 or 1 else flags2 and 1.inv()
			flags = if (participantsCount != 0) flags or 1 else flags and 1.inv()
			flags = if (adminsCount != 0) flags or 2 else flags and 2.inv()
			flags = if (kickedCount != 0) flags or 4 else flags and 4.inv()
			flags = if (onlineCount != 0) flags or 8192 else flags and 8192.inv()
			flags = if (exportedInvite != null) flags or 8388608 else flags and 8388608.inv()
			flags = if (payType != 0) flags or 16 else flags and 16.inv()
			flags = if (cost != 0.0) flags or 16 else flags and 16.inv()
			flags = if (pinnedMsgId != 0) flags or 32 else flags and 32.inv()
			flags = if (stickerset != null) flags or 256 else flags and 256.inv()
			flags = if (availableMinId != 0) flags or 512 else flags and 512.inv()
			flags = if (folderId != 0) flags or 2048 else flags and 2048.inv()
			flags = if (linkedChatId != 0L) flags or 16384 else flags and 16384.inv()
			flags = if (location != null) flags or 32768 else flags and 32768.inv()
			flags = if (slowmodeSeconds != 0) flags or 131072 else flags and 131072.inv()
			flags = if (slowmodeNextSendDate != 0) flags or 262144 else flags and 262144.inv()
			flags = if (statsDc != 0) flags or 4096 else flags and 4096.inv()
			flags = if (call != null) flags or 2097152 else flags and 2097152.inv()
			flags = if (ttlPeriod != 0) flags or 16777216 else flags and 16777216.inv()
			flags = if (groupcallDefaultJoinAs != null) flags or 67108864 else flags and 67108864.inv()
			flags = if (themeEmoticon != null) flags or 134217728 else flags and 134217728.inv()
			flags = if (requestsPending != 0) flags or 268435456 else flags and 268435456.inv()
			flags = if (defaultSendAs != null) flags or 536870912 else flags and 536870912.inv()
			flags = if (availableReactions != null) flags or 1073741824 else flags and 1073741824.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(flags2)
			stream.writeInt64(id)
			stream.writeString(about)
			stream.writeString(category)
			stream.writeString(country)
			if ((flags and 1) != 0) {
				stream.writeInt32(participantsCount)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(adminsCount)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(kickedCount)
			}
	
			if ((flags and 8192) != 0) {
				stream.writeInt32(onlineCount)
			}
	
			stream.writeInt32(readInboxMaxId)
			stream.writeInt32(readOutboxMaxId)
			stream.writeInt32(unreadCount)
			chatPhoto?.serializeToStream(stream)
			notifySettings?.serializeToStream(stream)
			if ((flags and 8388608) != 0) {
				exportedInvite?.serializeToStream(stream)
			}
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(botInfo.size)
			botInfo.forEach { it.serializeToStream(stream) }
			if ((flags and 16) != 0) {
				stream.writeInt32(payType)
			}
	
			if ((flags and 16) != 0) {
				stream.writeDouble(cost)
			}
	
			if ((flags and 32) != 0) {
				stream.writeInt32(pinnedMsgId)
			}
	
			if ((flags and 256) != 0) {
				stickerset?.serializeToStream(stream)
			}
	
			if ((flags and 512) != 0) {
				stream.writeInt32(availableMinId)
			}
	
			if ((flags and 2048) != 0) {
				stream.writeInt32(folderId)
			}
	
			if ((flags and 16384) != 0) {
				stream.writeInt64(linkedChatId)
			}
	
			if ((flags and 32768) != 0) {
				location?.serializeToStream(stream)
			}
	
			if ((flags and 131072) != 0) {
				stream.writeInt32(slowmodeSeconds)
			}
	
			if ((flags and 262144) != 0) {
				stream.writeInt32(slowmodeNextSendDate)
			}
	
			if ((flags and 4096) != 0) {
				stream.writeInt32(statsDc)
			}
	
			stream.writeInt32(pts)
			if ((flags and 2097152) != 0) {
				call?.serializeToStream(stream)
			}
	
			if ((flags and 16777216) != 0) {
				stream.writeInt32(ttlPeriod)
			}
	
			if ((flags and 33554432) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(pendingSuggestions.size)
			pendingSuggestions.forEach { stream.writeString(it) }
			}
	
			if ((flags and 67108864) != 0) {
				groupcallDefaultJoinAs?.serializeToStream(stream)
			}
	
			if ((flags and 134217728) != 0) {
				stream.writeString(themeEmoticon)
			}
	
			if ((flags and 268435456) != 0) {
				stream.writeInt32(requestsPending)
			}
	
			if ((flags and 268435456) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(recentRequesters.size)
			recentRequesters.forEach { stream.writeInt64(it) }
			}
	
			if ((flags and 536870912) != 0) {
				defaultSendAs?.serializeToStream(stream)
			}
	
			if ((flags and 1073741824) != 0) {
				availableReactions?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf2355507u.toInt()
		}
	}
	
	open class TLChatFullLayer3: ChatFull() {
					@JvmField var translationsDisabled = false
																				@JvmField var adult = false
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			canSetUsername = (flags and 128) != 0
			hasScheduled = (flags and 256) != 0
			translationsDisabled = (flags and 524288) != 0
			id = stream.readInt64(exception)
			about = stream.readString(exception) ?: return
			participants = ChatParticipants.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 4) != 0) {
				chatPhoto = Photo.deserialize(stream, stream.readInt32(exception), exception)
			}
			notifySettings = PeerNotifySettings.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 8192) != 0) {
				exportedInvite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 8) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLBotInfo.deserialize(stream, stream.readInt32(exception), exception) ?: return
					botInfo.add(obj)
				}
			}
		
			if ((flags and 64) != 0) {
				pinnedMsgId = stream.readInt32(exception)
			}
		
			if ((flags and 2048) != 0) {
				folderId = stream.readInt32(exception)
			}
		
			if ((flags and 4096) != 0) {
				call = TLInputGroupCall.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 16384) != 0) {
				ttlPeriod = stream.readInt32(exception)
			}
		
			if ((flags and 32768) != 0) {
				groupcallDefaultJoinAs = Peer.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 65536) != 0) {
				themeEmoticon = stream.readString(exception) ?: return
			}
		
			if ((flags and 131072) != 0) {
				requestsPending = stream.readInt32(exception)
			}
		
			if ((flags and 131072) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = stream.readInt64(exception)
					recentRequesters.add(obj)
				}
			}
		
			if ((flags and 262144) != 0) {
				availableReactions = ChatReactions.deserialize(stream, stream.readInt32(exception), exception)
			}
			country = stream.readString(exception) ?: return
			category = stream.readString(exception) ?: return
			adult = stream.readBool(exception)
			exportedInvite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 524288) != 0) {
				username = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (canSetUsername) flags or 128 else flags and 128.inv()
			flags = if (hasScheduled) flags or 256 else flags and 256.inv()
			flags = if (translationsDisabled) flags or 524288 else flags and 524288.inv()
			flags = if (chatPhoto != null) flags or 4 else flags and 4.inv()
			flags = if (exportedInvite != null) flags or 8192 else flags and 8192.inv()
			flags = if (pinnedMsgId != 0) flags or 64 else flags and 64.inv()
			flags = if (folderId != 0) flags or 2048 else flags and 2048.inv()
			flags = if (call != null) flags or 4096 else flags and 4096.inv()
			flags = if (ttlPeriod != 0) flags or 16384 else flags and 16384.inv()
			flags = if (groupcallDefaultJoinAs != null) flags or 32768 else flags and 32768.inv()
			flags = if (themeEmoticon != null) flags or 65536 else flags and 65536.inv()
			flags = if (requestsPending != 0) flags or 131072 else flags and 131072.inv()
			flags = if (availableReactions != null) flags or 262144 else flags and 262144.inv()
			flags = if (username != null) flags or 524288 else flags and 524288.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeString(about)
			participants?.serializeToStream(stream)
			if ((flags and 4) != 0) {
				chatPhoto?.serializeToStream(stream)
			}
	
			notifySettings?.serializeToStream(stream)
			if ((flags and 8192) != 0) {
				exportedInvite?.serializeToStream(stream)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(botInfo.size)
			botInfo.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 64) != 0) {
				stream.writeInt32(pinnedMsgId)
			}
	
			if ((flags and 2048) != 0) {
				stream.writeInt32(folderId)
			}
	
			if ((flags and 4096) != 0) {
				call?.serializeToStream(stream)
			}
	
			if ((flags and 16384) != 0) {
				stream.writeInt32(ttlPeriod)
			}
	
			if ((flags and 32768) != 0) {
				groupcallDefaultJoinAs?.serializeToStream(stream)
			}
	
			if ((flags and 65536) != 0) {
				stream.writeString(themeEmoticon)
			}
	
			if ((flags and 131072) != 0) {
				stream.writeInt32(requestsPending)
			}
	
			if ((flags and 131072) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(recentRequesters.size)
			recentRequesters.forEach { stream.writeInt64(it) }
			}
	
			if ((flags and 262144) != 0) {
				availableReactions?.serializeToStream(stream)
			}
	
			stream.writeString(country)
			stream.writeString(category)
			stream.writeBool(adult)
			exportedInvite?.serializeToStream(stream)
			if ((flags and 524288) != 0) {
				stream.writeString(username)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x7e574845u.toInt()
		}
	}
	
	open class TLChannelFullLayer3: ChatFull() {
																		@JvmField var bannedCount = 0
										@JvmField var migratedFromChatId = 0L
		@JvmField var migratedFromMaxId = 0
																				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			canViewParticipants = (flags and 8) != 0
			canSetUsername = (flags and 64) != 0
			canSetStickers = (flags and 128) != 0
			hiddenPrehistory = (flags and 1024) != 0
			canSetLocation = (flags and 65536) != 0
			hasScheduled = (flags and 524288) != 0
			canViewStats = (flags and 1048576) != 0
			blocked = (flags and 4194304) != 0
			flags2 = stream.readInt32(exception)
			canDeleteChannel = (flags2 and 1) != 0
			id = stream.readInt64(exception)
			about = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				participantsCount = stream.readInt32(exception)
			}
		
			if ((flags and 2) != 0) {
				adminsCount = stream.readInt32(exception)
			}
		
			if ((flags and 4) != 0) {
				kickedCount = stream.readInt32(exception)
			}
		
			if ((flags and 4) != 0) {
				bannedCount = stream.readInt32(exception)
			}
		
			if ((flags and 8192) != 0) {
				onlineCount = stream.readInt32(exception)
			}
			readInboxMaxId = stream.readInt32(exception)
			readOutboxMaxId = stream.readInt32(exception)
			unreadCount = stream.readInt32(exception)
			chatPhoto = Photo.deserialize(stream, stream.readInt32(exception), exception)
			notifySettings = PeerNotifySettings.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 8388608) != 0) {
				exportedInvite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLBotInfo.deserialize(stream, stream.readInt32(exception), exception) ?: return
				botInfo.add(obj)
			}
		
			if ((flags and 16) != 0) {
				migratedFromChatId = stream.readInt64(exception)
			}
		
			if ((flags and 16) != 0) {
				migratedFromMaxId = stream.readInt32(exception)
			}
		
			if ((flags and 32) != 0) {
				pinnedMsgId = stream.readInt32(exception)
			}
		
			if ((flags and 256) != 0) {
				stickerset = TLStickerSet.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 512) != 0) {
				availableMinId = stream.readInt32(exception)
			}
		
			if ((flags and 2048) != 0) {
				folderId = stream.readInt32(exception)
			}
		
			if ((flags and 16384) != 0) {
				linkedChatId = stream.readInt64(exception)
			}
		
			if ((flags and 32768) != 0) {
				location = ChannelLocation.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 131072) != 0) {
				slowmodeSeconds = stream.readInt32(exception)
			}
		
			if ((flags and 262144) != 0) {
				slowmodeNextSendDate = stream.readInt32(exception)
			}
		
			if ((flags and 4096) != 0) {
				statsDc = stream.readInt32(exception)
			}
			pts = stream.readInt32(exception)
		
			if ((flags and 2097152) != 0) {
				call = TLInputGroupCall.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 16777216) != 0) {
				ttlPeriod = stream.readInt32(exception)
			}
		
			if ((flags and 33554432) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = stream.readString(exception) ?: return
					pendingSuggestions.add(obj)
				}
			}
		
			if ((flags and 67108864) != 0) {
				groupcallDefaultJoinAs = Peer.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 134217728) != 0) {
				themeEmoticon = stream.readString(exception) ?: return
			}
		
			if ((flags and 268435456) != 0) {
				requestsPending = stream.readInt32(exception)
			}
		
			if ((flags and 268435456) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = stream.readInt64(exception)
					recentRequesters.add(obj)
				}
			}
		
			if ((flags and 536870912) != 0) {
				defaultSendAs = Peer.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 1073741824) != 0) {
				availableReactions = ChatReactions.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (canViewParticipants) flags or 8 else flags and 8.inv()
			flags = if (canSetUsername) flags or 64 else flags and 64.inv()
			flags = if (canSetStickers) flags or 128 else flags and 128.inv()
			flags = if (hiddenPrehistory) flags or 1024 else flags and 1024.inv()
			flags = if (canSetLocation) flags or 65536 else flags and 65536.inv()
			flags = if (hasScheduled) flags or 524288 else flags and 524288.inv()
			flags = if (canViewStats) flags or 1048576 else flags and 1048576.inv()
			flags = if (blocked) flags or 4194304 else flags and 4194304.inv()
			flags2 = if (canDeleteChannel) flags2 or 1 else flags2 and 1.inv()
			flags = if (participantsCount != 0) flags or 1 else flags and 1.inv()
			flags = if (adminsCount != 0) flags or 2 else flags and 2.inv()
			flags = if (kickedCount != 0) flags or 4 else flags and 4.inv()
			flags = if (bannedCount != 0) flags or 4 else flags and 4.inv()
			flags = if (onlineCount != 0) flags or 8192 else flags and 8192.inv()
			flags = if (exportedInvite != null) flags or 8388608 else flags and 8388608.inv()
			flags = if (migratedFromChatId != 0L) flags or 16 else flags and 16.inv()
			flags = if (migratedFromMaxId != 0) flags or 16 else flags and 16.inv()
			flags = if (pinnedMsgId != 0) flags or 32 else flags and 32.inv()
			flags = if (stickerset != null) flags or 256 else flags and 256.inv()
			flags = if (availableMinId != 0) flags or 512 else flags and 512.inv()
			flags = if (folderId != 0) flags or 2048 else flags and 2048.inv()
			flags = if (linkedChatId != 0L) flags or 16384 else flags and 16384.inv()
			flags = if (location != null) flags or 32768 else flags and 32768.inv()
			flags = if (slowmodeSeconds != 0) flags or 131072 else flags and 131072.inv()
			flags = if (slowmodeNextSendDate != 0) flags or 262144 else flags and 262144.inv()
			flags = if (statsDc != 0) flags or 4096 else flags and 4096.inv()
			flags = if (call != null) flags or 2097152 else flags and 2097152.inv()
			flags = if (ttlPeriod != 0) flags or 16777216 else flags and 16777216.inv()
			flags = if (groupcallDefaultJoinAs != null) flags or 67108864 else flags and 67108864.inv()
			flags = if (themeEmoticon != null) flags or 134217728 else flags and 134217728.inv()
			flags = if (requestsPending != 0) flags or 268435456 else flags and 268435456.inv()
			flags = if (defaultSendAs != null) flags or 536870912 else flags and 536870912.inv()
			flags = if (availableReactions != null) flags or 1073741824 else flags and 1073741824.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(flags2)
			stream.writeInt64(id)
			stream.writeString(about)
			if ((flags and 1) != 0) {
				stream.writeInt32(participantsCount)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(adminsCount)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(kickedCount)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(bannedCount)
			}
	
			if ((flags and 8192) != 0) {
				stream.writeInt32(onlineCount)
			}
	
			stream.writeInt32(readInboxMaxId)
			stream.writeInt32(readOutboxMaxId)
			stream.writeInt32(unreadCount)
			chatPhoto?.serializeToStream(stream)
			notifySettings?.serializeToStream(stream)
			if ((flags and 8388608) != 0) {
				exportedInvite?.serializeToStream(stream)
			}
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(botInfo.size)
			botInfo.forEach { it.serializeToStream(stream) }
			if ((flags and 16) != 0) {
				stream.writeInt64(migratedFromChatId)
			}
	
			if ((flags and 16) != 0) {
				stream.writeInt32(migratedFromMaxId)
			}
	
			if ((flags and 32) != 0) {
				stream.writeInt32(pinnedMsgId)
			}
	
			if ((flags and 256) != 0) {
				stickerset?.serializeToStream(stream)
			}
	
			if ((flags and 512) != 0) {
				stream.writeInt32(availableMinId)
			}
	
			if ((flags and 2048) != 0) {
				stream.writeInt32(folderId)
			}
	
			if ((flags and 16384) != 0) {
				stream.writeInt64(linkedChatId)
			}
	
			if ((flags and 32768) != 0) {
				location?.serializeToStream(stream)
			}
	
			if ((flags and 131072) != 0) {
				stream.writeInt32(slowmodeSeconds)
			}
	
			if ((flags and 262144) != 0) {
				stream.writeInt32(slowmodeNextSendDate)
			}
	
			if ((flags and 4096) != 0) {
				stream.writeInt32(statsDc)
			}
	
			stream.writeInt32(pts)
			if ((flags and 2097152) != 0) {
				call?.serializeToStream(stream)
			}
	
			if ((flags and 16777216) != 0) {
				stream.writeInt32(ttlPeriod)
			}
	
			if ((flags and 33554432) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(pendingSuggestions.size)
			pendingSuggestions.forEach { stream.writeString(it) }
			}
	
			if ((flags and 67108864) != 0) {
				groupcallDefaultJoinAs?.serializeToStream(stream)
			}
	
			if ((flags and 134217728) != 0) {
				stream.writeString(themeEmoticon)
			}
	
			if ((flags and 268435456) != 0) {
				stream.writeInt32(requestsPending)
			}
	
			if ((flags and 268435456) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(recentRequesters.size)
			recentRequesters.forEach { stream.writeInt64(it) }
			}
	
			if ((flags and 536870912) != 0) {
				defaultSendAs?.serializeToStream(stream)
			}
	
			if ((flags and 1073741824) != 0) {
				availableReactions?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x5f2a5281u.toInt()
		}
	}
	
	abstract class ChatParticipant: TLObject() {
		@JvmField var userId = 0L
		@JvmField var inviterId = 0L
		@JvmField var date = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChatParticipant? {
				val result = when (constructor) {
					TLChatParticipant.CONSTRUCTOR -> TLChatParticipant()
					TLChatParticipantCreator.CONSTRUCTOR -> TLChatParticipantCreator()
					TLChatParticipantAdmin.CONSTRUCTOR -> TLChatParticipantAdmin()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ChatParticipant")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChatParticipant: ChatParticipant() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			inviterId = stream.readInt64(exception)
			date = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeInt64(inviterId)
			stream.writeInt32(date)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc02d4007u.toInt()
		}
	}
	
	open class TLChatParticipantCreator: ChatParticipant() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe46bcee4u.toInt()
		}
	}
	
	open class TLChatParticipantAdmin: ChatParticipant() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			inviterId = stream.readInt64(exception)
			date = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeInt64(inviterId)
			stream.writeInt32(date)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa0933f5bu.toInt()
		}
	}
	
	abstract class ChatParticipants: TLObject() {
		@JvmField var chatId = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChatParticipants? {
				val result = when (constructor) {
					TLChatParticipantsForbidden.CONSTRUCTOR -> TLChatParticipantsForbidden()
					TLChatParticipants.CONSTRUCTOR -> TLChatParticipants()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ChatParticipants")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChatParticipantsForbidden: ChatParticipants() {
		@JvmField var flags = 0
			@JvmField var selfParticipant: ChatParticipant? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			chatId = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {
				selfParticipant = ChatParticipant.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (selfParticipant != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(chatId)
			if ((flags and 1) != 0) {
				selfParticipant?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8763d3e1u.toInt()
		}
	}
	
	open class TLChatParticipants: ChatParticipants() {
			@JvmField val participants = mutableListOf<ChatParticipant>()
		@JvmField var version = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			chatId = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = ChatParticipant.deserialize(stream, stream.readInt32(exception), exception) ?: return
				participants.add(obj)
			}
			version = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(chatId)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(participants.size)
			participants.forEach { it.serializeToStream(stream) }
			stream.writeInt32(version)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3cbc93f8u.toInt()
		}
	}
	
	abstract class ChatPhoto: TLObject() {
		@JvmField var dcId = 0
		@JvmField var flags = 0
		@JvmField var strippedThumb: ByteArray? = null
		@JvmField var hasVideo = false
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChatPhoto? {
				val result = when (constructor) {
					TLChatPhotoEmpty.CONSTRUCTOR -> TLChatPhotoEmpty()
					TLChatPhoto.CONSTRUCTOR -> TLChatPhoto()
					TLChatPhotoLayer127.CONSTRUCTOR -> TLChatPhotoLayer127()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ChatPhoto")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChatPhotoEmpty: ChatPhoto() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x37c1011cu.toInt()
		}
	}
	
	open class TLChatPhoto: ChatPhoto() {
				@JvmField var photoId = 0L
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			hasVideo = (flags and 1) != 0
			photoId = stream.readInt64(exception)
		
			if ((flags and 2) != 0) {
				strippedThumb = stream.readByteArray(exception) ?: return
			}
			dcId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (hasVideo) flags or 1 else flags and 1.inv()
			flags = if (strippedThumb != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(photoId)
			if ((flags and 2) != 0) {
				stream.writeByteArray(strippedThumb)
			}
	
			stream.writeInt32(dcId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1c6e1c11u.toInt()
		}
	}
	
	open class TLChatPhotoLayer127: TLChatPhoto() {
				@JvmField var photoSmall: FileLocation? = null
		@JvmField var photoBig: FileLocation? = null
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			hasVideo = (flags and 1) != 0
			photoSmall = FileLocation.deserialize(stream, stream.readInt32(exception), exception)
			photoBig = FileLocation.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 2) != 0) {
				strippedThumb = stream.readByteArray(exception) ?: return
			}
			dcId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (hasVideo) flags or 1 else flags and 1.inv()
			flags = if (strippedThumb != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			photoSmall?.serializeToStream(stream)
			photoBig?.serializeToStream(stream)
			if ((flags and 2) != 0) {
				stream.writeByteArray(strippedThumb)
			}
	
			stream.writeInt32(dcId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4790ee05u.toInt()
		}
	}
	
	abstract class Message: TLObject() {
		@JvmField var peerId: Peer? = null
		@JvmField var replyTo: TLMessageReplyHeader? = null
		@JvmField var mentioned = false
		@JvmField var legacy = false
		@JvmField var flags = 0
		@JvmField var ttlPeriod = 0
		@JvmField var out = false
		@JvmField var silent = false
		@JvmField var mediaUnread = false
		@JvmField var date = 0
		@JvmField var fromId: Peer? = null
		@JvmField var post = false
		@JvmField var id = 0
		@JvmField var unread: Boolean = false
		@JvmField var replyMessage: Message? = null
		@JvmField var dialogId: Long = 0L
		@JvmField var randomId: Long = 0L
		@JvmField var sendState: Int = 0
		@JvmField var attachPath: String? = ""
		@JvmField var params: MutableMap<String, String>? = null
		@JvmField var layer: Int = 0
		@JvmField var fwdMsgId: Int = 0
		@JvmField var voiceTranscription: String? = null
		@JvmField var voiceTranscriptionOpen: Boolean = false
		@JvmField var voiceTranscriptionRated: Boolean = false
		@JvmField var voiceTranscriptionFinal: Boolean = false
		@JvmField var voiceTranscriptionForce: Boolean = false
		@JvmField var voiceTranscriptionId: Long = 0L
		@JvmField var premiumEffectWasPlayed: Boolean = false
		@JvmField var ttl: Int = 0
		@JvmField var stickerVerified: Int = 1
		@JvmField var seqIn: Int = 0
		@JvmField var seqOut: Int = 0
		@JvmField var localId: Int = 0
		@JvmField var destroyTime: Int = 0
		@JvmField var realId: Int = 0
		@JvmField var isThreadMessage: Boolean = false
		@JvmField var reqId: Int = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Message? {
				val result = when (constructor) {
					TLMessageEmpty.CONSTRUCTOR -> TLMessageEmpty()
					TLMessage.CONSTRUCTOR -> TLMessage()
					TLMessageService.CONSTRUCTOR -> TLMessageService()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in Message")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessageEmpty: Message() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			id = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				peerId = Peer.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (peerId != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(id)
			if ((flags and 1) != 0) {
				peerId?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x90a6ca84u.toInt()
		}
	}
	
	open class TLMessage: Message() {
								@JvmField var fromScheduled = false
			@JvmField var editHide = false
		@JvmField var pinned = false
		@JvmField var noforwards = false
					@JvmField var fwdFrom: TLMessageFwdHeader? = null
		@JvmField var viaBotId = 0L
				@JvmField var message: String? = null
		@JvmField var media: MessageMedia? = null
		@JvmField var replyMarkup: ReplyMarkup? = null
		@JvmField val entities = mutableListOf<MessageEntity>()
		@JvmField var views = 0
		@JvmField var forwards = 0
		@JvmField var replies: TLMessageReplies? = null
		@JvmField var editDate = 0
		@JvmField var postAuthor: String? = null
		@JvmField var groupedId = 0L
		@JvmField var reactions: TLMessageReactions? = null
		@JvmField val restrictionReason = mutableListOf<TLRestrictionReason>()
			@JvmField var likes = 0
		@JvmField var isLiked = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			out = (flags and 2) != 0
			mentioned = (flags and 16) != 0
			mediaUnread = (flags and 32) != 0
			silent = (flags and 8192) != 0
			post = (flags and 16384) != 0
			fromScheduled = (flags and 262144) != 0
			legacy = (flags and 524288) != 0
			editHide = (flags and 2097152) != 0
			pinned = (flags and 16777216) != 0
			noforwards = (flags and 67108864) != 0
			id = stream.readInt32(exception)
		
			if ((flags and 256) != 0) {
				fromId = Peer.deserialize(stream, stream.readInt32(exception), exception)
			}
			peerId = Peer.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 4) != 0) {
				fwdFrom = TLMessageFwdHeader.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2048) != 0) {
				viaBotId = stream.readInt64(exception)
			}
		
			if ((flags and 8) != 0) {
				replyTo = TLMessageReplyHeader.deserialize(stream, stream.readInt32(exception), exception)
			}
			date = stream.readInt32(exception)
			message = stream.readString(exception) ?: return
		
			if ((flags and 512) != 0) {
				media = MessageMedia.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 64) != 0) {
				replyMarkup = ReplyMarkup.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 128) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
					entities.add(obj)
				}
			}
		
			if ((flags and 1024) != 0) {
				views = stream.readInt32(exception)
			}
		
			if ((flags and 268435456) != 0) {
				forwards = stream.readInt32(exception)
			}
		
			if ((flags and 8388608) != 0) {
				replies = TLMessageReplies.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 32768) != 0) {
				editDate = stream.readInt32(exception)
			}
		
			if ((flags and 65536) != 0) {
				postAuthor = stream.readString(exception) ?: return
			}
		
			if ((flags and 131072) != 0) {
				groupedId = stream.readInt64(exception)
			}
		
			if ((flags and 1048576) != 0) {
				reactions = TLMessageReactions.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 4194304) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLRestrictionReason.deserialize(stream, stream.readInt32(exception), exception) ?: return
					restrictionReason.add(obj)
				}
			}
		
			if ((flags and 33554432) != 0) {
				ttlPeriod = stream.readInt32(exception)
			}
		
			if ((flags and 536870912) != 0) {
				likes = stream.readInt32(exception)
			}
			isLiked = (flags and 1073741824) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (out) flags or 2 else flags and 2.inv()
			flags = if (mentioned) flags or 16 else flags and 16.inv()
			flags = if (mediaUnread) flags or 32 else flags and 32.inv()
			flags = if (silent) flags or 8192 else flags and 8192.inv()
			flags = if (post) flags or 16384 else flags and 16384.inv()
			flags = if (fromScheduled) flags or 262144 else flags and 262144.inv()
			flags = if (legacy) flags or 524288 else flags and 524288.inv()
			flags = if (editHide) flags or 2097152 else flags and 2097152.inv()
			flags = if (pinned) flags or 16777216 else flags and 16777216.inv()
			flags = if (noforwards) flags or 67108864 else flags and 67108864.inv()
			flags = if (fromId != null) flags or 256 else flags and 256.inv()
			flags = if (fwdFrom != null) flags or 4 else flags and 4.inv()
			flags = if (viaBotId != 0L) flags or 2048 else flags and 2048.inv()
			flags = if (replyTo != null) flags or 8 else flags and 8.inv()
			flags = if (media != null) flags or 512 else flags and 512.inv()
			flags = if (replyMarkup != null) flags or 64 else flags and 64.inv()
			flags = if (views != 0) flags or 1024 else flags and 1024.inv()
			flags = if (forwards != 0) flags or 268435456 else flags and 268435456.inv()
			flags = if (replies != null) flags or 8388608 else flags and 8388608.inv()
			flags = if (editDate != 0) flags or 32768 else flags and 32768.inv()
			flags = if (postAuthor != null) flags or 65536 else flags and 65536.inv()
			flags = if (groupedId != 0L) flags or 131072 else flags and 131072.inv()
			flags = if (reactions != null) flags or 1048576 else flags and 1048576.inv()
			flags = if (ttlPeriod != 0) flags or 33554432 else flags and 33554432.inv()
			flags = if (likes != 0) flags or 536870912 else flags and 536870912.inv()
			flags = if (isLiked) flags or 1073741824 else flags and 1073741824.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(id)
			if ((flags and 256) != 0) {
				fromId?.serializeToStream(stream)
			}
	
			peerId?.serializeToStream(stream)
			if ((flags and 4) != 0) {
				fwdFrom?.serializeToStream(stream)
			}
	
			if ((flags and 2048) != 0) {
				stream.writeInt64(viaBotId)
			}
	
			if ((flags and 8) != 0) {
				replyTo?.serializeToStream(stream)
			}
	
			stream.writeInt32(date)
			stream.writeString(message)
			if ((flags and 512) != 0) {
				media?.serializeToStream(stream)
			}
	
			if ((flags and 64) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
			if ((flags and 128) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 1024) != 0) {
				stream.writeInt32(views)
			}
	
			if ((flags and 268435456) != 0) {
				stream.writeInt32(forwards)
			}
	
			if ((flags and 8388608) != 0) {
				replies?.serializeToStream(stream)
			}
	
			if ((flags and 32768) != 0) {
				stream.writeInt32(editDate)
			}
	
			if ((flags and 65536) != 0) {
				stream.writeString(postAuthor)
			}
	
			if ((flags and 131072) != 0) {
				stream.writeInt64(groupedId)
			}
	
			if ((flags and 1048576) != 0) {
				reactions?.serializeToStream(stream)
			}
	
			if ((flags and 4194304) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(restrictionReason.size)
			restrictionReason.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 33554432) != 0) {
				stream.writeInt32(ttlPeriod)
			}
	
			if ((flags and 536870912) != 0) {
				stream.writeInt32(likes)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x38116ee0u.toInt()
		}
	}
	
	open class TLMessageService: Message() {
														@JvmField var action: MessageAction? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			out = (flags and 2) != 0
			mentioned = (flags and 16) != 0
			mediaUnread = (flags and 32) != 0
			silent = (flags and 8192) != 0
			post = (flags and 16384) != 0
			legacy = (flags and 524288) != 0
			id = stream.readInt32(exception)
		
			if ((flags and 256) != 0) {
				fromId = Peer.deserialize(stream, stream.readInt32(exception), exception)
			}
			peerId = Peer.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 8) != 0) {
				replyTo = TLMessageReplyHeader.deserialize(stream, stream.readInt32(exception), exception)
			}
			date = stream.readInt32(exception)
			action = MessageAction.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 33554432) != 0) {
				ttlPeriod = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (out) flags or 2 else flags and 2.inv()
			flags = if (mentioned) flags or 16 else flags and 16.inv()
			flags = if (mediaUnread) flags or 32 else flags and 32.inv()
			flags = if (silent) flags or 8192 else flags and 8192.inv()
			flags = if (post) flags or 16384 else flags and 16384.inv()
			flags = if (legacy) flags or 524288 else flags and 524288.inv()
			flags = if (fromId != null) flags or 256 else flags and 256.inv()
			flags = if (replyTo != null) flags or 8 else flags and 8.inv()
			flags = if (ttlPeriod != 0) flags or 33554432 else flags and 33554432.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(id)
			if ((flags and 256) != 0) {
				fromId?.serializeToStream(stream)
			}
	
			peerId?.serializeToStream(stream)
			if ((flags and 8) != 0) {
				replyTo?.serializeToStream(stream)
			}
	
			stream.writeInt32(date)
			action?.serializeToStream(stream)
			if ((flags and 33554432) != 0) {
				stream.writeInt32(ttlPeriod)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x2b085862u.toInt()
		}
	}
	
	abstract class MessageMedia: TLObject() {
		@JvmField var title: String? = null
		@JvmField var flags = 0
		@JvmField var ttlSeconds = 0
		@JvmField var geo: GeoPoint? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessageMedia? {
				val result = when (constructor) {
					TLMessageMediaEmpty.CONSTRUCTOR -> TLMessageMediaEmpty()
					TLMessageMediaPhoto.CONSTRUCTOR -> TLMessageMediaPhoto()
					TLMessageMediaGeo.CONSTRUCTOR -> TLMessageMediaGeo()
					TLMessageMediaContact.CONSTRUCTOR -> TLMessageMediaContact()
					TLMessageMediaUnsupported.CONSTRUCTOR -> TLMessageMediaUnsupported()
					TLMessageMediaDocument.CONSTRUCTOR -> TLMessageMediaDocument()
					TLMessageMediaWebPage.CONSTRUCTOR -> TLMessageMediaWebPage()
					TLMessageMediaVenue.CONSTRUCTOR -> TLMessageMediaVenue()
					TLMessageMediaGame.CONSTRUCTOR -> TLMessageMediaGame()
					TLMessageMediaInvoice.CONSTRUCTOR -> TLMessageMediaInvoice()
					TLMessageMediaGeoLive.CONSTRUCTOR -> TLMessageMediaGeoLive()
					TLMessageMediaPoll.CONSTRUCTOR -> TLMessageMediaPoll()
					TLMessageMediaDice.CONSTRUCTOR -> TLMessageMediaDice()
					TLMessageMediaBizDataRaw.CONSTRUCTOR -> TLMessageMediaBizDataRaw()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessageMedia")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessageMediaEmpty: MessageMedia() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3ded6320u.toInt()
		}
	}
	
	open class TLMessageMediaPhoto: MessageMedia() {
			@JvmField var photo: Photo? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				photo = Photo.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 4) != 0) {
				ttlSeconds = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (photo != null) flags or 1 else flags and 1.inv()
			flags = if (ttlSeconds != 0) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				photo?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(ttlSeconds)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x695150d7u.toInt()
		}
	}
	
	open class TLMessageMediaGeo: MessageMedia() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			geo = GeoPoint.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			geo?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x56e0d474u.toInt()
		}
	}
	
	open class TLMessageMediaContact: MessageMedia() {
		@JvmField var phoneNumber: String? = null
		@JvmField var firstName: String? = null
		@JvmField var lastName: String? = null
		@JvmField var vcard: String? = null
		@JvmField var userId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			phoneNumber = stream.readString(exception) ?: return
			firstName = stream.readString(exception) ?: return
			lastName = stream.readString(exception) ?: return
			vcard = stream.readString(exception) ?: return
			userId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phoneNumber)
			stream.writeString(firstName)
			stream.writeString(lastName)
			stream.writeString(vcard)
			stream.writeInt64(userId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x70322949u.toInt()
		}
	}
	
	open class TLMessageMediaUnsupported: MessageMedia() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9f84f49eu.toInt()
		}
	}
	
	open class TLMessageMediaDocument: MessageMedia() {
			@JvmField var nopremium = false
		@JvmField var document: Document? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			nopremium = (flags and 8) != 0
		
			if ((flags and 1) != 0) {
				document = Document.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 4) != 0) {
				ttlSeconds = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (nopremium) flags or 8 else flags and 8.inv()
			flags = if (document != null) flags or 1 else flags and 1.inv()
			flags = if (ttlSeconds != 0) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				document?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(ttlSeconds)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9cb070d7u.toInt()
		}
	}
	
	open class TLMessageMediaWebPage: MessageMedia() {
		@JvmField var webpage: WebPage? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			webpage = WebPage.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			webpage?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa32dd600u.toInt()
		}
	}
	
	open class TLMessageMediaVenue: MessageMedia() {
				@JvmField var address: String? = null
		@JvmField var provider: String? = null
		@JvmField var venueId: String? = null
		@JvmField var venueType: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			geo = GeoPoint.deserialize(stream, stream.readInt32(exception), exception)
			title = stream.readString(exception) ?: return
			address = stream.readString(exception) ?: return
			provider = stream.readString(exception) ?: return
			venueId = stream.readString(exception) ?: return
			venueType = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			geo?.serializeToStream(stream)
			stream.writeString(title)
			stream.writeString(address)
			stream.writeString(provider)
			stream.writeString(venueId)
			stream.writeString(venueType)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2ec0533fu.toInt()
		}
	}
	
	open class TLMessageMediaGame: MessageMedia() {
		@JvmField var game: TLGame? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			game = TLGame.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			game?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfdb19008u.toInt()
		}
	}
	
	open class TLMessageMediaInvoice: MessageMedia() {
			@JvmField var shippingAddressRequested = false
		@JvmField var test = false
			@JvmField var description: String? = null
		@JvmField var photo: WebDocument? = null
		@JvmField var receiptMsgId = 0
		@JvmField var currency: String? = null
		@JvmField var totalAmount = 0L
		@JvmField var startParam: String? = null
		@JvmField var extendedMedia: MessageExtendedMedia? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			shippingAddressRequested = (flags and 2) != 0
			test = (flags and 8) != 0
			title = stream.readString(exception) ?: return
			description = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				photo = WebDocument.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 4) != 0) {
				receiptMsgId = stream.readInt32(exception)
			}
			currency = stream.readString(exception) ?: return
			totalAmount = stream.readInt64(exception)
			startParam = stream.readString(exception) ?: return
		
			if ((flags and 16) != 0) {
				extendedMedia = MessageExtendedMedia.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (shippingAddressRequested) flags or 2 else flags and 2.inv()
			flags = if (test) flags or 8 else flags and 8.inv()
			flags = if (photo != null) flags or 1 else flags and 1.inv()
			flags = if (receiptMsgId != 0) flags or 4 else flags and 4.inv()
			flags = if (extendedMedia != null) flags or 16 else flags and 16.inv()
	
			stream.writeInt32(flags)
			stream.writeString(title)
			stream.writeString(description)
			if ((flags and 1) != 0) {
				photo?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(receiptMsgId)
			}
	
			stream.writeString(currency)
			stream.writeInt64(totalAmount)
			stream.writeString(startParam)
			if ((flags and 16) != 0) {
				extendedMedia?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf6a548d3u.toInt()
		}
	}
	
	open class TLMessageMediaGeoLive: MessageMedia() {
				@JvmField var heading = 0
		@JvmField var period = 0
		@JvmField var proximityNotificationRadius = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			geo = GeoPoint.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				heading = stream.readInt32(exception)
			}
			period = stream.readInt32(exception)
		
			if ((flags and 2) != 0) {
				proximityNotificationRadius = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (heading != 0) flags or 1 else flags and 1.inv()
			flags = if (proximityNotificationRadius != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			geo?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(heading)
			}
	
			stream.writeInt32(period)
			if ((flags and 2) != 0) {
				stream.writeInt32(proximityNotificationRadius)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb940c666u.toInt()
		}
	}
	
	open class TLMessageMediaPoll: MessageMedia() {
		@JvmField var poll: TLPoll? = null
		@JvmField var results: TLPollResults? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			poll = TLPoll.deserialize(stream, stream.readInt32(exception), exception)
			results = TLPollResults.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			poll?.serializeToStream(stream)
			results?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4bd6e798u.toInt()
		}
	}
	
	open class TLMessageMediaDice: MessageMedia() {
		@JvmField var value = 0
		@JvmField var emoticon: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			value = stream.readInt32(exception)
			emoticon = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(value)
			stream.writeString(emoticon)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3f7ee58bu.toInt()
		}
	}
	
	open class TLMessageMediaBizDataRaw: MessageMedia() {
		@JvmField var bizData: TLBizDataRaw? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			bizData = TLBizDataRaw.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			bizData?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb8cc6f06u.toInt()
		}
	}
	
	open class TLMessagesGetWebPagePreview: TLObject() {
		@JvmField var flags = 0
		@JvmField var message: String? = null
		@JvmField val entities = mutableListOf<MessageEntity>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessageMedia? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessageMedia.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (entities.isNotEmpty()) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			stream.writeString(message)
			if ((flags and 8) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8b68b0ccu.toInt()
		}
	}
	
	open class TLMessagesUploadMedia: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var media: InputMedia? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessageMedia? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessageMedia.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			media?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x519bc2b1u.toInt()
		}
	}
	
	open class TLMessagesUploadImportedMedia: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var importId = 0L
		@JvmField var fileName: String? = null
		@JvmField var media: InputMedia? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessageMedia? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessageMedia.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt64(importId)
			stream.writeString(fileName)
			media?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2a862092u.toInt()
		}
	}
	
	abstract class MessageAction: TLObject() {
		@JvmField var totalAmount = 0L
		@JvmField var duration = 0
		@JvmField var title: String? = null
		@JvmField var flags = 0
		@JvmField var recurringUsed = false
		@JvmField var call: TLInputGroupCall? = null
		@JvmField val users = mutableListOf<Long>()
		@JvmField var recurringInit = false
		@JvmField var text: String? = null
		@JvmField var currency: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessageAction? {
				val result = when (constructor) {
					TLMessageActionEmpty.CONSTRUCTOR -> TLMessageActionEmpty()
					TLMessageActionChatCreate.CONSTRUCTOR -> TLMessageActionChatCreate()
					TLMessageActionChatEditTitle.CONSTRUCTOR -> TLMessageActionChatEditTitle()
					TLMessageActionChatEditPhoto.CONSTRUCTOR -> TLMessageActionChatEditPhoto()
					TLMessageActionChatDeletePhoto.CONSTRUCTOR -> TLMessageActionChatDeletePhoto()
					TLMessageActionChatAddUser.CONSTRUCTOR -> TLMessageActionChatAddUser()
					TLMessageActionChatDeleteUser.CONSTRUCTOR -> TLMessageActionChatDeleteUser()
					TLMessageActionChatJoinedByLink.CONSTRUCTOR -> TLMessageActionChatJoinedByLink()
					TLMessageActionChannelCreate.CONSTRUCTOR -> TLMessageActionChannelCreate()
					TLMessageActionChatMigrateTo.CONSTRUCTOR -> TLMessageActionChatMigrateTo()
					TLMessageActionChannelMigrateFrom.CONSTRUCTOR -> TLMessageActionChannelMigrateFrom()
					TLMessageActionPinMessage.CONSTRUCTOR -> TLMessageActionPinMessage()
					TLMessageActionHistoryClear.CONSTRUCTOR -> TLMessageActionHistoryClear()
					TLMessageActionGameScore.CONSTRUCTOR -> TLMessageActionGameScore()
					TLMessageActionPaymentSentMe.CONSTRUCTOR -> TLMessageActionPaymentSentMe()
					TLMessageActionPaymentSent.CONSTRUCTOR -> TLMessageActionPaymentSent()
					TLMessageActionPhoneCall.CONSTRUCTOR -> TLMessageActionPhoneCall()
					TLMessageActionScreenshotTaken.CONSTRUCTOR -> TLMessageActionScreenshotTaken()
					TLMessageActionCustomAction.CONSTRUCTOR -> TLMessageActionCustomAction()
					TLMessageActionBotAllowed.CONSTRUCTOR -> TLMessageActionBotAllowed()
					TLMessageActionSecureValuesSentMe.CONSTRUCTOR -> TLMessageActionSecureValuesSentMe()
					TLMessageActionSecureValuesSent.CONSTRUCTOR -> TLMessageActionSecureValuesSent()
					TLMessageActionContactSignUp.CONSTRUCTOR -> TLMessageActionContactSignUp()
					TLMessageActionGeoProximityReached.CONSTRUCTOR -> TLMessageActionGeoProximityReached()
					TLMessageActionGroupCall.CONSTRUCTOR -> TLMessageActionGroupCall()
					TLMessageActionInviteToGroupCall.CONSTRUCTOR -> TLMessageActionInviteToGroupCall()
					TLMessageActionSetMessagesTTL.CONSTRUCTOR -> TLMessageActionSetMessagesTTL()
					TLMessageActionGroupCallScheduled.CONSTRUCTOR -> TLMessageActionGroupCallScheduled()
					TLMessageActionSetChatTheme.CONSTRUCTOR -> TLMessageActionSetChatTheme()
					TLMessageActionChatJoinedByRequest.CONSTRUCTOR -> TLMessageActionChatJoinedByRequest()
					TLMessageActionWebViewDataSentMe.CONSTRUCTOR -> TLMessageActionWebViewDataSentMe()
					TLMessageActionWebViewDataSent.CONSTRUCTOR -> TLMessageActionWebViewDataSent()
					TLMessageActionGiftPremium.CONSTRUCTOR -> TLMessageActionGiftPremium()
					TLMessageActionBizDataRaw.CONSTRUCTOR -> TLMessageActionBizDataRaw()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessageAction")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessageActionEmpty: MessageAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb6aef7b0u.toInt()
		}
	}
	
	open class TLMessageActionChatCreate: MessageAction() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			title = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(title)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xbd47cbadu.toInt()
		}
	}
	
	open class TLMessageActionChatEditTitle: MessageAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			title = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(title)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb5a1ce5au.toInt()
		}
	}
	
	open class TLMessageActionChatEditPhoto: MessageAction() {
		@JvmField var photo: Photo? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			photo = Photo.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			photo?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7fcb13a8u.toInt()
		}
	}
	
	open class TLMessageActionChatDeletePhoto: MessageAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x95e3fbefu.toInt()
		}
	}
	
	open class TLMessageActionChatAddUser: MessageAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x15cefd00u.toInt()
		}
	}
	
	open class TLMessageActionChatDeleteUser: MessageAction() {
		@JvmField var userId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa43f30ccu.toInt()
		}
	}
	
	open class TLMessageActionChatJoinedByLink: MessageAction() {
		@JvmField var inviterId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			inviterId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(inviterId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x31224c3u.toInt()
		}
	}
	
	open class TLMessageActionChannelCreate: MessageAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			title = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(title)
		}
	
		companion object {
			val CONSTRUCTOR = 0x95d2ac92u.toInt()
		}
	}
	
	open class TLMessageActionChatMigrateTo: MessageAction() {
		@JvmField var channelId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			channelId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(channelId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe1037f92u.toInt()
		}
	}
	
	open class TLMessageActionChannelMigrateFrom: MessageAction() {
			@JvmField var chatId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			title = stream.readString(exception) ?: return
			chatId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(title)
			stream.writeInt64(chatId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xea3948e9u.toInt()
		}
	}
	
	open class TLMessageActionPinMessage: MessageAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x94bd38edu.toInt()
		}
	}
	
	open class TLMessageActionHistoryClear: MessageAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9fbab604u.toInt()
		}
	}
	
	open class TLMessageActionGameScore: MessageAction() {
		@JvmField var gameId = 0L
		@JvmField var score = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			gameId = stream.readInt64(exception)
			score = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(gameId)
			stream.writeInt32(score)
		}
	
		companion object {
			val CONSTRUCTOR = 0x92a72876u.toInt()
		}
	}
	
	open class TLMessageActionPaymentSentMe: MessageAction() {
							@JvmField var payload: ByteArray? = null
		@JvmField var info: TLPaymentRequestedInfo? = null
		@JvmField var shippingOptionId: String? = null
		@JvmField var charge: TLPaymentCharge? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			recurringInit = (flags and 4) != 0
			recurringUsed = (flags and 8) != 0
			currency = stream.readString(exception) ?: return
			totalAmount = stream.readInt64(exception)
			payload = stream.readByteArray(exception) ?: return
		
			if ((flags and 1) != 0) {
				info = TLPaymentRequestedInfo.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				shippingOptionId = stream.readString(exception) ?: return
			}
			charge = TLPaymentCharge.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (recurringInit) flags or 4 else flags and 4.inv()
			flags = if (recurringUsed) flags or 8 else flags and 8.inv()
			flags = if (info != null) flags or 1 else flags and 1.inv()
			flags = if (shippingOptionId != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeString(currency)
			stream.writeInt64(totalAmount)
			stream.writeByteArray(payload)
			if ((flags and 1) != 0) {
				info?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(shippingOptionId)
			}
	
			charge?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8f31b327u.toInt()
		}
	}
	
	open class TLMessageActionPaymentSent: MessageAction() {
							@JvmField var invoiceSlug: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			recurringInit = (flags and 4) != 0
			recurringUsed = (flags and 8) != 0
			currency = stream.readString(exception) ?: return
			totalAmount = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {
				invoiceSlug = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (recurringInit) flags or 4 else flags and 4.inv()
			flags = if (recurringUsed) flags or 8 else flags and 8.inv()
			flags = if (invoiceSlug != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeString(currency)
			stream.writeInt64(totalAmount)
			if ((flags and 1) != 0) {
				stream.writeString(invoiceSlug)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x96163f56u.toInt()
		}
	}
	
	open class TLMessageActionPhoneCall: MessageAction() {
			@JvmField var video = false
		@JvmField var callId = 0L
		@JvmField var reason: PhoneCallDiscardReason? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			video = (flags and 4) != 0
			callId = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {
				reason = PhoneCallDiscardReason.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				duration = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (video) flags or 4 else flags and 4.inv()
			flags = if (reason != null) flags or 1 else flags and 1.inv()
			flags = if (duration != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(callId)
			if ((flags and 1) != 0) {
				reason?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(duration)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x80e11a7fu.toInt()
		}
	}
	
	open class TLMessageActionScreenshotTaken: MessageAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x4792929bu.toInt()
		}
	}
	
	open class TLMessageActionCustomAction: MessageAction() {
		@JvmField var message: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			message = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(message)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfae69f56u.toInt()
		}
	}
	
	open class TLMessageActionBotAllowed: MessageAction() {
		@JvmField var domain: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			domain = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(domain)
		}
	
		companion object {
			val CONSTRUCTOR = 0xabe9affeu.toInt()
		}
	}
	
	open class TLMessageActionSecureValuesSentMe: MessageAction() {
		@JvmField val values = mutableListOf<TLSecureValue>()
		@JvmField var credentials: TLSecureCredentialsEncrypted? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLSecureValue.deserialize(stream, stream.readInt32(exception), exception) ?: return
				values.add(obj)
			}
			credentials = TLSecureCredentialsEncrypted.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(values.size)
			values.forEach { it.serializeToStream(stream) }
			credentials?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1b287353u.toInt()
		}
	}
	
	open class TLMessageActionSecureValuesSent: MessageAction() {
		@JvmField val types = mutableListOf<SecureValueType>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = SecureValueType.deserialize(stream, stream.readInt32(exception), exception) ?: return
				types.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(types.size)
			types.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xd95c6154u.toInt()
		}
	}
	
	open class TLMessageActionContactSignUp: MessageAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf3f25f76u.toInt()
		}
	}
	
	open class TLMessageActionGeoProximityReached: MessageAction() {
		@JvmField var fromId: Peer? = null
		@JvmField var toId: Peer? = null
		@JvmField var distance = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			fromId = Peer.deserialize(stream, stream.readInt32(exception), exception)
			toId = Peer.deserialize(stream, stream.readInt32(exception), exception)
			distance = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			fromId?.serializeToStream(stream)
			toId?.serializeToStream(stream)
			stream.writeInt32(distance)
		}
	
		companion object {
			val CONSTRUCTOR = 0x98e0d697u.toInt()
		}
	}
	
	open class TLMessageActionGroupCall: MessageAction() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			call = TLInputGroupCall.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				duration = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (duration != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			call?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(duration)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x7a0d7f42u.toInt()
		}
	}
	
	open class TLMessageActionInviteToGroupCall: MessageAction() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			call = TLInputGroupCall.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x502f92f7u.toInt()
		}
	}
	
	open class TLMessageActionSetMessagesTTL: MessageAction() {
		@JvmField var period = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			period = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(period)
		}
	
		companion object {
			val CONSTRUCTOR = 0xaa1afbfdu.toInt()
		}
	}
	
	open class TLMessageActionGroupCallScheduled: MessageAction() {
			@JvmField var scheduleDate = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			call = TLInputGroupCall.deserialize(stream, stream.readInt32(exception), exception)
			scheduleDate = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
			stream.writeInt32(scheduleDate)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb3a07661u.toInt()
		}
	}
	
	open class TLMessageActionSetChatTheme: MessageAction() {
		@JvmField var emoticon: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			emoticon = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(emoticon)
		}
	
		companion object {
			val CONSTRUCTOR = 0xaa786345u.toInt()
		}
	}
	
	open class TLMessageActionChatJoinedByRequest: MessageAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xebbca3cbu.toInt()
		}
	}
	
	open class TLMessageActionWebViewDataSentMe: MessageAction() {
			@JvmField var data: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = stream.readString(exception) ?: return
			data = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(text)
			stream.writeString(data)
		}
	
		companion object {
			val CONSTRUCTOR = 0x47dd8079u.toInt()
		}
	}
	
	open class TLMessageActionWebViewDataSent: MessageAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb4c38cb5u.toInt()
		}
	}
	
	open class TLMessageActionGiftPremium: MessageAction() {
			@JvmField var amount = 0L
		@JvmField var months = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			currency = stream.readString(exception) ?: return
			amount = stream.readInt64(exception)
			months = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(currency)
			stream.writeInt64(amount)
			stream.writeInt32(months)
		}
	
		companion object {
			val CONSTRUCTOR = 0xaba0f5c6u.toInt()
		}
	}
	
	open class TLMessageActionBizDataRaw: MessageAction() {
		@JvmField var bizData: TLBizDataRaw? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			bizData = TLBizDataRaw.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			bizData?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3623dd77u.toInt()
		}
	}
	
	open class TLInputPeerNotifySettings: TLObject() {
		@JvmField var flags = 0
		@JvmField var showPreviews = false
		@JvmField var silent = false
		@JvmField var muteUntil = 0
		@JvmField var sound: NotificationSound? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				showPreviews = stream.readBool(exception)
			}
		
			if ((flags and 2) != 0) {
				silent = stream.readBool(exception)
			}
		
			if ((flags and 4) != 0) {
				muteUntil = stream.readInt32(exception)
			}
		
			if ((flags and 8) != 0) {
				sound = NotificationSound.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (showPreviews) flags or 1 else flags and 1.inv()
			flags = if (silent) flags or 2 else flags and 2.inv()
			flags = if (muteUntil != 0) flags or 4 else flags and 4.inv()
			flags = if (sound != null) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeBool(showPreviews)
			}
	
			if ((flags and 2) != 0) {
				stream.writeBool(silent)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(muteUntil)
			}
	
			if ((flags and 8) != 0) {
				sound?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xdf1f002bu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLInputPeerNotifySettings? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLInputPeerNotifySettings")
					}
					else {
						null
					}
				}
	
				val result = TLInputPeerNotifySettings()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class Dialog: TLObject() {
		@JvmField var peer: Peer? = null
		@JvmField var flags = 0
		@JvmField var pinned = false
		@JvmField var topMessage = 0
		@JvmField var id: Long = 0L
		@JvmField var lastMessageDate: Int = 0
		@JvmField var pinnedNum: Int = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Dialog? {
				val result = when (constructor) {
					TLDialog.CONSTRUCTOR -> TLDialog()
					TLDialogFolder.CONSTRUCTOR -> TLDialogFolder()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in Dialog")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLDialog: Dialog() {
				@JvmField var unreadMark = false
				@JvmField var readInboxMaxId = 0
		@JvmField var readOutboxMaxId = 0
		@JvmField var unreadCount = 0
		@JvmField var unreadMentionsCount = 0
		@JvmField var unreadReactionsCount = 0
		@JvmField var notifySettings: PeerNotifySettings? = null
		@JvmField var pts = 0
		@JvmField var draft: DraftMessage? = null
		@JvmField var folderId = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			pinned = (flags and 4) != 0
			unreadMark = (flags and 8) != 0
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			topMessage = stream.readInt32(exception)
			readInboxMaxId = stream.readInt32(exception)
			readOutboxMaxId = stream.readInt32(exception)
			unreadCount = stream.readInt32(exception)
			unreadMentionsCount = stream.readInt32(exception)
			unreadReactionsCount = stream.readInt32(exception)
			notifySettings = PeerNotifySettings.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				pts = stream.readInt32(exception)
			}
		
			if ((flags and 2) != 0) {
				draft = DraftMessage.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 16) != 0) {
				folderId = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (pinned) flags or 4 else flags and 4.inv()
			flags = if (unreadMark) flags or 8 else flags and 8.inv()
			flags = if (pts != 0) flags or 1 else flags and 1.inv()
			flags = if (draft != null) flags or 2 else flags and 2.inv()
			flags = if (folderId != 0) flags or 16 else flags and 16.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt32(topMessage)
			stream.writeInt32(readInboxMaxId)
			stream.writeInt32(readOutboxMaxId)
			stream.writeInt32(unreadCount)
			stream.writeInt32(unreadMentionsCount)
			stream.writeInt32(unreadReactionsCount)
			notifySettings?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(pts)
			}
	
			if ((flags and 2) != 0) {
				draft?.serializeToStream(stream)
			}
	
			if ((flags and 16) != 0) {
				stream.writeInt32(folderId)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa8edd0f5u.toInt()
		}
	}
	
	open class TLDialogFolder: Dialog() {
				@JvmField var folder: TLFolder? = null
				@JvmField var unreadMutedPeersCount = 0
		@JvmField var unreadUnmutedPeersCount = 0
		@JvmField var unreadMutedMessagesCount = 0
		@JvmField var unreadUnmutedMessagesCount = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			pinned = (flags and 4) != 0
			folder = TLFolder.deserialize(stream, stream.readInt32(exception), exception)
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			topMessage = stream.readInt32(exception)
			unreadMutedPeersCount = stream.readInt32(exception)
			unreadUnmutedPeersCount = stream.readInt32(exception)
			unreadMutedMessagesCount = stream.readInt32(exception)
			unreadUnmutedMessagesCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (pinned) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			folder?.serializeToStream(stream)
			peer?.serializeToStream(stream)
			stream.writeInt32(topMessage)
			stream.writeInt32(unreadMutedPeersCount)
			stream.writeInt32(unreadUnmutedPeersCount)
			stream.writeInt32(unreadMutedMessagesCount)
			stream.writeInt32(unreadUnmutedMessagesCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0x71bd134cu.toInt()
		}
	}
	
	abstract class Photo: TLObject() {
		@JvmField var id = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Photo? {
				val result = when (constructor) {
					TLPhotoEmpty.CONSTRUCTOR -> TLPhotoEmpty()
					TLPhoto.CONSTRUCTOR -> TLPhoto()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in Photo")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPhotoEmpty: Photo() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2331b22du.toInt()
		}
	}
	
	open class TLPhoto: Photo() {
		@JvmField var flags = 0
		@JvmField var hasStickers = false
			@JvmField var accessHash = 0L
		@JvmField var fileReference: ByteArray? = null
		@JvmField var date = 0
		@JvmField val sizes = mutableListOf<PhotoSize>()
		@JvmField val videoSizes = mutableListOf<VideoSize>()
		@JvmField var dcId = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			hasStickers = (flags and 1) != 0
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			fileReference = stream.readByteArray(exception) ?: return
			date = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = PhotoSize.deserialize(stream, stream.readInt32(exception), exception) ?: return
				sizes.add(obj)
			}
		
			if ((flags and 2) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = VideoSize.deserialize(stream, stream.readInt32(exception), exception) ?: return
					videoSizes.add(obj)
				}
			}
			dcId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (hasStickers) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeByteArray(fileReference)
			stream.writeInt32(date)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(sizes.size)
			sizes.forEach { it.serializeToStream(stream) }
			if ((flags and 2) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(videoSizes.size)
			videoSizes.forEach { it.serializeToStream(stream) }
			}
	
			stream.writeInt32(dcId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfb197a65u.toInt()
		}
	}
	
	abstract class PhotoSize: TLObject() {
		@JvmField val sizes = mutableListOf<Int>()
		@JvmField var location: FileLocation? = null
		@JvmField var size = 0
		@JvmField var h = 0
		@JvmField var type: String? = null
		@JvmField var w = 0
		@JvmField var bytes: ByteArray? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PhotoSize? {
				val result = when (constructor) {
					TLPhotoSizeEmpty.CONSTRUCTOR -> TLPhotoSizeEmpty()
					TLPhotoSize.CONSTRUCTOR -> TLPhotoSize()
					TLPhotoCachedSize.CONSTRUCTOR -> TLPhotoCachedSize()
					TLPhotoStrippedSize.CONSTRUCTOR -> TLPhotoStrippedSize()
					TLPhotoSizeProgressive.CONSTRUCTOR -> TLPhotoSizeProgressive()
					TLPhotoPathSize.CONSTRUCTOR -> TLPhotoPathSize()
					TLPhotoSizeLayer127.CONSTRUCTOR -> TLPhotoSizeLayer127()
					TLPhotoCachedSizeLayer127.CONSTRUCTOR -> TLPhotoCachedSizeLayer127()
					TLPhotoSizeProgressiveLayer127.CONSTRUCTOR -> TLPhotoSizeProgressiveLayer127()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in PhotoSize")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPhotoSizeEmpty: PhotoSize() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(type)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe17e23cu.toInt()
		}
	}
	
	open class TLPhotoSize: PhotoSize() {
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = stream.readString(exception) ?: return
			w = stream.readInt32(exception)
			h = stream.readInt32(exception)
			size = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(type)
			stream.writeInt32(w)
			stream.writeInt32(h)
			stream.writeInt32(size)
		}
	
		companion object {
			val CONSTRUCTOR = 0x75c78e60u.toInt()
		}
	}
	
	open class TLPhotoCachedSize: PhotoSize() {
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = stream.readString(exception) ?: return
			w = stream.readInt32(exception)
			h = stream.readInt32(exception)
			bytes = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(type)
			stream.writeInt32(w)
			stream.writeInt32(h)
			stream.writeByteArray(bytes)
		}
	
		companion object {
			val CONSTRUCTOR = 0x21e1ad6u.toInt()
		}
	}
	
	open class TLPhotoStrippedSize: PhotoSize() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = stream.readString(exception) ?: return
			bytes = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(type)
			stream.writeByteArray(bytes)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe0b0bc2eu.toInt()
		}
	}
	
	open class TLPhotoSizeProgressive: PhotoSize() {
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = stream.readString(exception) ?: return
			w = stream.readInt32(exception)
			h = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt32(exception)
				sizes.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(type)
			stream.writeInt32(w)
			stream.writeInt32(h)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(sizes.size)
			sizes.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xfa3efb95u.toInt()
		}
	}
	
	open class TLPhotoPathSize: PhotoSize() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = stream.readString(exception) ?: return
			bytes = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(type)
			stream.writeByteArray(bytes)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd8214d41u.toInt()
		}
	}
	
	open class TLPhotoSizeLayer127: TLPhotoSize() {
						
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			location = FileLocation.deserialize(stream, stream.readInt32(exception), exception)
			type = stream.readString(exception) ?: return
			w = stream.readInt32(exception)
			h = stream.readInt32(exception)
			size = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			location?.serializeToStream(stream)
			stream.writeString(type)
			stream.writeInt32(w)
			stream.writeInt32(h)
			stream.writeInt32(size)
		}
	
		companion object {
			val CONSTRUCTOR = 0x77bfb61bu.toInt()
		}
	}
	
	open class TLPhotoCachedSizeLayer127: TLPhotoCachedSize() {
						
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = stream.readString(exception) ?: return
			location = FileLocation.deserialize(stream, stream.readInt32(exception), exception)
			w = stream.readInt32(exception)
			h = stream.readInt32(exception)
			bytes = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(type)
			location?.serializeToStream(stream)
			stream.writeInt32(w)
			stream.writeInt32(h)
			stream.writeByteArray(bytes)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe9a734fau.toInt()
		}
	}
	
	open class TLPhotoSizeProgressiveLayer127: TLPhotoSizeProgressive() {
						
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = stream.readString(exception) ?: return
			location = FileLocation.deserialize(stream, stream.readInt32(exception), exception)
			w = stream.readInt32(exception)
			h = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt32(exception)
				sizes.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(type)
			location?.serializeToStream(stream)
			stream.writeInt32(w)
			stream.writeInt32(h)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(sizes.size)
			sizes.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x5aa86a51u.toInt()
		}
	}
	
	abstract class GeoPoint: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): GeoPoint? {
				val result = when (constructor) {
					TLGeoPointEmpty.CONSTRUCTOR -> TLGeoPointEmpty()
					TLGeoPoint.CONSTRUCTOR -> TLGeoPoint()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in GeoPoint")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLGeoPointEmpty: GeoPoint() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1117dd5fu.toInt()
		}
	}
	
	open class TLGeoPoint: GeoPoint() {
		@JvmField var flags = 0
		@JvmField var lon = 0.0
		@JvmField var lat = 0.0
		@JvmField var accessHash = 0L
		@JvmField var accuracyRadius = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			lon = stream.readDouble(exception)
			lat = stream.readDouble(exception)
			accessHash = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {
				accuracyRadius = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (accuracyRadius != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeDouble(lon)
			stream.writeDouble(lat)
			stream.writeInt64(accessHash)
			if ((flags and 1) != 0) {
				stream.writeInt32(accuracyRadius)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb2a2f663u.toInt()
		}
	}
	
	abstract class AuthSentCode: TLObject() {
		@JvmField var phoneCodeHash: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthSentCode? {
				val result = when (constructor) {
					TLAuthSentCode.CONSTRUCTOR -> TLAuthSentCode()
					TLAuthSentCodeSuccess.CONSTRUCTOR -> TLAuthSentCodeSuccess()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in AuthSentCode")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLAuthSentCode: AuthSentCode() {
		@JvmField var flags = 0
		@JvmField var type: AuthSentCodeType? = null
			@JvmField var nextType: AuthCodeType? = null
		@JvmField var timeout = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			type = AuthSentCodeType.deserialize(stream, stream.readInt32(exception), exception)
			phoneCodeHash = stream.readString(exception) ?: return
		
			if ((flags and 2) != 0) {
				nextType = AuthCodeType.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 4) != 0) {
				timeout = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (nextType != null) flags or 2 else flags and 2.inv()
			flags = if (timeout != 0) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			type?.serializeToStream(stream)
			stream.writeString(phoneCodeHash)
			if ((flags and 2) != 0) {
				nextType?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(timeout)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x5e002502u.toInt()
		}
	}
	
	open class TLAuthSentCodeSuccess: AuthSentCode() {
		@JvmField var authorization: AuthAuthorization? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			authorization = AuthAuthorization.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			authorization?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x129b13deu.toInt()
		}
	}
	
	open class TLAuthSendCode: TLObject() {
		@JvmField var phoneNumber: String? = null
		@JvmField var apiId = 0
		@JvmField var apiHash: String? = null
		@JvmField var settings: TLCodeSettings? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthSentCode? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AuthSentCode.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phoneNumber)
			stream.writeInt32(apiId)
			stream.writeString(apiHash)
			settings?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa677244fu.toInt()
		}
	}
	
	open class TLAuthResendCode: TLObject() {
		@JvmField var phoneNumber: String? = null
		@JvmField var phoneCodeHash: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthSentCode? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AuthSentCode.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phoneNumber)
			stream.writeString(phoneCodeHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3ef1a9bfu.toInt()
		}
	}
	
	open class TLAccountSendChangePhoneCode: TLObject() {
		@JvmField var phoneNumber: String? = null
		@JvmField var settings: TLCodeSettings? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthSentCode? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AuthSentCode.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phoneNumber)
			settings?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x82574ae5u.toInt()
		}
	}
	
	open class TLAccountSendConfirmPhoneCode: TLObject() {
		@JvmField var hash: String? = null
		@JvmField var settings: TLCodeSettings? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthSentCode? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AuthSentCode.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(hash)
			settings?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1b3faa88u.toInt()
		}
	}
	
	open class TLAccountSendVerifyPhoneCode: TLObject() {
		@JvmField var phoneNumber: String? = null
		@JvmField var settings: TLCodeSettings? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthSentCode? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AuthSentCode.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phoneNumber)
			settings?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa5a356f9u.toInt()
		}
	}
	
	abstract class AuthAuthorization: TLObject() {
		@JvmField var otherwiseReloginDays = 0
		@JvmField var flags = 0
		@JvmField var tmpSessions = 0
		@JvmField var setupPasswordRequired = false
		@JvmField var user: User? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthAuthorization? {
				val result = when (constructor) {
					TLAuthAuthorization.CONSTRUCTOR -> TLAuthAuthorization()
					TLAuthAuthorizationSignUpRequired.CONSTRUCTOR -> TLAuthAuthorizationSignUpRequired()
					TLAuthAuthorizationLayer3.CONSTRUCTOR -> TLAuthAuthorizationLayer3()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in AuthAuthorization")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLAuthAuthorization: AuthAuthorization() {
						
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			setupPasswordRequired = (flags and 2) != 0
		
			if ((flags and 2) != 0) {
				otherwiseReloginDays = stream.readInt32(exception)
			}
		
			if ((flags and 1) != 0) {
				tmpSessions = stream.readInt32(exception)
			}
			user = User.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (setupPasswordRequired) flags or 2 else flags and 2.inv()
			flags = if (otherwiseReloginDays != 0) flags or 2 else flags and 2.inv()
			flags = if (tmpSessions != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 2) != 0) {
				stream.writeInt32(otherwiseReloginDays)
			}
	
			if ((flags and 1) != 0) {
				stream.writeInt32(tmpSessions)
			}
	
			user?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x33fb7bb8u.toInt()
		}
	}
	
	open class TLAuthAuthorizationSignUpRequired: AuthAuthorization() {
			@JvmField var termsOfService: TLHelpTermsOfService? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				termsOfService = TLHelpTermsOfService.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (termsOfService != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				termsOfService?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x44747e9au.toInt()
		}
	}
	
	open class TLAuthAuthorizationLayer3: AuthAuthorization() {
							@JvmField var fullUser: TLUserFull? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			setupPasswordRequired = (flags and 2) != 0
		
			if ((flags and 2) != 0) {
				otherwiseReloginDays = stream.readInt32(exception)
			}
		
			if ((flags and 1) != 0) {
				tmpSessions = stream.readInt32(exception)
			}
			user = User.deserialize(stream, stream.readInt32(exception), exception)
			fullUser = TLUserFull.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (setupPasswordRequired) flags or 2 else flags and 2.inv()
			flags = if (otherwiseReloginDays != 0) flags or 2 else flags and 2.inv()
			flags = if (tmpSessions != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 2) != 0) {
				stream.writeInt32(otherwiseReloginDays)
			}
	
			if ((flags and 1) != 0) {
				stream.writeInt32(tmpSessions)
			}
	
			user?.serializeToStream(stream)
			fullUser?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x13edc64du.toInt()
		}
	}
	
	open class TLAuthSignUp: TLObject() {
		@JvmField var phoneNumber: String? = null
		@JvmField var phoneCodeHash: String? = null
		@JvmField var firstName: String? = null
		@JvmField var lastName: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthAuthorization? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AuthAuthorization.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phoneNumber)
			stream.writeString(phoneCodeHash)
			stream.writeString(firstName)
			stream.writeString(lastName)
		}
	
		companion object {
			val CONSTRUCTOR = 0x80eee427u.toInt()
		}
	}
	
	open class TLAuthSignIn: TLObject() {
		@JvmField var flags = 0
		@JvmField var phoneNumber: String? = null
		@JvmField var phoneCodeHash: String? = null
		@JvmField var phoneCode: String? = null
		@JvmField var emailVerification: EmailVerification? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthAuthorization? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AuthAuthorization.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (phoneCode != null) flags or 1 else flags and 1.inv()
			flags = if (emailVerification != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeString(phoneNumber)
			stream.writeString(phoneCodeHash)
			if ((flags and 1) != 0) {
				stream.writeString(phoneCode)
			}
	
			if ((flags and 2) != 0) {
				emailVerification?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8d52a951u.toInt()
		}
	}
	
	open class TLAuthImportAuthorization: TLObject() {
		@JvmField var id = 0L
		@JvmField var bytes: ByteArray? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthAuthorization? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AuthAuthorization.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeByteArray(bytes)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa57a7dadu.toInt()
		}
	}
	
	open class TLAuthImportBotAuthorization: TLObject() {
		@JvmField var flags = 0
		@JvmField var apiId = 0
		@JvmField var apiHash: String? = null
		@JvmField var botAuthToken: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthAuthorization? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AuthAuthorization.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(flags)
			stream.writeInt32(apiId)
			stream.writeString(apiHash)
			stream.writeString(botAuthToken)
		}
	
		companion object {
			val CONSTRUCTOR = 0x67a3ff2cu.toInt()
		}
	}
	
	open class TLAuthCheckPassword: TLObject() {
		@JvmField var password: InputCheckPasswordSRP? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthAuthorization? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AuthAuthorization.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			password?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd18b4d16u.toInt()
		}
	}
	
	open class TLAuthRecoverPassword: TLObject() {
		@JvmField var flags = 0
		@JvmField var code: String? = null
		@JvmField var newSettings: TLAccountPasswordInputSettings? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthAuthorization? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AuthAuthorization.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (newSettings != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeString(code)
			if ((flags and 1) != 0) {
				newSettings?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x37096c70u.toInt()
		}
	}
	
	open class TLAuthExportedAuthorization: TLObject() {
		@JvmField var id = 0L
		@JvmField var bytes: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			bytes = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeByteArray(bytes)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb434e2b8u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAuthExportedAuthorization? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAuthExportedAuthorization")
					}
					else {
						null
					}
				}
	
				val result = TLAuthExportedAuthorization()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAuthExportAuthorization: TLObject() {
		@JvmField var dcId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAuthExportedAuthorization? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAuthExportedAuthorization.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(dcId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe5bfffcdu.toInt()
		}
	}
	
	abstract class InputNotifyPeer: TLObject() {
		@JvmField var peer: InputPeer? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputNotifyPeer? {
				val result = when (constructor) {
					TLInputNotifyPeer.CONSTRUCTOR -> TLInputNotifyPeer()
					TLInputNotifyUsers.CONSTRUCTOR -> TLInputNotifyUsers()
					TLInputNotifyChats.CONSTRUCTOR -> TLInputNotifyChats()
					TLInputNotifyBroadcasts.CONSTRUCTOR -> TLInputNotifyBroadcasts()
					TLInputNotifyForumTopic.CONSTRUCTOR -> TLInputNotifyForumTopic()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputNotifyPeer")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputNotifyPeer: InputNotifyPeer() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = InputPeer.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb8bc5b0cu.toInt()
		}
	}
	
	open class TLInputNotifyUsers: InputNotifyPeer() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x193b4417u.toInt()
		}
	}
	
	open class TLInputNotifyChats: InputNotifyPeer() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x4a95e84eu.toInt()
		}
	}
	
	open class TLInputNotifyBroadcasts: InputNotifyPeer() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb1db7c7eu.toInt()
		}
	}
	
	open class TLInputNotifyForumTopic: InputNotifyPeer() {
			@JvmField var topMsgId = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = InputPeer.deserialize(stream, stream.readInt32(exception), exception)
			topMsgId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(topMsgId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5c467992u.toInt()
		}
	}
	
	abstract class PeerNotifySettings: TLObject() {
		@JvmField var iosSound: NotificationSound? = null
		@JvmField var androidSound: NotificationSound? = null
		@JvmField var muteUntil = 0
		@JvmField var silent = false
		@JvmField var flags = 0
		@JvmField var otherSound: NotificationSound? = null
		@JvmField var showPreviews = false
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PeerNotifySettings? {
				val result = when (constructor) {
					TLPeerNotifySettings.CONSTRUCTOR -> TLPeerNotifySettings()
					TLPeerNotifySettingsLayer3.CONSTRUCTOR -> TLPeerNotifySettingsLayer3()
					TLPeerPeerNotifySettings.CONSTRUCTOR -> TLPeerPeerNotifySettings()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in PeerNotifySettings")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPeerNotifySettings: PeerNotifySettings() {
								
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				showPreviews = stream.readBool(exception)
			}
		
			if ((flags and 2) != 0) {
				silent = stream.readBool(exception)
			}
		
			if ((flags and 4) != 0) {
				muteUntil = stream.readInt32(exception)
			}
		
			if ((flags and 8) != 0) {
				iosSound = NotificationSound.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 16) != 0) {
				androidSound = NotificationSound.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 32) != 0) {
				otherSound = NotificationSound.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (showPreviews) flags or 1 else flags and 1.inv()
			flags = if (silent) flags or 2 else flags and 2.inv()
			flags = if (muteUntil != 0) flags or 4 else flags and 4.inv()
			flags = if (iosSound != null) flags or 8 else flags and 8.inv()
			flags = if (androidSound != null) flags or 16 else flags and 16.inv()
			flags = if (otherSound != null) flags or 32 else flags and 32.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeBool(showPreviews)
			}
	
			if ((flags and 2) != 0) {
				stream.writeBool(silent)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(muteUntil)
			}
	
			if ((flags and 8) != 0) {
				iosSound?.serializeToStream(stream)
			}
	
			if ((flags and 16) != 0) {
				androidSound?.serializeToStream(stream)
			}
	
			if ((flags and 32) != 0) {
				otherSound?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa83b0426u.toInt()
		}
	}
	
	open class TLPeerNotifySettingsLayer3: PeerNotifySettings() {
									@JvmField var sound: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				showPreviews = stream.readBool(exception)
			}
		
			if ((flags and 2) != 0) {
				silent = stream.readBool(exception)
			}
		
			if ((flags and 4) != 0) {
				muteUntil = stream.readInt32(exception)
			}
		
			if ((flags and 8) != 0) {
				iosSound = NotificationSound.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 16) != 0) {
				androidSound = NotificationSound.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 32) != 0) {
				otherSound = NotificationSound.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 64) != 0) {
				sound = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (showPreviews) flags or 1 else flags and 1.inv()
			flags = if (silent) flags or 2 else flags and 2.inv()
			flags = if (muteUntil != 0) flags or 4 else flags and 4.inv()
			flags = if (iosSound != null) flags or 8 else flags and 8.inv()
			flags = if (androidSound != null) flags or 16 else flags and 16.inv()
			flags = if (otherSound != null) flags or 32 else flags and 32.inv()
			flags = if (sound != null) flags or 64 else flags and 64.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeBool(showPreviews)
			}
	
			if ((flags and 2) != 0) {
				stream.writeBool(silent)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(muteUntil)
			}
	
			if ((flags and 8) != 0) {
				iosSound?.serializeToStream(stream)
			}
	
			if ((flags and 16) != 0) {
				androidSound?.serializeToStream(stream)
			}
	
			if ((flags and 32) != 0) {
				otherSound?.serializeToStream(stream)
			}
	
			if ((flags and 64) != 0) {
				stream.writeString(sound)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x590dfbdfu.toInt()
		}
	}
	
	open class TLPeerPeerNotifySettings: PeerNotifySettings() {
		@JvmField var peerType = 0
		@JvmField var peerId = 0L
		@JvmField var settings: PeerNotifySettings? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peerType = stream.readInt32(exception)
			peerId = stream.readInt64(exception)
			settings = PeerNotifySettings.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(peerType)
			stream.writeInt64(peerId)
			settings?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa0e06dc5u.toInt()
		}
	}
	
	open class TLAccountGetNotifySettings: TLObject() {
		@JvmField var peer: InputNotifyPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PeerNotifySettings? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return PeerNotifySettings.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x12b3ad31u.toInt()
		}
	}
	
	open class TLPeerSettings: TLObject() {
		@JvmField var flags = 0
		@JvmField var reportSpam = false
		@JvmField var addContact = false
		@JvmField var blockContact = false
		@JvmField var shareContact = false
		@JvmField var needContactsException = false
		@JvmField var reportGeo = false
		@JvmField var autoarchived = false
		@JvmField var inviteMembers = false
		@JvmField var requestChatBroadcast = false
		@JvmField var geoDistance = 0
		@JvmField var requestChatTitle: String? = null
		@JvmField var requestChatDate = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			reportSpam = (flags and 1) != 0
			addContact = (flags and 2) != 0
			blockContact = (flags and 4) != 0
			shareContact = (flags and 8) != 0
			needContactsException = (flags and 16) != 0
			reportGeo = (flags and 32) != 0
			autoarchived = (flags and 128) != 0
			inviteMembers = (flags and 256) != 0
			requestChatBroadcast = (flags and 1024) != 0
		
			if ((flags and 64) != 0) {
				geoDistance = stream.readInt32(exception)
			}
		
			if ((flags and 512) != 0) {
				requestChatTitle = stream.readString(exception) ?: return
			}
		
			if ((flags and 512) != 0) {
				requestChatDate = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (reportSpam) flags or 1 else flags and 1.inv()
			flags = if (addContact) flags or 2 else flags and 2.inv()
			flags = if (blockContact) flags or 4 else flags and 4.inv()
			flags = if (shareContact) flags or 8 else flags and 8.inv()
			flags = if (needContactsException) flags or 16 else flags and 16.inv()
			flags = if (reportGeo) flags or 32 else flags and 32.inv()
			flags = if (autoarchived) flags or 128 else flags and 128.inv()
			flags = if (inviteMembers) flags or 256 else flags and 256.inv()
			flags = if (requestChatBroadcast) flags or 1024 else flags and 1024.inv()
			flags = if (geoDistance != 0) flags or 64 else flags and 64.inv()
			flags = if (requestChatTitle != null) flags or 512 else flags and 512.inv()
			flags = if (requestChatDate != 0) flags or 512 else flags and 512.inv()
	
			stream.writeInt32(flags)
			if ((flags and 64) != 0) {
				stream.writeInt32(geoDistance)
			}
	
			if ((flags and 512) != 0) {
				stream.writeString(requestChatTitle)
			}
	
			if ((flags and 512) != 0) {
				stream.writeInt32(requestChatDate)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa518110du.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPeerSettings? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPeerSettings")
					}
					else {
						null
					}
				}
	
				val result = TLPeerSettings()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class WallPaper: TLObject() {
		@JvmField var settings: TLWallPaperSettings? = null
		@JvmField var flags = 0
		@JvmField var id = 0L
		@JvmField var dark = false
		@JvmField var isDefault = false
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): WallPaper? {
				val result = when (constructor) {
					TLWallPaper.CONSTRUCTOR -> TLWallPaper()
					TLWallPaperNoFile.CONSTRUCTOR -> TLWallPaperNoFile()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in WallPaper")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLWallPaper: WallPaper() {
				@JvmField var creator = false
			@JvmField var pattern = false
			@JvmField var accessHash = 0L
		@JvmField var slug: String? = null
		@JvmField var document: Document? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			flags = stream.readInt32(exception)
			creator = (flags and 1) != 0
			isDefault = (flags and 2) != 0
			pattern = (flags and 8) != 0
			dark = (flags and 16) != 0
			accessHash = stream.readInt64(exception)
			slug = stream.readString(exception) ?: return
			document = Document.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 4) != 0) {
				settings = TLWallPaperSettings.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (creator) flags or 1 else flags and 1.inv()
			flags = if (isDefault) flags or 2 else flags and 2.inv()
			flags = if (pattern) flags or 8 else flags and 8.inv()
			flags = if (dark) flags or 16 else flags and 16.inv()
			flags = if (settings != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt64(id)
			stream.writeInt32(flags)
			stream.writeInt64(accessHash)
			stream.writeString(slug)
			document?.serializeToStream(stream)
			if ((flags and 4) != 0) {
				settings?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa437c3edu.toInt()
		}
	}
	
	open class TLWallPaperNoFile: WallPaper() {
						
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			flags = stream.readInt32(exception)
			isDefault = (flags and 2) != 0
			dark = (flags and 16) != 0
		
			if ((flags and 4) != 0) {
				settings = TLWallPaperSettings.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (isDefault) flags or 2 else flags and 2.inv()
			flags = if (dark) flags or 16 else flags and 16.inv()
			flags = if (settings != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt64(id)
			stream.writeInt32(flags)
			if ((flags and 4) != 0) {
				settings?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe0804116u.toInt()
		}
	}
	
	open class TLAccountGetWallPaper: TLObject() {
		@JvmField var wallpaper: InputWallPaper? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): WallPaper? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return WallPaper.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			wallpaper?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfc8ddbeau.toInt()
		}
	}
	
	open class TLAccountUploadWallPaper: TLObject() {
		@JvmField var file: InputFile? = null
		@JvmField var mimeType: String? = null
		@JvmField var settings: TLWallPaperSettings? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): WallPaper? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return WallPaper.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			file?.serializeToStream(stream)
			stream.writeString(mimeType)
			settings?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdd853661u.toInt()
		}
	}
	
	abstract class ReportReason: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ReportReason? {
				val result = when (constructor) {
					TLInputReportReasonSpam.CONSTRUCTOR -> TLInputReportReasonSpam()
					TLInputReportReasonViolence.CONSTRUCTOR -> TLInputReportReasonViolence()
					TLInputReportReasonPornography.CONSTRUCTOR -> TLInputReportReasonPornography()
					TLInputReportReasonChildAbuse.CONSTRUCTOR -> TLInputReportReasonChildAbuse()
					TLInputReportReasonOther.CONSTRUCTOR -> TLInputReportReasonOther()
					TLInputReportReasonCopyright.CONSTRUCTOR -> TLInputReportReasonCopyright()
					TLInputReportReasonGeoIrrelevant.CONSTRUCTOR -> TLInputReportReasonGeoIrrelevant()
					TLInputReportReasonFake.CONSTRUCTOR -> TLInputReportReasonFake()
					TLInputReportReasonIllegalDrugs.CONSTRUCTOR -> TLInputReportReasonIllegalDrugs()
					TLInputReportReasonPersonalDetails.CONSTRUCTOR -> TLInputReportReasonPersonalDetails()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ReportReason")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputReportReasonSpam: ReportReason() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x58dbcab8u.toInt()
		}
	}
	
	open class TLInputReportReasonViolence: ReportReason() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1e22c78du.toInt()
		}
	}
	
	open class TLInputReportReasonPornography: ReportReason() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x2e59d922u.toInt()
		}
	}
	
	open class TLInputReportReasonChildAbuse: ReportReason() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xadf44ee3u.toInt()
		}
	}
	
	open class TLInputReportReasonOther: ReportReason() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc1e4a2b1u.toInt()
		}
	}
	
	open class TLInputReportReasonCopyright: ReportReason() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9b89f93au.toInt()
		}
	}
	
	open class TLInputReportReasonGeoIrrelevant: ReportReason() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xdbd4feedu.toInt()
		}
	}
	
	open class TLInputReportReasonFake: ReportReason() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf5ddd6e7u.toInt()
		}
	}
	
	open class TLInputReportReasonIllegalDrugs: ReportReason() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa8eb2beu.toInt()
		}
	}
	
	open class TLInputReportReasonPersonalDetails: ReportReason() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9ec7863du.toInt()
		}
	}
	
	open class TLUserFull: TLObject() {
		@JvmField var flags = 0
		@JvmField var blocked = false
		@JvmField var phoneCallsAvailable = false
		@JvmField var phoneCallsPrivate = false
		@JvmField var canPinMessage = false
		@JvmField var hasScheduled = false
		@JvmField var videoCallsAvailable = false
		@JvmField var voiceMessagesForbidden = false
		@JvmField var id = 0L
		@JvmField var about: String? = null
		@JvmField var settings: TLPeerSettings? = null
		@JvmField var profilePhoto: Photo? = null
		@JvmField var notifySettings: PeerNotifySettings? = null
		@JvmField var botInfo: TLBotInfo? = null
		@JvmField var pinnedMsgId = 0
		@JvmField var commonChatsCount = 0
		@JvmField var folderId = 0
		@JvmField var ttlPeriod = 0
		@JvmField var themeEmoticon: String? = null
		@JvmField var privateForwardName: String? = null
		@JvmField var botGroupAdminRights: TLChatAdminRights? = null
		@JvmField var botBroadcastAdminRights: TLChatAdminRights? = null
		@JvmField val premiumGifts = mutableListOf<TLPremiumGiftOption>()
		@JvmField var email: String? = null
		@JvmField var country: String? = null
		@JvmField var isPublic = false
		@JvmField var business = false
		@JvmField var gender: String? = null
		@JvmField var date = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			blocked = (flags and 1) != 0
			phoneCallsAvailable = (flags and 16) != 0
			phoneCallsPrivate = (flags and 32) != 0
			canPinMessage = (flags and 128) != 0
			hasScheduled = (flags and 4096) != 0
			videoCallsAvailable = (flags and 8192) != 0
			voiceMessagesForbidden = (flags and 1048576) != 0
			id = stream.readInt64(exception)
		
			if ((flags and 2) != 0) {
				about = stream.readString(exception) ?: return
			}
			settings = TLPeerSettings.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 4) != 0) {
				profilePhoto = Photo.deserialize(stream, stream.readInt32(exception), exception)
			}
			notifySettings = PeerNotifySettings.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 8) != 0) {
				botInfo = TLBotInfo.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 64) != 0) {
				pinnedMsgId = stream.readInt32(exception)
			}
			commonChatsCount = stream.readInt32(exception)
		
			if ((flags and 2048) != 0) {
				folderId = stream.readInt32(exception)
			}
		
			if ((flags and 16384) != 0) {
				ttlPeriod = stream.readInt32(exception)
			}
		
			if ((flags and 32768) != 0) {
				themeEmoticon = stream.readString(exception) ?: return
			}
		
			if ((flags and 65536) != 0) {
				privateForwardName = stream.readString(exception) ?: return
			}
		
			if ((flags and 131072) != 0) {
				botGroupAdminRights = TLChatAdminRights.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 262144) != 0) {
				botBroadcastAdminRights = TLChatAdminRights.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 524288) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLPremiumGiftOption.deserialize(stream, stream.readInt32(exception), exception) ?: return
					premiumGifts.add(obj)
				}
			}
		
			if ((flags and 8388608) != 0) {
				email = stream.readString(exception) ?: return
			}
		
			if ((flags and 16777216) != 0) {
				country = stream.readString(exception) ?: return
			}
			isPublic = (flags and 2097152) != 0
			business = (flags and 4194304) != 0
		
			if ((flags and 33554432) != 0) {
				gender = stream.readString(exception) ?: return
			}
		
			if ((flags and 67108864) != 0) {
				date = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (blocked) flags or 1 else flags and 1.inv()
			flags = if (phoneCallsAvailable) flags or 16 else flags and 16.inv()
			flags = if (phoneCallsPrivate) flags or 32 else flags and 32.inv()
			flags = if (canPinMessage) flags or 128 else flags and 128.inv()
			flags = if (hasScheduled) flags or 4096 else flags and 4096.inv()
			flags = if (videoCallsAvailable) flags or 8192 else flags and 8192.inv()
			flags = if (voiceMessagesForbidden) flags or 1048576 else flags and 1048576.inv()
			flags = if (about != null) flags or 2 else flags and 2.inv()
			flags = if (profilePhoto != null) flags or 4 else flags and 4.inv()
			flags = if (botInfo != null) flags or 8 else flags and 8.inv()
			flags = if (pinnedMsgId != 0) flags or 64 else flags and 64.inv()
			flags = if (folderId != 0) flags or 2048 else flags and 2048.inv()
			flags = if (ttlPeriod != 0) flags or 16384 else flags and 16384.inv()
			flags = if (themeEmoticon != null) flags or 32768 else flags and 32768.inv()
			flags = if (privateForwardName != null) flags or 65536 else flags and 65536.inv()
			flags = if (botGroupAdminRights != null) flags or 131072 else flags and 131072.inv()
			flags = if (botBroadcastAdminRights != null) flags or 262144 else flags and 262144.inv()
			flags = if (email != null) flags or 8388608 else flags and 8388608.inv()
			flags = if (country != null) flags or 16777216 else flags and 16777216.inv()
			flags = if (isPublic) flags or 2097152 else flags and 2097152.inv()
			flags = if (business) flags or 4194304 else flags and 4194304.inv()
			flags = if (gender != null) flags or 33554432 else flags and 33554432.inv()
			flags = if (date != 0) flags or 67108864 else flags and 67108864.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			if ((flags and 2) != 0) {
				stream.writeString(about)
			}
	
			settings?.serializeToStream(stream)
			if ((flags and 4) != 0) {
				profilePhoto?.serializeToStream(stream)
			}
	
			notifySettings?.serializeToStream(stream)
			if ((flags and 8) != 0) {
				botInfo?.serializeToStream(stream)
			}
	
			if ((flags and 64) != 0) {
				stream.writeInt32(pinnedMsgId)
			}
	
			stream.writeInt32(commonChatsCount)
			if ((flags and 2048) != 0) {
				stream.writeInt32(folderId)
			}
	
			if ((flags and 16384) != 0) {
				stream.writeInt32(ttlPeriod)
			}
	
			if ((flags and 32768) != 0) {
				stream.writeString(themeEmoticon)
			}
	
			if ((flags and 65536) != 0) {
				stream.writeString(privateForwardName)
			}
	
			if ((flags and 131072) != 0) {
				botGroupAdminRights?.serializeToStream(stream)
			}
	
			if ((flags and 262144) != 0) {
				botBroadcastAdminRights?.serializeToStream(stream)
			}
	
			if ((flags and 524288) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(premiumGifts.size)
			premiumGifts.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 8388608) != 0) {
				stream.writeString(email)
			}
	
			if ((flags and 16777216) != 0) {
				stream.writeString(country)
			}
	
			if ((flags and 33554432) != 0) {
				stream.writeString(gender)
			}
	
			if ((flags and 67108864) != 0) {
				stream.writeInt32(date)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc4b1fc3fu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLUserFull? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLUserFull")
					}
					else {
						null
					}
				}
	
				val result = TLUserFull()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLContact: TLObject() {
		@JvmField var userId = 0L
		@JvmField var mutual = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			mutual = stream.readBool(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeBool(mutual)
		}
	
		companion object {
			val CONSTRUCTOR = 0x145ade0bu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLContact? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLContact")
					}
					else {
						null
					}
				}
	
				val result = TLContact()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLImportedContact: TLObject() {
		@JvmField var userId = 0L
		@JvmField var clientId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			clientId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeInt64(clientId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc13e3c50u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLImportedContact? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLImportedContact")
					}
					else {
						null
					}
				}
	
				val result = TLImportedContact()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLContactStatus: TLObject() {
		@JvmField var userId = 0L
		@JvmField var status: UserStatus? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			status = UserStatus.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			status?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x16d9703bu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLContactStatus? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLContactStatus")
					}
					else {
						null
					}
				}
	
				val result = TLContactStatus()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class ContactsContacts: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ContactsContacts? {
				val result = when (constructor) {
					TLContactsContactsNotModified.CONSTRUCTOR -> TLContactsContactsNotModified()
					TLContactsContacts.CONSTRUCTOR -> TLContactsContacts()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ContactsContacts")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLContactsContactsNotModified: ContactsContacts() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb74ba9d2u.toInt()
		}
	}
	
	open class TLContactsContacts: ContactsContacts() {
		@JvmField val contacts = mutableListOf<TLContact>()
		@JvmField var savedCount = 0
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLContact.deserialize(stream, stream.readInt32(exception), exception) ?: return
				contacts.add(obj)
			}
			savedCount = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(contacts.size)
			contacts.forEach { it.serializeToStream(stream) }
			stream.writeInt32(savedCount)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xeae87e42u.toInt()
		}
	}
	
	open class TLContactsGetContacts: TLObject() {
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ContactsContacts? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return ContactsContacts.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5dd69e12u.toInt()
		}
	}
	
	open class TLContactsImportedContacts: TLObject() {
		@JvmField val imported = mutableListOf<TLImportedContact>()
		@JvmField val popularInvites = mutableListOf<TLPopularContact>()
		@JvmField val retryContacts = mutableListOf<Long>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLImportedContact.deserialize(stream, stream.readInt32(exception), exception) ?: return
				imported.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLPopularContact.deserialize(stream, stream.readInt32(exception), exception) ?: return
				popularInvites.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				retryContacts.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(imported.size)
			imported.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(popularInvites.size)
			popularInvites.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(retryContacts.size)
			retryContacts.forEach { stream.writeInt64(it) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x77d01c3bu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLContactsImportedContacts? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLContactsImportedContacts")
					}
					else {
						null
					}
				}
	
				val result = TLContactsImportedContacts()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLContactsImportContacts: TLObject() {
		@JvmField val contacts = mutableListOf<TLInputContact>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLContactsImportedContacts? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLContactsImportedContacts.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(contacts.size)
			contacts.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x2c800be5u.toInt()
		}
	}
	
	abstract class ContactsBlocked: TLObject() {
		@JvmField val users = mutableListOf<User>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val blocked = mutableListOf<TLPeerBlocked>()
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ContactsBlocked? {
				val result = when (constructor) {
					TLContactsBlocked.CONSTRUCTOR -> TLContactsBlocked()
					TLContactsBlockedSlice.CONSTRUCTOR -> TLContactsBlockedSlice()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ContactsBlocked")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLContactsBlocked: ContactsBlocked() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLPeerBlocked.deserialize(stream, stream.readInt32(exception), exception) ?: return
				blocked.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(blocked.size)
			blocked.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xade1591u.toInt()
		}
	}
	
	open class TLContactsBlockedSlice: ContactsBlocked() {
		@JvmField var count = 0
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			count = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLPeerBlocked.deserialize(stream, stream.readInt32(exception), exception) ?: return
				blocked.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(count)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(blocked.size)
			blocked.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xe1664194u.toInt()
		}
	}
	
	open class TLContactsGetBlocked: TLObject() {
		@JvmField var offset = 0
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ContactsBlocked? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return ContactsBlocked.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf57c350fu.toInt()
		}
	}
	
	abstract class MessagesDialogs: TLObject() {
		@JvmField val dialogs = mutableListOf<Dialog>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField var count = 0
		@JvmField val messages = mutableListOf<Message>()
		@JvmField val users = mutableListOf<User>()
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesDialogs? {
				val result = when (constructor) {
					TLMessagesDialogs.CONSTRUCTOR -> TLMessagesDialogs()
					TLMessagesDialogsSlice.CONSTRUCTOR -> TLMessagesDialogsSlice()
					TLMessagesDialogsNotModified.CONSTRUCTOR -> TLMessagesDialogsNotModified()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesDialogs")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesDialogs: MessagesDialogs() {
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Dialog.deserialize(stream, stream.readInt32(exception), exception) ?: return
				dialogs.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Message.deserialize(stream, stream.readInt32(exception), exception) ?: return
				messages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(dialogs.size)
			dialogs.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x15ba6c40u.toInt()
		}
	}
	
	open class TLMessagesDialogsSlice: MessagesDialogs() {
						
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			count = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Dialog.deserialize(stream, stream.readInt32(exception), exception) ?: return
				dialogs.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Message.deserialize(stream, stream.readInt32(exception), exception) ?: return
				messages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(count)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(dialogs.size)
			dialogs.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x71e094f3u.toInt()
		}
	}
	
	open class TLMessagesDialogsNotModified: MessagesDialogs() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			count = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(count)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf0e3e596u.toInt()
		}
	}
	
	open class TLMessagesGetDialogs: TLObject() {
		@JvmField var flags = 0
		@JvmField var excludePinned = false
		@JvmField var folderId = 0
		@JvmField var offsetDate = 0
		@JvmField var offsetId = 0
		@JvmField var offsetPeer: InputPeer? = null
		@JvmField var limit = 0
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesDialogs? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesDialogs.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (excludePinned) flags or 1 else flags and 1.inv()
			flags = if (folderId != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			if ((flags and 2) != 0) {
				stream.writeInt32(folderId)
			}
	
			stream.writeInt32(offsetDate)
			stream.writeInt32(offsetId)
			offsetPeer?.serializeToStream(stream)
			stream.writeInt32(limit)
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa0f4cb4fu.toInt()
		}
	}
	
	abstract class MessagesMessages: TLObject() {
		@JvmField var inexact = false
		@JvmField var offsetIdOffset = 0
		@JvmField var flags = 0
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField var count = 0
		@JvmField val messages = mutableListOf<Message>()
		@JvmField val users = mutableListOf<User>()
		@JvmField var animatedEmoji: MutableList<Document>? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesMessages? {
				val result = when (constructor) {
					TLMessagesMessages.CONSTRUCTOR -> TLMessagesMessages()
					TLMessagesMessagesSlice.CONSTRUCTOR -> TLMessagesMessagesSlice()
					TLMessagesChannelMessages.CONSTRUCTOR -> TLMessagesChannelMessages()
					TLMessagesMessagesNotModified.CONSTRUCTOR -> TLMessagesMessagesNotModified()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesMessages")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesMessages: MessagesMessages() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Message.deserialize(stream, stream.readInt32(exception), exception) ?: return
				messages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x8c718e87u.toInt()
		}
	}
	
	open class TLMessagesMessagesSlice: MessagesMessages() {
					@JvmField var nextRate = 0
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			inexact = (flags and 2) != 0
			count = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				nextRate = stream.readInt32(exception)
			}
		
			if ((flags and 4) != 0) {
				offsetIdOffset = stream.readInt32(exception)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Message.deserialize(stream, stream.readInt32(exception), exception) ?: return
				messages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (inexact) flags or 2 else flags and 2.inv()
			flags = if (nextRate != 0) flags or 1 else flags and 1.inv()
			flags = if (offsetIdOffset != 0) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(count)
			if ((flags and 1) != 0) {
				stream.writeInt32(nextRate)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(offsetIdOffset)
			}
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x3a54685eu.toInt()
		}
	}
	
	open class TLMessagesChannelMessages: MessagesMessages() {
				@JvmField var pts = 0
						
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			inexact = (flags and 2) != 0
			pts = stream.readInt32(exception)
			count = stream.readInt32(exception)
		
			if ((flags and 4) != 0) {
				offsetIdOffset = stream.readInt32(exception)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Message.deserialize(stream, stream.readInt32(exception), exception) ?: return
				messages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (inexact) flags or 2 else flags and 2.inv()
			flags = if (offsetIdOffset != 0) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(pts)
			stream.writeInt32(count)
			if ((flags and 4) != 0) {
				stream.writeInt32(offsetIdOffset)
			}
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x64479808u.toInt()
		}
	}
	
	open class TLMessagesMessagesNotModified: MessagesMessages() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			count = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(count)
		}
	
		companion object {
			val CONSTRUCTOR = 0x74535f21u.toInt()
		}
	}
	
	open class TLMessagesGetMessages: TLObject() {
		@JvmField val id = mutableListOf<InputMessage>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x63c66506u.toInt()
		}
	}
	
	open class TLMessagesGetHistory: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var offsetId = 0
		@JvmField var offsetDate = 0
		@JvmField var addOffset = 0
		@JvmField var limit = 0
		@JvmField var maxId = 0
		@JvmField var minId = 0
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(offsetId)
			stream.writeInt32(offsetDate)
			stream.writeInt32(addOffset)
			stream.writeInt32(limit)
			stream.writeInt32(maxId)
			stream.writeInt32(minId)
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4423e6c5u.toInt()
		}
	}
	
	open class TLMessagesSearch: TLObject() {
		@JvmField var flags = 0
		@JvmField var peer: InputPeer? = null
		@JvmField var q: String? = null
		@JvmField var fromId: InputPeer? = null
		@JvmField var topMsgId = 0
		@JvmField var filter: MessagesFilter? = null
		@JvmField var minDate = 0
		@JvmField var maxDate = 0
		@JvmField var offsetId = 0
		@JvmField var addOffset = 0
		@JvmField var limit = 0
		@JvmField var maxId = 0
		@JvmField var minId = 0
		@JvmField var hash = 0L
		@JvmField var isPaid = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (fromId != null) flags or 1 else flags and 1.inv()
			flags = if (topMsgId != 0) flags or 2 else flags and 2.inv()
			flags = if (isPaid) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeString(q)
			if ((flags and 1) != 0) {
				fromId?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(topMsgId)
			}
	
			filter?.serializeToStream(stream)
			stream.writeInt32(minDate)
			stream.writeInt32(maxDate)
			stream.writeInt32(offsetId)
			stream.writeInt32(addOffset)
			stream.writeInt32(limit)
			stream.writeInt32(maxId)
			stream.writeInt32(minId)
			stream.writeInt64(hash)
			if ((flags and 4) != 0) {
				stream.writeBool(isPaid)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa0fda762u.toInt()
		}
	}
	
	open class TLMessagesSearchGlobal: TLObject() {
		@JvmField var flags = 0
		@JvmField var folderId = 0
		@JvmField var q: String? = null
		@JvmField var filter: MessagesFilter? = null
		@JvmField var minDate = 0
		@JvmField var maxDate = 0
		@JvmField var offsetRate = 0
		@JvmField var offsetPeer: InputPeer? = null
		@JvmField var offsetId = 0
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (folderId != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeInt32(folderId)
			}
	
			stream.writeString(q)
			filter?.serializeToStream(stream)
			stream.writeInt32(minDate)
			stream.writeInt32(maxDate)
			stream.writeInt32(offsetRate)
			offsetPeer?.serializeToStream(stream)
			stream.writeInt32(offsetId)
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4bc6589au.toInt()
		}
	}
	
	open class TLMessagesGetUnreadMentions: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var offsetId = 0
		@JvmField var addOffset = 0
		@JvmField var limit = 0
		@JvmField var maxId = 0
		@JvmField var minId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(offsetId)
			stream.writeInt32(addOffset)
			stream.writeInt32(limit)
			stream.writeInt32(maxId)
			stream.writeInt32(minId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x46578472u.toInt()
		}
	}
	
	open class TLMessagesGetRecentLocations: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var limit = 0
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(limit)
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x702a40e0u.toInt()
		}
	}
	
	open class TLMessagesGetScheduledHistory: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf516760bu.toInt()
		}
	}
	
	open class TLMessagesGetScheduledMessages: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField val id = mutableListOf<Int>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xbdbb0464u.toInt()
		}
	}
	
	open class TLMessagesGetReplies: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var msgId = 0
		@JvmField var offsetId = 0
		@JvmField var offsetDate = 0
		@JvmField var addOffset = 0
		@JvmField var limit = 0
		@JvmField var maxId = 0
		@JvmField var minId = 0
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
			stream.writeInt32(offsetId)
			stream.writeInt32(offsetDate)
			stream.writeInt32(addOffset)
			stream.writeInt32(limit)
			stream.writeInt32(maxId)
			stream.writeInt32(minId)
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x22ddd30cu.toInt()
		}
	}
	
	open class TLMessagesGetUnreadReactions: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var offsetId = 0
		@JvmField var addOffset = 0
		@JvmField var limit = 0
		@JvmField var maxId = 0
		@JvmField var minId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(offsetId)
			stream.writeInt32(addOffset)
			stream.writeInt32(limit)
			stream.writeInt32(maxId)
			stream.writeInt32(minId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe85bae1au.toInt()
		}
	}
	
	open class TLMessagesSearchSentMedia: TLObject() {
		@JvmField var q: String? = null
		@JvmField var filter: MessagesFilter? = null
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(q)
			filter?.serializeToStream(stream)
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0x107e31a0u.toInt()
		}
	}
	
	open class TLChannelsGetMessages: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField val id = mutableListOf<InputMessage>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xad8c9a23u.toInt()
		}
	}
	
	open class TLStatsGetMessagePublicForwards: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var msgId = 0
		@JvmField var offsetRate = 0
		@JvmField var offsetPeer: InputPeer? = null
		@JvmField var offsetId = 0
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeInt32(msgId)
			stream.writeInt32(offsetRate)
			offsetPeer?.serializeToStream(stream)
			stream.writeInt32(offsetId)
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5630281bu.toInt()
		}
	}
	
	abstract class MessagesChats: TLObject() {
		@JvmField val chats = mutableListOf<Chat>()
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesChats? {
				val result = when (constructor) {
					TLMessagesChats.CONSTRUCTOR -> TLMessagesChats()
					TLMessagesChatsSlice.CONSTRUCTOR -> TLMessagesChatsSlice()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesChats")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesChats: MessagesChats() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x64ff9fd5u.toInt()
		}
	}
	
	open class TLMessagesChatsSlice: MessagesChats() {
		@JvmField var count = 0
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			count = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(count)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x9cd81144u.toInt()
		}
	}
	
	open class TLMessagesGetChats: TLObject() {
		@JvmField val id = mutableListOf<Long>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesChats? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesChats.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x49e9528fu.toInt()
		}
	}
	
	open class TLMessagesGetCommonChats: TLObject() {
		@JvmField var userId: InputUser? = null
		@JvmField var maxId = 0L
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesChats? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesChats.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			userId?.serializeToStream(stream)
			stream.writeInt64(maxId)
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe40ca104u.toInt()
		}
	}
	
	open class TLMessagesGetAllChats: TLObject() {
		@JvmField val exceptIds = mutableListOf<Long>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesChats? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesChats.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(exceptIds.size)
			exceptIds.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x875f74beu.toInt()
		}
	}
	
	open class TLChannelsGetChannels: TLObject() {
		@JvmField val id = mutableListOf<InputChannel>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesChats? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesChats.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xa7f6bbbu.toInt()
		}
	}
	
	open class TLChannelsGetAdminedPublicChannels: TLObject() {
		@JvmField var flags = 0
		@JvmField var byLocation = false
		@JvmField var checkLimit = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesChats? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesChats.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (byLocation) flags or 1 else flags and 1.inv()
			flags = if (checkLimit) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf8b036afu.toInt()
		}
	}
	
	open class TLChannelsGetLeftChannels: TLObject() {
		@JvmField var offset = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesChats? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesChats.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8341ecc0u.toInt()
		}
	}
	
	open class TLChannelsGetGroupsForDiscussion: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesChats? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesChats.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf5dad378u.toInt()
		}
	}
	
	open class TLMessagesChatFull: TLObject() {
		@JvmField var fullChat: ChatFull? = null
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			fullChat = ChatFull.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			fullChat?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xe5d7d19cu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesChatFull? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesChatFull")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesChatFull()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetFullChat: TLObject() {
		@JvmField var chatId = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesChatFull? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesChatFull.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(chatId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xaeb00b34u.toInt()
		}
	}
	
	open class TLChannelsGetFullChannel: TLObject() {
		@JvmField var channel: InputChannel? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesChatFull? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesChatFull.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8736a09u.toInt()
		}
	}
	
	open class TLMessagesAffectedHistory: TLObject() {
		@JvmField var pts = 0
		@JvmField var ptsCount = 0
		@JvmField var offset = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
			offset = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
			stream.writeInt32(offset)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb45c69d1u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesAffectedHistory? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesAffectedHistory")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesAffectedHistory()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesDeleteHistory: TLObject() {
		@JvmField var flags = 0
		@JvmField var justClear = false
		@JvmField var revoke = false
		@JvmField var peer: InputPeer? = null
		@JvmField var maxId = 0
		@JvmField var minDate = 0
		@JvmField var maxDate = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesAffectedHistory? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesAffectedHistory.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (justClear) flags or 1 else flags and 1.inv()
			flags = if (revoke) flags or 2 else flags and 2.inv()
			flags = if (minDate != 0) flags or 4 else flags and 4.inv()
			flags = if (maxDate != 0) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt32(maxId)
			if ((flags and 4) != 0) {
				stream.writeInt32(minDate)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt32(maxDate)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb08f922au.toInt()
		}
	}
	
	open class TLMessagesReadMentions: TLObject() {
		@JvmField var peer: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesAffectedHistory? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesAffectedHistory.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf0189d3u.toInt()
		}
	}
	
	open class TLMessagesUnpinAllMessages: TLObject() {
		@JvmField var peer: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesAffectedHistory? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesAffectedHistory.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf025bc8bu.toInt()
		}
	}
	
	open class TLMessagesReadReactions: TLObject() {
		@JvmField var peer: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesAffectedHistory? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesAffectedHistory.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x82e251d7u.toInt()
		}
	}
	
	open class TLChannelsDeleteParticipantHistory: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var participant: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesAffectedHistory? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesAffectedHistory.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			participant?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x367544dbu.toInt()
		}
	}
	
	open class TLChannelsDeleteTopicHistory: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var topMsgId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesAffectedHistory? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesAffectedHistory.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeInt32(topMsgId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x34435f2du.toInt()
		}
	}
	
	abstract class MessagesFilter: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesFilter? {
				val result = when (constructor) {
					TLInputMessagesFilterEmpty.CONSTRUCTOR -> TLInputMessagesFilterEmpty()
					TLInputMessagesFilterPhotos.CONSTRUCTOR -> TLInputMessagesFilterPhotos()
					TLInputMessagesFilterVideo.CONSTRUCTOR -> TLInputMessagesFilterVideo()
					TLInputMessagesFilterPhotoVideo.CONSTRUCTOR -> TLInputMessagesFilterPhotoVideo()
					TLInputMessagesFilterDocument.CONSTRUCTOR -> TLInputMessagesFilterDocument()
					TLInputMessagesFilterUrl.CONSTRUCTOR -> TLInputMessagesFilterUrl()
					TLInputMessagesFilterGif.CONSTRUCTOR -> TLInputMessagesFilterGif()
					TLInputMessagesFilterVoice.CONSTRUCTOR -> TLInputMessagesFilterVoice()
					TLInputMessagesFilterMusic.CONSTRUCTOR -> TLInputMessagesFilterMusic()
					TLInputMessagesFilterChatPhotos.CONSTRUCTOR -> TLInputMessagesFilterChatPhotos()
					TLInputMessagesFilterPhoneCalls.CONSTRUCTOR -> TLInputMessagesFilterPhoneCalls()
					TLInputMessagesFilterRoundVoice.CONSTRUCTOR -> TLInputMessagesFilterRoundVoice()
					TLInputMessagesFilterRoundVideo.CONSTRUCTOR -> TLInputMessagesFilterRoundVideo()
					TLInputMessagesFilterMyMentions.CONSTRUCTOR -> TLInputMessagesFilterMyMentions()
					TLInputMessagesFilterGeo.CONSTRUCTOR -> TLInputMessagesFilterGeo()
					TLInputMessagesFilterContacts.CONSTRUCTOR -> TLInputMessagesFilterContacts()
					TLInputMessagesFilterPinned.CONSTRUCTOR -> TLInputMessagesFilterPinned()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesFilter")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputMessagesFilterEmpty: MessagesFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x57e2f66cu.toInt()
		}
	}
	
	open class TLInputMessagesFilterPhotos: MessagesFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9609a51cu.toInt()
		}
	}
	
	open class TLInputMessagesFilterVideo: MessagesFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9fc00e65u.toInt()
		}
	}
	
	open class TLInputMessagesFilterPhotoVideo: MessagesFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x56e9f0e4u.toInt()
		}
	}
	
	open class TLInputMessagesFilterDocument: MessagesFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9eddf188u.toInt()
		}
	}
	
	open class TLInputMessagesFilterUrl: MessagesFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x7ef0dd87u.toInt()
		}
	}
	
	open class TLInputMessagesFilterGif: MessagesFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xffc86587u.toInt()
		}
	}
	
	open class TLInputMessagesFilterVoice: MessagesFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x50f5c392u.toInt()
		}
	}
	
	open class TLInputMessagesFilterMusic: MessagesFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3751b49eu.toInt()
		}
	}
	
	open class TLInputMessagesFilterChatPhotos: MessagesFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3a20ecb8u.toInt()
		}
	}
	
	open class TLInputMessagesFilterPhoneCalls: MessagesFilter() {
		@JvmField var flags = 0
		@JvmField var missed = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			missed = (flags and 1) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (missed) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0x80c99768u.toInt()
		}
	}
	
	open class TLInputMessagesFilterRoundVoice: MessagesFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x7a7c17a4u.toInt()
		}
	}
	
	open class TLInputMessagesFilterRoundVideo: MessagesFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb549da53u.toInt()
		}
	}
	
	open class TLInputMessagesFilterMyMentions: MessagesFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc1f8e69au.toInt()
		}
	}
	
	open class TLInputMessagesFilterGeo: MessagesFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe7026d0du.toInt()
		}
	}
	
	open class TLInputMessagesFilterContacts: MessagesFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe062db83u.toInt()
		}
	}
	
	open class TLInputMessagesFilterPinned: MessagesFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1bb00451u.toInt()
		}
	}
	
	abstract class Update: TLObject() {
		@JvmField var userId = 0L
		@JvmField var maxId = 0
		@JvmField var readMaxId = 0
		@JvmField var gameShortName: String? = null
		@JvmField var webpage: WebPage? = null
		@JvmField var qts = 0
		@JvmField var folderId = 0
		@JvmField var action: SendMessageAction? = null
		@JvmField var invite: ExportedChatInvite? = null
		@JvmField var channelId = 0L
		@JvmField var queryId = 0L
		@JvmField val messages = mutableListOf<Int>()
		@JvmField var pts = 0
		@JvmField var emojis = false
		@JvmField var actorId = 0L
		@JvmField var geo: GeoPoint? = null
		@JvmField var pollId = 0L
		@JvmField var topMsgId = 0
		@JvmField var chatInstance = 0L
		@JvmField var fromId: Peer? = null
		@JvmField var masks = false
		@JvmField var pinned = false
		@JvmField var stillUnreadCount = 0
		@JvmField var version = 0
		@JvmField var payload: ByteArray? = null
		@JvmField var flags = 0
		@JvmField var ptsCount = 0
		@JvmField var date = 0
		@JvmField var query: String? = null
		@JvmField var botId = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Update? {
				val result = when (constructor) {
					TLUpdateNewMessage.CONSTRUCTOR -> TLUpdateNewMessage()
					TLUpdateMessageID.CONSTRUCTOR -> TLUpdateMessageID()
					TLUpdateDeleteMessages.CONSTRUCTOR -> TLUpdateDeleteMessages()
					TLUpdateUserTyping.CONSTRUCTOR -> TLUpdateUserTyping()
					TLUpdateUser.CONSTRUCTOR -> TLUpdateUser()
					TLUpdateChatUserTyping.CONSTRUCTOR -> TLUpdateChatUserTyping()
					TLUpdateChatParticipants.CONSTRUCTOR -> TLUpdateChatParticipants()
					TLUpdateUserStatus.CONSTRUCTOR -> TLUpdateUserStatus()
					TLUpdateUserName.CONSTRUCTOR -> TLUpdateUserName()
					TLUpdateNewAuthorization.CONSTRUCTOR -> TLUpdateNewAuthorization()
					TLUpdateUserPhoto.CONSTRUCTOR -> TLUpdateUserPhoto()
					TLUpdateNewEncryptedMessage.CONSTRUCTOR -> TLUpdateNewEncryptedMessage()
					TLUpdateEncryptedChatTyping.CONSTRUCTOR -> TLUpdateEncryptedChatTyping()
					TLUpdateEncryption.CONSTRUCTOR -> TLUpdateEncryption()
					TLUpdateEncryptedMessagesRead.CONSTRUCTOR -> TLUpdateEncryptedMessagesRead()
					TLUpdateChatParticipantAdd.CONSTRUCTOR -> TLUpdateChatParticipantAdd()
					TLUpdateChatParticipantDelete.CONSTRUCTOR -> TLUpdateChatParticipantDelete()
					TLUpdateDcOptions.CONSTRUCTOR -> TLUpdateDcOptions()
					TLUpdateNotifySettings.CONSTRUCTOR -> TLUpdateNotifySettings()
					TLUpdateServiceNotification.CONSTRUCTOR -> TLUpdateServiceNotification()
					TLUpdatePrivacy.CONSTRUCTOR -> TLUpdatePrivacy()
					TLUpdateUserPhone.CONSTRUCTOR -> TLUpdateUserPhone()
					TLUpdateReadHistoryInbox.CONSTRUCTOR -> TLUpdateReadHistoryInbox()
					TLUpdateReadHistoryOutbox.CONSTRUCTOR -> TLUpdateReadHistoryOutbox()
					TLUpdateWebPage.CONSTRUCTOR -> TLUpdateWebPage()
					TLUpdateReadMessagesContents.CONSTRUCTOR -> TLUpdateReadMessagesContents()
					TLUpdateChannelTooLong.CONSTRUCTOR -> TLUpdateChannelTooLong()
					TLUpdateChannel.CONSTRUCTOR -> TLUpdateChannel()
					TLUpdateNewChannelMessage.CONSTRUCTOR -> TLUpdateNewChannelMessage()
					TLUpdateReadChannelInbox.CONSTRUCTOR -> TLUpdateReadChannelInbox()
					TLUpdateDeleteChannelMessages.CONSTRUCTOR -> TLUpdateDeleteChannelMessages()
					TLUpdateChannelMessageViews.CONSTRUCTOR -> TLUpdateChannelMessageViews()
					TLUpdateChatParticipantAdmin.CONSTRUCTOR -> TLUpdateChatParticipantAdmin()
					TLUpdateNewStickerSet.CONSTRUCTOR -> TLUpdateNewStickerSet()
					TLUpdateStickerSetsOrder.CONSTRUCTOR -> TLUpdateStickerSetsOrder()
					TLUpdateStickerSets.CONSTRUCTOR -> TLUpdateStickerSets()
					TLUpdateSavedGifs.CONSTRUCTOR -> TLUpdateSavedGifs()
					TLUpdateBotInlineQuery.CONSTRUCTOR -> TLUpdateBotInlineQuery()
					TLUpdateBotInlineSend.CONSTRUCTOR -> TLUpdateBotInlineSend()
					TLUpdateEditChannelMessage.CONSTRUCTOR -> TLUpdateEditChannelMessage()
					TLUpdateBotCallbackQuery.CONSTRUCTOR -> TLUpdateBotCallbackQuery()
					TLUpdateEditMessage.CONSTRUCTOR -> TLUpdateEditMessage()
					TLUpdateInlineBotCallbackQuery.CONSTRUCTOR -> TLUpdateInlineBotCallbackQuery()
					TLUpdateReadChannelOutbox.CONSTRUCTOR -> TLUpdateReadChannelOutbox()
					TLUpdateDraftMessage.CONSTRUCTOR -> TLUpdateDraftMessage()
					TLUpdateReadFeaturedStickers.CONSTRUCTOR -> TLUpdateReadFeaturedStickers()
					TLUpdateRecentStickers.CONSTRUCTOR -> TLUpdateRecentStickers()
					TLUpdateConfig.CONSTRUCTOR -> TLUpdateConfig()
					TLUpdatePtsChanged.CONSTRUCTOR -> TLUpdatePtsChanged()
					TLUpdateChannelWebPage.CONSTRUCTOR -> TLUpdateChannelWebPage()
					TLUpdateDialogPinned.CONSTRUCTOR -> TLUpdateDialogPinned()
					TLUpdatePinnedDialogs.CONSTRUCTOR -> TLUpdatePinnedDialogs()
					TLUpdateBotWebhookJSON.CONSTRUCTOR -> TLUpdateBotWebhookJSON()
					TLUpdateBotWebhookJSONQuery.CONSTRUCTOR -> TLUpdateBotWebhookJSONQuery()
					TLUpdateBotShippingQuery.CONSTRUCTOR -> TLUpdateBotShippingQuery()
					TLUpdateBotPrecheckoutQuery.CONSTRUCTOR -> TLUpdateBotPrecheckoutQuery()
					TLUpdatePhoneCall.CONSTRUCTOR -> TLUpdatePhoneCall()
					TLUpdateLangPackTooLong.CONSTRUCTOR -> TLUpdateLangPackTooLong()
					TLUpdateLangPack.CONSTRUCTOR -> TLUpdateLangPack()
					TLUpdateFavedStickers.CONSTRUCTOR -> TLUpdateFavedStickers()
					TLUpdateChannelReadMessagesContents.CONSTRUCTOR -> TLUpdateChannelReadMessagesContents()
					TLUpdateContactsReset.CONSTRUCTOR -> TLUpdateContactsReset()
					TLUpdateChannelAvailableMessages.CONSTRUCTOR -> TLUpdateChannelAvailableMessages()
					TLUpdateDialogUnreadMark.CONSTRUCTOR -> TLUpdateDialogUnreadMark()
					TLUpdateMessagePoll.CONSTRUCTOR -> TLUpdateMessagePoll()
					TLUpdateChatDefaultBannedRights.CONSTRUCTOR -> TLUpdateChatDefaultBannedRights()
					TLUpdateFolderPeers.CONSTRUCTOR -> TLUpdateFolderPeers()
					TLUpdatePeerSettings.CONSTRUCTOR -> TLUpdatePeerSettings()
					TLUpdatePeerLocated.CONSTRUCTOR -> TLUpdatePeerLocated()
					TLUpdateNewScheduledMessage.CONSTRUCTOR -> TLUpdateNewScheduledMessage()
					TLUpdateDeleteScheduledMessages.CONSTRUCTOR -> TLUpdateDeleteScheduledMessages()
					TLUpdateTheme.CONSTRUCTOR -> TLUpdateTheme()
					TLUpdateGeoLiveViewed.CONSTRUCTOR -> TLUpdateGeoLiveViewed()
					TLUpdateLoginToken.CONSTRUCTOR -> TLUpdateLoginToken()
					TLUpdateMessagePollVote.CONSTRUCTOR -> TLUpdateMessagePollVote()
					TLUpdateDialogFilter.CONSTRUCTOR -> TLUpdateDialogFilter()
					TLUpdateDialogFilterOrder.CONSTRUCTOR -> TLUpdateDialogFilterOrder()
					TLUpdateDialogFilters.CONSTRUCTOR -> TLUpdateDialogFilters()
					TLUpdatePhoneCallSignalingData.CONSTRUCTOR -> TLUpdatePhoneCallSignalingData()
					TLUpdateChannelMessageForwards.CONSTRUCTOR -> TLUpdateChannelMessageForwards()
					TLUpdateReadChannelDiscussionInbox.CONSTRUCTOR -> TLUpdateReadChannelDiscussionInbox()
					TLUpdateReadChannelDiscussionOutbox.CONSTRUCTOR -> TLUpdateReadChannelDiscussionOutbox()
					TLUpdatePeerBlocked.CONSTRUCTOR -> TLUpdatePeerBlocked()
					TLUpdateChannelUserTyping.CONSTRUCTOR -> TLUpdateChannelUserTyping()
					TLUpdatePinnedMessages.CONSTRUCTOR -> TLUpdatePinnedMessages()
					TLUpdatePinnedChannelMessages.CONSTRUCTOR -> TLUpdatePinnedChannelMessages()
					TLUpdateChat.CONSTRUCTOR -> TLUpdateChat()
					TLUpdateGroupCallParticipants.CONSTRUCTOR -> TLUpdateGroupCallParticipants()
					TLUpdateGroupCall.CONSTRUCTOR -> TLUpdateGroupCall()
					TLUpdatePeerHistoryTTL.CONSTRUCTOR -> TLUpdatePeerHistoryTTL()
					TLUpdateChatParticipant.CONSTRUCTOR -> TLUpdateChatParticipant()
					TLUpdateChannelParticipant.CONSTRUCTOR -> TLUpdateChannelParticipant()
					TLUpdateBotStopped.CONSTRUCTOR -> TLUpdateBotStopped()
					TLUpdateGroupCallConnection.CONSTRUCTOR -> TLUpdateGroupCallConnection()
					TLUpdateBotCommands.CONSTRUCTOR -> TLUpdateBotCommands()
					TLUpdatePendingJoinRequests.CONSTRUCTOR -> TLUpdatePendingJoinRequests()
					TLUpdateBotChatInviteRequester.CONSTRUCTOR -> TLUpdateBotChatInviteRequester()
					TLUpdateMessageReactions.CONSTRUCTOR -> TLUpdateMessageReactions()
					TLUpdateAttachMenuBots.CONSTRUCTOR -> TLUpdateAttachMenuBots()
					TLUpdateWebViewResultSent.CONSTRUCTOR -> TLUpdateWebViewResultSent()
					TLUpdateBotMenuButton.CONSTRUCTOR -> TLUpdateBotMenuButton()
					TLUpdateSavedRingtones.CONSTRUCTOR -> TLUpdateSavedRingtones()
					TLUpdateTranscribedAudio.CONSTRUCTOR -> TLUpdateTranscribedAudio()
					TLUpdateReadFeaturedEmojiStickers.CONSTRUCTOR -> TLUpdateReadFeaturedEmojiStickers()
					TLUpdateUserEmojiStatus.CONSTRUCTOR -> TLUpdateUserEmojiStatus()
					TLUpdateRecentEmojiStatuses.CONSTRUCTOR -> TLUpdateRecentEmojiStatuses()
					TLUpdateRecentReactions.CONSTRUCTOR -> TLUpdateRecentReactions()
					TLUpdateMoveStickerSetToTop.CONSTRUCTOR -> TLUpdateMoveStickerSetToTop()
					TLUpdateMessageExtendedMedia.CONSTRUCTOR -> TLUpdateMessageExtendedMedia()
					TLUpdateBizDataRaw.CONSTRUCTOR -> TLUpdateBizDataRaw()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in Update")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLUpdateNewMessage: Update() {
		@JvmField var message: Message? = null
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			message = Message.deserialize(stream, stream.readInt32(exception), exception)
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			message?.serializeToStream(stream)
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1f2b0afdu.toInt()
		}
	}
	
	open class TLUpdateMessageID: Update() {
		@JvmField var id = 0
		@JvmField var randomId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt32(exception)
			randomId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(id)
			stream.writeInt64(randomId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4e90bfd6u.toInt()
		}
	}
	
	open class TLUpdateDeleteMessages: Update() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt32(exception)
				messages.add(obj)
			}
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { stream.writeInt32(it) }
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa20db0e5u.toInt()
		}
	}
	
	open class TLUpdateUserTyping: Update() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			action = SendMessageAction.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			action?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc01e857fu.toInt()
		}
	}
	
	open class TLUpdateUser: Update() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x20529438u.toInt()
		}
	}
	
	open class TLUpdateChatUserTyping: Update() {
		@JvmField var chatId = 0L
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			chatId = stream.readInt64(exception)
			fromId = Peer.deserialize(stream, stream.readInt32(exception), exception)
			action = SendMessageAction.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(chatId)
			fromId?.serializeToStream(stream)
			action?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x83487af0u.toInt()
		}
	}
	
	open class TLUpdateChatParticipants: Update() {
		@JvmField var participants: ChatParticipants? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			participants = ChatParticipants.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			participants?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7761198u.toInt()
		}
	}
	
	open class TLUpdateUserStatus: Update() {
			@JvmField var status: UserStatus? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			status = UserStatus.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			status?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe5bdf8deu.toInt()
		}
	}
	
	open class TLUpdateUserName: Update() {
			@JvmField var firstName: String? = null
		@JvmField var lastName: String? = null
		@JvmField var username: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			firstName = stream.readString(exception) ?: return
			lastName = stream.readString(exception) ?: return
			username = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeString(firstName)
			stream.writeString(lastName)
			stream.writeString(username)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc3f202e0u.toInt()
		}
	}
	
	open class TLUpdateNewAuthorization: Update() {
			@JvmField var unconfirmed = false
		@JvmField var hash = 0L
			@JvmField var device: String? = null
		@JvmField var location: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			unconfirmed = (flags and 1) != 0
			hash = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {
				date = stream.readInt32(exception)
			}
		
			if ((flags and 1) != 0) {
				device = stream.readString(exception) ?: return
			}
		
			if ((flags and 1) != 0) {
				location = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (unconfirmed) flags or 1 else flags and 1.inv()
			flags = if (date != 0) flags or 1 else flags and 1.inv()
			flags = if (device != null) flags or 1 else flags and 1.inv()
			flags = if (location != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(hash)
			if ((flags and 1) != 0) {
				stream.writeInt32(date)
			}
	
			if ((flags and 1) != 0) {
				stream.writeString(device)
			}
	
			if ((flags and 1) != 0) {
				stream.writeString(location)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8951abefu.toInt()
		}
	}
	
	open class TLUpdateUserPhoto: Update() {
				@JvmField var photo: UserProfilePhoto? = null
		@JvmField var previous = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			date = stream.readInt32(exception)
			photo = UserProfilePhoto.deserialize(stream, stream.readInt32(exception), exception)
			previous = stream.readBool(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeInt32(date)
			photo?.serializeToStream(stream)
			stream.writeBool(previous)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf227868cu.toInt()
		}
	}
	
	open class TLUpdateNewEncryptedMessage: Update() {
		@JvmField var message: EncryptedMessage? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			message = EncryptedMessage.deserialize(stream, stream.readInt32(exception), exception)
			qts = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			message?.serializeToStream(stream)
			stream.writeInt32(qts)
		}
	
		companion object {
			val CONSTRUCTOR = 0x12bcbd9au.toInt()
		}
	}
	
	open class TLUpdateEncryptedChatTyping: Update() {
		@JvmField var chatId = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			chatId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(chatId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1710f156u.toInt()
		}
	}
	
	open class TLUpdateEncryption: Update() {
		@JvmField var chat: EncryptedChat? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			chat = EncryptedChat.deserialize(stream, stream.readInt32(exception), exception)
			date = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			chat?.serializeToStream(stream)
			stream.writeInt32(date)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb4a2e88du.toInt()
		}
	}
	
	open class TLUpdateEncryptedMessagesRead: Update() {
		@JvmField var chatId = 0
		@JvmField var maxDate = 0
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			chatId = stream.readInt32(exception)
			maxDate = stream.readInt32(exception)
			date = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(chatId)
			stream.writeInt32(maxDate)
			stream.writeInt32(date)
		}
	
		companion object {
			val CONSTRUCTOR = 0x38fe25b7u.toInt()
		}
	}
	
	open class TLUpdateChatParticipantAdd: Update() {
		@JvmField var chatId = 0L
			@JvmField var inviterId = 0L
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			chatId = stream.readInt64(exception)
			userId = stream.readInt64(exception)
			inviterId = stream.readInt64(exception)
			date = stream.readInt32(exception)
			version = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(chatId)
			stream.writeInt64(userId)
			stream.writeInt64(inviterId)
			stream.writeInt32(date)
			stream.writeInt32(version)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3dda5451u.toInt()
		}
	}
	
	open class TLUpdateChatParticipantDelete: Update() {
		@JvmField var chatId = 0L
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			chatId = stream.readInt64(exception)
			userId = stream.readInt64(exception)
			version = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(chatId)
			stream.writeInt64(userId)
			stream.writeInt32(version)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe32f3d77u.toInt()
		}
	}
	
	open class TLUpdateDcOptions: Update() {
		@JvmField val dcOptions = mutableListOf<TLDcOption>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLDcOption.deserialize(stream, stream.readInt32(exception), exception) ?: return
				dcOptions.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(dcOptions.size)
			dcOptions.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x8e5e9873u.toInt()
		}
	}
	
	open class TLUpdateNotifySettings: Update() {
		@JvmField var peer: NotifyPeer? = null
		@JvmField var notifySettings: PeerNotifySettings? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = NotifyPeer.deserialize(stream, stream.readInt32(exception), exception)
			notifySettings = PeerNotifySettings.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			notifySettings?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbec268efu.toInt()
		}
	}
	
	open class TLUpdateServiceNotification: Update() {
			@JvmField var popup = false
		@JvmField var inboxDate = 0
		@JvmField var type: String? = null
		@JvmField var message: String? = null
		@JvmField var media: MessageMedia? = null
		@JvmField val entities = mutableListOf<MessageEntity>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			popup = (flags and 1) != 0
		
			if ((flags and 2) != 0) {
				inboxDate = stream.readInt32(exception)
			}
			type = stream.readString(exception) ?: return
			message = stream.readString(exception) ?: return
			media = MessageMedia.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
				entities.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (popup) flags or 1 else flags and 1.inv()
			flags = if (inboxDate != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			if ((flags and 2) != 0) {
				stream.writeInt32(inboxDate)
			}
	
			stream.writeString(type)
			stream.writeString(message)
			media?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xebe46819u.toInt()
		}
	}
	
	open class TLUpdatePrivacy: Update() {
		@JvmField var key: PrivacyKey? = null
		@JvmField val rules = mutableListOf<PrivacyRule>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			key = PrivacyKey.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = PrivacyRule.deserialize(stream, stream.readInt32(exception), exception) ?: return
				rules.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			key?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(rules.size)
			rules.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xee3b272au.toInt()
		}
	}
	
	open class TLUpdateUserPhone: Update() {
			@JvmField var phone: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			phone = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeString(phone)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5492a13u.toInt()
		}
	}
	
	open class TLUpdateReadHistoryInbox: Update() {
				@JvmField var peer: Peer? = null
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				folderId = stream.readInt32(exception)
			}
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			maxId = stream.readInt32(exception)
			stillUnreadCount = stream.readInt32(exception)
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (folderId != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeInt32(folderId)
			}
	
			peer?.serializeToStream(stream)
			stream.writeInt32(maxId)
			stream.writeInt32(stillUnreadCount)
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9c974fdfu.toInt()
		}
	}
	
	open class TLUpdateReadHistoryOutbox: Update() {
		@JvmField var peer: Peer? = null
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			maxId = stream.readInt32(exception)
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(maxId)
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2f2f21bfu.toInt()
		}
	}
	
	open class TLUpdateWebPage: Update() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			webpage = WebPage.deserialize(stream, stream.readInt32(exception), exception)
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			webpage?.serializeToStream(stream)
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7f891213u.toInt()
		}
	}
	
	open class TLUpdateReadMessagesContents: Update() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt32(exception)
				messages.add(obj)
			}
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { stream.writeInt32(it) }
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0x68c13933u.toInt()
		}
	}
	
	open class TLUpdateChannelTooLong: Update() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			channelId = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {
				pts = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (pts != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(channelId)
			if ((flags and 1) != 0) {
				stream.writeInt32(pts)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x108d941fu.toInt()
		}
	}
	
	open class TLUpdateChannel: Update() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			channelId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(channelId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x635b4c09u.toInt()
		}
	}
	
	open class TLUpdateNewChannelMessage: Update() {
		@JvmField var message: Message? = null
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			message = Message.deserialize(stream, stream.readInt32(exception), exception)
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			message?.serializeToStream(stream)
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0x62ba04d9u.toInt()
		}
	}
	
	open class TLUpdateReadChannelInbox: Update() {
							
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				folderId = stream.readInt32(exception)
			}
			channelId = stream.readInt64(exception)
			maxId = stream.readInt32(exception)
			stillUnreadCount = stream.readInt32(exception)
			pts = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (folderId != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeInt32(folderId)
			}
	
			stream.writeInt64(channelId)
			stream.writeInt32(maxId)
			stream.writeInt32(stillUnreadCount)
			stream.writeInt32(pts)
		}
	
		companion object {
			val CONSTRUCTOR = 0x922e6e10u.toInt()
		}
	}
	
	open class TLUpdateDeleteChannelMessages: Update() {
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			channelId = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt32(exception)
				messages.add(obj)
			}
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(channelId)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { stream.writeInt32(it) }
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc32d5b12u.toInt()
		}
	}
	
	open class TLUpdateChannelMessageViews: Update() {
			@JvmField var id = 0
		@JvmField var views = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			channelId = stream.readInt64(exception)
			id = stream.readInt32(exception)
			views = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(channelId)
			stream.writeInt32(id)
			stream.writeInt32(views)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf226ac08u.toInt()
		}
	}
	
	open class TLUpdateChatParticipantAdmin: Update() {
		@JvmField var chatId = 0L
			@JvmField var isAdmin = false
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			chatId = stream.readInt64(exception)
			userId = stream.readInt64(exception)
			isAdmin = stream.readBool(exception)
			version = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(chatId)
			stream.writeInt64(userId)
			stream.writeBool(isAdmin)
			stream.writeInt32(version)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd7ca61a2u.toInt()
		}
	}
	
	open class TLUpdateNewStickerSet: Update() {
		@JvmField var stickerset: MessagesStickerSet? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			stickerset = MessagesStickerSet.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stickerset?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x688a30aau.toInt()
		}
	}
	
	open class TLUpdateStickerSetsOrder: Update() {
					@JvmField val order = mutableListOf<Long>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			masks = (flags and 1) != 0
			emojis = (flags and 2) != 0
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				order.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (masks) flags or 1 else flags and 1.inv()
			flags = if (emojis) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(order.size)
			order.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xbb2d201u.toInt()
		}
	}
	
	open class TLUpdateStickerSets: Update() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			masks = (flags and 1) != 0
			emojis = (flags and 2) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (masks) flags or 1 else flags and 1.inv()
			flags = if (emojis) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0x31c24808u.toInt()
		}
	}
	
	open class TLUpdateSavedGifs: Update() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9375341eu.toInt()
		}
	}
	
	open class TLUpdateBotInlineQuery: Update() {
							@JvmField var peerType: InlineQueryPeerType? = null
		@JvmField var offset: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			queryId = stream.readInt64(exception)
			userId = stream.readInt64(exception)
			query = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				geo = GeoPoint.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				peerType = InlineQueryPeerType.deserialize(stream, stream.readInt32(exception), exception)
			}
			offset = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (geo != null) flags or 1 else flags and 1.inv()
			flags = if (peerType != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(queryId)
			stream.writeInt64(userId)
			stream.writeString(query)
			if ((flags and 1) != 0) {
				geo?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				peerType?.serializeToStream(stream)
			}
	
			stream.writeString(offset)
		}
	
		companion object {
			val CONSTRUCTOR = 0x496f379cu.toInt()
		}
	}
	
	open class TLUpdateBotInlineSend: Update() {
						@JvmField var id: String? = null
		@JvmField var msgId: InputBotInlineMessageID? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			userId = stream.readInt64(exception)
			query = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				geo = GeoPoint.deserialize(stream, stream.readInt32(exception), exception)
			}
			id = stream.readString(exception) ?: return
		
			if ((flags and 2) != 0) {
				msgId = InputBotInlineMessageID.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (geo != null) flags or 1 else flags and 1.inv()
			flags = if (msgId != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(userId)
			stream.writeString(query)
			if ((flags and 1) != 0) {
				geo?.serializeToStream(stream)
			}
	
			stream.writeString(id)
			if ((flags and 2) != 0) {
				msgId?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x12f12a07u.toInt()
		}
	}
	
	open class TLUpdateEditChannelMessage: Update() {
		@JvmField var message: Message? = null
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			message = Message.deserialize(stream, stream.readInt32(exception), exception)
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			message?.serializeToStream(stream)
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1b3f4df7u.toInt()
		}
	}
	
	open class TLUpdateBotCallbackQuery: Update() {
					@JvmField var peer: Peer? = null
		@JvmField var msgId = 0
			@JvmField var data: ByteArray? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			queryId = stream.readInt64(exception)
			userId = stream.readInt64(exception)
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			msgId = stream.readInt32(exception)
			chatInstance = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {
				data = stream.readByteArray(exception) ?: return
			}
		
			if ((flags and 2) != 0) {
				gameShortName = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (data != null) flags or 1 else flags and 1.inv()
			flags = if (gameShortName != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(queryId)
			stream.writeInt64(userId)
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
			stream.writeInt64(chatInstance)
			if ((flags and 1) != 0) {
				stream.writeByteArray(data)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(gameShortName)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb9cfc48du.toInt()
		}
	}
	
	open class TLUpdateEditMessage: Update() {
		@JvmField var message: Message? = null
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			message = Message.deserialize(stream, stream.readInt32(exception), exception)
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			message?.serializeToStream(stream)
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe40370a3u.toInt()
		}
	}
	
	open class TLUpdateInlineBotCallbackQuery: Update() {
					@JvmField var msgId: InputBotInlineMessageID? = null
			@JvmField var data: ByteArray? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			queryId = stream.readInt64(exception)
			userId = stream.readInt64(exception)
			msgId = InputBotInlineMessageID.deserialize(stream, stream.readInt32(exception), exception)
			chatInstance = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {
				data = stream.readByteArray(exception) ?: return
			}
		
			if ((flags and 2) != 0) {
				gameShortName = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (data != null) flags or 1 else flags and 1.inv()
			flags = if (gameShortName != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(queryId)
			stream.writeInt64(userId)
			msgId?.serializeToStream(stream)
			stream.writeInt64(chatInstance)
			if ((flags and 1) != 0) {
				stream.writeByteArray(data)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(gameShortName)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x691e9052u.toInt()
		}
	}
	
	open class TLUpdateReadChannelOutbox: Update() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			channelId = stream.readInt64(exception)
			maxId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(channelId)
			stream.writeInt32(maxId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb75f99a9u.toInt()
		}
	}
	
	open class TLUpdateDraftMessage: Update() {
		@JvmField var peer: Peer? = null
			@JvmField var draft: DraftMessage? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				topMsgId = stream.readInt32(exception)
			}
			draft = DraftMessage.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (topMsgId != 0) flags or 1 else flags and 1.inv()
	
			peer?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(topMsgId)
			}
	
			draft?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xee2bb969u.toInt()
		}
	}
	
	open class TLUpdateReadFeaturedStickers: Update() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x571d2742u.toInt()
		}
	}
	
	open class TLUpdateRecentStickers: Update() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9a422c20u.toInt()
		}
	}
	
	open class TLUpdateConfig: Update() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa229dd06u.toInt()
		}
	}
	
	open class TLUpdatePtsChanged: Update() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3354678fu.toInt()
		}
	}
	
	open class TLUpdateChannelWebPage: Update() {
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			channelId = stream.readInt64(exception)
			webpage = WebPage.deserialize(stream, stream.readInt32(exception), exception)
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(channelId)
			webpage?.serializeToStream(stream)
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2f2ba99fu.toInt()
		}
	}
	
	open class TLUpdateDialogPinned: Update() {
					@JvmField var peer: DialogPeer? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			pinned = (flags and 1) != 0
		
			if ((flags and 2) != 0) {
				folderId = stream.readInt32(exception)
			}
			peer = DialogPeer.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (pinned) flags or 1 else flags and 1.inv()
			flags = if (folderId != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			if ((flags and 2) != 0) {
				stream.writeInt32(folderId)
			}
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6e6fe51cu.toInt()
		}
	}
	
	open class TLUpdatePinnedDialogs: Update() {
				@JvmField val order = mutableListOf<DialogPeer>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 2) != 0) {
				folderId = stream.readInt32(exception)
			}
		
			if ((flags and 1) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = DialogPeer.deserialize(stream, stream.readInt32(exception), exception) ?: return
					order.add(obj)
				}
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (folderId != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			if ((flags and 2) != 0) {
				stream.writeInt32(folderId)
			}
	
			if ((flags and 1) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(order.size)
			order.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xfa0f3ca2u.toInt()
		}
	}
	
	open class TLUpdateBotWebhookJSON: Update() {
		@JvmField var data: TLDataJSON? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			data = TLDataJSON.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			data?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8317c0c3u.toInt()
		}
	}
	
	open class TLUpdateBotWebhookJSONQuery: Update() {
			@JvmField var data: TLDataJSON? = null
		@JvmField var timeout = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			queryId = stream.readInt64(exception)
			data = TLDataJSON.deserialize(stream, stream.readInt32(exception), exception)
			timeout = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(queryId)
			data?.serializeToStream(stream)
			stream.writeInt32(timeout)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9b9240a6u.toInt()
		}
	}
	
	open class TLUpdateBotShippingQuery: Update() {
					@JvmField var shippingAddress: TLPostAddress? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			queryId = stream.readInt64(exception)
			userId = stream.readInt64(exception)
			payload = stream.readByteArray(exception) ?: return
			shippingAddress = TLPostAddress.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(queryId)
			stream.writeInt64(userId)
			stream.writeByteArray(payload)
			shippingAddress?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb5aefd7du.toInt()
		}
	}
	
	open class TLUpdateBotPrecheckoutQuery: Update() {
						@JvmField var info: TLPaymentRequestedInfo? = null
		@JvmField var shippingOptionId: String? = null
		@JvmField var currency: String? = null
		@JvmField var totalAmount = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			queryId = stream.readInt64(exception)
			userId = stream.readInt64(exception)
			payload = stream.readByteArray(exception) ?: return
		
			if ((flags and 1) != 0) {
				info = TLPaymentRequestedInfo.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				shippingOptionId = stream.readString(exception) ?: return
			}
			currency = stream.readString(exception) ?: return
			totalAmount = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (info != null) flags or 1 else flags and 1.inv()
			flags = if (shippingOptionId != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(queryId)
			stream.writeInt64(userId)
			stream.writeByteArray(payload)
			if ((flags and 1) != 0) {
				info?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(shippingOptionId)
			}
	
			stream.writeString(currency)
			stream.writeInt64(totalAmount)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8caa9a96u.toInt()
		}
	}
	
	open class TLUpdatePhoneCall: Update() {
		@JvmField var phoneCall: PhoneCall? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			phoneCall = PhoneCall.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			phoneCall?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xab0f6b1eu.toInt()
		}
	}
	
	open class TLUpdateLangPackTooLong: Update() {
		@JvmField var langCode: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			langCode = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(langCode)
		}
	
		companion object {
			val CONSTRUCTOR = 0x46560264u.toInt()
		}
	}
	
	open class TLUpdateLangPack: Update() {
		@JvmField var difference: TLLangPackDifference? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			difference = TLLangPackDifference.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			difference?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x56022f4du.toInt()
		}
	}
	
	open class TLUpdateFavedStickers: Update() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe511996du.toInt()
		}
	}
	
	open class TLUpdateChannelReadMessagesContents: Update() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			channelId = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt32(exception)
				messages.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(channelId)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x44bdd535u.toInt()
		}
	}
	
	open class TLUpdateContactsReset: Update() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x7084a7beu.toInt()
		}
	}
	
	open class TLUpdateChannelAvailableMessages: Update() {
			@JvmField var availableMinId = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			channelId = stream.readInt64(exception)
			availableMinId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(channelId)
			stream.writeInt32(availableMinId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb23fc698u.toInt()
		}
	}
	
	open class TLUpdateDialogUnreadMark: Update() {
			@JvmField var unread = false
		@JvmField var peer: DialogPeer? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			unread = (flags and 1) != 0
			peer = DialogPeer.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (unread) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe16459c3u.toInt()
		}
	}
	
	open class TLUpdateMessagePoll: Update() {
				@JvmField var poll: TLPoll? = null
		@JvmField var results: TLPollResults? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			pollId = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {
				poll = TLPoll.deserialize(stream, stream.readInt32(exception), exception)
			}
			results = TLPollResults.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (poll != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(pollId)
			if ((flags and 1) != 0) {
				poll?.serializeToStream(stream)
			}
	
			results?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xaca1657bu.toInt()
		}
	}
	
	open class TLUpdateChatDefaultBannedRights: Update() {
		@JvmField var peer: Peer? = null
		@JvmField var defaultBannedRights: TLChatBannedRights? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			defaultBannedRights = TLChatBannedRights.deserialize(stream, stream.readInt32(exception), exception)
			version = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			defaultBannedRights?.serializeToStream(stream)
			stream.writeInt32(version)
		}
	
		companion object {
			val CONSTRUCTOR = 0x54c01850u.toInt()
		}
	}
	
	open class TLUpdateFolderPeers: Update() {
		@JvmField val folderPeers = mutableListOf<TLFolderPeer>()
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLFolderPeer.deserialize(stream, stream.readInt32(exception), exception) ?: return
				folderPeers.add(obj)
			}
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(folderPeers.size)
			folderPeers.forEach { it.serializeToStream(stream) }
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0x19360dc0u.toInt()
		}
	}
	
	open class TLUpdatePeerSettings: Update() {
		@JvmField var peer: Peer? = null
		@JvmField var settings: TLPeerSettings? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			settings = TLPeerSettings.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			settings?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6a7e7366u.toInt()
		}
	}
	
	open class TLUpdatePeerLocated: Update() {
		@JvmField val peers = mutableListOf<PeerLocated>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = PeerLocated.deserialize(stream, stream.readInt32(exception), exception) ?: return
				peers.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(peers.size)
			peers.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xb4afcfb0u.toInt()
		}
	}
	
	open class TLUpdateNewScheduledMessage: Update() {
		@JvmField var message: Message? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			message = Message.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			message?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x39a51dfbu.toInt()
		}
	}
	
	open class TLUpdateDeleteScheduledMessages: Update() {
		@JvmField var peer: Peer? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt32(exception)
				messages.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x90866ceeu.toInt()
		}
	}
	
	open class TLUpdateTheme: Update() {
		@JvmField var theme: TLTheme? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			theme = TLTheme.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			theme?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8216fba3u.toInt()
		}
	}
	
	open class TLUpdateGeoLiveViewed: Update() {
		@JvmField var peer: Peer? = null
		@JvmField var msgId = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			msgId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x871fb939u.toInt()
		}
	}
	
	open class TLUpdateLoginToken: Update() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x564fe691u.toInt()
		}
	}
	
	open class TLUpdateMessagePollVote: Update() {
				@JvmField val options = mutableListOf<ByteArray>()
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			pollId = stream.readInt64(exception)
			userId = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readByteArray(exception) ?: return
				options.add(obj)
			}
			qts = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(pollId)
			stream.writeInt64(userId)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(options.size)
			options.forEach { stream.writeByteArray(it) }
			stream.writeInt32(qts)
		}
	
		companion object {
			val CONSTRUCTOR = 0x106395c9u.toInt()
		}
	}
	
	open class TLUpdateDialogFilter: Update() {
			@JvmField var id = 0
		@JvmField var filter: DialogFilter? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			id = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				filter = DialogFilter.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (filter != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(id)
			if ((flags and 1) != 0) {
				filter?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x26ffde7du.toInt()
		}
	}
	
	open class TLUpdateDialogFilterOrder: Update() {
		@JvmField val order = mutableListOf<Int>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt32(exception)
				order.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(order.size)
			order.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xa5d72105u.toInt()
		}
	}
	
	open class TLUpdateDialogFilters: Update() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3504914fu.toInt()
		}
	}
	
	open class TLUpdatePhoneCallSignalingData: Update() {
		@JvmField var phoneCallId = 0L
		@JvmField var data: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			phoneCallId = stream.readInt64(exception)
			data = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(phoneCallId)
			stream.writeByteArray(data)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2661bf09u.toInt()
		}
	}
	
	open class TLUpdateChannelMessageForwards: Update() {
			@JvmField var id = 0
		@JvmField var forwards = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			channelId = stream.readInt64(exception)
			id = stream.readInt32(exception)
			forwards = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(channelId)
			stream.writeInt32(id)
			stream.writeInt32(forwards)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd29a27f4u.toInt()
		}
	}
	
	open class TLUpdateReadChannelDiscussionInbox: Update() {
						@JvmField var broadcastId = 0L
		@JvmField var broadcastPost = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			channelId = stream.readInt64(exception)
			topMsgId = stream.readInt32(exception)
			readMaxId = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				broadcastId = stream.readInt64(exception)
			}
		
			if ((flags and 1) != 0) {
				broadcastPost = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (broadcastId != 0L) flags or 1 else flags and 1.inv()
			flags = if (broadcastPost != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(channelId)
			stream.writeInt32(topMsgId)
			stream.writeInt32(readMaxId)
			if ((flags and 1) != 0) {
				stream.writeInt64(broadcastId)
			}
	
			if ((flags and 1) != 0) {
				stream.writeInt32(broadcastPost)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd6b19546u.toInt()
		}
	}
	
	open class TLUpdateReadChannelDiscussionOutbox: Update() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			channelId = stream.readInt64(exception)
			topMsgId = stream.readInt32(exception)
			readMaxId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(channelId)
			stream.writeInt32(topMsgId)
			stream.writeInt32(readMaxId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x695c9e7cu.toInt()
		}
	}
	
	open class TLUpdatePeerBlocked: Update() {
		@JvmField var peerId: Peer? = null
		@JvmField var blocked = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peerId = Peer.deserialize(stream, stream.readInt32(exception), exception)
			blocked = stream.readBool(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peerId?.serializeToStream(stream)
			stream.writeBool(blocked)
		}
	
		companion object {
			val CONSTRUCTOR = 0x246a4b22u.toInt()
		}
	}
	
	open class TLUpdateChannelUserTyping: Update() {
						
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			channelId = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {
				topMsgId = stream.readInt32(exception)
			}
			fromId = Peer.deserialize(stream, stream.readInt32(exception), exception)
			action = SendMessageAction.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (topMsgId != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(channelId)
			if ((flags and 1) != 0) {
				stream.writeInt32(topMsgId)
			}
	
			fromId?.serializeToStream(stream)
			action?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8c88c923u.toInt()
		}
	}
	
	open class TLUpdatePinnedMessages: Update() {
				@JvmField var peer: Peer? = null
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			pinned = (flags and 1) != 0
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt32(exception)
				messages.add(obj)
			}
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (pinned) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { stream.writeInt32(it) }
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0xed85eab5u.toInt()
		}
	}
	
	open class TLUpdatePinnedChannelMessages: Update() {
							
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			pinned = (flags and 1) != 0
			channelId = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt32(exception)
				messages.add(obj)
			}
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (pinned) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(channelId)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { stream.writeInt32(it) }
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5bb98608u.toInt()
		}
	}
	
	open class TLUpdateChat: Update() {
		@JvmField var chatId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			chatId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(chatId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf89a6a4eu.toInt()
		}
	}
	
	open class TLUpdateGroupCallParticipants: Update() {
		@JvmField var call: TLInputGroupCall? = null
		@JvmField val participants = mutableListOf<TLGroupCallParticipant>()
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			call = TLInputGroupCall.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLGroupCallParticipant.deserialize(stream, stream.readInt32(exception), exception) ?: return
				participants.add(obj)
			}
			version = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(participants.size)
			participants.forEach { it.serializeToStream(stream) }
			stream.writeInt32(version)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf2ebdb4eu.toInt()
		}
	}
	
	open class TLUpdateGroupCall: Update() {
		@JvmField var chatId = 0L
		@JvmField var call: GroupCall? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			chatId = stream.readInt64(exception)
			call = GroupCall.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(chatId)
			call?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x14b24500u.toInt()
		}
	}
	
	open class TLUpdatePeerHistoryTTL: Update() {
			@JvmField var peer: Peer? = null
		@JvmField var ttlPeriod = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				ttlPeriod = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (ttlPeriod != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(ttlPeriod)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xbb9bb9a5u.toInt()
		}
	}
	
	open class TLUpdateChatParticipant: Update() {
			@JvmField var chatId = 0L
					@JvmField var prevParticipant: ChatParticipant? = null
		@JvmField var newParticipant: ChatParticipant? = null
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			chatId = stream.readInt64(exception)
			date = stream.readInt32(exception)
			actorId = stream.readInt64(exception)
			userId = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {
				prevParticipant = ChatParticipant.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				newParticipant = ChatParticipant.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 4) != 0) {
				invite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
			}
			qts = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (prevParticipant != null) flags or 1 else flags and 1.inv()
			flags = if (newParticipant != null) flags or 2 else flags and 2.inv()
			flags = if (invite != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(chatId)
			stream.writeInt32(date)
			stream.writeInt64(actorId)
			stream.writeInt64(userId)
			if ((flags and 1) != 0) {
				prevParticipant?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				newParticipant?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				invite?.serializeToStream(stream)
			}
	
			stream.writeInt32(qts)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd087663au.toInt()
		}
	}
	
	open class TLUpdateChannelParticipant: Update() {
							@JvmField var prevParticipant: ChannelParticipant? = null
		@JvmField var newParticipant: ChannelParticipant? = null
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			channelId = stream.readInt64(exception)
			date = stream.readInt32(exception)
			actorId = stream.readInt64(exception)
			userId = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {
				prevParticipant = ChannelParticipant.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				newParticipant = ChannelParticipant.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 4) != 0) {
				invite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
			}
			qts = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (prevParticipant != null) flags or 1 else flags and 1.inv()
			flags = if (newParticipant != null) flags or 2 else flags and 2.inv()
			flags = if (invite != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(channelId)
			stream.writeInt32(date)
			stream.writeInt64(actorId)
			stream.writeInt64(userId)
			if ((flags and 1) != 0) {
				prevParticipant?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				newParticipant?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				invite?.serializeToStream(stream)
			}
	
			stream.writeInt32(qts)
		}
	
		companion object {
			val CONSTRUCTOR = 0x985d3abbu.toInt()
		}
	}
	
	open class TLUpdateBotStopped: Update() {
				@JvmField var stopped = false
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			date = stream.readInt32(exception)
			stopped = stream.readBool(exception)
			qts = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeInt32(date)
			stream.writeBool(stopped)
			stream.writeInt32(qts)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc4870a49u.toInt()
		}
	}
	
	open class TLUpdateGroupCallConnection: Update() {
			@JvmField var presentation = false
		@JvmField var params: TLDataJSON? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			presentation = (flags and 1) != 0
			params = TLDataJSON.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (presentation) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			params?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb783982u.toInt()
		}
	}
	
	open class TLUpdateBotCommands: Update() {
		@JvmField var peer: Peer? = null
			@JvmField val commands = mutableListOf<TLBotCommand>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			botId = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLBotCommand.deserialize(stream, stream.readInt32(exception), exception) ?: return
				commands.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt64(botId)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(commands.size)
			commands.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x4d712f2eu.toInt()
		}
	}
	
	open class TLUpdatePendingJoinRequests: Update() {
		@JvmField var peer: Peer? = null
		@JvmField var requestsPending = 0
		@JvmField val recentRequesters = mutableListOf<Long>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			requestsPending = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				recentRequesters.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(requestsPending)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(recentRequesters.size)
			recentRequesters.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x7063c3dbu.toInt()
		}
	}
	
	open class TLUpdateBotChatInviteRequester: Update() {
		@JvmField var peer: Peer? = null
				@JvmField var about: String? = null
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			date = stream.readInt32(exception)
			userId = stream.readInt64(exception)
			about = stream.readString(exception) ?: return
			invite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
			qts = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(date)
			stream.writeInt64(userId)
			stream.writeString(about)
			invite?.serializeToStream(stream)
			stream.writeInt32(qts)
		}
	
		companion object {
			val CONSTRUCTOR = 0x11dfa986u.toInt()
		}
	}
	
	open class TLUpdateMessageReactions: Update() {
		@JvmField var peer: Peer? = null
		@JvmField var msgId = 0
		@JvmField var reactions: TLMessageReactions? = null
	
		@JvmField var updateUnreadState: Boolean = true
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			msgId = stream.readInt32(exception)
			reactions = TLMessageReactions.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
			reactions?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x154798c3u.toInt()
		}
	}
	
	open class TLUpdateAttachMenuBots: Update() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x17b7a20bu.toInt()
		}
	}
	
	open class TLUpdateWebViewResultSent: Update() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			queryId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(queryId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1592b79du.toInt()
		}
	}
	
	open class TLUpdateBotMenuButton: Update() {
			@JvmField var button: BotMenuButton? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			botId = stream.readInt64(exception)
			button = BotMenuButton.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(botId)
			button?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x14b85813u.toInt()
		}
	}
	
	open class TLUpdateSavedRingtones: Update() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x74d8be99u.toInt()
		}
	}
	
	open class TLUpdateTranscribedAudio: Update() {
			@JvmField var pending = false
		@JvmField var peer: Peer? = null
		@JvmField var msgId = 0
		@JvmField var transcriptionId = 0L
		@JvmField var text: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			pending = (flags and 1) != 0
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			msgId = stream.readInt32(exception)
			transcriptionId = stream.readInt64(exception)
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (pending) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
			stream.writeInt64(transcriptionId)
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0x84cd5au.toInt()
		}
	}
	
	open class TLUpdateReadFeaturedEmojiStickers: Update() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xfb4c496cu.toInt()
		}
	}
	
	open class TLUpdateUserEmojiStatus: Update() {
			@JvmField var emojiStatus: EmojiStatus? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			emojiStatus = EmojiStatus.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			emojiStatus?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x28373599u.toInt()
		}
	}
	
	open class TLUpdateRecentEmojiStatuses: Update() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x30f443dbu.toInt()
		}
	}
	
	open class TLUpdateRecentReactions: Update() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x6f7863f4u.toInt()
		}
	}
	
	open class TLUpdateMoveStickerSetToTop: Update() {
					@JvmField var stickerset = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			masks = (flags and 1) != 0
			emojis = (flags and 2) != 0
			stickerset = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (masks) flags or 1 else flags and 1.inv()
			flags = if (emojis) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(stickerset)
		}
	
		companion object {
			val CONSTRUCTOR = 0x86fccf85u.toInt()
		}
	}
	
	open class TLUpdateMessageExtendedMedia: Update() {
		@JvmField var peer: Peer? = null
		@JvmField var msgId = 0
		@JvmField var extendedMedia: MessageExtendedMedia? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			msgId = stream.readInt32(exception)
			extendedMedia = MessageExtendedMedia.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
			extendedMedia?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5a73a98cu.toInt()
		}
	}
	
	open class TLUpdateBizDataRaw: Update() {
		@JvmField var bizData: TLBizDataRaw? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			bizData = TLBizDataRaw.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			bizData?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8432e5d4u.toInt()
		}
	}
	
	open class TLUpdatesState: TLObject() {
		@JvmField var pts = 0
		@JvmField var qts = 0
		@JvmField var date = 0
		@JvmField var seq = 0
		@JvmField var unreadCount = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			pts = stream.readInt32(exception)
			qts = stream.readInt32(exception)
			date = stream.readInt32(exception)
			seq = stream.readInt32(exception)
			unreadCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(pts)
			stream.writeInt32(qts)
			stream.writeInt32(date)
			stream.writeInt32(seq)
			stream.writeInt32(unreadCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa56c2a3eu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLUpdatesState? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLUpdatesState")
					}
					else {
						null
					}
				}
	
				val result = TLUpdatesState()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLUpdatesGetState: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLUpdatesState? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLUpdatesState.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xedd4882au.toInt()
		}
	}
	
	abstract class UpdatesDifference: TLObject() {
		@JvmField val newMessages = mutableListOf<Message>()
		@JvmField val otherUpdates = mutableListOf<Update>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val newEncryptedMessages = mutableListOf<EncryptedMessage>()
		@JvmField var date = 0
		@JvmField var pts = 0
		@JvmField val users = mutableListOf<User>()
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): UpdatesDifference? {
				val result = when (constructor) {
					TLUpdatesDifferenceEmpty.CONSTRUCTOR -> TLUpdatesDifferenceEmpty()
					TLUpdatesDifference.CONSTRUCTOR -> TLUpdatesDifference()
					TLUpdatesDifferenceSlice.CONSTRUCTOR -> TLUpdatesDifferenceSlice()
					TLUpdatesDifferenceTooLong.CONSTRUCTOR -> TLUpdatesDifferenceTooLong()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in UpdatesDifference")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLUpdatesDifferenceEmpty: UpdatesDifference() {
			@JvmField var seq = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			date = stream.readInt32(exception)
			seq = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(date)
			stream.writeInt32(seq)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5d75a138u.toInt()
		}
	}
	
	open class TLUpdatesDifference: UpdatesDifference() {
							@JvmField var state: TLUpdatesState? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Message.deserialize(stream, stream.readInt32(exception), exception) ?: return
				newMessages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = EncryptedMessage.deserialize(stream, stream.readInt32(exception), exception) ?: return
				newEncryptedMessages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Update.deserialize(stream, stream.readInt32(exception), exception) ?: return
				otherUpdates.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
			state = TLUpdatesState.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(newMessages.size)
			newMessages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(newEncryptedMessages.size)
			newEncryptedMessages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(otherUpdates.size)
			otherUpdates.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
			state?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf49ca0u.toInt()
		}
	}
	
	open class TLUpdatesDifferenceSlice: UpdatesDifference() {
							@JvmField var intermediateState: TLUpdatesState? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Message.deserialize(stream, stream.readInt32(exception), exception) ?: return
				newMessages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = EncryptedMessage.deserialize(stream, stream.readInt32(exception), exception) ?: return
				newEncryptedMessages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Update.deserialize(stream, stream.readInt32(exception), exception) ?: return
				otherUpdates.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
			intermediateState = TLUpdatesState.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(newMessages.size)
			newMessages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(newEncryptedMessages.size)
			newEncryptedMessages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(otherUpdates.size)
			otherUpdates.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
			intermediateState?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa8fb1981u.toInt()
		}
	}
	
	open class TLUpdatesDifferenceTooLong: UpdatesDifference() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			pts = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(pts)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4afe8f6du.toInt()
		}
	}
	
	open class TLUpdatesGetDifference: TLObject() {
		@JvmField var flags = 0
		@JvmField var pts = 0
		@JvmField var ptsTotalLimit = 0
		@JvmField var date = 0
		@JvmField var qts = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): UpdatesDifference? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return UpdatesDifference.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (ptsTotalLimit != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(pts)
			if ((flags and 1) != 0) {
				stream.writeInt32(ptsTotalLimit)
			}
	
			stream.writeInt32(date)
			stream.writeInt32(qts)
		}
	
		companion object {
			val CONSTRUCTOR = 0x25939651u.toInt()
		}
	}
	
	abstract class Updates: TLObject() {
		@JvmField var mentioned = false
		@JvmField var silent = false
		@JvmField var viaBotId = 0L
		@JvmField var id = 0
		@JvmField val entities = mutableListOf<MessageEntity>()
		@JvmField var ttlPeriod = 0
		@JvmField var pts = 0
		@JvmField var fwdFrom: TLMessageFwdHeader? = null
		@JvmField var out = false
		@JvmField var mediaUnread = false
		@JvmField var media: MessageMedia? = null
		@JvmField var seq = 0
		@JvmField var message: String? = null
		@JvmField val users = mutableListOf<User>()
		@JvmField var replyTo: TLMessageReplyHeader? = null
		@JvmField val updates = mutableListOf<Update>()
		@JvmField var flags = 0
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField var receipt: ByteArray? = null
		@JvmField var ptsCount = 0
		@JvmField var date = 0
		@JvmField var chatId = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
				val result = when (constructor) {
					TLUpdatesTooLong.CONSTRUCTOR -> TLUpdatesTooLong()
					TLUpdateShortMessage.CONSTRUCTOR -> TLUpdateShortMessage()
					TLUpdateShortChatMessage.CONSTRUCTOR -> TLUpdateShortChatMessage()
					TLUpdateShort.CONSTRUCTOR -> TLUpdateShort()
					TLUpdatesCombined.CONSTRUCTOR -> TLUpdatesCombined()
					TLUpdates.CONSTRUCTOR -> TLUpdates()
					TLUpdateShortSentMessage.CONSTRUCTOR -> TLUpdateShortSentMessage()
					TLUpdateAccountResetAuthorization.CONSTRUCTOR -> TLUpdateAccountResetAuthorization()
					TLPaymentsRequestRecurringPayment.CONSTRUCTOR -> TLPaymentsRequestRecurringPayment()
					TLPaymentsRestorePlayMarketReceipt.CONSTRUCTOR -> TLPaymentsRestorePlayMarketReceipt()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in Updates")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLUpdatesTooLong: Updates() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe317af7eu.toInt()
		}
	}
	
	open class TLUpdateShortMessage: Updates() {
								@JvmField var userId = 0L
										
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			out = (flags and 2) != 0
			mentioned = (flags and 16) != 0
			mediaUnread = (flags and 32) != 0
			silent = (flags and 8192) != 0
			id = stream.readInt32(exception)
			userId = stream.readInt64(exception)
			message = stream.readString(exception) ?: return
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
			date = stream.readInt32(exception)
		
			if ((flags and 4) != 0) {
				fwdFrom = TLMessageFwdHeader.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2048) != 0) {
				viaBotId = stream.readInt64(exception)
			}
		
			if ((flags and 8) != 0) {
				replyTo = TLMessageReplyHeader.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 128) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
					entities.add(obj)
				}
			}
		
			if ((flags and 33554432) != 0) {
				ttlPeriod = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (out) flags or 2 else flags and 2.inv()
			flags = if (mentioned) flags or 16 else flags and 16.inv()
			flags = if (mediaUnread) flags or 32 else flags and 32.inv()
			flags = if (silent) flags or 8192 else flags and 8192.inv()
			flags = if (fwdFrom != null) flags or 4 else flags and 4.inv()
			flags = if (viaBotId != 0L) flags or 2048 else flags and 2048.inv()
			flags = if (replyTo != null) flags or 8 else flags and 8.inv()
			flags = if (ttlPeriod != 0) flags or 33554432 else flags and 33554432.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(id)
			stream.writeInt64(userId)
			stream.writeString(message)
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
			stream.writeInt32(date)
			if ((flags and 4) != 0) {
				fwdFrom?.serializeToStream(stream)
			}
	
			if ((flags and 2048) != 0) {
				stream.writeInt64(viaBotId)
			}
	
			if ((flags and 8) != 0) {
				replyTo?.serializeToStream(stream)
			}
	
			if ((flags and 128) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 33554432) != 0) {
				stream.writeInt32(ttlPeriod)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x313bc7f8u.toInt()
		}
	}
	
	open class TLUpdateShortChatMessage: Updates() {
								@JvmField var fromId = 0L
											
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			out = (flags and 2) != 0
			mentioned = (flags and 16) != 0
			mediaUnread = (flags and 32) != 0
			silent = (flags and 8192) != 0
			id = stream.readInt32(exception)
			fromId = stream.readInt64(exception)
			chatId = stream.readInt64(exception)
			message = stream.readString(exception) ?: return
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
			date = stream.readInt32(exception)
		
			if ((flags and 4) != 0) {
				fwdFrom = TLMessageFwdHeader.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2048) != 0) {
				viaBotId = stream.readInt64(exception)
			}
		
			if ((flags and 8) != 0) {
				replyTo = TLMessageReplyHeader.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 128) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
					entities.add(obj)
				}
			}
		
			if ((flags and 33554432) != 0) {
				ttlPeriod = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (out) flags or 2 else flags and 2.inv()
			flags = if (mentioned) flags or 16 else flags and 16.inv()
			flags = if (mediaUnread) flags or 32 else flags and 32.inv()
			flags = if (silent) flags or 8192 else flags and 8192.inv()
			flags = if (fwdFrom != null) flags or 4 else flags and 4.inv()
			flags = if (viaBotId != 0L) flags or 2048 else flags and 2048.inv()
			flags = if (replyTo != null) flags or 8 else flags and 8.inv()
			flags = if (ttlPeriod != 0) flags or 33554432 else flags and 33554432.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(id)
			stream.writeInt64(fromId)
			stream.writeInt64(chatId)
			stream.writeString(message)
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
			stream.writeInt32(date)
			if ((flags and 4) != 0) {
				fwdFrom?.serializeToStream(stream)
			}
	
			if ((flags and 2048) != 0) {
				stream.writeInt64(viaBotId)
			}
	
			if ((flags and 8) != 0) {
				replyTo?.serializeToStream(stream)
			}
	
			if ((flags and 128) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 33554432) != 0) {
				stream.writeInt32(ttlPeriod)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x4d6deea5u.toInt()
		}
	}
	
	open class TLUpdateShort: Updates() {
		@JvmField var update: Update? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			update = Update.deserialize(stream, stream.readInt32(exception), exception)
			date = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			update?.serializeToStream(stream)
			stream.writeInt32(date)
		}
	
		companion object {
			val CONSTRUCTOR = 0x78d4dec1u.toInt()
		}
	}
	
	open class TLUpdatesCombined: Updates() {
						@JvmField var seqStart = 0
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Update.deserialize(stream, stream.readInt32(exception), exception) ?: return
				updates.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
			date = stream.readInt32(exception)
			seqStart = stream.readInt32(exception)
			seq = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(updates.size)
			updates.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(date)
			stream.writeInt32(seqStart)
			stream.writeInt32(seq)
		}
	
		companion object {
			val CONSTRUCTOR = 0x725b04c3u.toInt()
		}
	}
	
	open class TLUpdates: Updates() {
						
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Update.deserialize(stream, stream.readInt32(exception), exception) ?: return
				updates.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
			date = stream.readInt32(exception)
			seq = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(updates.size)
			updates.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(date)
			stream.writeInt32(seq)
		}
	
		companion object {
			val CONSTRUCTOR = 0x74ae4240u.toInt()
		}
	}
	
	open class TLUpdateShortSentMessage: Updates() {
										
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			out = (flags and 2) != 0
			id = stream.readInt32(exception)
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
			date = stream.readInt32(exception)
		
			if ((flags and 512) != 0) {
				media = MessageMedia.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 128) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
					entities.add(obj)
				}
			}
		
			if ((flags and 33554432) != 0) {
				ttlPeriod = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (out) flags or 2 else flags and 2.inv()
			flags = if (media != null) flags or 512 else flags and 512.inv()
			flags = if (ttlPeriod != 0) flags or 33554432 else flags and 33554432.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(id)
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
			stream.writeInt32(date)
			if ((flags and 512) != 0) {
				media?.serializeToStream(stream)
			}
	
			if ((flags and 128) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 33554432) != 0) {
				stream.writeInt32(ttlPeriod)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9015e101u.toInt()
		}
	}
	
	open class TLUpdateAccountResetAuthorization: Updates() {
		@JvmField var userId = 0L
		@JvmField var authKeyId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			authKeyId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeInt64(authKeyId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3b70de75u.toInt()
		}
	}
	
	open class TLPaymentsRequestRecurringPayment: Updates() {
		@JvmField var userId: InputUser? = null
		@JvmField var recurringInitCharge: String? = null
		@JvmField var invoiceMedia: InputMedia? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = InputUser.deserialize(stream, stream.readInt32(exception), exception)
			recurringInitCharge = stream.readString(exception) ?: return
			invoiceMedia = InputMedia.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			userId?.serializeToStream(stream)
			stream.writeString(recurringInitCharge)
			invoiceMedia?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf01497a1u.toInt()
		}
	}
	
	open class TLPaymentsRestorePlayMarketReceipt: Updates() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			receipt = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteArray(receipt)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd268d789u.toInt()
		}
	}
	
	open class TLAccountGetNotifyExceptions: TLObject() {
		@JvmField var flags = 0
		@JvmField var compareSound = false
		@JvmField var peer: InputNotifyPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (compareSound) flags or 2 else flags and 2.inv()
			flags = if (peer != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				peer?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x53577479u.toInt()
		}
	}
	
	open class TLContactsDeleteContacts: TLObject() {
		@JvmField val id = mutableListOf<InputUser>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x96a0e00u.toInt()
		}
	}
	
	open class TLContactsAddContact: TLObject() {
		@JvmField var flags = 0
		@JvmField var addPhonePrivacyException = false
		@JvmField var id: InputUser? = null
		@JvmField var firstName: String? = null
		@JvmField var lastName: String? = null
		@JvmField var phone: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (addPhonePrivacyException) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			id?.serializeToStream(stream)
			stream.writeString(firstName)
			stream.writeString(lastName)
			stream.writeString(phone)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe8f463d0u.toInt()
		}
	}
	
	open class TLContactsAcceptContact: TLObject() {
		@JvmField var id: InputUser? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			id?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf831a20fu.toInt()
		}
	}
	
	open class TLContactsGetLocated: TLObject() {
		@JvmField var flags = 0
		@JvmField var background = false
		@JvmField var geoPoint: InputGeoPoint? = null
		@JvmField var selfExpires = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (background) flags or 2 else flags and 2.inv()
			flags = if (selfExpires != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			geoPoint?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(selfExpires)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd348bc44u.toInt()
		}
	}
	
	open class TLContactsBlockFromReplies: TLObject() {
		@JvmField var flags = 0
		@JvmField var deleteMessage = false
		@JvmField var deleteHistory = false
		@JvmField var reportSpam = false
		@JvmField var msgId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (deleteMessage) flags or 1 else flags and 1.inv()
			flags = if (deleteHistory) flags or 2 else flags and 2.inv()
			flags = if (reportSpam) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(msgId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x29a8962cu.toInt()
		}
	}
	
	open class TLMessagesGetExtendedMedia: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField val id = mutableListOf<Int>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x84f80814u.toInt()
		}
	}
	
	open class TLMessagesSendMessage: TLObject() {
		@JvmField var flags = 0
		@JvmField var noWebpage = false
		@JvmField var silent = false
		@JvmField var background = false
		@JvmField var clearDraft = false
		@JvmField var noforwards = false
		@JvmField var updateStickersetsOrder = false
		@JvmField var peer: InputPeer? = null
		@JvmField var replyToMsgId = 0
		@JvmField var message: String? = null
		@JvmField var randomId = 0L
		@JvmField var replyMarkup: ReplyMarkup? = null
		@JvmField val entities = mutableListOf<MessageEntity>()
		@JvmField var scheduleDate = 0
		@JvmField var sendAs: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (noWebpage) flags or 2 else flags and 2.inv()
			flags = if (silent) flags or 32 else flags and 32.inv()
			flags = if (background) flags or 64 else flags and 64.inv()
			flags = if (clearDraft) flags or 128 else flags and 128.inv()
			flags = if (noforwards) flags or 16384 else flags and 16384.inv()
			flags = if (updateStickersetsOrder) flags or 32768 else flags and 32768.inv()
			flags = if (replyToMsgId != 0) flags or 1 else flags and 1.inv()
			flags = if (replyMarkup != null) flags or 4 else flags and 4.inv()
			flags = if (entities.isNotEmpty()) flags or 8 else flags and 8.inv()
			flags = if (scheduleDate != 0) flags or 1024 else flags and 1024.inv()
			flags = if (sendAs != null) flags or 8192 else flags and 8192.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(replyToMsgId)
			}
	
			stream.writeString(message)
			stream.writeInt64(randomId)
			if ((flags and 4) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 1024) != 0) {
				stream.writeInt32(scheduleDate)
			}
	
			if ((flags and 8192) != 0) {
				sendAs?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd9d75a4u.toInt()
		}
	}
	
	open class TLMessagesSendMedia: TLObject() {
		@JvmField var flags = 0
		@JvmField var silent = false
		@JvmField var background = false
		@JvmField var clearDraft = false
		@JvmField var noforwards = false
		@JvmField var updateStickersetsOrder = false
		@JvmField var peer: InputPeer? = null
		@JvmField var replyToMsgId = 0
		@JvmField var media: InputMedia? = null
		@JvmField var message: String? = null
		@JvmField var randomId = 0L
		@JvmField var replyMarkup: ReplyMarkup? = null
		@JvmField val entities = mutableListOf<MessageEntity>()
		@JvmField var scheduleDate = 0
		@JvmField var sendAs: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (silent) flags or 32 else flags and 32.inv()
			flags = if (background) flags or 64 else flags and 64.inv()
			flags = if (clearDraft) flags or 128 else flags and 128.inv()
			flags = if (noforwards) flags or 16384 else flags and 16384.inv()
			flags = if (updateStickersetsOrder) flags or 32768 else flags and 32768.inv()
			flags = if (replyToMsgId != 0) flags or 1 else flags and 1.inv()
			flags = if (replyMarkup != null) flags or 4 else flags and 4.inv()
			flags = if (entities.isNotEmpty()) flags or 8 else flags and 8.inv()
			flags = if (scheduleDate != 0) flags or 1024 else flags and 1024.inv()
			flags = if (sendAs != null) flags or 8192 else flags and 8192.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(replyToMsgId)
			}
	
			media?.serializeToStream(stream)
			stream.writeString(message)
			stream.writeInt64(randomId)
			if ((flags and 4) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 1024) != 0) {
				stream.writeInt32(scheduleDate)
			}
	
			if ((flags and 8192) != 0) {
				sendAs?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe25ff8e0u.toInt()
		}
	}
	
	open class TLMessagesForwardMessages: TLObject() {
		@JvmField var flags = 0
		@JvmField var silent = false
		@JvmField var background = false
		@JvmField var withMyScore = false
		@JvmField var dropAuthor = false
		@JvmField var dropMediaCaptions = false
		@JvmField var noforwards = false
		@JvmField var fromPeer: InputPeer? = null
		@JvmField val id = mutableListOf<Int>()
		@JvmField val randomId = mutableListOf<Long>()
		@JvmField var toPeer: InputPeer? = null
		@JvmField var scheduleDate = 0
		@JvmField var sendAs: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (silent) flags or 32 else flags and 32.inv()
			flags = if (background) flags or 64 else flags and 64.inv()
			flags = if (withMyScore) flags or 256 else flags and 256.inv()
			flags = if (dropAuthor) flags or 2048 else flags and 2048.inv()
			flags = if (dropMediaCaptions) flags or 4096 else flags and 4096.inv()
			flags = if (noforwards) flags or 16384 else flags and 16384.inv()
			flags = if (scheduleDate != 0) flags or 1024 else flags and 1024.inv()
			flags = if (sendAs != null) flags or 8192 else flags and 8192.inv()
	
			stream.writeInt32(flags)
			fromPeer?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { stream.writeInt32(it) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(randomId.size)
			randomId.forEach { stream.writeInt64(it) }
			toPeer?.serializeToStream(stream)
			if ((flags and 1024) != 0) {
				stream.writeInt32(scheduleDate)
			}
	
			if ((flags and 8192) != 0) {
				sendAs?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xcc30290bu.toInt()
		}
	}
	
	open class TLMessagesEditChatTitle: TLObject() {
		@JvmField var chatId = 0L
		@JvmField var title: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(chatId)
			stream.writeString(title)
		}
	
		companion object {
			val CONSTRUCTOR = 0x73783ffdu.toInt()
		}
	}
	
	open class TLMessagesEditChatPhoto: TLObject() {
		@JvmField var chatId = 0L
		@JvmField var photo: InputChatPhoto? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(chatId)
			photo?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x35ddd674u.toInt()
		}
	}
	
	open class TLMessagesAddChatUser: TLObject() {
		@JvmField var chatId = 0L
		@JvmField var userId: InputUser? = null
		@JvmField var fwdLimit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(chatId)
			userId?.serializeToStream(stream)
			stream.writeInt32(fwdLimit)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf24753e3u.toInt()
		}
	}
	
	open class TLMessagesDeleteChatUser: TLObject() {
		@JvmField var flags = 0
		@JvmField var revokeHistory = false
		@JvmField var chatId = 0L
		@JvmField var userId: InputUser? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (revokeHistory) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(chatId)
			userId?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa2185cabu.toInt()
		}
	}
	
	open class TLMessagesCreateChat: TLObject() {
		@JvmField val users = mutableListOf<InputUser>()
		@JvmField var title: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
			stream.writeString(title)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9cb126eu.toInt()
		}
	}
	
	open class TLMessagesImportChatInvite: TLObject() {
		@JvmField var hash: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6c50051cu.toInt()
		}
	}
	
	open class TLMessagesStartBot: TLObject() {
		@JvmField var bot: InputUser? = null
		@JvmField var peer: InputPeer? = null
		@JvmField var randomId = 0L
		@JvmField var startParam: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			bot?.serializeToStream(stream)
			peer?.serializeToStream(stream)
			stream.writeInt64(randomId)
			stream.writeString(startParam)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe6df7378u.toInt()
		}
	}
	
	open class TLMessagesMigrateChat: TLObject() {
		@JvmField var chatId = 0L
		@JvmField var status = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(chatId)
			stream.writeBool(status)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa2875319u.toInt()
		}
	}
	
	open class TLMessagesSendInlineBotResult: TLObject() {
		@JvmField var flags = 0
		@JvmField var silent = false
		@JvmField var background = false
		@JvmField var clearDraft = false
		@JvmField var hideVia = false
		@JvmField var peer: InputPeer? = null
		@JvmField var replyToMsgId = 0
		@JvmField var randomId = 0L
		@JvmField var queryId = 0L
		@JvmField var id: String? = null
		@JvmField var scheduleDate = 0
		@JvmField var sendAs: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (silent) flags or 32 else flags and 32.inv()
			flags = if (background) flags or 64 else flags and 64.inv()
			flags = if (clearDraft) flags or 128 else flags and 128.inv()
			flags = if (hideVia) flags or 2048 else flags and 2048.inv()
			flags = if (replyToMsgId != 0) flags or 1 else flags and 1.inv()
			flags = if (scheduleDate != 0) flags or 1024 else flags and 1024.inv()
			flags = if (sendAs != null) flags or 8192 else flags and 8192.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(replyToMsgId)
			}
	
			stream.writeInt64(randomId)
			stream.writeInt64(queryId)
			stream.writeString(id)
			if ((flags and 1024) != 0) {
				stream.writeInt32(scheduleDate)
			}
	
			if ((flags and 8192) != 0) {
				sendAs?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x7aa11297u.toInt()
		}
	}
	
	open class TLMessagesEditMessage: TLObject() {
		@JvmField var flags = 0
		@JvmField var noWebpage = false
		@JvmField var peer: InputPeer? = null
		@JvmField var id = 0
		@JvmField var message: String? = null
		@JvmField var media: InputMedia? = null
		@JvmField var replyMarkup: ReplyMarkup? = null
		@JvmField val entities = mutableListOf<MessageEntity>()
		@JvmField var scheduleDate = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (noWebpage) flags or 2 else flags and 2.inv()
			flags = if (message != null) flags or 2048 else flags and 2048.inv()
			flags = if (media != null) flags or 16384 else flags and 16384.inv()
			flags = if (replyMarkup != null) flags or 4 else flags and 4.inv()
			flags = if (entities.isNotEmpty()) flags or 8 else flags and 8.inv()
			flags = if (scheduleDate != 0) flags or 32768 else flags and 32768.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt32(id)
			if ((flags and 2048) != 0) {
				stream.writeString(message)
			}
	
			if ((flags and 16384) != 0) {
				media?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 32768) != 0) {
				stream.writeInt32(scheduleDate)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x48f71778u.toInt()
		}
	}
	
	open class TLMessagesGetAllDrafts: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x6a3f8d65u.toInt()
		}
	}
	
	open class TLMessagesSetGameScore: TLObject() {
		@JvmField var flags = 0
		@JvmField var editMessage = false
		@JvmField var force = false
		@JvmField var peer: InputPeer? = null
		@JvmField var id = 0
		@JvmField var userId: InputUser? = null
		@JvmField var score = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (editMessage) flags or 1 else flags and 1.inv()
			flags = if (force) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt32(id)
			userId?.serializeToStream(stream)
			stream.writeInt32(score)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8ef8ecc0u.toInt()
		}
	}
	
	open class TLMessagesSendScreenshotNotification: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var replyToMsgId = 0
		@JvmField var randomId = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(replyToMsgId)
			stream.writeInt64(randomId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc97df020u.toInt()
		}
	}
	
	open class TLMessagesSendMultiMedia: TLObject() {
		@JvmField var flags = 0
		@JvmField var silent = false
		@JvmField var background = false
		@JvmField var clearDraft = false
		@JvmField var noforwards = false
		@JvmField var updateStickersetsOrder = false
		@JvmField var peer: InputPeer? = null
		@JvmField var replyToMsgId = 0
		@JvmField val multiMedia = mutableListOf<TLInputSingleMedia>()
		@JvmField var scheduleDate = 0
		@JvmField var sendAs: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (silent) flags or 32 else flags and 32.inv()
			flags = if (background) flags or 64 else flags and 64.inv()
			flags = if (clearDraft) flags or 128 else flags and 128.inv()
			flags = if (noforwards) flags or 16384 else flags and 16384.inv()
			flags = if (updateStickersetsOrder) flags or 32768 else flags and 32768.inv()
			flags = if (replyToMsgId != 0) flags or 1 else flags and 1.inv()
			flags = if (scheduleDate != 0) flags or 1024 else flags and 1024.inv()
			flags = if (sendAs != null) flags or 8192 else flags and 8192.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(replyToMsgId)
			}
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(multiMedia.size)
			multiMedia.forEach { it.serializeToStream(stream) }
			if ((flags and 1024) != 0) {
				stream.writeInt32(scheduleDate)
			}
	
			if ((flags and 8192) != 0) {
				sendAs?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf803138fu.toInt()
		}
	}
	
	open class TLMessagesUpdatePinnedMessage: TLObject() {
		@JvmField var flags = 0
		@JvmField var silent = false
		@JvmField var unpin = false
		@JvmField var pmOneside = false
		@JvmField var peer: InputPeer? = null
		@JvmField var id = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (silent) flags or 1 else flags and 1.inv()
			flags = if (unpin) flags or 2 else flags and 2.inv()
			flags = if (pmOneside) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt32(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd2aaf7ecu.toInt()
		}
	}
	
	open class TLMessagesSendVote: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var msgId = 0
		@JvmField val options = mutableListOf<ByteArray>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(options.size)
			options.forEach { stream.writeByteArray(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x10ea6184u.toInt()
		}
	}
	
	open class TLMessagesGetPollResults: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var msgId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x73bb643bu.toInt()
		}
	}
	
	open class TLMessagesEditChatDefaultBannedRights: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var bannedRights: TLChatBannedRights? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			bannedRights?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa5866b41u.toInt()
		}
	}
	
	open class TLMessagesSendScheduledMessages: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField val id = mutableListOf<Int>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xbd38850au.toInt()
		}
	}
	
	open class TLMessagesDeleteScheduledMessages: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField val id = mutableListOf<Int>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x59ae2b16u.toInt()
		}
	}
	
	open class TLMessagesSetHistoryTTL: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var period = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(period)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb80e5fe4u.toInt()
		}
	}
	
	open class TLMessagesSetChatTheme: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var emoticon: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeString(emoticon)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe63be13fu.toInt()
		}
	}
	
	open class TLMessagesHideChatJoinRequest: TLObject() {
		@JvmField var flags = 0
		@JvmField var approved = false
		@JvmField var peer: InputPeer? = null
		@JvmField var userId: InputUser? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (approved) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			userId?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7fe7e815u.toInt()
		}
	}
	
	open class TLMessagesHideAllChatJoinRequests: TLObject() {
		@JvmField var flags = 0
		@JvmField var approved = false
		@JvmField var peer: InputPeer? = null
		@JvmField var link: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (approved) flags or 1 else flags and 1.inv()
			flags = if (link != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			if ((flags and 2) != 0) {
				stream.writeString(link)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe085f4eau.toInt()
		}
	}
	
	open class TLMessagesToggleNoForwards: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var enabled = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeBool(enabled)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb11eafa2u.toInt()
		}
	}
	
	open class TLMessagesSendReaction: TLObject() {
		@JvmField var flags = 0
		@JvmField var big = false
		@JvmField var addToRecent = false
		@JvmField var peer: InputPeer? = null
		@JvmField var msgId = 0
		@JvmField val reaction = mutableListOf<Reaction>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (big) flags or 2 else flags and 2.inv()
			flags = if (addToRecent) flags or 4 else flags and 4.inv()
			flags = if (reaction.isNotEmpty()) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
			if ((flags and 1) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(reaction.size)
			reaction.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd30d78d4u.toInt()
		}
	}
	
	open class TLMessagesGetMessagesReactions: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField val id = mutableListOf<Int>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x8bba90e6u.toInt()
		}
	}
	
	open class TLMessagesSetChatAvailableReactions: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var availableReactions: ChatReactions? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			availableReactions?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfeb16771u.toInt()
		}
	}
	
	open class TLMessagesSendWebViewData: TLObject() {
		@JvmField var bot: InputUser? = null
		@JvmField var randomId = 0L
		@JvmField var buttonText: String? = null
		@JvmField var data: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			bot?.serializeToStream(stream)
			stream.writeInt64(randomId)
			stream.writeString(buttonText)
			stream.writeString(data)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdc0242c8u.toInt()
		}
	}
	
	open class TLHelpGetAppChangelog: TLObject() {
		@JvmField var prevAppVersion: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(prevAppVersion)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9010ef6fu.toInt()
		}
	}
	
	open class TLChannelsCreateChannel: TLObject() {
		@JvmField var flags = 0
		@JvmField var broadcast = false
		@JvmField var megagroup = false
		@JvmField var forImport = false
		@JvmField var title: String? = null
		@JvmField var about: String? = null
		@JvmField var geoPoint: InputGeoPoint? = null
		@JvmField var address: String? = null
		@JvmField var payType = 0
		@JvmField var cost = 0.0
		@JvmField var startDate = 0L
		@JvmField var endDate = 0L
		@JvmField var category: String? = null
		@JvmField var country: String? = null
		@JvmField var adult = false
		@JvmField var genre: String? = null
		@JvmField var subGenre: String? = null
		@JvmField var channelName: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (broadcast) flags or 1 else flags and 1.inv()
			flags = if (megagroup) flags or 2 else flags and 2.inv()
			flags = if (forImport) flags or 8 else flags and 8.inv()
			flags = if (geoPoint != null) flags or 4 else flags and 4.inv()
			flags = if (address != null) flags or 4 else flags and 4.inv()
			flags = if (payType != 0) flags or 16 else flags and 16.inv()
			flags = if (cost != 0.0) flags or 16 else flags and 16.inv()
			flags = if (startDate != 0L) flags or 32 else flags and 32.inv()
			flags = if (endDate != 0L) flags or 32 else flags and 32.inv()
			flags = if (category != null) flags or 64 else flags and 64.inv()
			flags = if (country != null) flags or 256 else flags and 256.inv()
			flags = if (adult) flags or 1024 else flags and 1024.inv()
			flags = if (genre != null) flags or 2048 else flags and 2048.inv()
			flags = if (subGenre != null) flags or 4096 else flags and 4096.inv()
			flags = if (channelName != null) flags or 8192 else flags and 8192.inv()
	
			stream.writeInt32(flags)
			stream.writeString(title)
			stream.writeString(about)
			if ((flags and 4) != 0) {
				geoPoint?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(address)
			}
	
			if ((flags and 16) != 0) {
				stream.writeInt32(payType)
			}
	
			if ((flags and 16) != 0) {
				stream.writeDouble(cost)
			}
	
			if ((flags and 32) != 0) {
				stream.writeInt64(startDate)
			}
	
			if ((flags and 32) != 0) {
				stream.writeInt64(endDate)
			}
	
			if ((flags and 64) != 0) {
				stream.writeString(category)
			}
	
			if ((flags and 256) != 0) {
				stream.writeString(country)
			}
	
			if ((flags and 2048) != 0) {
				stream.writeString(genre)
			}
	
			if ((flags and 4096) != 0) {
				stream.writeString(subGenre)
			}
	
			if ((flags and 8192) != 0) {
				stream.writeString(channelName)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3d5fb10fu.toInt()
		}
	}
	
	open class TLChannelsEditAdmin: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var userId: InputUser? = null
		@JvmField var adminRights: TLChatAdminRights? = null
		@JvmField var rank: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			userId?.serializeToStream(stream)
			adminRights?.serializeToStream(stream)
			stream.writeString(rank)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd33c8902u.toInt()
		}
	}
	
	open class TLChannelsEditTitle: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var title: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeString(title)
		}
	
		companion object {
			val CONSTRUCTOR = 0x566decd0u.toInt()
		}
	}
	
	open class TLChannelsEditPhoto: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var photo: InputChatPhoto? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			photo?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf12e57c9u.toInt()
		}
	}
	
	open class TLChannelsJoinChannel: TLObject() {
		@JvmField var channel: InputChannel? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x24b524c5u.toInt()
		}
	}
	
	open class TLChannelsLeaveChannel: TLObject() {
		@JvmField var channel: InputChannel? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf836aa95u.toInt()
		}
	}
	
	open class TLChannelsInviteToChannel: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField val users = mutableListOf<InputUser>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x199f3a6cu.toInt()
		}
	}
	
	open class TLChannelsDeleteChannel: TLObject() {
		@JvmField var channel: InputChannel? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc0111fe3u.toInt()
		}
	}
	
	open class TLChannelsToggleSignatures: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var enabled = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeBool(enabled)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1f69b606u.toInt()
		}
	}
	
	open class TLChannelsEditBanned: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var participant: InputPeer? = null
		@JvmField var bannedRights: TLChatBannedRights? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			participant?.serializeToStream(stream)
			bannedRights?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x96e6cd81u.toInt()
		}
	}
	
	open class TLChannelsDeleteHistory: TLObject() {
		@JvmField var flags = 0
		@JvmField var forEveryone = false
		@JvmField var channel: InputChannel? = null
		@JvmField var maxId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (forEveryone) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			channel?.serializeToStream(stream)
			stream.writeInt32(maxId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9baa9647u.toInt()
		}
	}
	
	open class TLChannelsTogglePreHistoryHidden: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var enabled = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeBool(enabled)
		}
	
		companion object {
			val CONSTRUCTOR = 0xeabbb94cu.toInt()
		}
	}
	
	open class TLChannelsEditCreator: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var userId: InputUser? = null
		@JvmField var password: InputCheckPasswordSRP? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			userId?.serializeToStream(stream)
			password?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8f38cd1fu.toInt()
		}
	}
	
	open class TLChannelsToggleSlowMode: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var seconds = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeInt32(seconds)
		}
	
		companion object {
			val CONSTRUCTOR = 0xedd49ef0u.toInt()
		}
	}
	
	open class TLChannelsConvertToGigagroup: TLObject() {
		@JvmField var channel: InputChannel? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb290c69u.toInt()
		}
	}
	
	open class TLChannelsToggleJoinToSend: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var enabled = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeBool(enabled)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe4cb9580u.toInt()
		}
	}
	
	open class TLChannelsToggleJoinRequest: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var enabled = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeBool(enabled)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4c2985b6u.toInt()
		}
	}
	
	open class TLChannelsToggleParticipantsHidden: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var enabled = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeBool(enabled)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6a6e7854u.toInt()
		}
	}
	
	open class TLChannelsCreateForumTopic: TLObject() {
		@JvmField var flags = 0
		@JvmField var channel: InputChannel? = null
		@JvmField var title: String? = null
		@JvmField var iconColor = 0
		@JvmField var iconEmojiId = 0L
		@JvmField var randomId = 0L
		@JvmField var sendAs: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (iconColor != 0) flags or 1 else flags and 1.inv()
			flags = if (iconEmojiId != 0L) flags or 8 else flags and 8.inv()
			flags = if (sendAs != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			channel?.serializeToStream(stream)
			stream.writeString(title)
			if ((flags and 1) != 0) {
				stream.writeInt32(iconColor)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt64(iconEmojiId)
			}
	
			stream.writeInt64(randomId)
			if ((flags and 4) != 0) {
				sendAs?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf40c0224u.toInt()
		}
	}
	
	open class TLChannelsUpdatePinnedForumTopic: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var topicId = 0
		@JvmField var pinned = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeInt32(topicId)
			stream.writeBool(pinned)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6c2d9026u.toInt()
		}
	}
	
	open class TLChannelsEditForumTopic: TLObject() {
		@JvmField var flags = 0
		@JvmField var channel: InputChannel? = null
		@JvmField var topicId = 0
		@JvmField var title: String? = null
		@JvmField var iconEmojiId = 0L
		@JvmField var closed = false
		@JvmField var hidden = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (title != null) flags or 1 else flags and 1.inv()
			flags = if (iconEmojiId != 0L) flags or 2 else flags and 2.inv()
			flags = if (closed) flags or 4 else flags and 4.inv()
			flags = if (hidden) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			channel?.serializeToStream(stream)
			stream.writeInt32(topicId)
			if ((flags and 1) != 0) {
				stream.writeString(title)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt64(iconEmojiId)
			}
	
			if ((flags and 4) != 0) {
				stream.writeBool(closed)
			}
	
			if ((flags and 8) != 0) {
				stream.writeBool(hidden)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf4dfa185u.toInt()
		}
	}
	
	open class TLChannelsToggleForum: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var enabled = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeBool(enabled)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa4298b29u.toInt()
		}
	}
	
	open class TLPhoneDiscardCall: TLObject() {
		@JvmField var flags = 0
		@JvmField var video = false
		@JvmField var peer: TLInputPhoneCall? = null
		@JvmField var duration = 0
		@JvmField var reason: PhoneCallDiscardReason? = null
		@JvmField var connectionId = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (video) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt32(duration)
			reason?.serializeToStream(stream)
			stream.writeInt64(connectionId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb2cbc1c0u.toInt()
		}
	}
	
	open class TLPhoneSetCallRating: TLObject() {
		@JvmField var flags = 0
		@JvmField var userInitiative = false
		@JvmField var peer: TLInputPhoneCall? = null
		@JvmField var rating = 0
		@JvmField var comment: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (userInitiative) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt32(rating)
			stream.writeString(comment)
		}
	
		companion object {
			val CONSTRUCTOR = 0x59ead627u.toInt()
		}
	}
	
	open class TLPhoneCreateGroupCall: TLObject() {
		@JvmField var flags = 0
		@JvmField var rtmpStream = false
		@JvmField var peer: InputPeer? = null
		@JvmField var randomId = 0
		@JvmField var title: String? = null
		@JvmField var scheduleDate = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (rtmpStream) flags or 4 else flags and 4.inv()
			flags = if (title != null) flags or 1 else flags and 1.inv()
			flags = if (scheduleDate != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt32(randomId)
			if ((flags and 1) != 0) {
				stream.writeString(title)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(scheduleDate)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x48cdc6d8u.toInt()
		}
	}
	
	open class TLPhoneJoinGroupCall: TLObject() {
		@JvmField var flags = 0
		@JvmField var muted = false
		@JvmField var videoStopped = false
		@JvmField var call: TLInputGroupCall? = null
		@JvmField var joinAs: InputPeer? = null
		@JvmField var inviteHash: String? = null
		@JvmField var params: TLDataJSON? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (muted) flags or 1 else flags and 1.inv()
			flags = if (videoStopped) flags or 4 else flags and 4.inv()
			flags = if (inviteHash != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			call?.serializeToStream(stream)
			joinAs?.serializeToStream(stream)
			if ((flags and 2) != 0) {
				stream.writeString(inviteHash)
			}
	
			params?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb132ff7bu.toInt()
		}
	}
	
	open class TLPhoneLeaveGroupCall: TLObject() {
		@JvmField var call: TLInputGroupCall? = null
		@JvmField var source = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
			stream.writeInt32(source)
		}
	
		companion object {
			val CONSTRUCTOR = 0x500377f9u.toInt()
		}
	}
	
	open class TLPhoneInviteToGroupCall: TLObject() {
		@JvmField var call: TLInputGroupCall? = null
		@JvmField val users = mutableListOf<InputUser>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x7b393160u.toInt()
		}
	}
	
	open class TLPhoneDiscardGroupCall: TLObject() {
		@JvmField var call: TLInputGroupCall? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7a777135u.toInt()
		}
	}
	
	open class TLPhoneToggleGroupCallSettings: TLObject() {
		@JvmField var flags = 0
		@JvmField var resetInviteHash = false
		@JvmField var call: TLInputGroupCall? = null
		@JvmField var joinMuted = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (resetInviteHash) flags or 2 else flags and 2.inv()
			flags = if (joinMuted) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			call?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeBool(joinMuted)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x74bbb43du.toInt()
		}
	}
	
	open class TLPhoneToggleGroupCallRecord: TLObject() {
		@JvmField var flags = 0
		@JvmField var start = false
		@JvmField var video = false
		@JvmField var call: TLInputGroupCall? = null
		@JvmField var title: String? = null
		@JvmField var videoPortrait = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (start) flags or 1 else flags and 1.inv()
			flags = if (video) flags or 4 else flags and 4.inv()
			flags = if (title != null) flags or 2 else flags and 2.inv()
			flags = if (videoPortrait) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			call?.serializeToStream(stream)
			if ((flags and 2) != 0) {
				stream.writeString(title)
			}
	
			if ((flags and 4) != 0) {
				stream.writeBool(videoPortrait)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf128c708u.toInt()
		}
	}
	
	open class TLPhoneEditGroupCallParticipant: TLObject() {
		@JvmField var flags = 0
		@JvmField var call: TLInputGroupCall? = null
		@JvmField var participant: InputPeer? = null
		@JvmField var muted = false
		@JvmField var volume = 0
		@JvmField var raiseHand = false
		@JvmField var videoStopped = false
		@JvmField var videoPaused = false
		@JvmField var presentationPaused = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (muted) flags or 1 else flags and 1.inv()
			flags = if (volume != 0) flags or 2 else flags and 2.inv()
			flags = if (raiseHand) flags or 4 else flags and 4.inv()
			flags = if (videoStopped) flags or 8 else flags and 8.inv()
			flags = if (videoPaused) flags or 16 else flags and 16.inv()
			flags = if (presentationPaused) flags or 32 else flags and 32.inv()
	
			stream.writeInt32(flags)
			call?.serializeToStream(stream)
			participant?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeBool(muted)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(volume)
			}
	
			if ((flags and 4) != 0) {
				stream.writeBool(raiseHand)
			}
	
			if ((flags and 8) != 0) {
				stream.writeBool(videoStopped)
			}
	
			if ((flags and 16) != 0) {
				stream.writeBool(videoPaused)
			}
	
			if ((flags and 32) != 0) {
				stream.writeBool(presentationPaused)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa5273abfu.toInt()
		}
	}
	
	open class TLPhoneEditGroupCallTitle: TLObject() {
		@JvmField var call: TLInputGroupCall? = null
		@JvmField var title: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
			stream.writeString(title)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1ca6ac0au.toInt()
		}
	}
	
	open class TLPhoneToggleGroupCallStartSubscription: TLObject() {
		@JvmField var call: TLInputGroupCall? = null
		@JvmField var subscribed = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
			stream.writeBool(subscribed)
		}
	
		companion object {
			val CONSTRUCTOR = 0x219c34e6u.toInt()
		}
	}
	
	open class TLPhoneStartScheduledGroupCall: TLObject() {
		@JvmField var call: TLInputGroupCall? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5680e342u.toInt()
		}
	}
	
	open class TLPhoneJoinGroupCallPresentation: TLObject() {
		@JvmField var call: TLInputGroupCall? = null
		@JvmField var params: TLDataJSON? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
			params?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcbea6bc4u.toInt()
		}
	}
	
	open class TLPhoneLeaveGroupCallPresentation: TLObject() {
		@JvmField var call: TLInputGroupCall? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1c50d144u.toInt()
		}
	}
	
	open class TLFoldersEditPeerFolders: TLObject() {
		@JvmField val folderPeers = mutableListOf<TLInputFolderPeer>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(folderPeers.size)
			folderPeers.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x6847d0abu.toInt()
		}
	}
	
	open class TLFoldersDeleteFolder: TLObject() {
		@JvmField var folderId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(folderId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1c295881u.toInt()
		}
	}
	
	open class TLChatlistsLeaveChatlist: TLObject() {
		@JvmField var chatlist: TLInputChatlist? = null
		@JvmField val peers = mutableListOf<InputPeer>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			chatlist?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(peers.size)
			peers.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x74fae13au.toInt()
		}
	}
	
	open class TLChatlistsJoinChatlistInvite: TLObject() {
		@JvmField var slug: String? = null
		@JvmField val peers = mutableListOf<InputPeer>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(slug)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(peers.size)
			peers.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xa6b1e39au.toInt()
		}
	}
	
	open class TLPaymentsAssignAppStoreTransaction: TLObject() {
		@JvmField var receipt: ByteArray? = null
		@JvmField var purpose: InputStorePaymentPurpose? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteArray(receipt)
			purpose?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x80ed747du.toInt()
		}
	}
	
	open class TLPaymentsAssignPlayMarketTransaction: TLObject() {
		@JvmField var receipt: TLDataJSON? = null
		@JvmField var purpose: InputStorePaymentPurpose? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Updates? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Updates.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			receipt?.serializeToStream(stream)
			purpose?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdffd50d3u.toInt()
		}
	}
	
	abstract class PhotosPhotos: TLObject() {
		@JvmField val photos = mutableListOf<Photo>()
		@JvmField val users = mutableListOf<User>()
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PhotosPhotos? {
				val result = when (constructor) {
					TLPhotosPhotos.CONSTRUCTOR -> TLPhotosPhotos()
					TLPhotosPhotosSlice.CONSTRUCTOR -> TLPhotosPhotosSlice()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in PhotosPhotos")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPhotosPhotos: PhotosPhotos() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Photo.deserialize(stream, stream.readInt32(exception), exception) ?: return
				photos.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(photos.size)
			photos.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x8dca6aa5u.toInt()
		}
	}
	
	open class TLPhotosPhotosSlice: PhotosPhotos() {
		@JvmField var count = 0
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			count = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Photo.deserialize(stream, stream.readInt32(exception), exception) ?: return
				photos.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(count)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(photos.size)
			photos.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x15051f54u.toInt()
		}
	}
	
	open class TLPhotosGetUserPhotos: TLObject() {
		@JvmField var userId: InputUser? = null
		@JvmField var offset = 0
		@JvmField var maxId = 0L
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PhotosPhotos? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return PhotosPhotos.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			userId?.serializeToStream(stream)
			stream.writeInt32(offset)
			stream.writeInt64(maxId)
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0x91cd32a8u.toInt()
		}
	}
	
	open class TLPhotosPhoto: TLObject() {
		@JvmField var photo: Photo? = null
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			photo = Photo.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			photo?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x20212ca8u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhotosPhoto? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPhotosPhoto")
					}
					else {
						null
					}
				}
	
				val result = TLPhotosPhoto()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPhotosUpdateProfilePhoto: TLObject() {
		@JvmField var id: InputPhoto? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhotosPhoto? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPhotosPhoto.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			id?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x72d4742cu.toInt()
		}
	}
	
	open class TLPhotosUploadProfilePhoto: TLObject() {
		@JvmField var flags = 0
		@JvmField var file: InputFile? = null
		@JvmField var video: InputFile? = null
		@JvmField var videoStartTs = 0.0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhotosPhoto? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPhotosPhoto.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (file != null) flags or 1 else flags and 1.inv()
			flags = if (video != null) flags or 2 else flags and 2.inv()
			flags = if (videoStartTs != 0.0) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				file?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				video?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				stream.writeDouble(videoStartTs)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x89f30f69u.toInt()
		}
	}
	
	abstract class UploadFile: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): UploadFile? {
				val result = when (constructor) {
					TLUploadFile.CONSTRUCTOR -> TLUploadFile()
					TLUploadFileCdnRedirect.CONSTRUCTOR -> TLUploadFileCdnRedirect()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in UploadFile")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLUploadFile: UploadFile() {
		@JvmField var type: StorageFileType? = null
		@JvmField var mtime = 0
		@JvmField var bytes: NativeByteBuffer? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = StorageFileType.deserialize(stream, stream.readInt32(exception), exception)
			mtime = stream.readInt32(exception)
			bytes = stream.readByteBuffer(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			type?.serializeToStream(stream)
			stream.writeInt32(mtime)
			stream.writeByteBuffer(bytes)
		}
	
		companion object {
			val CONSTRUCTOR = 0x96a18d5u.toInt()
		}
	}
	
	open class TLUploadFileCdnRedirect: UploadFile() {
		@JvmField var dcId = 0
		@JvmField var fileToken: ByteArray? = null
		@JvmField var encryptionKey: ByteArray? = null
		@JvmField var encryptionIv: ByteArray? = null
		@JvmField val fileHashes = mutableListOf<TLFileHash>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			dcId = stream.readInt32(exception)
			fileToken = stream.readByteArray(exception) ?: return
			encryptionKey = stream.readByteArray(exception) ?: return
			encryptionIv = stream.readByteArray(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLFileHash.deserialize(stream, stream.readInt32(exception), exception) ?: return
				fileHashes.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(dcId)
			stream.writeByteArray(fileToken)
			stream.writeByteArray(encryptionKey)
			stream.writeByteArray(encryptionIv)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(fileHashes.size)
			fileHashes.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xf18cda44u.toInt()
		}
	}
	
	open class TLUploadGetFile: TLObject() {
		@JvmField var flags = 0
		@JvmField var precise = false
		@JvmField var cdnSupported = false
		@JvmField var location: InputFileLocation? = null
		@JvmField var offset = 0L
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): UploadFile? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return UploadFile.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (precise) flags or 1 else flags and 1.inv()
			flags = if (cdnSupported) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			location?.serializeToStream(stream)
			stream.writeInt64(offset)
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbe5335beu.toInt()
		}
	}
	
	open class TLDcOption: TLObject() {
		@JvmField var flags = 0
		@JvmField var ipv6 = false
		@JvmField var mediaOnly = false
		@JvmField var tcpoOnly = false
		@JvmField var cdn = false
		@JvmField var isStatic = false
		@JvmField var thisPortOnly = false
		@JvmField var id = 0
		@JvmField var ipAddress: String? = null
		@JvmField var port = 0
		@JvmField var secret: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			ipv6 = (flags and 1) != 0
			mediaOnly = (flags and 2) != 0
			tcpoOnly = (flags and 4) != 0
			cdn = (flags and 8) != 0
			isStatic = (flags and 16) != 0
			thisPortOnly = (flags and 32) != 0
			id = stream.readInt32(exception)
			ipAddress = stream.readString(exception) ?: return
			port = stream.readInt32(exception)
		
			if ((flags and 1024) != 0) {
				secret = stream.readByteArray(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (ipv6) flags or 1 else flags and 1.inv()
			flags = if (mediaOnly) flags or 2 else flags and 2.inv()
			flags = if (tcpoOnly) flags or 4 else flags and 4.inv()
			flags = if (cdn) flags or 8 else flags and 8.inv()
			flags = if (isStatic) flags or 16 else flags and 16.inv()
			flags = if (thisPortOnly) flags or 32 else flags and 32.inv()
			flags = if (secret != null) flags or 1024 else flags and 1024.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(id)
			stream.writeString(ipAddress)
			stream.writeInt32(port)
			if ((flags and 1024) != 0) {
				stream.writeByteArray(secret)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x18b7a10du.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLDcOption? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLDcOption")
					}
					else {
						null
					}
				}
	
				val result = TLDcOption()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLConfig: TLObject() {
		@JvmField var flags = 0
		@JvmField var phonecallsEnabled = false
		@JvmField var defaultP2pContacts = false
		@JvmField var preloadFeaturedStickers = false
		@JvmField var ignorePhoneEntities = false
		@JvmField var revokePmInbox = false
		@JvmField var blockedMode = false
		@JvmField var pfsEnabled = false
		@JvmField var forceTryIpv6 = false
		@JvmField var date = 0
		@JvmField var expires = 0
		@JvmField var testMode = false
		@JvmField var thisDc = 0
		@JvmField val dcOptions = mutableListOf<TLDcOption>()
		@JvmField var dcTxtDomainName: String? = null
		@JvmField var chatSizeMax = 0
		@JvmField var megagroupSizeMax = 0
		@JvmField var forwardedCountMax = 0
		@JvmField var onlineUpdatePeriodMs = 0
		@JvmField var offlineBlurTimeoutMs = 0
		@JvmField var offlineIdleTimeoutMs = 0
		@JvmField var onlineCloudTimeoutMs = 0
		@JvmField var notifyCloudDelayMs = 0
		@JvmField var notifyDefaultDelayMs = 0
		@JvmField var pushChatPeriodMs = 0
		@JvmField var pushChatLimit = 0
		@JvmField var savedGifsLimit = 0
		@JvmField var editTimeLimit = 0
		@JvmField var revokeTimeLimit = 0
		@JvmField var revokePmTimeLimit = 0
		@JvmField var ratingEDecay = 0
		@JvmField var stickersRecentLimit = 0
		@JvmField var stickersFavedLimit = 0
		@JvmField var channelsReadMediaPeriod = 0
		@JvmField var tmpSessions = 0
		@JvmField var pinnedDialogsCountMax = 0
		@JvmField var pinnedInfolderCountMax = 0
		@JvmField var callReceiveTimeoutMs = 0
		@JvmField var callRingTimeoutMs = 0
		@JvmField var callConnectTimeoutMs = 0
		@JvmField var callPacketTimeoutMs = 0
		@JvmField var meUrlPrefix: String? = null
		@JvmField var autoupdateUrlPrefix: String? = null
		@JvmField var gifSearchUsername: String? = null
		@JvmField var venueSearchUsername: String? = null
		@JvmField var imgSearchUsername: String? = null
		@JvmField var staticMapsProvider: String? = null
		@JvmField var captionLengthMax = 0
		@JvmField var messageLengthMax = 0
		@JvmField var webfileDcId = 0
		@JvmField var suggestedLangCode: String? = null
		@JvmField var langPackVersion = 0
		@JvmField var baseLangPackVersion = 0
		@JvmField var reactionsDefault: Reaction? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			phonecallsEnabled = (flags and 2) != 0
			defaultP2pContacts = (flags and 8) != 0
			preloadFeaturedStickers = (flags and 16) != 0
			ignorePhoneEntities = (flags and 32) != 0
			revokePmInbox = (flags and 64) != 0
			blockedMode = (flags and 256) != 0
			pfsEnabled = (flags and 8192) != 0
			forceTryIpv6 = (flags and 16384) != 0
			date = stream.readInt32(exception)
			expires = stream.readInt32(exception)
			testMode = stream.readBool(exception)
			thisDc = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLDcOption.deserialize(stream, stream.readInt32(exception), exception) ?: return
				dcOptions.add(obj)
			}
			dcTxtDomainName = stream.readString(exception) ?: return
			chatSizeMax = stream.readInt32(exception)
			megagroupSizeMax = stream.readInt32(exception)
			forwardedCountMax = stream.readInt32(exception)
			onlineUpdatePeriodMs = stream.readInt32(exception)
			offlineBlurTimeoutMs = stream.readInt32(exception)
			offlineIdleTimeoutMs = stream.readInt32(exception)
			onlineCloudTimeoutMs = stream.readInt32(exception)
			notifyCloudDelayMs = stream.readInt32(exception)
			notifyDefaultDelayMs = stream.readInt32(exception)
			pushChatPeriodMs = stream.readInt32(exception)
			pushChatLimit = stream.readInt32(exception)
			savedGifsLimit = stream.readInt32(exception)
			editTimeLimit = stream.readInt32(exception)
			revokeTimeLimit = stream.readInt32(exception)
			revokePmTimeLimit = stream.readInt32(exception)
			ratingEDecay = stream.readInt32(exception)
			stickersRecentLimit = stream.readInt32(exception)
			stickersFavedLimit = stream.readInt32(exception)
			channelsReadMediaPeriod = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				tmpSessions = stream.readInt32(exception)
			}
			pinnedDialogsCountMax = stream.readInt32(exception)
			pinnedInfolderCountMax = stream.readInt32(exception)
			callReceiveTimeoutMs = stream.readInt32(exception)
			callRingTimeoutMs = stream.readInt32(exception)
			callConnectTimeoutMs = stream.readInt32(exception)
			callPacketTimeoutMs = stream.readInt32(exception)
			meUrlPrefix = stream.readString(exception) ?: return
		
			if ((flags and 128) != 0) {
				autoupdateUrlPrefix = stream.readString(exception) ?: return
			}
		
			if ((flags and 512) != 0) {
				gifSearchUsername = stream.readString(exception) ?: return
			}
		
			if ((flags and 1024) != 0) {
				venueSearchUsername = stream.readString(exception) ?: return
			}
		
			if ((flags and 2048) != 0) {
				imgSearchUsername = stream.readString(exception) ?: return
			}
		
			if ((flags and 4096) != 0) {
				staticMapsProvider = stream.readString(exception) ?: return
			}
			captionLengthMax = stream.readInt32(exception)
			messageLengthMax = stream.readInt32(exception)
			webfileDcId = stream.readInt32(exception)
		
			if ((flags and 4) != 0) {
				suggestedLangCode = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				langPackVersion = stream.readInt32(exception)
			}
		
			if ((flags and 4) != 0) {
				baseLangPackVersion = stream.readInt32(exception)
			}
		
			if ((flags and 32768) != 0) {
				reactionsDefault = Reaction.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (phonecallsEnabled) flags or 2 else flags and 2.inv()
			flags = if (defaultP2pContacts) flags or 8 else flags and 8.inv()
			flags = if (preloadFeaturedStickers) flags or 16 else flags and 16.inv()
			flags = if (ignorePhoneEntities) flags or 32 else flags and 32.inv()
			flags = if (revokePmInbox) flags or 64 else flags and 64.inv()
			flags = if (blockedMode) flags or 256 else flags and 256.inv()
			flags = if (pfsEnabled) flags or 8192 else flags and 8192.inv()
			flags = if (forceTryIpv6) flags or 16384 else flags and 16384.inv()
			flags = if (tmpSessions != 0) flags or 1 else flags and 1.inv()
			flags = if (autoupdateUrlPrefix != null) flags or 128 else flags and 128.inv()
			flags = if (gifSearchUsername != null) flags or 512 else flags and 512.inv()
			flags = if (venueSearchUsername != null) flags or 1024 else flags and 1024.inv()
			flags = if (imgSearchUsername != null) flags or 2048 else flags and 2048.inv()
			flags = if (staticMapsProvider != null) flags or 4096 else flags and 4096.inv()
			flags = if (suggestedLangCode != null) flags or 4 else flags and 4.inv()
			flags = if (langPackVersion != 0) flags or 4 else flags and 4.inv()
			flags = if (baseLangPackVersion != 0) flags or 4 else flags and 4.inv()
			flags = if (reactionsDefault != null) flags or 32768 else flags and 32768.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(date)
			stream.writeInt32(expires)
			stream.writeBool(testMode)
			stream.writeInt32(thisDc)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(dcOptions.size)
			dcOptions.forEach { it.serializeToStream(stream) }
			stream.writeString(dcTxtDomainName)
			stream.writeInt32(chatSizeMax)
			stream.writeInt32(megagroupSizeMax)
			stream.writeInt32(forwardedCountMax)
			stream.writeInt32(onlineUpdatePeriodMs)
			stream.writeInt32(offlineBlurTimeoutMs)
			stream.writeInt32(offlineIdleTimeoutMs)
			stream.writeInt32(onlineCloudTimeoutMs)
			stream.writeInt32(notifyCloudDelayMs)
			stream.writeInt32(notifyDefaultDelayMs)
			stream.writeInt32(pushChatPeriodMs)
			stream.writeInt32(pushChatLimit)
			stream.writeInt32(savedGifsLimit)
			stream.writeInt32(editTimeLimit)
			stream.writeInt32(revokeTimeLimit)
			stream.writeInt32(revokePmTimeLimit)
			stream.writeInt32(ratingEDecay)
			stream.writeInt32(stickersRecentLimit)
			stream.writeInt32(stickersFavedLimit)
			stream.writeInt32(channelsReadMediaPeriod)
			if ((flags and 1) != 0) {
				stream.writeInt32(tmpSessions)
			}
	
			stream.writeInt32(pinnedDialogsCountMax)
			stream.writeInt32(pinnedInfolderCountMax)
			stream.writeInt32(callReceiveTimeoutMs)
			stream.writeInt32(callRingTimeoutMs)
			stream.writeInt32(callConnectTimeoutMs)
			stream.writeInt32(callPacketTimeoutMs)
			stream.writeString(meUrlPrefix)
			if ((flags and 128) != 0) {
				stream.writeString(autoupdateUrlPrefix)
			}
	
			if ((flags and 512) != 0) {
				stream.writeString(gifSearchUsername)
			}
	
			if ((flags and 1024) != 0) {
				stream.writeString(venueSearchUsername)
			}
	
			if ((flags and 2048) != 0) {
				stream.writeString(imgSearchUsername)
			}
	
			if ((flags and 4096) != 0) {
				stream.writeString(staticMapsProvider)
			}
	
			stream.writeInt32(captionLengthMax)
			stream.writeInt32(messageLengthMax)
			stream.writeInt32(webfileDcId)
			if ((flags and 4) != 0) {
				stream.writeString(suggestedLangCode)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(langPackVersion)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(baseLangPackVersion)
			}
	
			if ((flags and 32768) != 0) {
				reactionsDefault?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x232566acu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLConfig? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLConfig")
					}
					else {
						null
					}
				}
	
				val result = TLConfig()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLHelpGetConfig: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLConfig? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLConfig.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc4f9186bu.toInt()
		}
	}
	
	open class TLNearestDc: TLObject() {
		@JvmField var country: String? = null
		@JvmField var thisDc = 0
		@JvmField var nearestDc = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			country = stream.readString(exception) ?: return
			thisDc = stream.readInt32(exception)
			nearestDc = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(country)
			stream.writeInt32(thisDc)
			stream.writeInt32(nearestDc)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8e1a1775u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLNearestDc? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLNearestDc")
					}
					else {
						null
					}
				}
	
				val result = TLNearestDc()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLHelpGetNearestDc: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLNearestDc? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLNearestDc.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1fb33026u.toInt()
		}
	}
	
	abstract class HelpAppUpdate: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpAppUpdate? {
				val result = when (constructor) {
					TLHelpAppUpdate.CONSTRUCTOR -> TLHelpAppUpdate()
					TLHelpNoAppUpdate.CONSTRUCTOR -> TLHelpNoAppUpdate()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in HelpAppUpdate")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLHelpAppUpdate: HelpAppUpdate() {
		@JvmField var flags = 0
		@JvmField var canNotSkip = false
		@JvmField var id = 0
		@JvmField var version: String? = null
		@JvmField var text: String? = null
		@JvmField val entities = mutableListOf<MessageEntity>()
		@JvmField var document: Document? = null
		@JvmField var url: String? = null
		@JvmField var sticker: Document? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			canNotSkip = (flags and 1) != 0
			id = stream.readInt32(exception)
			version = stream.readString(exception) ?: return
			text = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
				entities.add(obj)
			}
		
			if ((flags and 2) != 0) {
				document = Document.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 4) != 0) {
				url = stream.readString(exception) ?: return
			}
		
			if ((flags and 8) != 0) {
				sticker = Document.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (canNotSkip) flags or 1 else flags and 1.inv()
			flags = if (document != null) flags or 2 else flags and 2.inv()
			flags = if (url != null) flags or 4 else flags and 4.inv()
			flags = if (sticker != null) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(id)
			stream.writeString(version)
			stream.writeString(text)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			if ((flags and 2) != 0) {
				document?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(url)
			}
	
			if ((flags and 8) != 0) {
				sticker?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xccbbce30u.toInt()
		}
	}
	
	open class TLHelpNoAppUpdate: HelpAppUpdate() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc45a6536u.toInt()
		}
	}
	
	open class TLHelpGetAppUpdate: TLObject() {
		@JvmField var source: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpAppUpdate? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return HelpAppUpdate.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(source)
		}
	
		companion object {
			val CONSTRUCTOR = 0x522d5a7du.toInt()
		}
	}
	
	open class TLHelpInviteText: TLObject() {
		@JvmField var message: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			message = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(message)
		}
	
		companion object {
			val CONSTRUCTOR = 0x18cb9f78u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLHelpInviteText? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLHelpInviteText")
					}
					else {
						null
					}
				}
	
				val result = TLHelpInviteText()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLHelpGetInviteText: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLHelpInviteText? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLHelpInviteText.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x4d392343u.toInt()
		}
	}
	
	abstract class EncryptedChat: TLObject() {
		@JvmField var gA: ByteArray? = null
		@JvmField var flags = 0
		@JvmField var keyFingerprint = 0L
		@JvmField var date = 0
		@JvmField var accessHash = 0L
		@JvmField var adminId = 0L
		@JvmField var participantId = 0L
		@JvmField var id = 0
		@JvmField var aOrB: ByteArray? = null
		@JvmField var authKey: ByteArray? = null
		@JvmField var userId: Long = 0L
		@JvmField var ttl: Int = 0
		@JvmField var layer: Int = 0
		@JvmField var seqIn: Int = 0
		@JvmField var seqOut: Int = 0
		@JvmField var inSeqNo: Int = 0
		@JvmField var mtprotoSeq: Int = 0
		@JvmField var keyHash: ByteArray? = null
		@JvmField var keyUseCountIn: Short = 0
		@JvmField var keyUseCountOut: Short = 0
		@JvmField var exchangeId: Long = 0L
		@JvmField var keyCreateDate: Int = 0
		@JvmField var futureKeyFingerprint: Long = 0L
		@JvmField var futureAuthKey: ByteArray? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): EncryptedChat? {
				val result = when (constructor) {
					TLEncryptedChatEmpty.CONSTRUCTOR -> TLEncryptedChatEmpty()
					TLEncryptedChatWaiting.CONSTRUCTOR -> TLEncryptedChatWaiting()
					TLEncryptedChatRequested.CONSTRUCTOR -> TLEncryptedChatRequested()
					TLEncryptedChat.CONSTRUCTOR -> TLEncryptedChat()
					TLEncryptedChatDiscarded.CONSTRUCTOR -> TLEncryptedChatDiscarded()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in EncryptedChat")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLEncryptedChatEmpty: EncryptedChat() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0xab7ec0a0u.toInt()
		}
	}
	
	open class TLEncryptedChatWaiting: EncryptedChat() {
						
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt32(exception)
			accessHash = stream.readInt64(exception)
			date = stream.readInt32(exception)
			adminId = stream.readInt64(exception)
			participantId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(id)
			stream.writeInt64(accessHash)
			stream.writeInt32(date)
			stream.writeInt64(adminId)
			stream.writeInt64(participantId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x66b25953u.toInt()
		}
	}
	
	open class TLEncryptedChatRequested: EncryptedChat() {
			@JvmField var folderId = 0
							
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				folderId = stream.readInt32(exception)
			}
			id = stream.readInt32(exception)
			accessHash = stream.readInt64(exception)
			date = stream.readInt32(exception)
			adminId = stream.readInt64(exception)
			participantId = stream.readInt64(exception)
			gA = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (folderId != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeInt32(folderId)
			}
	
			stream.writeInt32(id)
			stream.writeInt64(accessHash)
			stream.writeInt32(date)
			stream.writeInt64(adminId)
			stream.writeInt64(participantId)
			stream.writeByteArray(gA)
		}
	
		companion object {
			val CONSTRUCTOR = 0x48f1d94cu.toInt()
		}
	}
	
	open class TLEncryptedChat: EncryptedChat() {
							@JvmField var gAOrB: ByteArray? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt32(exception)
			accessHash = stream.readInt64(exception)
			date = stream.readInt32(exception)
			adminId = stream.readInt64(exception)
			participantId = stream.readInt64(exception)
			gAOrB = stream.readByteArray(exception) ?: return
			keyFingerprint = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(id)
			stream.writeInt64(accessHash)
			stream.writeInt32(date)
			stream.writeInt64(adminId)
			stream.writeInt64(participantId)
			stream.writeByteArray(gAOrB)
			stream.writeInt64(keyFingerprint)
		}
	
		companion object {
			val CONSTRUCTOR = 0x61f0d4c7u.toInt()
		}
	}
	
	open class TLEncryptedChatDiscarded: EncryptedChat() {
			@JvmField var historyDeleted = false
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			historyDeleted = (flags and 1) != 0
			id = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (historyDeleted) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1e1c7c45u.toInt()
		}
	}
	
	open class TLMessagesRequestEncryption: TLObject() {
		@JvmField var userId: InputUser? = null
		@JvmField var randomId = 0
		@JvmField var gA: ByteArray? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): EncryptedChat? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return EncryptedChat.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			userId?.serializeToStream(stream)
			stream.writeInt32(randomId)
			stream.writeByteArray(gA)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf64daf43u.toInt()
		}
	}
	
	open class TLMessagesAcceptEncryption: TLObject() {
		@JvmField var peer: TLInputEncryptedChat? = null
		@JvmField var gB: ByteArray? = null
		@JvmField var keyFingerprint = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): EncryptedChat? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return EncryptedChat.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeByteArray(gB)
			stream.writeInt64(keyFingerprint)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3dbc0415u.toInt()
		}
	}
	
	open class TLInputEncryptedChat: TLObject() {
		@JvmField var chatId = 0
		@JvmField var accessHash = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			chatId = stream.readInt32(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(chatId)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf141b5e1u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLInputEncryptedChat? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLInputEncryptedChat")
					}
					else {
						null
					}
				}
	
				val result = TLInputEncryptedChat()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class EncryptedFile: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): EncryptedFile? {
				val result = when (constructor) {
					TLEncryptedFileEmpty.CONSTRUCTOR -> TLEncryptedFileEmpty()
					TLEncryptedFile.CONSTRUCTOR -> TLEncryptedFile()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in EncryptedFile")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLEncryptedFileEmpty: EncryptedFile() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc21f497eu.toInt()
		}
	}
	
	open class TLEncryptedFile: EncryptedFile() {
		@JvmField var id = 0L
		@JvmField var accessHash = 0L
		@JvmField var size = 0L
		@JvmField var dcId = 0
		@JvmField var keyFingerprint = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			size = stream.readInt64(exception)
			dcId = stream.readInt32(exception)
			keyFingerprint = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeInt64(size)
			stream.writeInt32(dcId)
			stream.writeInt32(keyFingerprint)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa8008cd8u.toInt()
		}
	}
	
	open class TLMessagesUploadEncryptedFile: TLObject() {
		@JvmField var peer: TLInputEncryptedChat? = null
		@JvmField var file: InputEncryptedFile? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): EncryptedFile? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return EncryptedFile.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			file?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5057c497u.toInt()
		}
	}
	
	abstract class InputEncryptedFile: TLObject() {
		@JvmField var keyFingerprint = 0
		@JvmField var parts = 0
		@JvmField var id = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputEncryptedFile? {
				val result = when (constructor) {
					TLInputEncryptedFileEmpty.CONSTRUCTOR -> TLInputEncryptedFileEmpty()
					TLInputEncryptedFileUploaded.CONSTRUCTOR -> TLInputEncryptedFileUploaded()
					TLInputEncryptedFile.CONSTRUCTOR -> TLInputEncryptedFile()
					TLInputEncryptedFileBigUploaded.CONSTRUCTOR -> TLInputEncryptedFileBigUploaded()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputEncryptedFile")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputEncryptedFileEmpty: InputEncryptedFile() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1837c364u.toInt()
		}
	}
	
	open class TLInputEncryptedFileUploaded: InputEncryptedFile() {
				@JvmField var md5Checksum: String? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			parts = stream.readInt32(exception)
			md5Checksum = stream.readString(exception) ?: return
			keyFingerprint = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt32(parts)
			stream.writeString(md5Checksum)
			stream.writeInt32(keyFingerprint)
		}
	
		companion object {
			val CONSTRUCTOR = 0x64bd0306u.toInt()
		}
	}
	
	open class TLInputEncryptedFile: InputEncryptedFile() {
			@JvmField var accessHash = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5a17b5e5u.toInt()
		}
	}
	
	open class TLInputEncryptedFileBigUploaded: InputEncryptedFile() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			parts = stream.readInt32(exception)
			keyFingerprint = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt32(parts)
			stream.writeInt32(keyFingerprint)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2dc173c8u.toInt()
		}
	}
	
	abstract class EncryptedMessage: TLObject() {
		@JvmField var chatId = 0
		@JvmField var randomId = 0L
		@JvmField var bytes: ByteArray? = null
		@JvmField var date = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): EncryptedMessage? {
				val result = when (constructor) {
					TLEncryptedMessage.CONSTRUCTOR -> TLEncryptedMessage()
					TLEncryptedMessageService.CONSTRUCTOR -> TLEncryptedMessageService()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in EncryptedMessage")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLEncryptedMessage: EncryptedMessage() {
						@JvmField var file: EncryptedFile? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			randomId = stream.readInt64(exception)
			chatId = stream.readInt32(exception)
			date = stream.readInt32(exception)
			bytes = stream.readByteArray(exception) ?: return
			file = EncryptedFile.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(randomId)
			stream.writeInt32(chatId)
			stream.writeInt32(date)
			stream.writeByteArray(bytes)
			file?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xed18c118u.toInt()
		}
	}
	
	open class TLEncryptedMessageService: EncryptedMessage() {
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			randomId = stream.readInt64(exception)
			chatId = stream.readInt32(exception)
			date = stream.readInt32(exception)
			bytes = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(randomId)
			stream.writeInt32(chatId)
			stream.writeInt32(date)
			stream.writeByteArray(bytes)
		}
	
		companion object {
			val CONSTRUCTOR = 0x23734b06u.toInt()
		}
	}
	
	abstract class MessagesDhConfig: TLObject() {
		@JvmField var version = 0
		@JvmField var random: ByteArray? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesDhConfig? {
				val result = when (constructor) {
					TLMessagesDhConfigNotModified.CONSTRUCTOR -> TLMessagesDhConfigNotModified()
					TLMessagesDhConfig.CONSTRUCTOR -> TLMessagesDhConfig()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesDhConfig")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesDhConfigNotModified: MessagesDhConfig() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			random = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteArray(random)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc0e24635u.toInt()
		}
	}
	
	open class TLMessagesDhConfig: MessagesDhConfig() {
		@JvmField var g = 0
		@JvmField var p: ByteArray? = null
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			g = stream.readInt32(exception)
			p = stream.readByteArray(exception) ?: return
			version = stream.readInt32(exception)
			random = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(g)
			stream.writeByteArray(p)
			stream.writeInt32(version)
			stream.writeByteArray(random)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2c221eddu.toInt()
		}
	}
	
	open class TLMessagesGetDhConfig: TLObject() {
		@JvmField var version = 0
		@JvmField var randomLength = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesDhConfig? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesDhConfig.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(version)
			stream.writeInt32(randomLength)
		}
	
		companion object {
			val CONSTRUCTOR = 0x26cf8950u.toInt()
		}
	}
	
	abstract class MessagesSentEncryptedMessage: TLObject() {
		@JvmField var file: EncryptedFile? = null
		@JvmField var date = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesSentEncryptedMessage? {
				val result = when (constructor) {
					TLMessagesSentEncryptedMessage.CONSTRUCTOR -> TLMessagesSentEncryptedMessage()
					TLMessagesSentEncryptedFile.CONSTRUCTOR -> TLMessagesSentEncryptedFile()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesSentEncryptedMessage")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesSentEncryptedMessage: MessagesSentEncryptedMessage() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			date = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(date)
		}
	
		companion object {
			val CONSTRUCTOR = 0x560f8935u.toInt()
		}
	}
	
	open class TLMessagesSentEncryptedFile: MessagesSentEncryptedMessage() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			date = stream.readInt32(exception)
			file = EncryptedFile.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(date)
			file?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9493ff32u.toInt()
		}
	}
	
	open class TLMessagesSendEncrypted: TLObject() {
		@JvmField var flags = 0
		@JvmField var silent = false
		@JvmField var peer: TLInputEncryptedChat? = null
		@JvmField var randomId = 0L
		@JvmField var data: ByteArray? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesSentEncryptedMessage? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesSentEncryptedMessage.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (silent) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt64(randomId)
			stream.writeByteArray(data)
		}
	
		companion object {
			val CONSTRUCTOR = 0x44fa7a15u.toInt()
		}
	}
	
	open class TLMessagesSendEncryptedFile: TLObject() {
		@JvmField var flags = 0
		@JvmField var silent = false
		@JvmField var peer: TLInputEncryptedChat? = null
		@JvmField var randomId = 0L
		@JvmField var data: ByteArray? = null
		@JvmField var file: InputEncryptedFile? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesSentEncryptedMessage? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesSentEncryptedMessage.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (silent) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt64(randomId)
			stream.writeByteArray(data)
			file?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5559481du.toInt()
		}
	}
	
	open class TLMessagesSendEncryptedService: TLObject() {
		@JvmField var peer: TLInputEncryptedChat? = null
		@JvmField var randomId = 0L
		@JvmField var data: ByteArray? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesSentEncryptedMessage? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesSentEncryptedMessage.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt64(randomId)
			stream.writeByteArray(data)
		}
	
		companion object {
			val CONSTRUCTOR = 0x32d439a4u.toInt()
		}
	}
	
	abstract class InputDocument: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputDocument? {
				val result = when (constructor) {
					TLInputDocumentEmpty.CONSTRUCTOR -> TLInputDocumentEmpty()
					TLInputDocument.CONSTRUCTOR -> TLInputDocument()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputDocument")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputDocumentEmpty: InputDocument() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x72f0eaaeu.toInt()
		}
	}
	
	open class TLInputDocument: InputDocument() {
		@JvmField var id = 0L
		@JvmField var accessHash = 0L
		@JvmField var fileReference: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			fileReference = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeByteArray(fileReference)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1abfb575u.toInt()
		}
	}
	
	abstract class Document: TLObject() {
		@JvmField var size = 0L
		@JvmField var flags = 0
		@JvmField var id = 0L
		@JvmField var mimeType: String? = null
		@JvmField var fileNameFixed: String? = null
		@JvmField var localPath: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Document? {
				val result = when (constructor) {
					TLDocumentEmpty.CONSTRUCTOR -> TLDocumentEmpty()
					TLDocument.CONSTRUCTOR -> TLDocument()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in Document")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLDocumentEmpty: Document() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0x36f8c871u.toInt()
		}
	}
	
	open class TLDocument: Document() {
				@JvmField var accessHash = 0L
		@JvmField var fileReference: ByteArray? = null
		@JvmField var date = 0
				@JvmField val thumbs = mutableListOf<PhotoSize>()
		@JvmField val videoThumbs = mutableListOf<VideoSize>()
		@JvmField var dcId = 0
		@JvmField val attributes = mutableListOf<DocumentAttribute>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			fileReference = stream.readByteArray(exception) ?: return
			date = stream.readInt32(exception)
			mimeType = stream.readString(exception) ?: return
			size = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = PhotoSize.deserialize(stream, stream.readInt32(exception), exception) ?: return
					thumbs.add(obj)
				}
			}
		
			if ((flags and 2) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = VideoSize.deserialize(stream, stream.readInt32(exception), exception) ?: return
					videoThumbs.add(obj)
				}
			}
			dcId = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = DocumentAttribute.deserialize(stream, stream.readInt32(exception), exception) ?: return
				attributes.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeByteArray(fileReference)
			stream.writeInt32(date)
			stream.writeString(mimeType)
			stream.writeInt64(size)
			if ((flags and 1) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(thumbs.size)
			thumbs.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(videoThumbs.size)
			videoThumbs.forEach { it.serializeToStream(stream) }
			}
	
			stream.writeInt32(dcId)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(attributes.size)
			attributes.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x8fd4c4d8u.toInt()
		}
	}
	
	open class TLAccountUploadTheme: TLObject() {
		@JvmField var flags = 0
		@JvmField var file: InputFile? = null
		@JvmField var thumb: InputFile? = null
		@JvmField var fileName: String? = null
		@JvmField var mimeType: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Document? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Document.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (thumb != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			file?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				thumb?.serializeToStream(stream)
			}
	
			stream.writeString(fileName)
			stream.writeString(mimeType)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1c3db333u.toInt()
		}
	}
	
	open class TLAccountUploadRingtone: TLObject() {
		@JvmField var file: InputFile? = null
		@JvmField var fileName: String? = null
		@JvmField var mimeType: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Document? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Document.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			file?.serializeToStream(stream)
			stream.writeString(fileName)
			stream.writeString(mimeType)
		}
	
		companion object {
			val CONSTRUCTOR = 0x831a83a2u.toInt()
		}
	}
	
	open class TLMessagesGetDocumentByHash: TLObject() {
		@JvmField var sha256: ByteArray? = null
		@JvmField var size = 0L
		@JvmField var mimeType: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Document? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return Document.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteArray(sha256)
			stream.writeInt64(size)
			stream.writeString(mimeType)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb1f2061fu.toInt()
		}
	}
	
	open class TLHelpSupport: TLObject() {
		@JvmField var phoneNumber: String? = null
		@JvmField var user: User? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			phoneNumber = stream.readString(exception) ?: return
			user = User.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phoneNumber)
			user?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x17c6b5f6u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLHelpSupport? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLHelpSupport")
					}
					else {
						null
					}
				}
	
				val result = TLHelpSupport()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLHelpGetSupport: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLHelpSupport? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLHelpSupport.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9cdf08cdu.toInt()
		}
	}
	
	abstract class NotifyPeer: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): NotifyPeer? {
				val result = when (constructor) {
					TLNotifyPeer.CONSTRUCTOR -> TLNotifyPeer()
					TLNotifyUsers.CONSTRUCTOR -> TLNotifyUsers()
					TLNotifyChats.CONSTRUCTOR -> TLNotifyChats()
					TLNotifyBroadcasts.CONSTRUCTOR -> TLNotifyBroadcasts()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in NotifyPeer")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLNotifyPeer: NotifyPeer() {
		@JvmField var peer: Peer? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9fd40bd8u.toInt()
		}
	}
	
	open class TLNotifyUsers: NotifyPeer() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb4c83b4cu.toInt()
		}
	}
	
	open class TLNotifyChats: NotifyPeer() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc007cec3u.toInt()
		}
	}
	
	open class TLNotifyBroadcasts: NotifyPeer() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd612e8efu.toInt()
		}
	}
	
	abstract class SendMessageAction: TLObject() {
		@JvmField var progress = 0
		@JvmField var emoticon: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): SendMessageAction? {
				val result = when (constructor) {
					TLSendMessageTypingAction.CONSTRUCTOR -> TLSendMessageTypingAction()
					TLSendMessageCancelAction.CONSTRUCTOR -> TLSendMessageCancelAction()
					TLSendMessageRecordVideoAction.CONSTRUCTOR -> TLSendMessageRecordVideoAction()
					TLSendMessageUploadVideoAction.CONSTRUCTOR -> TLSendMessageUploadVideoAction()
					TLSendMessageRecordAudioAction.CONSTRUCTOR -> TLSendMessageRecordAudioAction()
					TLSendMessageUploadAudioAction.CONSTRUCTOR -> TLSendMessageUploadAudioAction()
					TLSendMessageUploadPhotoAction.CONSTRUCTOR -> TLSendMessageUploadPhotoAction()
					TLSendMessageUploadDocumentAction.CONSTRUCTOR -> TLSendMessageUploadDocumentAction()
					TLSendMessageGeoLocationAction.CONSTRUCTOR -> TLSendMessageGeoLocationAction()
					TLSendMessageChooseContactAction.CONSTRUCTOR -> TLSendMessageChooseContactAction()
					TLSendMessageGamePlayAction.CONSTRUCTOR -> TLSendMessageGamePlayAction()
					TLSendMessageRecordRoundAction.CONSTRUCTOR -> TLSendMessageRecordRoundAction()
					TLSendMessageUploadRoundAction.CONSTRUCTOR -> TLSendMessageUploadRoundAction()
					TLSpeakingInGroupCallAction.CONSTRUCTOR -> TLSpeakingInGroupCallAction()
					TLSendMessageHistoryImportAction.CONSTRUCTOR -> TLSendMessageHistoryImportAction()
					TLSendMessageChooseStickerAction.CONSTRUCTOR -> TLSendMessageChooseStickerAction()
					TLSendMessageEmojiInteraction.CONSTRUCTOR -> TLSendMessageEmojiInteraction()
					TLSendMessageEmojiInteractionSeen.CONSTRUCTOR -> TLSendMessageEmojiInteractionSeen()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in SendMessageAction")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLSendMessageTypingAction: SendMessageAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x16bf744eu.toInt()
		}
	}
	
	open class TLSendMessageCancelAction: SendMessageAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xfd5ec8f5u.toInt()
		}
	}
	
	open class TLSendMessageRecordVideoAction: SendMessageAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa187d66fu.toInt()
		}
	}
	
	open class TLSendMessageUploadVideoAction: SendMessageAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			progress = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(progress)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe9763aecu.toInt()
		}
	}
	
	open class TLSendMessageRecordAudioAction: SendMessageAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd52f73f7u.toInt()
		}
	}
	
	open class TLSendMessageUploadAudioAction: SendMessageAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			progress = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(progress)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf351d7abu.toInt()
		}
	}
	
	open class TLSendMessageUploadPhotoAction: SendMessageAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			progress = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(progress)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd1d34a26u.toInt()
		}
	}
	
	open class TLSendMessageUploadDocumentAction: SendMessageAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			progress = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(progress)
		}
	
		companion object {
			val CONSTRUCTOR = 0xaa0cd9e4u.toInt()
		}
	}
	
	open class TLSendMessageGeoLocationAction: SendMessageAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x176f8ba1u.toInt()
		}
	}
	
	open class TLSendMessageChooseContactAction: SendMessageAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x628cbc6fu.toInt()
		}
	}
	
	open class TLSendMessageGamePlayAction: SendMessageAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xdd6a8f48u.toInt()
		}
	}
	
	open class TLSendMessageRecordRoundAction: SendMessageAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x88f27fbcu.toInt()
		}
	}
	
	open class TLSendMessageUploadRoundAction: SendMessageAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			progress = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(progress)
		}
	
		companion object {
			val CONSTRUCTOR = 0x243e1c66u.toInt()
		}
	}
	
	open class TLSpeakingInGroupCallAction: SendMessageAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd92c2285u.toInt()
		}
	}
	
	open class TLSendMessageHistoryImportAction: SendMessageAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			progress = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(progress)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdbda9246u.toInt()
		}
	}
	
	open class TLSendMessageChooseStickerAction: SendMessageAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb05ac6b1u.toInt()
		}
	}
	
	open class TLSendMessageEmojiInteraction: SendMessageAction() {
			@JvmField var msgId = 0
		@JvmField var interaction: TLDataJSON? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			emoticon = stream.readString(exception) ?: return
			msgId = stream.readInt32(exception)
			interaction = TLDataJSON.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(emoticon)
			stream.writeInt32(msgId)
			interaction?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x25972bcbu.toInt()
		}
	}
	
	open class TLSendMessageEmojiInteractionSeen: SendMessageAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			emoticon = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(emoticon)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb665902eu.toInt()
		}
	}
	
	open class TLContactsFound: TLObject() {
		@JvmField val myResults = mutableListOf<Peer>()
		@JvmField val results = mutableListOf<Peer>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Peer.deserialize(stream, stream.readInt32(exception), exception) ?: return
				myResults.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Peer.deserialize(stream, stream.readInt32(exception), exception) ?: return
				results.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(myResults.size)
			myResults.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(results.size)
			results.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xb3134d9du.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLContactsFound? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLContactsFound")
					}
					else {
						null
					}
				}
	
				val result = TLContactsFound()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLContactsSearch: TLObject() {
		@JvmField var q: String? = null
		@JvmField var limit = 0
		@JvmField var flags = 0
		@JvmField var isRecommended = false
		@JvmField var isNew = false
		@JvmField var isPaid = false
		@JvmField var isCourse = false
		@JvmField var isPublic = false
		@JvmField var country: String? = null
		@JvmField var category: String? = null
		@JvmField var genre: String? = null
		@JvmField var page = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLContactsFound? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLContactsFound.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (isRecommended) flags or 4 else flags and 4.inv()
			flags = if (isNew) flags or 8 else flags and 8.inv()
			flags = if (isPaid) flags or 16 else flags and 16.inv()
			flags = if (isCourse) flags or 32 else flags and 32.inv()
			flags = if (isPublic) flags or 64 else flags and 64.inv()
			flags = if (country != null) flags or 128 else flags and 128.inv()
			flags = if (category != null) flags or 256 else flags and 256.inv()
			flags = if (genre != null) flags or 512 else flags and 512.inv()
			flags = if (page != 0) flags or 1024 else flags and 1024.inv()
	
			stream.writeString(q)
			stream.writeInt32(limit)
			stream.writeInt32(flags)
			if ((flags and 128) != 0) {
				stream.writeString(country)
			}
	
			if ((flags and 256) != 0) {
				stream.writeString(category)
			}
	
			if ((flags and 512) != 0) {
				stream.writeString(genre)
			}
	
			if ((flags and 1024) != 0) {
				stream.writeInt32(page)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x11f812d8u.toInt()
		}
	}
	
	abstract class InputPrivacyKey: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputPrivacyKey? {
				val result = when (constructor) {
					TLInputPrivacyKeyStatusTimestamp.CONSTRUCTOR -> TLInputPrivacyKeyStatusTimestamp()
					TLInputPrivacyKeyChatInvite.CONSTRUCTOR -> TLInputPrivacyKeyChatInvite()
					TLInputPrivacyKeyPhoneCall.CONSTRUCTOR -> TLInputPrivacyKeyPhoneCall()
					TLInputPrivacyKeyPhoneP2P.CONSTRUCTOR -> TLInputPrivacyKeyPhoneP2P()
					TLInputPrivacyKeyForwards.CONSTRUCTOR -> TLInputPrivacyKeyForwards()
					TLInputPrivacyKeyProfilePhoto.CONSTRUCTOR -> TLInputPrivacyKeyProfilePhoto()
					TLInputPrivacyKeyPhoneNumber.CONSTRUCTOR -> TLInputPrivacyKeyPhoneNumber()
					TLInputPrivacyKeyAddedByPhone.CONSTRUCTOR -> TLInputPrivacyKeyAddedByPhone()
					TLInputPrivacyKeyVoiceMessages.CONSTRUCTOR -> TLInputPrivacyKeyVoiceMessages()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputPrivacyKey")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputPrivacyKeyStatusTimestamp: InputPrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x4f96cb18u.toInt()
		}
	}
	
	open class TLInputPrivacyKeyChatInvite: InputPrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xbdfb0426u.toInt()
		}
	}
	
	open class TLInputPrivacyKeyPhoneCall: InputPrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xfabadc5fu.toInt()
		}
	}
	
	open class TLInputPrivacyKeyPhoneP2P: InputPrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xdb9e70d2u.toInt()
		}
	}
	
	open class TLInputPrivacyKeyForwards: InputPrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa4dd4c08u.toInt()
		}
	}
	
	open class TLInputPrivacyKeyProfilePhoto: InputPrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x5719baccu.toInt()
		}
	}
	
	open class TLInputPrivacyKeyPhoneNumber: InputPrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x352dafau.toInt()
		}
	}
	
	open class TLInputPrivacyKeyAddedByPhone: InputPrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd1219bddu.toInt()
		}
	}
	
	open class TLInputPrivacyKeyVoiceMessages: InputPrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xaee69d68u.toInt()
		}
	}
	
	abstract class PrivacyKey: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PrivacyKey? {
				val result = when (constructor) {
					TLPrivacyKeyStatusTimestamp.CONSTRUCTOR -> TLPrivacyKeyStatusTimestamp()
					TLPrivacyKeyChatInvite.CONSTRUCTOR -> TLPrivacyKeyChatInvite()
					TLPrivacyKeyPhoneCall.CONSTRUCTOR -> TLPrivacyKeyPhoneCall()
					TLPrivacyKeyPhoneP2P.CONSTRUCTOR -> TLPrivacyKeyPhoneP2P()
					TLPrivacyKeyForwards.CONSTRUCTOR -> TLPrivacyKeyForwards()
					TLPrivacyKeyProfilePhoto.CONSTRUCTOR -> TLPrivacyKeyProfilePhoto()
					TLPrivacyKeyPhoneNumber.CONSTRUCTOR -> TLPrivacyKeyPhoneNumber()
					TLPrivacyKeyAddedByPhone.CONSTRUCTOR -> TLPrivacyKeyAddedByPhone()
					TLPrivacyKeyVoiceMessages.CONSTRUCTOR -> TLPrivacyKeyVoiceMessages()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in PrivacyKey")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPrivacyKeyStatusTimestamp: PrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xbc2eab30u.toInt()
		}
	}
	
	open class TLPrivacyKeyChatInvite: PrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x500e6dfau.toInt()
		}
	}
	
	open class TLPrivacyKeyPhoneCall: PrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3d662b7bu.toInt()
		}
	}
	
	open class TLPrivacyKeyPhoneP2P: PrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x39491cc8u.toInt()
		}
	}
	
	open class TLPrivacyKeyForwards: PrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x69ec56a3u.toInt()
		}
	}
	
	open class TLPrivacyKeyProfilePhoto: PrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x96151fedu.toInt()
		}
	}
	
	open class TLPrivacyKeyPhoneNumber: PrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd19ae46du.toInt()
		}
	}
	
	open class TLPrivacyKeyAddedByPhone: PrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x42ffd42bu.toInt()
		}
	}
	
	open class TLPrivacyKeyVoiceMessages: PrivacyKey() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x697f414u.toInt()
		}
	}
	
	abstract class InputPrivacyRule: TLObject() {
		@JvmField val chats = mutableListOf<Long>()
		@JvmField val users = mutableListOf<InputUser>()
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputPrivacyRule? {
				val result = when (constructor) {
					TLInputPrivacyValueAllowContacts.CONSTRUCTOR -> TLInputPrivacyValueAllowContacts()
					TLInputPrivacyValueAllowAll.CONSTRUCTOR -> TLInputPrivacyValueAllowAll()
					TLInputPrivacyValueAllowUsers.CONSTRUCTOR -> TLInputPrivacyValueAllowUsers()
					TLInputPrivacyValueDisallowContacts.CONSTRUCTOR -> TLInputPrivacyValueDisallowContacts()
					TLInputPrivacyValueDisallowAll.CONSTRUCTOR -> TLInputPrivacyValueDisallowAll()
					TLInputPrivacyValueDisallowUsers.CONSTRUCTOR -> TLInputPrivacyValueDisallowUsers()
					TLInputPrivacyValueAllowChatParticipants.CONSTRUCTOR -> TLInputPrivacyValueAllowChatParticipants()
					TLInputPrivacyValueDisallowChatParticipants.CONSTRUCTOR -> TLInputPrivacyValueDisallowChatParticipants()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputPrivacyRule")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputPrivacyValueAllowContacts: InputPrivacyRule() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd09e07bu.toInt()
		}
	}
	
	open class TLInputPrivacyValueAllowAll: InputPrivacyRule() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x184b35ceu.toInt()
		}
	}
	
	open class TLInputPrivacyValueAllowUsers: InputPrivacyRule() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = InputUser.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x131cc67fu.toInt()
		}
	}
	
	open class TLInputPrivacyValueDisallowContacts: InputPrivacyRule() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xba52007u.toInt()
		}
	}
	
	open class TLInputPrivacyValueDisallowAll: InputPrivacyRule() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd66b66c9u.toInt()
		}
	}
	
	open class TLInputPrivacyValueDisallowUsers: InputPrivacyRule() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = InputUser.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x90110467u.toInt()
		}
	}
	
	open class TLInputPrivacyValueAllowChatParticipants: InputPrivacyRule() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				chats.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x840649cfu.toInt()
		}
	}
	
	open class TLInputPrivacyValueDisallowChatParticipants: InputPrivacyRule() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				chats.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xe94f0f86u.toInt()
		}
	}
	
	open class TLAccountPrivacyRules: TLObject() {
		@JvmField val rules = mutableListOf<PrivacyRule>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = PrivacyRule.deserialize(stream, stream.readInt32(exception), exception) ?: return
				rules.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(rules.size)
			rules.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x50a04e45u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountPrivacyRules? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAccountPrivacyRules")
					}
					else {
						null
					}
				}
	
				val result = TLAccountPrivacyRules()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountGetPrivacy: TLObject() {
		@JvmField var key: InputPrivacyKey? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountPrivacyRules? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAccountPrivacyRules.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			key?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdadbc950u.toInt()
		}
	}
	
	open class TLAccountSetPrivacy: TLObject() {
		@JvmField var key: InputPrivacyKey? = null
		@JvmField val rules = mutableListOf<InputPrivacyRule>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountPrivacyRules? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAccountPrivacyRules.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			key?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(rules.size)
			rules.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xc9f81ce8u.toInt()
		}
	}
	
	open class TLAccountDaysTTL: TLObject() {
		@JvmField var days = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			days = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(days)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb8d0afdfu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountDaysTTL? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAccountDaysTTL")
					}
					else {
						null
					}
				}
	
				val result = TLAccountDaysTTL()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountGetAccountTTL: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountDaysTTL? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAccountDaysTTL.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8fc711du.toInt()
		}
	}
	
	abstract class DocumentAttribute: TLObject() {
		@JvmField var stickerset: InputStickerSet? = null
		@JvmField var flags = 0
		@JvmField var h = 0
		@JvmField var alt: String? = null
		@JvmField var w = 0
		@JvmField var duration = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): DocumentAttribute? {
				val result = when (constructor) {
					TLDocumentAttributeImageSize.CONSTRUCTOR -> TLDocumentAttributeImageSize()
					TLDocumentAttributeAnimated.CONSTRUCTOR -> TLDocumentAttributeAnimated()
					TLDocumentAttributeSticker.CONSTRUCTOR -> TLDocumentAttributeSticker()
					TLDocumentAttributeVideo.CONSTRUCTOR -> TLDocumentAttributeVideo()
					TLDocumentAttributeAudio.CONSTRUCTOR -> TLDocumentAttributeAudio()
					TLDocumentAttributeFilename.CONSTRUCTOR -> TLDocumentAttributeFilename()
					TLDocumentAttributeHasStickers.CONSTRUCTOR -> TLDocumentAttributeHasStickers()
					TLDocumentAttributeCustomEmoji.CONSTRUCTOR -> TLDocumentAttributeCustomEmoji()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in DocumentAttribute")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLDocumentAttributeImageSize: DocumentAttribute() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			w = stream.readInt32(exception)
			h = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(w)
			stream.writeInt32(h)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6c37c15cu.toInt()
		}
	}
	
	open class TLDocumentAttributeAnimated: DocumentAttribute() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x11b58939u.toInt()
		}
	}
	
	open class TLDocumentAttributeSticker: DocumentAttribute() {
			@JvmField var mask = false
				@JvmField var maskCoords: TLMaskCoords? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			mask = (flags and 2) != 0
			alt = stream.readString(exception) ?: return
			stickerset = InputStickerSet.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				maskCoords = TLMaskCoords.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (mask) flags or 2 else flags and 2.inv()
			flags = if (maskCoords != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeString(alt)
			stickerset?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				maskCoords?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x6319d612u.toInt()
		}
	}
	
	open class TLDocumentAttributeVideo: DocumentAttribute() {
			@JvmField var roundMessage = false
		@JvmField var supportsStreaming = false
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			roundMessage = (flags and 1) != 0
			supportsStreaming = (flags and 2) != 0
			duration = stream.readInt32(exception)
			w = stream.readInt32(exception)
			h = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (roundMessage) flags or 1 else flags and 1.inv()
			flags = if (supportsStreaming) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(duration)
			stream.writeInt32(w)
			stream.writeInt32(h)
		}
	
		companion object {
			val CONSTRUCTOR = 0xef02ce6u.toInt()
		}
	}
	
	open class TLDocumentAttributeAudio: DocumentAttribute() {
			@JvmField var voice = false
			@JvmField var title: String? = null
		@JvmField var performer: String? = null
		@JvmField var waveform: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			voice = (flags and 1024) != 0
			duration = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				title = stream.readString(exception) ?: return
			}
		
			if ((flags and 2) != 0) {
				performer = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				waveform = stream.readByteArray(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (voice) flags or 1024 else flags and 1024.inv()
			flags = if (title != null) flags or 1 else flags and 1.inv()
			flags = if (performer != null) flags or 2 else flags and 2.inv()
			flags = if (waveform != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(duration)
			if ((flags and 1) != 0) {
				stream.writeString(title)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(performer)
			}
	
			if ((flags and 4) != 0) {
				stream.writeByteArray(waveform)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9852f9c6u.toInt()
		}
	}
	
	open class TLDocumentAttributeFilename: DocumentAttribute() {
		@JvmField var fileName: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			fileName = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(fileName)
		}
	
		companion object {
			val CONSTRUCTOR = 0x15590068u.toInt()
		}
	}
	
	open class TLDocumentAttributeHasStickers: DocumentAttribute() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9801d2f7u.toInt()
		}
	}
	
	open class TLDocumentAttributeCustomEmoji: DocumentAttribute() {
			@JvmField var free = false
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			free = (flags and 1) != 0
			alt = stream.readString(exception) ?: return
			stickerset = InputStickerSet.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (free) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeString(alt)
			stickerset?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfd149899u.toInt()
		}
	}
	
	abstract class MessagesStickers: TLObject() {
		@JvmField var hash = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesStickers? {
				val result = when (constructor) {
					TLMessagesStickersNotModified.CONSTRUCTOR -> TLMessagesStickersNotModified()
					TLMessagesStickers.CONSTRUCTOR -> TLMessagesStickers()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesStickers")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesStickersNotModified: MessagesStickers() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf1749a22u.toInt()
		}
	}
	
	open class TLMessagesStickers: MessagesStickers() {
			@JvmField val stickers = mutableListOf<Document>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			hash = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Document.deserialize(stream, stream.readInt32(exception), exception) ?: return
				stickers.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(stickers.size)
			stickers.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x30a6ec7eu.toInt()
		}
	}
	
	open class TLMessagesGetStickers: TLObject() {
		@JvmField var emoticon: String? = null
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesStickers? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesStickers.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(emoticon)
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd5a5d3a1u.toInt()
		}
	}
	
	open class TLStickerPack: TLObject() {
		@JvmField var emoticon: String? = null
		@JvmField val documents = mutableListOf<Long>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			emoticon = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				documents.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(emoticon)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(documents.size)
			documents.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x12b299d4u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStickerPack? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLStickerPack")
					}
					else {
						null
					}
				}
	
				val result = TLStickerPack()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class MessagesAllStickers: TLObject() {
		@JvmField var hash = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesAllStickers? {
				val result = when (constructor) {
					TLMessagesAllStickersNotModified.CONSTRUCTOR -> TLMessagesAllStickersNotModified()
					TLMessagesAllStickers.CONSTRUCTOR -> TLMessagesAllStickers()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesAllStickers")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesAllStickersNotModified: MessagesAllStickers() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe86602c3u.toInt()
		}
	}
	
	open class TLMessagesAllStickers: MessagesAllStickers() {
			@JvmField val sets = mutableListOf<TLStickerSet>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			hash = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLStickerSet.deserialize(stream, stream.readInt32(exception), exception) ?: return
				sets.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(sets.size)
			sets.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xcdbbcebbu.toInt()
		}
	}
	
	open class TLMessagesGetAllStickers: TLObject() {
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesAllStickers? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesAllStickers.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb8a0a1a8u.toInt()
		}
	}
	
	open class TLMessagesGetMaskStickers: TLObject() {
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesAllStickers? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesAllStickers.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x640f82b8u.toInt()
		}
	}
	
	open class TLMessagesGetEmojiStickers: TLObject() {
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesAllStickers? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesAllStickers.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfbfca18fu.toInt()
		}
	}
	
	open class TLMessagesAffectedMessages: TLObject() {
		@JvmField var pts = 0
		@JvmField var ptsCount = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0x84d19185u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesAffectedMessages? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesAffectedMessages")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesAffectedMessages()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesReadHistory: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var maxId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesAffectedMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesAffectedMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(maxId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe306d3au.toInt()
		}
	}
	
	open class TLMessagesDeleteMessages: TLObject() {
		@JvmField var flags = 0
		@JvmField var revoke = false
		@JvmField val id = mutableListOf<Int>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesAffectedMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesAffectedMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (revoke) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xe58e95d2u.toInt()
		}
	}
	
	open class TLMessagesReadMessageContents: TLObject() {
		@JvmField val id = mutableListOf<Int>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesAffectedMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesAffectedMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x36a73f77u.toInt()
		}
	}
	
	open class TLChannelsDeleteMessages: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField val id = mutableListOf<Int>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesAffectedMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesAffectedMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x84c1fd4eu.toInt()
		}
	}
	
	abstract class WebPage: TLObject() {
		@JvmField var url: String? = null
		@JvmField var flags = 0
		@JvmField var id = 0L
		@JvmField var hash = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): WebPage? {
				val result = when (constructor) {
					TLWebPageEmpty.CONSTRUCTOR -> TLWebPageEmpty()
					TLWebPagePending.CONSTRUCTOR -> TLWebPagePending()
					TLWebPage.CONSTRUCTOR -> TLWebPage()
					TLWebPageNotModified.CONSTRUCTOR -> TLWebPageNotModified()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in WebPage")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLWebPageEmpty: WebPage() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0xeb1477e8u.toInt()
		}
	}
	
	open class TLWebPagePending: WebPage() {
			@JvmField var date = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			date = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt32(date)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc586da1cu.toInt()
		}
	}
	
	open class TLWebPage: WebPage() {
					@JvmField var displayUrl: String? = null
			@JvmField var type: String? = null
		@JvmField var siteName: String? = null
		@JvmField var title: String? = null
		@JvmField var description: String? = null
		@JvmField var photo: Photo? = null
		@JvmField var embedUrl: String? = null
		@JvmField var embedType: String? = null
		@JvmField var embedWidth = 0
		@JvmField var embedHeight = 0
		@JvmField var duration = 0
		@JvmField var author: String? = null
		@JvmField var document: Document? = null
		@JvmField var cachedPage: TLPage? = null
		@JvmField val attributes = mutableListOf<TLWebPageAttribute>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			id = stream.readInt64(exception)
			url = stream.readString(exception) ?: return
			displayUrl = stream.readString(exception) ?: return
			hash = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				type = stream.readString(exception) ?: return
			}
		
			if ((flags and 2) != 0) {
				siteName = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				title = stream.readString(exception) ?: return
			}
		
			if ((flags and 8) != 0) {
				description = stream.readString(exception) ?: return
			}
		
			if ((flags and 16) != 0) {
				photo = Photo.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 32) != 0) {
				embedUrl = stream.readString(exception) ?: return
			}
		
			if ((flags and 32) != 0) {
				embedType = stream.readString(exception) ?: return
			}
		
			if ((flags and 64) != 0) {
				embedWidth = stream.readInt32(exception)
			}
		
			if ((flags and 64) != 0) {
				embedHeight = stream.readInt32(exception)
			}
		
			if ((flags and 128) != 0) {
				duration = stream.readInt32(exception)
			}
		
			if ((flags and 256) != 0) {
				author = stream.readString(exception) ?: return
			}
		
			if ((flags and 512) != 0) {
				document = Document.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 1024) != 0) {
				cachedPage = TLPage.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 4096) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLWebPageAttribute.deserialize(stream, stream.readInt32(exception), exception) ?: return
					attributes.add(obj)
				}
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (type != null) flags or 1 else flags and 1.inv()
			flags = if (siteName != null) flags or 2 else flags and 2.inv()
			flags = if (title != null) flags or 4 else flags and 4.inv()
			flags = if (description != null) flags or 8 else flags and 8.inv()
			flags = if (photo != null) flags or 16 else flags and 16.inv()
			flags = if (embedUrl != null) flags or 32 else flags and 32.inv()
			flags = if (embedType != null) flags or 32 else flags and 32.inv()
			flags = if (embedWidth != 0) flags or 64 else flags and 64.inv()
			flags = if (embedHeight != 0) flags or 64 else flags and 64.inv()
			flags = if (duration != 0) flags or 128 else flags and 128.inv()
			flags = if (author != null) flags or 256 else flags and 256.inv()
			flags = if (document != null) flags or 512 else flags and 512.inv()
			flags = if (cachedPage != null) flags or 1024 else flags and 1024.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeString(url)
			stream.writeString(displayUrl)
			stream.writeInt32(hash)
			if ((flags and 1) != 0) {
				stream.writeString(type)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(siteName)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(title)
			}
	
			if ((flags and 8) != 0) {
				stream.writeString(description)
			}
	
			if ((flags and 16) != 0) {
				photo?.serializeToStream(stream)
			}
	
			if ((flags and 32) != 0) {
				stream.writeString(embedUrl)
			}
	
			if ((flags and 32) != 0) {
				stream.writeString(embedType)
			}
	
			if ((flags and 64) != 0) {
				stream.writeInt32(embedWidth)
			}
	
			if ((flags and 64) != 0) {
				stream.writeInt32(embedHeight)
			}
	
			if ((flags and 128) != 0) {
				stream.writeInt32(duration)
			}
	
			if ((flags and 256) != 0) {
				stream.writeString(author)
			}
	
			if ((flags and 512) != 0) {
				document?.serializeToStream(stream)
			}
	
			if ((flags and 1024) != 0) {
				cachedPage?.serializeToStream(stream)
			}
	
			if ((flags and 4096) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(attributes.size)
			attributes.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe89c45b2u.toInt()
		}
	}
	
	open class TLWebPageNotModified: WebPage() {
			@JvmField var cachedPageViews = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				cachedPageViews = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (cachedPageViews != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeInt32(cachedPageViews)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x7311ca11u.toInt()
		}
	}
	
	open class TLMessagesGetWebPage: TLObject() {
		@JvmField var url: String? = null
		@JvmField var hash = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): WebPage? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return WebPage.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
			stream.writeInt32(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x32ca8f91u.toInt()
		}
	}
	
	open class TLAuthorization: TLObject() {
		@JvmField var flags = 0
		@JvmField var current = false
		@JvmField var officialApp = false
		@JvmField var passwordPending = false
		@JvmField var encryptedRequestsDisabled = false
		@JvmField var callRequestsDisabled = false
		@JvmField var hash = 0L
		@JvmField var deviceModel: String? = null
		@JvmField var platform: String? = null
		@JvmField var systemVersion: String? = null
		@JvmField var apiId = 0
		@JvmField var appName: String? = null
		@JvmField var appVersion: String? = null
		@JvmField var dateCreated = 0
		@JvmField var dateActive = 0
		@JvmField var ip: String? = null
		@JvmField var country: String? = null
		@JvmField var region: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			current = (flags and 1) != 0
			officialApp = (flags and 2) != 0
			passwordPending = (flags and 4) != 0
			encryptedRequestsDisabled = (flags and 8) != 0
			callRequestsDisabled = (flags and 16) != 0
			hash = stream.readInt64(exception)
			deviceModel = stream.readString(exception) ?: return
			platform = stream.readString(exception) ?: return
			systemVersion = stream.readString(exception) ?: return
			apiId = stream.readInt32(exception)
			appName = stream.readString(exception) ?: return
			appVersion = stream.readString(exception) ?: return
			dateCreated = stream.readInt32(exception)
			dateActive = stream.readInt32(exception)
			ip = stream.readString(exception) ?: return
			country = stream.readString(exception) ?: return
			region = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (current) flags or 1 else flags and 1.inv()
			flags = if (officialApp) flags or 2 else flags and 2.inv()
			flags = if (passwordPending) flags or 4 else flags and 4.inv()
			flags = if (encryptedRequestsDisabled) flags or 8 else flags and 8.inv()
			flags = if (callRequestsDisabled) flags or 16 else flags and 16.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(hash)
			stream.writeString(deviceModel)
			stream.writeString(platform)
			stream.writeString(systemVersion)
			stream.writeInt32(apiId)
			stream.writeString(appName)
			stream.writeString(appVersion)
			stream.writeInt32(dateCreated)
			stream.writeInt32(dateActive)
			stream.writeString(ip)
			stream.writeString(country)
			stream.writeString(region)
		}
	
		companion object {
			val CONSTRUCTOR = 0xad01d61du.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAuthorization? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAuthorization")
					}
					else {
						null
					}
				}
	
				val result = TLAuthorization()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAuthAcceptLoginToken: TLObject() {
		@JvmField var token: ByteArray? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAuthorization? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAuthorization.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteArray(token)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe894ad4du.toInt()
		}
	}
	
	open class TLAccountAuthorizations: TLObject() {
		@JvmField var authorizationTtlDays = 0
		@JvmField val authorizations = mutableListOf<TLAuthorization>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			authorizationTtlDays = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLAuthorization.deserialize(stream, stream.readInt32(exception), exception) ?: return
				authorizations.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(authorizationTtlDays)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(authorizations.size)
			authorizations.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x4bff8ea0u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountAuthorizations? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAccountAuthorizations")
					}
					else {
						null
					}
				}
	
				val result = TLAccountAuthorizations()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountGetAuthorizations: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountAuthorizations? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAccountAuthorizations.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe320c158u.toInt()
		}
	}
	
	open class TLAccountPassword: TLObject() {
		@JvmField var flags = 0
		@JvmField var hasRecovery = false
		@JvmField var hasSecureValues = false
		@JvmField var hasPassword = false
		@JvmField var currentAlgo: PasswordKdfAlgo? = null
		@JvmField var srpB: ByteArray? = null
		@JvmField var srpId = 0L
		@JvmField var hint: String? = null
		@JvmField var emailUnconfirmedPattern: String? = null
		@JvmField var newAlgo: PasswordKdfAlgo? = null
		@JvmField var newSecureAlgo: SecurePasswordKdfAlgo? = null
		@JvmField var secureRandom: ByteArray? = null
		@JvmField var pendingResetDate = 0
		@JvmField var loginEmailPattern: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			hasRecovery = (flags and 1) != 0
			hasSecureValues = (flags and 2) != 0
			hasPassword = (flags and 4) != 0
		
			if ((flags and 4) != 0) {
				currentAlgo = PasswordKdfAlgo.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 4) != 0) {
				srpB = stream.readByteArray(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				srpId = stream.readInt64(exception)
			}
		
			if ((flags and 8) != 0) {
				hint = stream.readString(exception) ?: return
			}
		
			if ((flags and 16) != 0) {
				emailUnconfirmedPattern = stream.readString(exception) ?: return
			}
			newAlgo = PasswordKdfAlgo.deserialize(stream, stream.readInt32(exception), exception)
			newSecureAlgo = SecurePasswordKdfAlgo.deserialize(stream, stream.readInt32(exception), exception)
			secureRandom = stream.readByteArray(exception) ?: return
		
			if ((flags and 32) != 0) {
				pendingResetDate = stream.readInt32(exception)
			}
		
			if ((flags and 64) != 0) {
				loginEmailPattern = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (hasRecovery) flags or 1 else flags and 1.inv()
			flags = if (hasSecureValues) flags or 2 else flags and 2.inv()
			flags = if (hasPassword) flags or 4 else flags and 4.inv()
			flags = if (currentAlgo != null) flags or 4 else flags and 4.inv()
			flags = if (srpB != null) flags or 4 else flags and 4.inv()
			flags = if (srpId != 0L) flags or 4 else flags and 4.inv()
			flags = if (hint != null) flags or 8 else flags and 8.inv()
			flags = if (emailUnconfirmedPattern != null) flags or 16 else flags and 16.inv()
			flags = if (pendingResetDate != 0) flags or 32 else flags and 32.inv()
			flags = if (loginEmailPattern != null) flags or 64 else flags and 64.inv()
	
			stream.writeInt32(flags)
			if ((flags and 4) != 0) {
				currentAlgo?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				stream.writeByteArray(srpB)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt64(srpId)
			}
	
			if ((flags and 8) != 0) {
				stream.writeString(hint)
			}
	
			if ((flags and 16) != 0) {
				stream.writeString(emailUnconfirmedPattern)
			}
	
			newAlgo?.serializeToStream(stream)
			newSecureAlgo?.serializeToStream(stream)
			stream.writeByteArray(secureRandom)
			if ((flags and 32) != 0) {
				stream.writeInt32(pendingResetDate)
			}
	
			if ((flags and 64) != 0) {
				stream.writeString(loginEmailPattern)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x957b50fbu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountPassword? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAccountPassword")
					}
					else {
						null
					}
				}
	
				val result = TLAccountPassword()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountGetPassword: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountPassword? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAccountPassword.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x548a30f5u.toInt()
		}
	}
	
	open class TLAccountPasswordSettings: TLObject() {
		@JvmField var flags = 0
		@JvmField var email: String? = null
		@JvmField var secureSettings: TLSecureSecretSettings? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				email = stream.readString(exception) ?: return
			}
		
			if ((flags and 2) != 0) {
				secureSettings = TLSecureSecretSettings.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (email != null) flags or 1 else flags and 1.inv()
			flags = if (secureSettings != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeString(email)
			}
	
			if ((flags and 2) != 0) {
				secureSettings?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9a5c33e5u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountPasswordSettings? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAccountPasswordSettings")
					}
					else {
						null
					}
				}
	
				val result = TLAccountPasswordSettings()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountGetPasswordSettings: TLObject() {
		@JvmField var password: InputCheckPasswordSRP? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountPasswordSettings? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAccountPasswordSettings.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			password?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9cd4eaf9u.toInt()
		}
	}
	
	open class TLAccountPasswordInputSettings: TLObject() {
		@JvmField var flags = 0
		@JvmField var newAlgo: PasswordKdfAlgo? = null
		@JvmField var newPasswordHash: ByteArray? = null
		@JvmField var hint: String? = null
		@JvmField var email: String? = null
		@JvmField var newSecureSettings: TLSecureSecretSettings? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				newAlgo = PasswordKdfAlgo.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 1) != 0) {
				newPasswordHash = stream.readByteArray(exception) ?: return
			}
		
			if ((flags and 1) != 0) {
				hint = stream.readString(exception) ?: return
			}
		
			if ((flags and 2) != 0) {
				email = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				newSecureSettings = TLSecureSecretSettings.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (newAlgo != null) flags or 1 else flags and 1.inv()
			flags = if (newPasswordHash != null) flags or 1 else flags and 1.inv()
			flags = if (hint != null) flags or 1 else flags and 1.inv()
			flags = if (email != null) flags or 2 else flags and 2.inv()
			flags = if (newSecureSettings != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				newAlgo?.serializeToStream(stream)
			}
	
			if ((flags and 1) != 0) {
				stream.writeByteArray(newPasswordHash)
			}
	
			if ((flags and 1) != 0) {
				stream.writeString(hint)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(email)
			}
	
			if ((flags and 4) != 0) {
				newSecureSettings?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc23727c9u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountPasswordInputSettings? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAccountPasswordInputSettings")
					}
					else {
						null
					}
				}
	
				val result = TLAccountPasswordInputSettings()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAuthPasswordRecovery: TLObject() {
		@JvmField var emailPattern: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			emailPattern = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(emailPattern)
		}
	
		companion object {
			val CONSTRUCTOR = 0x137948a5u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAuthPasswordRecovery? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAuthPasswordRecovery")
					}
					else {
						null
					}
				}
	
				val result = TLAuthPasswordRecovery()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAuthRequestPasswordRecovery: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAuthPasswordRecovery? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAuthPasswordRecovery.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd897bc66u.toInt()
		}
	}
	
	open class TLReceivedNotifyMessage: TLObject() {
		@JvmField var id = 0
		@JvmField var flags = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt32(exception)
			flags = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(id)
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa384b779u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLReceivedNotifyMessage? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLReceivedNotifyMessage")
					}
					else {
						null
					}
				}
	
				val result = TLReceivedNotifyMessage()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class ExportedChatInvite: TLObject() {
		@JvmField var title: String? = null
		@JvmField var flags = 0
		@JvmField var requestNeeded = false
		@JvmField var usageLimit = 0
		@JvmField var expireDate = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ExportedChatInvite? {
				val result = when (constructor) {
					TLChatInviteExported.CONSTRUCTOR -> TLChatInviteExported()
					TLChatInvitePublicJoinRequests.CONSTRUCTOR -> TLChatInvitePublicJoinRequests()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ExportedChatInvite")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChatInviteExported: ExportedChatInvite() {
			@JvmField var revoked = false
		@JvmField var permanent = false
			@JvmField var link: String? = null
		@JvmField var adminId = 0L
		@JvmField var date = 0
		@JvmField var startDate = 0
				@JvmField var usage = 0
		@JvmField var requested = 0
		
		@JvmField var expired: Boolean = false
		@JvmField var importers: MutableList<User>? = null
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			revoked = (flags and 1) != 0
			permanent = (flags and 32) != 0
			requestNeeded = (flags and 64) != 0
			link = stream.readString(exception) ?: return
			adminId = stream.readInt64(exception)
			date = stream.readInt32(exception)
		
			if ((flags and 16) != 0) {
				startDate = stream.readInt32(exception)
			}
		
			if ((flags and 2) != 0) {
				expireDate = stream.readInt32(exception)
			}
		
			if ((flags and 4) != 0) {
				usageLimit = stream.readInt32(exception)
			}
		
			if ((flags and 8) != 0) {
				usage = stream.readInt32(exception)
			}
		
			if ((flags and 128) != 0) {
				requested = stream.readInt32(exception)
			}
		
			if ((flags and 256) != 0) {
				title = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (revoked) flags or 1 else flags and 1.inv()
			flags = if (permanent) flags or 32 else flags and 32.inv()
			flags = if (requestNeeded) flags or 64 else flags and 64.inv()
			flags = if (startDate != 0) flags or 16 else flags and 16.inv()
			flags = if (expireDate != 0) flags or 2 else flags and 2.inv()
			flags = if (usageLimit != 0) flags or 4 else flags and 4.inv()
			flags = if (usage != 0) flags or 8 else flags and 8.inv()
			flags = if (requested != 0) flags or 128 else flags and 128.inv()
			flags = if (title != null) flags or 256 else flags and 256.inv()
	
			stream.writeInt32(flags)
			stream.writeString(link)
			stream.writeInt64(adminId)
			stream.writeInt32(date)
			if ((flags and 16) != 0) {
				stream.writeInt32(startDate)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(expireDate)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(usageLimit)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt32(usage)
			}
	
			if ((flags and 128) != 0) {
				stream.writeInt32(requested)
			}
	
			if ((flags and 256) != 0) {
				stream.writeString(title)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xab4a819u.toInt()
		}
	}
	
	open class TLChatInvitePublicJoinRequests: ExportedChatInvite() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xed107ab7u.toInt()
		}
	}
	
	open class TLMessagesExportChatInvite: TLObject() {
		@JvmField var flags = 0
		@JvmField var legacyRevokePermanent = false
		@JvmField var requestNeeded = false
		@JvmField var peer: InputPeer? = null
		@JvmField var expireDate = 0
		@JvmField var usageLimit = 0
		@JvmField var title: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ExportedChatInvite? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return ExportedChatInvite.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (legacyRevokePermanent) flags or 4 else flags and 4.inv()
			flags = if (requestNeeded) flags or 8 else flags and 8.inv()
			flags = if (expireDate != 0) flags or 1 else flags and 1.inv()
			flags = if (usageLimit != 0) flags or 2 else flags and 2.inv()
			flags = if (title != null) flags or 16 else flags and 16.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(expireDate)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(usageLimit)
			}
	
			if ((flags and 16) != 0) {
				stream.writeString(title)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa02ce5d5u.toInt()
		}
	}
	
	abstract class ChatInvite: TLObject() {
		@JvmField var channel = false
		@JvmField var title: String? = null
		@JvmField var chat: Chat? = null
		@JvmField var flags = 0
		@JvmField var broadcast = false
		@JvmField var megagroup = false
		@JvmField var requestNeeded = false
		@JvmField var photo: Photo? = null
		@JvmField val participants = mutableListOf<User>()
		@JvmField var isPublic = false
		@JvmField var participantsCount = 0
		@JvmField var expires = 0
		@JvmField var about: String? = null
		@JvmField var user: User? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChatInvite? {
				val result = when (constructor) {
					TLChatInvite.CONSTRUCTOR -> TLChatInvite()
					TLChatInviteAlready.CONSTRUCTOR -> TLChatInviteAlready()
					TLChatInvitePeek.CONSTRUCTOR -> TLChatInvitePeek()
					TLChatInviteUser.CONSTRUCTOR -> TLChatInviteUser()
					TLChatInviteLayer3.CONSTRUCTOR -> TLChatInviteLayer3()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ChatInvite")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChatInvite: ChatInvite() {
													
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			channel = (flags and 1) != 0
			broadcast = (flags and 2) != 0
			isPublic = (flags and 4) != 0
			megagroup = (flags and 8) != 0
			requestNeeded = (flags and 64) != 0
			title = stream.readString(exception) ?: return
		
			if ((flags and 32) != 0) {
				about = stream.readString(exception) ?: return
			}
			photo = Photo.deserialize(stream, stream.readInt32(exception), exception)
			participantsCount = stream.readInt32(exception)
		
			if ((flags and 16) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
					participants.add(obj)
				}
			}
		
			if ((flags and 128) != 0) {
				chat = Chat.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (channel) flags or 1 else flags and 1.inv()
			flags = if (broadcast) flags or 2 else flags and 2.inv()
			flags = if (isPublic) flags or 4 else flags and 4.inv()
			flags = if (megagroup) flags or 8 else flags and 8.inv()
			flags = if (requestNeeded) flags or 64 else flags and 64.inv()
			flags = if (about != null) flags or 32 else flags and 32.inv()
			flags = if (chat != null) flags or 128 else flags and 128.inv()
	
			stream.writeInt32(flags)
			stream.writeString(title)
			if ((flags and 32) != 0) {
				stream.writeString(about)
			}
	
			photo?.serializeToStream(stream)
			stream.writeInt32(participantsCount)
			if ((flags and 16) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(participants.size)
			participants.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 128) != 0) {
				chat?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x300c44c1u.toInt()
		}
	}
	
	open class TLChatInviteAlready: ChatInvite() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				chat = Chat.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				user = User.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (chat != null) flags or 1 else flags and 1.inv()
			flags = if (user != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				chat?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				user?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x5a686d7cu.toInt()
		}
	}
	
	open class TLChatInvitePeek: ChatInvite() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			chat = Chat.deserialize(stream, stream.readInt32(exception), exception)
			expires = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			chat?.serializeToStream(stream)
			stream.writeInt32(expires)
		}
	
		companion object {
			val CONSTRUCTOR = 0x61695cb0u.toInt()
		}
	}
	
	open class TLChatInviteUser: ChatInvite() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			user = User.deserialize(stream, stream.readInt32(exception), exception)
			expires = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			user?.serializeToStream(stream)
			stream.writeInt32(expires)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9e96a350u.toInt()
		}
	}
	
	open class TLChatInviteLayer3: ChatInvite() {
															
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			channel = (flags and 1) != 0
			broadcast = (flags and 2) != 0
			isPublic = (flags and 4) != 0
			megagroup = (flags and 8) != 0
			requestNeeded = (flags and 64) != 0
			title = stream.readString(exception) ?: return
		
			if ((flags and 32) != 0) {
				about = stream.readString(exception) ?: return
			}
			photo = Photo.deserialize(stream, stream.readInt32(exception), exception)
			participantsCount = stream.readInt32(exception)
		
			if ((flags and 16) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
					participants.add(obj)
				}
			}
		
			if ((flags and 128) != 0) {
				chat = Chat.deserialize(stream, stream.readInt32(exception), exception)
			}
			expires = stream.readInt32(exception)
		
			if ((flags and 256) != 0) {
				user = User.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (channel) flags or 1 else flags and 1.inv()
			flags = if (broadcast) flags or 2 else flags and 2.inv()
			flags = if (isPublic) flags or 4 else flags and 4.inv()
			flags = if (megagroup) flags or 8 else flags and 8.inv()
			flags = if (requestNeeded) flags or 64 else flags and 64.inv()
			flags = if (about != null) flags or 32 else flags and 32.inv()
			flags = if (chat != null) flags or 128 else flags and 128.inv()
			flags = if (user != null) flags or 256 else flags and 256.inv()
	
			stream.writeInt32(flags)
			stream.writeString(title)
			if ((flags and 32) != 0) {
				stream.writeString(about)
			}
	
			photo?.serializeToStream(stream)
			stream.writeInt32(participantsCount)
			if ((flags and 16) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(participants.size)
			participants.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 128) != 0) {
				chat?.serializeToStream(stream)
			}
	
			stream.writeInt32(expires)
			if ((flags and 256) != 0) {
				user?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x528ee149u.toInt()
		}
	}
	
	open class TLMessagesCheckChatInvite: TLObject() {
		@JvmField var hash: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChatInvite? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return ChatInvite.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3eadb1bbu.toInt()
		}
	}
	
	abstract class InputStickerSet: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputStickerSet? {
				val result = when (constructor) {
					TLInputStickerSetEmpty.CONSTRUCTOR -> TLInputStickerSetEmpty()
					TLInputStickerSetID.CONSTRUCTOR -> TLInputStickerSetID()
					TLInputStickerSetShortName.CONSTRUCTOR -> TLInputStickerSetShortName()
					TLInputStickerSetAnimatedEmoji.CONSTRUCTOR -> TLInputStickerSetAnimatedEmoji()
					TLInputStickerSetDice.CONSTRUCTOR -> TLInputStickerSetDice()
					TLInputStickerSetAnimatedEmojiAnimations.CONSTRUCTOR -> TLInputStickerSetAnimatedEmojiAnimations()
					TLInputStickerSetPremiumGifts.CONSTRUCTOR -> TLInputStickerSetPremiumGifts()
					TLInputStickerSetEmojiGenericAnimations.CONSTRUCTOR -> TLInputStickerSetEmojiGenericAnimations()
					TLInputStickerSetEmojiDefaultStatuses.CONSTRUCTOR -> TLInputStickerSetEmojiDefaultStatuses()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputStickerSet")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputStickerSetEmpty: InputStickerSet() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xffb62b95u.toInt()
		}
	}
	
	open class TLInputStickerSetID: InputStickerSet() {
		@JvmField var id = 0L
		@JvmField var accessHash = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9de7a269u.toInt()
		}
	}
	
	open class TLInputStickerSetShortName: InputStickerSet() {
		@JvmField var shortName: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			shortName = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(shortName)
		}
	
		companion object {
			val CONSTRUCTOR = 0x861cc8a0u.toInt()
		}
	}
	
	open class TLInputStickerSetAnimatedEmoji: InputStickerSet() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x28703c8u.toInt()
		}
	}
	
	open class TLInputStickerSetDice: InputStickerSet() {
		@JvmField var emoticon: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			emoticon = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(emoticon)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe67f520eu.toInt()
		}
	}
	
	open class TLInputStickerSetAnimatedEmojiAnimations: InputStickerSet() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xcde3739u.toInt()
		}
	}
	
	open class TLInputStickerSetPremiumGifts: InputStickerSet() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc88b3b02u.toInt()
		}
	}
	
	open class TLInputStickerSetEmojiGenericAnimations: InputStickerSet() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x4c4d4ceu.toInt()
		}
	}
	
	open class TLInputStickerSetEmojiDefaultStatuses: InputStickerSet() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x29d0f5eeu.toInt()
		}
	}
	
	open class TLStickerSet: TLObject() {
		@JvmField var flags = 0
		@JvmField var archived = false
		@JvmField var official = false
		@JvmField var masks = false
		@JvmField var animated = false
		@JvmField var videos = false
		@JvmField var emojis = false
		@JvmField var installedDate = 0
		@JvmField var id = 0L
		@JvmField var accessHash = 0L
		@JvmField var title: String? = null
		@JvmField var shortName: String? = null
		@JvmField val thumbs = mutableListOf<PhotoSize>()
		@JvmField var thumbDcId = 0
		@JvmField var thumbVersion = 0
		@JvmField var thumbDocumentId = 0L
		@JvmField var count = 0
		@JvmField var hash = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			archived = (flags and 2) != 0
			official = (flags and 4) != 0
			masks = (flags and 8) != 0
			animated = (flags and 32) != 0
			videos = (flags and 64) != 0
			emojis = (flags and 128) != 0
		
			if ((flags and 1) != 0) {
				installedDate = stream.readInt32(exception)
			}
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			title = stream.readString(exception) ?: return
			shortName = stream.readString(exception) ?: return
		
			if ((flags and 16) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = PhotoSize.deserialize(stream, stream.readInt32(exception), exception) ?: return
					thumbs.add(obj)
				}
			}
		
			if ((flags and 16) != 0) {
				thumbDcId = stream.readInt32(exception)
			}
		
			if ((flags and 16) != 0) {
				thumbVersion = stream.readInt32(exception)
			}
		
			if ((flags and 256) != 0) {
				thumbDocumentId = stream.readInt64(exception)
			}
			count = stream.readInt32(exception)
			hash = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (archived) flags or 2 else flags and 2.inv()
			flags = if (official) flags or 4 else flags and 4.inv()
			flags = if (masks) flags or 8 else flags and 8.inv()
			flags = if (animated) flags or 32 else flags and 32.inv()
			flags = if (videos) flags or 64 else flags and 64.inv()
			flags = if (emojis) flags or 128 else flags and 128.inv()
			flags = if (installedDate != 0) flags or 1 else flags and 1.inv()
			flags = if (thumbDcId != 0) flags or 16 else flags and 16.inv()
			flags = if (thumbVersion != 0) flags or 16 else flags and 16.inv()
			flags = if (thumbDocumentId != 0L) flags or 256 else flags and 256.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeInt32(installedDate)
			}
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeString(title)
			stream.writeString(shortName)
			if ((flags and 16) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(thumbs.size)
			thumbs.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 16) != 0) {
				stream.writeInt32(thumbDcId)
			}
	
			if ((flags and 16) != 0) {
				stream.writeInt32(thumbVersion)
			}
	
			if ((flags and 256) != 0) {
				stream.writeInt64(thumbDocumentId)
			}
	
			stream.writeInt32(count)
			stream.writeInt32(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2dd14edcu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStickerSet? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLStickerSet")
					}
					else {
						null
					}
				}
	
				val result = TLStickerSet()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class MessagesStickerSet: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesStickerSet? {
				val result = when (constructor) {
					TLMessagesStickerSet.CONSTRUCTOR -> TLMessagesStickerSet()
					TLMessagesStickerSetNotModified.CONSTRUCTOR -> TLMessagesStickerSetNotModified()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesStickerSet")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesStickerSet: MessagesStickerSet() {
		@JvmField var set: TLStickerSet? = null
		@JvmField val packs = mutableListOf<TLStickerPack>()
		@JvmField val keywords = mutableListOf<TLStickerKeyword>()
		@JvmField val documents = mutableListOf<Document>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			set = TLStickerSet.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLStickerPack.deserialize(stream, stream.readInt32(exception), exception) ?: return
				packs.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLStickerKeyword.deserialize(stream, stream.readInt32(exception), exception) ?: return
				keywords.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Document.deserialize(stream, stream.readInt32(exception), exception) ?: return
				documents.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			set?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(packs.size)
			packs.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(keywords.size)
			keywords.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(documents.size)
			documents.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x6e153f16u.toInt()
		}
	}
	
	open class TLMessagesStickerSetNotModified: MessagesStickerSet() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd3f924ebu.toInt()
		}
	}
	
	open class TLMessagesGetStickerSet: TLObject() {
		@JvmField var stickerset: InputStickerSet? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesStickerSet? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesStickerSet.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stickerset?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2619a90eu.toInt()
		}
	}
	
	open class TLStickersCreateStickerSet: TLObject() {
		@JvmField var flags = 0
		@JvmField var masks = false
		@JvmField var animated = false
		@JvmField var videos = false
		@JvmField var userId: InputUser? = null
		@JvmField var title: String? = null
		@JvmField var shortName: String? = null
		@JvmField var thumb: InputDocument? = null
		@JvmField val stickers = mutableListOf<TLInputStickerSetItem>()
		@JvmField var software: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesStickerSet? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesStickerSet.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (masks) flags or 1 else flags and 1.inv()
			flags = if (animated) flags or 2 else flags and 2.inv()
			flags = if (videos) flags or 16 else flags and 16.inv()
			flags = if (thumb != null) flags or 4 else flags and 4.inv()
			flags = if (software != null) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			userId?.serializeToStream(stream)
			stream.writeString(title)
			stream.writeString(shortName)
			if ((flags and 4) != 0) {
				thumb?.serializeToStream(stream)
			}
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(stickers.size)
			stickers.forEach { it.serializeToStream(stream) }
			if ((flags and 8) != 0) {
				stream.writeString(software)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9021ab67u.toInt()
		}
	}
	
	open class TLStickersRemoveStickerFromSet: TLObject() {
		@JvmField var sticker: InputDocument? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesStickerSet? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesStickerSet.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			sticker?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf7760f51u.toInt()
		}
	}
	
	open class TLStickersChangeStickerPosition: TLObject() {
		@JvmField var sticker: InputDocument? = null
		@JvmField var position = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesStickerSet? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesStickerSet.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			sticker?.serializeToStream(stream)
			stream.writeInt32(position)
		}
	
		companion object {
			val CONSTRUCTOR = 0xffb6d4cau.toInt()
		}
	}
	
	open class TLStickersAddStickerToSet: TLObject() {
		@JvmField var stickerset: InputStickerSet? = null
		@JvmField var sticker: TLInputStickerSetItem? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesStickerSet? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesStickerSet.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stickerset?.serializeToStream(stream)
			sticker?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8653febeu.toInt()
		}
	}
	
	open class TLStickersSetStickerSetThumb: TLObject() {
		@JvmField var stickerset: InputStickerSet? = null
		@JvmField var thumb: InputDocument? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesStickerSet? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesStickerSet.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stickerset?.serializeToStream(stream)
			thumb?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9a364e30u.toInt()
		}
	}
	
	open class TLMessagesGetStickerSetLayer3: TLObject() {
		@JvmField var stickerset: InputStickerSet? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesStickerSet? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesStickerSet.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stickerset?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x84973207u.toInt()
		}
	}
	
	open class TLBotCommand: TLObject() {
		@JvmField var command: String? = null
		@JvmField var description: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			command = stream.readString(exception) ?: return
			description = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(command)
			stream.writeString(description)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc27ac8c7u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLBotCommand? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLBotCommand")
					}
					else {
						null
					}
				}
	
				val result = TLBotCommand()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLBotInfo: TLObject() {
		@JvmField var flags = 0
		@JvmField var userId = 0L
		@JvmField var description: String? = null
		@JvmField var descriptionPhoto: Photo? = null
		@JvmField var descriptionDocument: Document? = null
		@JvmField val commands = mutableListOf<TLBotCommand>()
		@JvmField var menuButton: BotMenuButton? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				userId = stream.readInt64(exception)
			}
		
			if ((flags and 2) != 0) {
				description = stream.readString(exception) ?: return
			}
		
			if ((flags and 16) != 0) {
				descriptionPhoto = Photo.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 32) != 0) {
				descriptionDocument = Document.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 4) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLBotCommand.deserialize(stream, stream.readInt32(exception), exception) ?: return
					commands.add(obj)
				}
			}
		
			if ((flags and 8) != 0) {
				menuButton = BotMenuButton.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (userId != 0L) flags or 1 else flags and 1.inv()
			flags = if (description != null) flags or 2 else flags and 2.inv()
			flags = if (descriptionPhoto != null) flags or 16 else flags and 16.inv()
			flags = if (descriptionDocument != null) flags or 32 else flags and 32.inv()
			flags = if (menuButton != null) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeInt64(userId)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(description)
			}
	
			if ((flags and 16) != 0) {
				descriptionPhoto?.serializeToStream(stream)
			}
	
			if ((flags and 32) != 0) {
				descriptionDocument?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(commands.size)
			commands.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 8) != 0) {
				menuButton?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8f300b57u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLBotInfo? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLBotInfo")
					}
					else {
						null
					}
				}
	
				val result = TLBotInfo()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class KeyboardButton: TLObject() {
		@JvmField var url: String? = null
		@JvmField var flags = 0
		@JvmField var text: String? = null
		@JvmField var fwdText: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): KeyboardButton? {
				val result = when (constructor) {
					TLKeyboardButton.CONSTRUCTOR -> TLKeyboardButton()
					TLKeyboardButtonUrl.CONSTRUCTOR -> TLKeyboardButtonUrl()
					TLKeyboardButtonCallback.CONSTRUCTOR -> TLKeyboardButtonCallback()
					TLKeyboardButtonRequestPhone.CONSTRUCTOR -> TLKeyboardButtonRequestPhone()
					TLKeyboardButtonRequestGeoLocation.CONSTRUCTOR -> TLKeyboardButtonRequestGeoLocation()
					TLKeyboardButtonSwitchInline.CONSTRUCTOR -> TLKeyboardButtonSwitchInline()
					TLKeyboardButtonGame.CONSTRUCTOR -> TLKeyboardButtonGame()
					TLKeyboardButtonBuy.CONSTRUCTOR -> TLKeyboardButtonBuy()
					TLKeyboardButtonUrlAuth.CONSTRUCTOR -> TLKeyboardButtonUrlAuth()
					TLInputKeyboardButtonUrlAuth.CONSTRUCTOR -> TLInputKeyboardButtonUrlAuth()
					TLKeyboardButtonRequestPoll.CONSTRUCTOR -> TLKeyboardButtonRequestPoll()
					TLInputKeyboardButtonUserProfile.CONSTRUCTOR -> TLInputKeyboardButtonUserProfile()
					TLKeyboardButtonUserProfile.CONSTRUCTOR -> TLKeyboardButtonUserProfile()
					TLKeyboardButtonWebView.CONSTRUCTOR -> TLKeyboardButtonWebView()
					TLKeyboardButtonSimpleWebView.CONSTRUCTOR -> TLKeyboardButtonSimpleWebView()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in KeyboardButton")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLKeyboardButton: KeyboardButton() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa2fa4880u.toInt()
		}
	}
	
	open class TLKeyboardButtonUrl: KeyboardButton() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = stream.readString(exception) ?: return
			url = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(text)
			stream.writeString(url)
		}
	
		companion object {
			val CONSTRUCTOR = 0x258aff05u.toInt()
		}
	}
	
	open class TLKeyboardButtonCallback: KeyboardButton() {
			@JvmField var requiresPassword = false
			@JvmField var data: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			requiresPassword = (flags and 1) != 0
			text = stream.readString(exception) ?: return
			data = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (requiresPassword) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeString(text)
			stream.writeByteArray(data)
		}
	
		companion object {
			val CONSTRUCTOR = 0x35bbdb6bu.toInt()
		}
	}
	
	open class TLKeyboardButtonRequestPhone: KeyboardButton() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb16a6c29u.toInt()
		}
	}
	
	open class TLKeyboardButtonRequestGeoLocation: KeyboardButton() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfc796b3fu.toInt()
		}
	}
	
	open class TLKeyboardButtonSwitchInline: KeyboardButton() {
			@JvmField var samePeer = false
			@JvmField var query: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			samePeer = (flags and 1) != 0
			text = stream.readString(exception) ?: return
			query = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (samePeer) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeString(text)
			stream.writeString(query)
		}
	
		companion object {
			val CONSTRUCTOR = 0x568a748u.toInt()
		}
	}
	
	open class TLKeyboardButtonGame: KeyboardButton() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0x50f41ccfu.toInt()
		}
	}
	
	open class TLKeyboardButtonBuy: KeyboardButton() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0xafd93fbbu.toInt()
		}
	}
	
	open class TLKeyboardButtonUrlAuth: KeyboardButton() {
						@JvmField var buttonId = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			text = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				fwdText = stream.readString(exception) ?: return
			}
			url = stream.readString(exception) ?: return
			buttonId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (fwdText != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeString(text)
			if ((flags and 1) != 0) {
				stream.writeString(fwdText)
			}
	
			stream.writeString(url)
			stream.writeInt32(buttonId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x10b78d29u.toInt()
		}
	}
	
	open class TLInputKeyboardButtonUrlAuth: KeyboardButton() {
			@JvmField var requestWriteAccess = false
					@JvmField var bot: InputUser? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			requestWriteAccess = (flags and 1) != 0
			text = stream.readString(exception) ?: return
		
			if ((flags and 2) != 0) {
				fwdText = stream.readString(exception) ?: return
			}
			url = stream.readString(exception) ?: return
			bot = InputUser.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (requestWriteAccess) flags or 1 else flags and 1.inv()
			flags = if (fwdText != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeString(text)
			if ((flags and 2) != 0) {
				stream.writeString(fwdText)
			}
	
			stream.writeString(url)
			bot?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd02e7fd4u.toInt()
		}
	}
	
	open class TLKeyboardButtonRequestPoll: KeyboardButton() {
			@JvmField var quiz = false
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				quiz = stream.readBool(exception)
			}
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (quiz) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeBool(quiz)
			}
	
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbbc7515du.toInt()
		}
	}
	
	open class TLInputKeyboardButtonUserProfile: KeyboardButton() {
			@JvmField var userId: InputUser? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = stream.readString(exception) ?: return
			userId = InputUser.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(text)
			userId?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe988037bu.toInt()
		}
	}
	
	open class TLKeyboardButtonUserProfile: KeyboardButton() {
			@JvmField var userId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = stream.readString(exception) ?: return
			userId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(text)
			stream.writeInt64(userId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x308660c1u.toInt()
		}
	}
	
	open class TLKeyboardButtonWebView: KeyboardButton() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = stream.readString(exception) ?: return
			url = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(text)
			stream.writeString(url)
		}
	
		companion object {
			val CONSTRUCTOR = 0x13767230u.toInt()
		}
	}
	
	open class TLKeyboardButtonSimpleWebView: KeyboardButton() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = stream.readString(exception) ?: return
			url = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(text)
			stream.writeString(url)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa0c0505cu.toInt()
		}
	}
	
	open class TLKeyboardButtonRow: TLObject() {
		@JvmField val buttons = mutableListOf<KeyboardButton>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = KeyboardButton.deserialize(stream, stream.readInt32(exception), exception) ?: return
				buttons.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(buttons.size)
			buttons.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x77608b83u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLKeyboardButtonRow? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLKeyboardButtonRow")
					}
					else {
						null
					}
				}
	
				val result = TLKeyboardButtonRow()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class ReplyMarkup: TLObject() {
		@JvmField var singleUse = false
		@JvmField var flags = 0
		@JvmField var selective = false
		@JvmField val rows = mutableListOf<TLKeyboardButtonRow>()
		@JvmField var placeholder: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ReplyMarkup? {
				val result = when (constructor) {
					TLReplyKeyboardHide.CONSTRUCTOR -> TLReplyKeyboardHide()
					TLReplyKeyboardForceReply.CONSTRUCTOR -> TLReplyKeyboardForceReply()
					TLReplyKeyboardMarkup.CONSTRUCTOR -> TLReplyKeyboardMarkup()
					TLReplyInlineMarkup.CONSTRUCTOR -> TLReplyInlineMarkup()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ReplyMarkup")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLReplyKeyboardHide: ReplyMarkup() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			selective = (flags and 4) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (selective) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa03e5b85u.toInt()
		}
	}
	
	open class TLReplyKeyboardForceReply: ReplyMarkup() {
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			singleUse = (flags and 2) != 0
			selective = (flags and 4) != 0
		
			if ((flags and 8) != 0) {
				placeholder = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (singleUse) flags or 2 else flags and 2.inv()
			flags = if (selective) flags or 4 else flags and 4.inv()
			flags = if (placeholder != null) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			if ((flags and 8) != 0) {
				stream.writeString(placeholder)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x86b40b08u.toInt()
		}
	}
	
	open class TLReplyKeyboardMarkup: ReplyMarkup() {
			@JvmField var resize = false
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			resize = (flags and 1) != 0
			singleUse = (flags and 2) != 0
			selective = (flags and 4) != 0
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLKeyboardButtonRow.deserialize(stream, stream.readInt32(exception), exception) ?: return
				rows.add(obj)
			}
		
			if ((flags and 8) != 0) {
				placeholder = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (resize) flags or 1 else flags and 1.inv()
			flags = if (singleUse) flags or 2 else flags and 2.inv()
			flags = if (selective) flags or 4 else flags and 4.inv()
			flags = if (placeholder != null) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(rows.size)
			rows.forEach { it.serializeToStream(stream) }
			if ((flags and 8) != 0) {
				stream.writeString(placeholder)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x85dd99d1u.toInt()
		}
	}
	
	open class TLReplyInlineMarkup: ReplyMarkup() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLKeyboardButtonRow.deserialize(stream, stream.readInt32(exception), exception) ?: return
				rows.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(rows.size)
			rows.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x48a30254u.toInt()
		}
	}
	
	abstract class MessageEntity: TLObject() {
		@JvmField var length = 0
		@JvmField var offset = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessageEntity? {
				val result = when (constructor) {
					TLMessageEntityUnknown.CONSTRUCTOR -> TLMessageEntityUnknown()
					TLMessageEntityMention.CONSTRUCTOR -> TLMessageEntityMention()
					TLMessageEntityHashtag.CONSTRUCTOR -> TLMessageEntityHashtag()
					TLMessageEntityBotCommand.CONSTRUCTOR -> TLMessageEntityBotCommand()
					TLMessageEntityUrl.CONSTRUCTOR -> TLMessageEntityUrl()
					TLMessageEntityEmail.CONSTRUCTOR -> TLMessageEntityEmail()
					TLMessageEntityBold.CONSTRUCTOR -> TLMessageEntityBold()
					TLMessageEntityItalic.CONSTRUCTOR -> TLMessageEntityItalic()
					TLMessageEntityCode.CONSTRUCTOR -> TLMessageEntityCode()
					TLMessageEntityPre.CONSTRUCTOR -> TLMessageEntityPre()
					TLMessageEntityTextUrl.CONSTRUCTOR -> TLMessageEntityTextUrl()
					TLMessageEntityMentionName.CONSTRUCTOR -> TLMessageEntityMentionName()
					TLInputMessageEntityMentionName.CONSTRUCTOR -> TLInputMessageEntityMentionName()
					TLMessageEntityPhone.CONSTRUCTOR -> TLMessageEntityPhone()
					TLMessageEntityCashtag.CONSTRUCTOR -> TLMessageEntityCashtag()
					TLMessageEntityUnderline.CONSTRUCTOR -> TLMessageEntityUnderline()
					TLMessageEntityStrike.CONSTRUCTOR -> TLMessageEntityStrike()
					TLMessageEntityBlockquote.CONSTRUCTOR -> TLMessageEntityBlockquote()
					TLMessageEntityBankCard.CONSTRUCTOR -> TLMessageEntityBankCard()
					TLMessageEntitySpoiler.CONSTRUCTOR -> TLMessageEntitySpoiler()
					TLMessageEntityCustomEmoji.CONSTRUCTOR -> TLMessageEntityCustomEmoji()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessageEntity")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessageEntityUnknown: MessageEntity() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbb92ba95u.toInt()
		}
	}
	
	open class TLMessageEntityMention: MessageEntity() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfa04579du.toInt()
		}
	}
	
	open class TLMessageEntityHashtag: MessageEntity() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6f635b0du.toInt()
		}
	}
	
	open class TLMessageEntityBotCommand: MessageEntity() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6cef8ac7u.toInt()
		}
	}
	
	open class TLMessageEntityUrl: MessageEntity() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6ed02538u.toInt()
		}
	}
	
	open class TLMessageEntityEmail: MessageEntity() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0x64e475c2u.toInt()
		}
	}
	
	open class TLMessageEntityBold: MessageEntity() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbd610bc9u.toInt()
		}
	}
	
	open class TLMessageEntityItalic: MessageEntity() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0x826f8b60u.toInt()
		}
	}
	
	open class TLMessageEntityCode: MessageEntity() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0x28a20571u.toInt()
		}
	}
	
	open class TLMessageEntityPre: MessageEntity() {
				@JvmField var language: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
			language = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
			stream.writeString(language)
		}
	
		companion object {
			val CONSTRUCTOR = 0x73924be0u.toInt()
		}
	}
	
	open class TLMessageEntityTextUrl: MessageEntity() {
				@JvmField var url: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
			url = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
			stream.writeString(url)
		}
	
		companion object {
			val CONSTRUCTOR = 0x76a6d327u.toInt()
		}
	}
	
	open class TLMessageEntityMentionName: MessageEntity() {
				@JvmField var userId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
			userId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
			stream.writeInt64(userId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdc7b1140u.toInt()
		}
	}
	
	open class TLInputMessageEntityMentionName: MessageEntity() {
				@JvmField var userId: InputUser? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
			userId = InputUser.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
			userId?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x208e68c9u.toInt()
		}
	}
	
	open class TLMessageEntityPhone: MessageEntity() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9b69e34bu.toInt()
		}
	}
	
	open class TLMessageEntityCashtag: MessageEntity() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4c4e743fu.toInt()
		}
	}
	
	open class TLMessageEntityUnderline: MessageEntity() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9c4e7e8bu.toInt()
		}
	}
	
	open class TLMessageEntityStrike: MessageEntity() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbf0693d4u.toInt()
		}
	}
	
	open class TLMessageEntityBlockquote: MessageEntity() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0x20df5d0u.toInt()
		}
	}
	
	open class TLMessageEntityBankCard: MessageEntity() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0x761e6af4u.toInt()
		}
	}
	
	open class TLMessageEntitySpoiler: MessageEntity() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0x32ca960fu.toInt()
		}
	}
	
	open class TLMessageEntityCustomEmoji: MessageEntity() {
				@JvmField var documentId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt32(exception)
			length = stream.readInt32(exception)
			documentId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(length)
			stream.writeInt64(documentId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc8cf05f8u.toInt()
		}
	}
	
	abstract class InputChannel: TLObject() {
		@JvmField var channelId = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputChannel? {
				val result = when (constructor) {
					TLInputChannelEmpty.CONSTRUCTOR -> TLInputChannelEmpty()
					TLInputChannel.CONSTRUCTOR -> TLInputChannel()
					TLInputChannelFromMessage.CONSTRUCTOR -> TLInputChannelFromMessage()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputChannel")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputChannelEmpty: InputChannel() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xee8c1e86u.toInt()
		}
	}
	
	open class TLInputChannel: InputChannel() {
			@JvmField var accessHash = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			channelId = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(channelId)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf35aec28u.toInt()
		}
	}
	
	open class TLInputChannelFromMessage: InputChannel() {
		@JvmField var peer: InputPeer? = null
		@JvmField var msgId = 0
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = InputPeer.deserialize(stream, stream.readInt32(exception), exception)
			msgId = stream.readInt32(exception)
			channelId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
			stream.writeInt64(channelId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5b934f9du.toInt()
		}
	}
	
	open class TLContactsResolvedPeer: TLObject() {
		@JvmField var peer: Peer? = null
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x7f077ad9u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLContactsResolvedPeer? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLContactsResolvedPeer")
					}
					else {
						null
					}
				}
	
				val result = TLContactsResolvedPeer()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLContactsResolveUsername: TLObject() {
		@JvmField var username: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLContactsResolvedPeer? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLContactsResolvedPeer.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(username)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf93ccba3u.toInt()
		}
	}
	
	open class TLContactsResolvePhone: TLObject() {
		@JvmField var phone: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLContactsResolvedPeer? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLContactsResolvedPeer.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phone)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8af94344u.toInt()
		}
	}
	
	open class TLMessageRange: TLObject() {
		@JvmField var minId = 0
		@JvmField var maxId = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			minId = stream.readInt32(exception)
			maxId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(minId)
			stream.writeInt32(maxId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xae30253u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessageRange? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessageRange")
					}
					else {
						null
					}
				}
	
				val result = TLMessageRange()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class UpdatesChannelDifference: TLObject() {
		@JvmField var flags = 0
		@JvmField var timeout = 0
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField var isFinal = false
		@JvmField var pts = 0
		@JvmField val users = mutableListOf<User>()
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): UpdatesChannelDifference? {
				val result = when (constructor) {
					TLUpdatesChannelDifferenceEmpty.CONSTRUCTOR -> TLUpdatesChannelDifferenceEmpty()
					TLUpdatesChannelDifferenceTooLong.CONSTRUCTOR -> TLUpdatesChannelDifferenceTooLong()
					TLUpdatesChannelDifference.CONSTRUCTOR -> TLUpdatesChannelDifference()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in UpdatesChannelDifference")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLUpdatesChannelDifferenceEmpty: UpdatesChannelDifference() {
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			isFinal = (flags and 1) != 0
			pts = stream.readInt32(exception)
		
			if ((flags and 2) != 0) {
				timeout = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (isFinal) flags or 1 else flags and 1.inv()
			flags = if (timeout != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(pts)
			if ((flags and 2) != 0) {
				stream.writeInt32(timeout)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3e11affbu.toInt()
		}
	}
	
	open class TLUpdatesChannelDifferenceTooLong: UpdatesChannelDifference() {
					@JvmField var dialog: Dialog? = null
		@JvmField val messages = mutableListOf<Message>()
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			isFinal = (flags and 1) != 0
		
			if ((flags and 2) != 0) {
				timeout = stream.readInt32(exception)
			}
			dialog = Dialog.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Message.deserialize(stream, stream.readInt32(exception), exception) ?: return
				messages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (isFinal) flags or 1 else flags and 1.inv()
			flags = if (timeout != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			if ((flags and 2) != 0) {
				stream.writeInt32(timeout)
			}
	
			dialog?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xa4bcc6feu.toInt()
		}
	}
	
	open class TLUpdatesChannelDifference: UpdatesChannelDifference() {
						@JvmField val newMessages = mutableListOf<Message>()
		@JvmField val otherUpdates = mutableListOf<Update>()
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			isFinal = (flags and 1) != 0
			pts = stream.readInt32(exception)
		
			if ((flags and 2) != 0) {
				timeout = stream.readInt32(exception)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Message.deserialize(stream, stream.readInt32(exception), exception) ?: return
				newMessages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Update.deserialize(stream, stream.readInt32(exception), exception) ?: return
				otherUpdates.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (isFinal) flags or 1 else flags and 1.inv()
			flags = if (timeout != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(pts)
			if ((flags and 2) != 0) {
				stream.writeInt32(timeout)
			}
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(newMessages.size)
			newMessages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(otherUpdates.size)
			otherUpdates.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x2064674eu.toInt()
		}
	}
	
	open class TLUpdatesGetChannelDifference: TLObject() {
		@JvmField var flags = 0
		@JvmField var force = false
		@JvmField var channel: InputChannel? = null
		@JvmField var filter: ChannelMessagesFilter? = null
		@JvmField var pts = 0
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): UpdatesChannelDifference? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return UpdatesChannelDifference.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (force) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			channel?.serializeToStream(stream)
			filter?.serializeToStream(stream)
			stream.writeInt32(pts)
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3173d78u.toInt()
		}
	}
	
	abstract class ChannelMessagesFilter: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChannelMessagesFilter? {
				val result = when (constructor) {
					TLChannelMessagesFilterEmpty.CONSTRUCTOR -> TLChannelMessagesFilterEmpty()
					TLChannelMessagesFilter.CONSTRUCTOR -> TLChannelMessagesFilter()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ChannelMessagesFilter")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChannelMessagesFilterEmpty: ChannelMessagesFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x94d42ee7u.toInt()
		}
	}
	
	open class TLChannelMessagesFilter: ChannelMessagesFilter() {
		@JvmField var flags = 0
		@JvmField var excludeNewMessages = false
		@JvmField val ranges = mutableListOf<TLMessageRange>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			excludeNewMessages = (flags and 2) != 0
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLMessageRange.deserialize(stream, stream.readInt32(exception), exception) ?: return
				ranges.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (excludeNewMessages) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(ranges.size)
			ranges.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xcd77d957u.toInt()
		}
	}
	
	abstract class ChannelParticipant: TLObject() {
		@JvmField var userId = 0L
		@JvmField var flags = 0
		@JvmField var date = 0
		@JvmField var rank: String? = null
		@JvmField var inviterId = 0L
		@JvmField var peer: Peer? = null
		@JvmField var adminRights: TLChatAdminRights? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChannelParticipant? {
				val result = when (constructor) {
					TLChannelParticipant.CONSTRUCTOR -> TLChannelParticipant()
					TLChannelParticipantSelf.CONSTRUCTOR -> TLChannelParticipantSelf()
					TLChannelParticipantCreator.CONSTRUCTOR -> TLChannelParticipantCreator()
					TLChannelParticipantAdmin.CONSTRUCTOR -> TLChannelParticipantAdmin()
					TLChannelParticipantBanned.CONSTRUCTOR -> TLChannelParticipantBanned()
					TLChannelParticipantLeft.CONSTRUCTOR -> TLChannelParticipantLeft()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ChannelParticipant")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChannelParticipant: ChannelParticipant() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			date = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeInt32(date)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc00c07c0u.toInt()
		}
	}
	
	open class TLChannelParticipantSelf: ChannelParticipant() {
			@JvmField var viaRequest = false
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			viaRequest = (flags and 1) != 0
			userId = stream.readInt64(exception)
			inviterId = stream.readInt64(exception)
			date = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (viaRequest) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(userId)
			stream.writeInt64(inviterId)
			stream.writeInt32(date)
		}
	
		companion object {
			val CONSTRUCTOR = 0x35a8bfa7u.toInt()
		}
	}
	
	open class TLChannelParticipantCreator: ChannelParticipant() {
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			userId = stream.readInt64(exception)
			adminRights = TLChatAdminRights.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				rank = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (rank != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(userId)
			adminRights?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeString(rank)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x2fe601d3u.toInt()
		}
	}
	
	open class TLChannelParticipantAdmin: ChannelParticipant() {
			@JvmField var canEdit = false
		@JvmField var isSelf = false
				@JvmField var promotedBy = 0L
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			canEdit = (flags and 1) != 0
			isSelf = (flags and 2) != 0
			userId = stream.readInt64(exception)
		
			if ((flags and 8) != 0) {
				inviterId = stream.readInt64(exception)
			}
			promotedBy = stream.readInt64(exception)
			date = stream.readInt32(exception)
			adminRights = TLChatAdminRights.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 4) != 0) {
				rank = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (canEdit) flags or 1 else flags and 1.inv()
			flags = if (isSelf) flags or 2 else flags and 2.inv()
			flags = if (inviterId != 0L) flags or 8 else flags and 8.inv()
			flags = if (rank != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(userId)
			if ((flags and 8) != 0) {
				stream.writeInt64(inviterId)
			}
	
			stream.writeInt64(promotedBy)
			stream.writeInt32(date)
			adminRights?.serializeToStream(stream)
			if ((flags and 4) != 0) {
				stream.writeString(rank)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x34c3bb53u.toInt()
		}
	}
	
	open class TLChannelParticipantBanned: ChannelParticipant() {
			@JvmField var left = false
			@JvmField var kickedBy = 0L
			@JvmField var bannedRights: TLChatBannedRights? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			left = (flags and 1) != 0
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			kickedBy = stream.readInt64(exception)
			date = stream.readInt32(exception)
			bannedRights = TLChatBannedRights.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (left) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt64(kickedBy)
			stream.writeInt32(date)
			bannedRights?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6df8014eu.toInt()
		}
	}
	
	open class TLChannelParticipantLeft: ChannelParticipant() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1b03f006u.toInt()
		}
	}
	
	abstract class ChannelParticipantsFilter: TLObject() {
		@JvmField var q: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChannelParticipantsFilter? {
				val result = when (constructor) {
					TLChannelParticipantsRecent.CONSTRUCTOR -> TLChannelParticipantsRecent()
					TLChannelParticipantsAdmins.CONSTRUCTOR -> TLChannelParticipantsAdmins()
					TLChannelParticipantsKicked.CONSTRUCTOR -> TLChannelParticipantsKicked()
					TLChannelParticipantsBots.CONSTRUCTOR -> TLChannelParticipantsBots()
					TLChannelParticipantsBanned.CONSTRUCTOR -> TLChannelParticipantsBanned()
					TLChannelParticipantsSearch.CONSTRUCTOR -> TLChannelParticipantsSearch()
					TLChannelParticipantsContacts.CONSTRUCTOR -> TLChannelParticipantsContacts()
					TLChannelParticipantsMentions.CONSTRUCTOR -> TLChannelParticipantsMentions()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ChannelParticipantsFilter")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChannelParticipantsRecent: ChannelParticipantsFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xde3f3c79u.toInt()
		}
	}
	
	open class TLChannelParticipantsAdmins: ChannelParticipantsFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb4608969u.toInt()
		}
	}
	
	open class TLChannelParticipantsKicked: ChannelParticipantsFilter() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			q = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(q)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa3b54985u.toInt()
		}
	}
	
	open class TLChannelParticipantsBots: ChannelParticipantsFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb0d1865bu.toInt()
		}
	}
	
	open class TLChannelParticipantsBanned: ChannelParticipantsFilter() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			q = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(q)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1427a5e1u.toInt()
		}
	}
	
	open class TLChannelParticipantsSearch: ChannelParticipantsFilter() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			q = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(q)
		}
	
		companion object {
			val CONSTRUCTOR = 0x656ac4bu.toInt()
		}
	}
	
	open class TLChannelParticipantsContacts: ChannelParticipantsFilter() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			q = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(q)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbb6ae88du.toInt()
		}
	}
	
	open class TLChannelParticipantsMentions: ChannelParticipantsFilter() {
		@JvmField var flags = 0
			@JvmField var topMsgId = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				q = stream.readString(exception) ?: return
			}
		
			if ((flags and 2) != 0) {
				topMsgId = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (q != null) flags or 1 else flags and 1.inv()
			flags = if (topMsgId != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeString(q)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(topMsgId)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe04b5cebu.toInt()
		}
	}
	
	abstract class ChannelsChannelParticipants: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChannelsChannelParticipants? {
				val result = when (constructor) {
					TLChannelsChannelParticipants.CONSTRUCTOR -> TLChannelsChannelParticipants()
					TLChannelsChannelParticipantsNotModified.CONSTRUCTOR -> TLChannelsChannelParticipantsNotModified()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ChannelsChannelParticipants")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChannelsChannelParticipants: ChannelsChannelParticipants() {
		@JvmField var count = 0
		@JvmField val participants = mutableListOf<ChannelParticipant>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			count = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = ChannelParticipant.deserialize(stream, stream.readInt32(exception), exception) ?: return
				participants.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(count)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(participants.size)
			participants.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x9ab0feafu.toInt()
		}
	}
	
	open class TLChannelsChannelParticipantsNotModified: ChannelsChannelParticipants() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf0173fe9u.toInt()
		}
	}
	
	open class TLChannelsGetParticipants: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var filter: ChannelParticipantsFilter? = null
		@JvmField var offset = 0
		@JvmField var limit = 0
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChannelsChannelParticipants? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return ChannelsChannelParticipants.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			filter?.serializeToStream(stream)
			stream.writeInt32(offset)
			stream.writeInt32(limit)
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x77ced9d0u.toInt()
		}
	}
	
	open class TLChannelsChannelParticipant: TLObject() {
		@JvmField var participant: ChannelParticipant? = null
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			participant = ChannelParticipant.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			participant?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xdfb80317u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChannelsChannelParticipant? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLChannelsChannelParticipant")
					}
					else {
						null
					}
				}
	
				val result = TLChannelsChannelParticipant()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLChannelsGetParticipant: TLObject() {
		@JvmField var channel: InputChannel? = null
		@JvmField var participant: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChannelsChannelParticipant? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLChannelsChannelParticipant.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
			participant?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa0ab6cc6u.toInt()
		}
	}
	
	open class TLHelpTermsOfService: TLObject() {
		@JvmField var flags = 0
		@JvmField var popup = false
		@JvmField var id: TLDataJSON? = null
		@JvmField var text: String? = null
		@JvmField val entities = mutableListOf<MessageEntity>()
		@JvmField var minAgeConfirm = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			popup = (flags and 1) != 0
			id = TLDataJSON.deserialize(stream, stream.readInt32(exception), exception)
			text = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
				entities.add(obj)
			}
		
			if ((flags and 2) != 0) {
				minAgeConfirm = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (popup) flags or 1 else flags and 1.inv()
			flags = if (minAgeConfirm != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			id?.serializeToStream(stream)
			stream.writeString(text)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			if ((flags and 2) != 0) {
				stream.writeInt32(minAgeConfirm)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x780a0310u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLHelpTermsOfService? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLHelpTermsOfService")
					}
					else {
						null
					}
				}
	
				val result = TLHelpTermsOfService()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class MessagesSavedGifs: TLObject() {
		@JvmField var hash = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesSavedGifs? {
				val result = when (constructor) {
					TLMessagesSavedGifsNotModified.CONSTRUCTOR -> TLMessagesSavedGifsNotModified()
					TLMessagesSavedGifs.CONSTRUCTOR -> TLMessagesSavedGifs()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesSavedGifs")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesSavedGifsNotModified: MessagesSavedGifs() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe8025ca2u.toInt()
		}
	}
	
	open class TLMessagesSavedGifs: MessagesSavedGifs() {
			@JvmField val gifs = mutableListOf<Document>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			hash = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Document.deserialize(stream, stream.readInt32(exception), exception) ?: return
				gifs.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(gifs.size)
			gifs.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x84a02a0du.toInt()
		}
	}
	
	open class TLMessagesGetSavedGifs: TLObject() {
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesSavedGifs? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesSavedGifs.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5cf09635u.toInt()
		}
	}
	
	abstract class InputBotInlineMessage: TLObject() {
		@JvmField val entities = mutableListOf<MessageEntity>()
		@JvmField var title: String? = null
		@JvmField var flags = 0
		@JvmField var geoPoint: InputGeoPoint? = null
		@JvmField var message: String? = null
		@JvmField var provider: String? = null
		@JvmField var replyMarkup: ReplyMarkup? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputBotInlineMessage? {
				val result = when (constructor) {
					TLInputBotInlineMessageMediaAuto.CONSTRUCTOR -> TLInputBotInlineMessageMediaAuto()
					TLInputBotInlineMessageText.CONSTRUCTOR -> TLInputBotInlineMessageText()
					TLInputBotInlineMessageMediaGeo.CONSTRUCTOR -> TLInputBotInlineMessageMediaGeo()
					TLInputBotInlineMessageMediaVenue.CONSTRUCTOR -> TLInputBotInlineMessageMediaVenue()
					TLInputBotInlineMessageMediaContact.CONSTRUCTOR -> TLInputBotInlineMessageMediaContact()
					TLInputBotInlineMessageGame.CONSTRUCTOR -> TLInputBotInlineMessageGame()
					TLInputBotInlineMessageMediaInvoice.CONSTRUCTOR -> TLInputBotInlineMessageMediaInvoice()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputBotInlineMessage")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputBotInlineMessageMediaAuto: InputBotInlineMessage() {
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			message = stream.readString(exception) ?: return
		
			if ((flags and 2) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
					entities.add(obj)
				}
			}
		
			if ((flags and 4) != 0) {
				replyMarkup = ReplyMarkup.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (replyMarkup != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeString(message)
			if ((flags and 2) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 4) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3380c786u.toInt()
		}
	}
	
	open class TLInputBotInlineMessageText: InputBotInlineMessage() {
			@JvmField var noWebpage = false
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			noWebpage = (flags and 1) != 0
			message = stream.readString(exception) ?: return
		
			if ((flags and 2) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
					entities.add(obj)
				}
			}
		
			if ((flags and 4) != 0) {
				replyMarkup = ReplyMarkup.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (noWebpage) flags or 1 else flags and 1.inv()
			flags = if (replyMarkup != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeString(message)
			if ((flags and 2) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 4) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3dcd7a87u.toInt()
		}
	}
	
	open class TLInputBotInlineMessageMediaGeo: InputBotInlineMessage() {
				@JvmField var heading = 0
		@JvmField var period = 0
		@JvmField var proximityNotificationRadius = 0
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			geoPoint = InputGeoPoint.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				heading = stream.readInt32(exception)
			}
		
			if ((flags and 2) != 0) {
				period = stream.readInt32(exception)
			}
		
			if ((flags and 8) != 0) {
				proximityNotificationRadius = stream.readInt32(exception)
			}
		
			if ((flags and 4) != 0) {
				replyMarkup = ReplyMarkup.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (heading != 0) flags or 1 else flags and 1.inv()
			flags = if (period != 0) flags or 2 else flags and 2.inv()
			flags = if (proximityNotificationRadius != 0) flags or 8 else flags and 8.inv()
			flags = if (replyMarkup != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			geoPoint?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(heading)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(period)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt32(proximityNotificationRadius)
			}
	
			if ((flags and 4) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x96929a85u.toInt()
		}
	}
	
	open class TLInputBotInlineMessageMediaVenue: InputBotInlineMessage() {
					@JvmField var address: String? = null
			@JvmField var venueId: String? = null
		@JvmField var venueType: String? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			geoPoint = InputGeoPoint.deserialize(stream, stream.readInt32(exception), exception)
			title = stream.readString(exception) ?: return
			address = stream.readString(exception) ?: return
			provider = stream.readString(exception) ?: return
			venueId = stream.readString(exception) ?: return
			venueType = stream.readString(exception) ?: return
		
			if ((flags and 4) != 0) {
				replyMarkup = ReplyMarkup.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (replyMarkup != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			geoPoint?.serializeToStream(stream)
			stream.writeString(title)
			stream.writeString(address)
			stream.writeString(provider)
			stream.writeString(venueId)
			stream.writeString(venueType)
			if ((flags and 4) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x417bbf11u.toInt()
		}
	}
	
	open class TLInputBotInlineMessageMediaContact: InputBotInlineMessage() {
			@JvmField var phoneNumber: String? = null
		@JvmField var firstName: String? = null
		@JvmField var lastName: String? = null
		@JvmField var vcard: String? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			phoneNumber = stream.readString(exception) ?: return
			firstName = stream.readString(exception) ?: return
			lastName = stream.readString(exception) ?: return
			vcard = stream.readString(exception) ?: return
		
			if ((flags and 4) != 0) {
				replyMarkup = ReplyMarkup.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (replyMarkup != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeString(phoneNumber)
			stream.writeString(firstName)
			stream.writeString(lastName)
			stream.writeString(vcard)
			if ((flags and 4) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa6edbffdu.toInt()
		}
	}
	
	open class TLInputBotInlineMessageGame: InputBotInlineMessage() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 4) != 0) {
				replyMarkup = ReplyMarkup.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (replyMarkup != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			if ((flags and 4) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x4b425864u.toInt()
		}
	}
	
	open class TLInputBotInlineMessageMediaInvoice: InputBotInlineMessage() {
				@JvmField var description: String? = null
		@JvmField var photo: TLInputWebDocument? = null
		@JvmField var invoice: TLInvoice? = null
		@JvmField var payload: ByteArray? = null
			@JvmField var providerData: TLDataJSON? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			title = stream.readString(exception) ?: return
			description = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				photo = TLInputWebDocument.deserialize(stream, stream.readInt32(exception), exception)
			}
			invoice = TLInvoice.deserialize(stream, stream.readInt32(exception), exception)
			payload = stream.readByteArray(exception) ?: return
			provider = stream.readString(exception) ?: return
			providerData = TLDataJSON.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 4) != 0) {
				replyMarkup = ReplyMarkup.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (photo != null) flags or 1 else flags and 1.inv()
			flags = if (replyMarkup != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeString(title)
			stream.writeString(description)
			if ((flags and 1) != 0) {
				photo?.serializeToStream(stream)
			}
	
			invoice?.serializeToStream(stream)
			stream.writeByteArray(payload)
			stream.writeString(provider)
			providerData?.serializeToStream(stream)
			if ((flags and 4) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd7e78225u.toInt()
		}
	}
	
	abstract class InputBotInlineResult: TLObject() {
		@JvmField var id: String? = null
		@JvmField var title: String? = null
		@JvmField var flags = 0
		@JvmField var description: String? = null
		@JvmField var type: String? = null
		@JvmField var sendMessage: InputBotInlineMessage? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputBotInlineResult? {
				val result = when (constructor) {
					TLInputBotInlineResult.CONSTRUCTOR -> TLInputBotInlineResult()
					TLInputBotInlineResultPhoto.CONSTRUCTOR -> TLInputBotInlineResultPhoto()
					TLInputBotInlineResultDocument.CONSTRUCTOR -> TLInputBotInlineResultDocument()
					TLInputBotInlineResultGame.CONSTRUCTOR -> TLInputBotInlineResultGame()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputBotInlineResult")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputBotInlineResult: InputBotInlineResult() {
							@JvmField var url: String? = null
		@JvmField var thumb: TLInputWebDocument? = null
		@JvmField var content: TLInputWebDocument? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			id = stream.readString(exception) ?: return
			type = stream.readString(exception) ?: return
		
			if ((flags and 2) != 0) {
				title = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				description = stream.readString(exception) ?: return
			}
		
			if ((flags and 8) != 0) {
				url = stream.readString(exception) ?: return
			}
		
			if ((flags and 16) != 0) {
				thumb = TLInputWebDocument.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 32) != 0) {
				content = TLInputWebDocument.deserialize(stream, stream.readInt32(exception), exception)
			}
			sendMessage = InputBotInlineMessage.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (title != null) flags or 2 else flags and 2.inv()
			flags = if (description != null) flags or 4 else flags and 4.inv()
			flags = if (url != null) flags or 8 else flags and 8.inv()
			flags = if (thumb != null) flags or 16 else flags and 16.inv()
			flags = if (content != null) flags or 32 else flags and 32.inv()
	
			stream.writeInt32(flags)
			stream.writeString(id)
			stream.writeString(type)
			if ((flags and 2) != 0) {
				stream.writeString(title)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(description)
			}
	
			if ((flags and 8) != 0) {
				stream.writeString(url)
			}
	
			if ((flags and 16) != 0) {
				thumb?.serializeToStream(stream)
			}
	
			if ((flags and 32) != 0) {
				content?.serializeToStream(stream)
			}
	
			sendMessage?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x88bf9319u.toInt()
		}
	}
	
	open class TLInputBotInlineResultPhoto: InputBotInlineResult() {
				@JvmField var photo: InputPhoto? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readString(exception) ?: return
			type = stream.readString(exception) ?: return
			photo = InputPhoto.deserialize(stream, stream.readInt32(exception), exception)
			sendMessage = InputBotInlineMessage.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(id)
			stream.writeString(type)
			photo?.serializeToStream(stream)
			sendMessage?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa8d864a7u.toInt()
		}
	}
	
	open class TLInputBotInlineResultDocument: InputBotInlineResult() {
							@JvmField var document: InputDocument? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			id = stream.readString(exception) ?: return
			type = stream.readString(exception) ?: return
		
			if ((flags and 2) != 0) {
				title = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				description = stream.readString(exception) ?: return
			}
			document = InputDocument.deserialize(stream, stream.readInt32(exception), exception)
			sendMessage = InputBotInlineMessage.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (title != null) flags or 2 else flags and 2.inv()
			flags = if (description != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeString(id)
			stream.writeString(type)
			if ((flags and 2) != 0) {
				stream.writeString(title)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(description)
			}
	
			document?.serializeToStream(stream)
			sendMessage?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfff8fdc4u.toInt()
		}
	}
	
	open class TLInputBotInlineResultGame: InputBotInlineResult() {
			@JvmField var shortName: String? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readString(exception) ?: return
			shortName = stream.readString(exception) ?: return
			sendMessage = InputBotInlineMessage.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(id)
			stream.writeString(shortName)
			sendMessage?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4fa417f2u.toInt()
		}
	}
	
	abstract class BotInlineMessage: TLObject() {
		@JvmField val entities = mutableListOf<MessageEntity>()
		@JvmField var title: String? = null
		@JvmField var flags = 0
		@JvmField var message: String? = null
		@JvmField var geo: GeoPoint? = null
		@JvmField var replyMarkup: ReplyMarkup? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): BotInlineMessage? {
				val result = when (constructor) {
					TLBotInlineMessageMediaAuto.CONSTRUCTOR -> TLBotInlineMessageMediaAuto()
					TLBotInlineMessageText.CONSTRUCTOR -> TLBotInlineMessageText()
					TLBotInlineMessageMediaGeo.CONSTRUCTOR -> TLBotInlineMessageMediaGeo()
					TLBotInlineMessageMediaVenue.CONSTRUCTOR -> TLBotInlineMessageMediaVenue()
					TLBotInlineMessageMediaContact.CONSTRUCTOR -> TLBotInlineMessageMediaContact()
					TLBotInlineMessageMediaInvoice.CONSTRUCTOR -> TLBotInlineMessageMediaInvoice()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in BotInlineMessage")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLBotInlineMessageMediaAuto: BotInlineMessage() {
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			message = stream.readString(exception) ?: return
		
			if ((flags and 2) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
					entities.add(obj)
				}
			}
		
			if ((flags and 4) != 0) {
				replyMarkup = ReplyMarkup.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (replyMarkup != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeString(message)
			if ((flags and 2) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 4) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x764cf810u.toInt()
		}
	}
	
	open class TLBotInlineMessageText: BotInlineMessage() {
			@JvmField var noWebpage = false
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			noWebpage = (flags and 1) != 0
			message = stream.readString(exception) ?: return
		
			if ((flags and 2) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
					entities.add(obj)
				}
			}
		
			if ((flags and 4) != 0) {
				replyMarkup = ReplyMarkup.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (noWebpage) flags or 1 else flags and 1.inv()
			flags = if (replyMarkup != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeString(message)
			if ((flags and 2) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 4) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8c7f65e2u.toInt()
		}
	}
	
	open class TLBotInlineMessageMediaGeo: BotInlineMessage() {
				@JvmField var heading = 0
		@JvmField var period = 0
		@JvmField var proximityNotificationRadius = 0
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			geo = GeoPoint.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				heading = stream.readInt32(exception)
			}
		
			if ((flags and 2) != 0) {
				period = stream.readInt32(exception)
			}
		
			if ((flags and 8) != 0) {
				proximityNotificationRadius = stream.readInt32(exception)
			}
		
			if ((flags and 4) != 0) {
				replyMarkup = ReplyMarkup.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (heading != 0) flags or 1 else flags and 1.inv()
			flags = if (period != 0) flags or 2 else flags and 2.inv()
			flags = if (proximityNotificationRadius != 0) flags or 8 else flags and 8.inv()
			flags = if (replyMarkup != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			geo?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(heading)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(period)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt32(proximityNotificationRadius)
			}
	
			if ((flags and 4) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x51846fdu.toInt()
		}
	}
	
	open class TLBotInlineMessageMediaVenue: BotInlineMessage() {
					@JvmField var address: String? = null
		@JvmField var provider: String? = null
		@JvmField var venueId: String? = null
		@JvmField var venueType: String? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			geo = GeoPoint.deserialize(stream, stream.readInt32(exception), exception)
			title = stream.readString(exception) ?: return
			address = stream.readString(exception) ?: return
			provider = stream.readString(exception) ?: return
			venueId = stream.readString(exception) ?: return
			venueType = stream.readString(exception) ?: return
		
			if ((flags and 4) != 0) {
				replyMarkup = ReplyMarkup.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (replyMarkup != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			geo?.serializeToStream(stream)
			stream.writeString(title)
			stream.writeString(address)
			stream.writeString(provider)
			stream.writeString(venueId)
			stream.writeString(venueType)
			if ((flags and 4) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8a86659cu.toInt()
		}
	}
	
	open class TLBotInlineMessageMediaContact: BotInlineMessage() {
			@JvmField var phoneNumber: String? = null
		@JvmField var firstName: String? = null
		@JvmField var lastName: String? = null
		@JvmField var vcard: String? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			phoneNumber = stream.readString(exception) ?: return
			firstName = stream.readString(exception) ?: return
			lastName = stream.readString(exception) ?: return
			vcard = stream.readString(exception) ?: return
		
			if ((flags and 4) != 0) {
				replyMarkup = ReplyMarkup.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (replyMarkup != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeString(phoneNumber)
			stream.writeString(firstName)
			stream.writeString(lastName)
			stream.writeString(vcard)
			if ((flags and 4) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x18d1cdc2u.toInt()
		}
	}
	
	open class TLBotInlineMessageMediaInvoice: BotInlineMessage() {
			@JvmField var shippingAddressRequested = false
		@JvmField var test = false
			@JvmField var description: String? = null
		@JvmField var photo: WebDocument? = null
		@JvmField var currency: String? = null
		@JvmField var totalAmount = 0L
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			shippingAddressRequested = (flags and 2) != 0
			test = (flags and 8) != 0
			title = stream.readString(exception) ?: return
			description = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				photo = WebDocument.deserialize(stream, stream.readInt32(exception), exception)
			}
			currency = stream.readString(exception) ?: return
			totalAmount = stream.readInt64(exception)
		
			if ((flags and 4) != 0) {
				replyMarkup = ReplyMarkup.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (shippingAddressRequested) flags or 2 else flags and 2.inv()
			flags = if (test) flags or 8 else flags and 8.inv()
			flags = if (photo != null) flags or 1 else flags and 1.inv()
			flags = if (replyMarkup != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeString(title)
			stream.writeString(description)
			if ((flags and 1) != 0) {
				photo?.serializeToStream(stream)
			}
	
			stream.writeString(currency)
			stream.writeInt64(totalAmount)
			if ((flags and 4) != 0) {
				replyMarkup?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x354a9b09u.toInt()
		}
	}
	
	abstract class BotInlineResult: TLObject() {
		@JvmField var sendMessage: BotInlineMessage? = null
		@JvmField var id: String? = null
		@JvmField var title: String? = null
		@JvmField var flags = 0
		@JvmField var description: String? = null
		@JvmField var type: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): BotInlineResult? {
				val result = when (constructor) {
					TLBotInlineResult.CONSTRUCTOR -> TLBotInlineResult()
					TLBotInlineMediaResult.CONSTRUCTOR -> TLBotInlineMediaResult()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in BotInlineResult")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLBotInlineResult: BotInlineResult() {
							@JvmField var url: String? = null
		@JvmField var thumb: WebDocument? = null
		@JvmField var content: WebDocument? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			id = stream.readString(exception) ?: return
			type = stream.readString(exception) ?: return
		
			if ((flags and 2) != 0) {
				title = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				description = stream.readString(exception) ?: return
			}
		
			if ((flags and 8) != 0) {
				url = stream.readString(exception) ?: return
			}
		
			if ((flags and 16) != 0) {
				thumb = WebDocument.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 32) != 0) {
				content = WebDocument.deserialize(stream, stream.readInt32(exception), exception)
			}
			sendMessage = BotInlineMessage.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (title != null) flags or 2 else flags and 2.inv()
			flags = if (description != null) flags or 4 else flags and 4.inv()
			flags = if (url != null) flags or 8 else flags and 8.inv()
			flags = if (thumb != null) flags or 16 else flags and 16.inv()
			flags = if (content != null) flags or 32 else flags and 32.inv()
	
			stream.writeInt32(flags)
			stream.writeString(id)
			stream.writeString(type)
			if ((flags and 2) != 0) {
				stream.writeString(title)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(description)
			}
	
			if ((flags and 8) != 0) {
				stream.writeString(url)
			}
	
			if ((flags and 16) != 0) {
				thumb?.serializeToStream(stream)
			}
	
			if ((flags and 32) != 0) {
				content?.serializeToStream(stream)
			}
	
			sendMessage?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x11965f3au.toInt()
		}
	}
	
	open class TLBotInlineMediaResult: BotInlineResult() {
					@JvmField var photo: Photo? = null
		@JvmField var document: Document? = null
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			id = stream.readString(exception) ?: return
			type = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				photo = Photo.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				document = Document.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 4) != 0) {
				title = stream.readString(exception) ?: return
			}
		
			if ((flags and 8) != 0) {
				description = stream.readString(exception) ?: return
			}
			sendMessage = BotInlineMessage.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (photo != null) flags or 1 else flags and 1.inv()
			flags = if (document != null) flags or 2 else flags and 2.inv()
			flags = if (title != null) flags or 4 else flags and 4.inv()
			flags = if (description != null) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			stream.writeString(id)
			stream.writeString(type)
			if ((flags and 1) != 0) {
				photo?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				document?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(title)
			}
	
			if ((flags and 8) != 0) {
				stream.writeString(description)
			}
	
			sendMessage?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x17db940bu.toInt()
		}
	}
	
	open class TLMessagesBotResults: TLObject() {
		@JvmField var flags = 0
		@JvmField var gallery = false
		@JvmField var queryId = 0L
		@JvmField var nextOffset: String? = null
		@JvmField var switchPm: TLInlineBotSwitchPM? = null
		@JvmField val results = mutableListOf<BotInlineResult>()
		@JvmField var cacheTime = 0
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			gallery = (flags and 1) != 0
			queryId = stream.readInt64(exception)
		
			if ((flags and 2) != 0) {
				nextOffset = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				switchPm = TLInlineBotSwitchPM.deserialize(stream, stream.readInt32(exception), exception)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = BotInlineResult.deserialize(stream, stream.readInt32(exception), exception) ?: return
				results.add(obj)
			}
			cacheTime = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (gallery) flags or 1 else flags and 1.inv()
			flags = if (nextOffset != null) flags or 2 else flags and 2.inv()
			flags = if (switchPm != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(queryId)
			if ((flags and 2) != 0) {
				stream.writeString(nextOffset)
			}
	
			if ((flags and 4) != 0) {
				switchPm?.serializeToStream(stream)
			}
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(results.size)
			results.forEach { it.serializeToStream(stream) }
			stream.writeInt32(cacheTime)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x947ca848u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesBotResults? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesBotResults")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesBotResults()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetInlineBotResults: TLObject() {
		@JvmField var flags = 0
		@JvmField var bot: InputUser? = null
		@JvmField var peer: InputPeer? = null
		@JvmField var geoPoint: InputGeoPoint? = null
		@JvmField var query: String? = null
		@JvmField var offset: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesBotResults? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesBotResults.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (geoPoint != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			bot?.serializeToStream(stream)
			peer?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				geoPoint?.serializeToStream(stream)
			}
	
			stream.writeString(query)
			stream.writeString(offset)
		}
	
		companion object {
			val CONSTRUCTOR = 0x514e999du.toInt()
		}
	}
	
	open class TLExportedMessageLink: TLObject() {
		@JvmField var link: String? = null
		@JvmField var html: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			link = stream.readString(exception) ?: return
			html = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(link)
			stream.writeString(html)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5dab1af4u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLExportedMessageLink? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLExportedMessageLink")
					}
					else {
						null
					}
				}
	
				val result = TLExportedMessageLink()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLChannelsExportMessageLink: TLObject() {
		@JvmField var flags = 0
		@JvmField var grouped = false
		@JvmField var thread = false
		@JvmField var channel: InputChannel? = null
		@JvmField var id = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLExportedMessageLink? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLExportedMessageLink.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (grouped) flags or 1 else flags and 1.inv()
			flags = if (thread) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			channel?.serializeToStream(stream)
			stream.writeInt32(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe63fadebu.toInt()
		}
	}
	
	open class TLMessageFwdHeader: TLObject() {
		@JvmField var flags = 0
		@JvmField var imported = false
		@JvmField var fromId: Peer? = null
		@JvmField var fromName: String? = null
		@JvmField var date = 0
		@JvmField var channelPost = 0
		@JvmField var postAuthor: String? = null
		@JvmField var savedFromPeer: Peer? = null
		@JvmField var savedFromMsgId = 0
		@JvmField var psaType: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			imported = (flags and 128) != 0
		
			if ((flags and 1) != 0) {
				fromId = Peer.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 32) != 0) {
				fromName = stream.readString(exception) ?: return
			}
			date = stream.readInt32(exception)
		
			if ((flags and 4) != 0) {
				channelPost = stream.readInt32(exception)
			}
		
			if ((flags and 8) != 0) {
				postAuthor = stream.readString(exception) ?: return
			}
		
			if ((flags and 16) != 0) {
				savedFromPeer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 16) != 0) {
				savedFromMsgId = stream.readInt32(exception)
			}
		
			if ((flags and 64) != 0) {
				psaType = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (imported) flags or 128 else flags and 128.inv()
			flags = if (fromId != null) flags or 1 else flags and 1.inv()
			flags = if (fromName != null) flags or 32 else flags and 32.inv()
			flags = if (channelPost != 0) flags or 4 else flags and 4.inv()
			flags = if (postAuthor != null) flags or 8 else flags and 8.inv()
			flags = if (savedFromPeer != null) flags or 16 else flags and 16.inv()
			flags = if (savedFromMsgId != 0) flags or 16 else flags and 16.inv()
			flags = if (psaType != null) flags or 64 else flags and 64.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				fromId?.serializeToStream(stream)
			}
	
			if ((flags and 32) != 0) {
				stream.writeString(fromName)
			}
	
			stream.writeInt32(date)
			if ((flags and 4) != 0) {
				stream.writeInt32(channelPost)
			}
	
			if ((flags and 8) != 0) {
				stream.writeString(postAuthor)
			}
	
			if ((flags and 16) != 0) {
				savedFromPeer?.serializeToStream(stream)
			}
	
			if ((flags and 16) != 0) {
				stream.writeInt32(savedFromMsgId)
			}
	
			if ((flags and 64) != 0) {
				stream.writeString(psaType)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x5f777dceu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessageFwdHeader? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessageFwdHeader")
					}
					else {
						null
					}
				}
	
				val result = TLMessageFwdHeader()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class AuthCodeType: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthCodeType? {
				val result = when (constructor) {
					TLAuthCodeTypeSms.CONSTRUCTOR -> TLAuthCodeTypeSms()
					TLAuthCodeTypeCall.CONSTRUCTOR -> TLAuthCodeTypeCall()
					TLAuthCodeTypeFlashCall.CONSTRUCTOR -> TLAuthCodeTypeFlashCall()
					TLAuthCodeTypeMissedCall.CONSTRUCTOR -> TLAuthCodeTypeMissedCall()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in AuthCodeType")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLAuthCodeTypeSms: AuthCodeType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x72a3158cu.toInt()
		}
	}
	
	open class TLAuthCodeTypeCall: AuthCodeType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x741cd3e3u.toInt()
		}
	}
	
	open class TLAuthCodeTypeFlashCall: AuthCodeType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x226ccefbu.toInt()
		}
	}
	
	open class TLAuthCodeTypeMissedCall: AuthCodeType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd61ad6eeu.toInt()
		}
	}
	
	abstract class AuthSentCodeType: TLObject() {
		@JvmField var length = 0
		@JvmField var flags = 0
		@JvmField var appleSigninAllowed = false
		@JvmField var googleSigninAllowed = false
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthSentCodeType? {
				val result = when (constructor) {
					TLAuthSentCodeTypeApp.CONSTRUCTOR -> TLAuthSentCodeTypeApp()
					TLAuthSentCodeTypeSms.CONSTRUCTOR -> TLAuthSentCodeTypeSms()
					TLAuthSentCodeTypeCall.CONSTRUCTOR -> TLAuthSentCodeTypeCall()
					TLAuthSentCodeTypeFlashCall.CONSTRUCTOR -> TLAuthSentCodeTypeFlashCall()
					TLAuthSentCodeTypeMissedCall.CONSTRUCTOR -> TLAuthSentCodeTypeMissedCall()
					TLAuthSentCodeTypeEmailCode.CONSTRUCTOR -> TLAuthSentCodeTypeEmailCode()
					TLAuthSentCodeTypeSetUpEmailRequired.CONSTRUCTOR -> TLAuthSentCodeTypeSetUpEmailRequired()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in AuthSentCodeType")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLAuthSentCodeTypeApp: AuthSentCodeType() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3dbb5986u.toInt()
		}
	}
	
	open class TLAuthSentCodeTypeSms: AuthSentCodeType() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc000bba2u.toInt()
		}
	}
	
	open class TLAuthSentCodeTypeCall: AuthSentCodeType() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5353e5a7u.toInt()
		}
	}
	
	open class TLAuthSentCodeTypeFlashCall: AuthSentCodeType() {
		@JvmField var pattern: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			pattern = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(pattern)
		}
	
		companion object {
			val CONSTRUCTOR = 0xab03c6d9u.toInt()
		}
	}
	
	open class TLAuthSentCodeTypeMissedCall: AuthSentCodeType() {
		@JvmField var prefix: String? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			prefix = stream.readString(exception) ?: return
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(prefix)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0x82006484u.toInt()
		}
	}
	
	open class TLAuthSentCodeTypeEmailCode: AuthSentCodeType() {
					@JvmField var emailPattern: String? = null
			@JvmField var nextPhoneLoginDate = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			appleSigninAllowed = (flags and 1) != 0
			googleSigninAllowed = (flags and 2) != 0
			emailPattern = stream.readString(exception) ?: return
			length = stream.readInt32(exception)
		
			if ((flags and 4) != 0) {
				nextPhoneLoginDate = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (appleSigninAllowed) flags or 1 else flags and 1.inv()
			flags = if (googleSigninAllowed) flags or 2 else flags and 2.inv()
			flags = if (nextPhoneLoginDate != 0) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeString(emailPattern)
			stream.writeInt32(length)
			if ((flags and 4) != 0) {
				stream.writeInt32(nextPhoneLoginDate)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x5a159841u.toInt()
		}
	}
	
	open class TLAuthSentCodeTypeSetUpEmailRequired: AuthSentCodeType() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			appleSigninAllowed = (flags and 1) != 0
			googleSigninAllowed = (flags and 2) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (appleSigninAllowed) flags or 1 else flags and 1.inv()
			flags = if (googleSigninAllowed) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa5491deau.toInt()
		}
	}
	
	open class TLMessagesBotCallbackAnswer: TLObject() {
		@JvmField var flags = 0
		@JvmField var alert = false
		@JvmField var hasUrl = false
		@JvmField var nativeUi = false
		@JvmField var message: String? = null
		@JvmField var url: String? = null
		@JvmField var cacheTime = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			alert = (flags and 2) != 0
			hasUrl = (flags and 8) != 0
			nativeUi = (flags and 16) != 0
		
			if ((flags and 1) != 0) {
				message = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				url = stream.readString(exception) ?: return
			}
			cacheTime = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (alert) flags or 2 else flags and 2.inv()
			flags = if (hasUrl) flags or 8 else flags and 8.inv()
			flags = if (nativeUi) flags or 16 else flags and 16.inv()
			flags = if (message != null) flags or 1 else flags and 1.inv()
			flags = if (url != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeString(message)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(url)
			}
	
			stream.writeInt32(cacheTime)
		}
	
		companion object {
			val CONSTRUCTOR = 0x36585ea4u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesBotCallbackAnswer? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesBotCallbackAnswer")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesBotCallbackAnswer()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetBotCallbackAnswer: TLObject() {
		@JvmField var flags = 0
		@JvmField var game = false
		@JvmField var peer: InputPeer? = null
		@JvmField var msgId = 0
		@JvmField var data: ByteArray? = null
		@JvmField var password: InputCheckPasswordSRP? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesBotCallbackAnswer? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesBotCallbackAnswer.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (game) flags or 2 else flags and 2.inv()
			flags = if (data != null) flags or 1 else flags and 1.inv()
			flags = if (password != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
			if ((flags and 1) != 0) {
				stream.writeByteArray(data)
			}
	
			if ((flags and 4) != 0) {
				password?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9342ca07u.toInt()
		}
	}
	
	open class TLMessagesMessageEditData: TLObject() {
		@JvmField var flags = 0
		@JvmField var caption = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			caption = (flags and 1) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (caption) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0x26b5dde6u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesMessageEditData? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesMessageEditData")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesMessageEditData()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetMessageEditData: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var id = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesMessageEditData? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesMessageEditData.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfda68d36u.toInt()
		}
	}
	
	abstract class InputBotInlineMessageID: TLObject() {
		@JvmField var dcId = 0
		@JvmField var accessHash = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputBotInlineMessageID? {
				val result = when (constructor) {
					TLInputBotInlineMessageID.CONSTRUCTOR -> TLInputBotInlineMessageID()
					TLInputBotInlineMessageID64.CONSTRUCTOR -> TLInputBotInlineMessageID64()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputBotInlineMessageID")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputBotInlineMessageID: InputBotInlineMessageID() {
			@JvmField var id = 0L
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			dcId = stream.readInt32(exception)
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(dcId)
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x890c3d89u.toInt()
		}
	}
	
	open class TLInputBotInlineMessageID64: InputBotInlineMessageID() {
			@JvmField var ownerId = 0L
		@JvmField var id = 0
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			dcId = stream.readInt32(exception)
			ownerId = stream.readInt64(exception)
			id = stream.readInt32(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(dcId)
			stream.writeInt64(ownerId)
			stream.writeInt32(id)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb6d915d7u.toInt()
		}
	}
	
	open class TLInlineBotSwitchPM: TLObject() {
		@JvmField var text: String? = null
		@JvmField var startParam: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = stream.readString(exception) ?: return
			startParam = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(text)
			stream.writeString(startParam)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3c20629fu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLInlineBotSwitchPM? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLInlineBotSwitchPM")
					}
					else {
						null
					}
				}
	
				val result = TLInlineBotSwitchPM()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesPeerDialogs: TLObject() {
		@JvmField val dialogs = mutableListOf<Dialog>()
		@JvmField val messages = mutableListOf<Message>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
		@JvmField var state: TLUpdatesState? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Dialog.deserialize(stream, stream.readInt32(exception), exception) ?: return
				dialogs.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Message.deserialize(stream, stream.readInt32(exception), exception) ?: return
				messages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
			state = TLUpdatesState.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(dialogs.size)
			dialogs.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
			state?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3371c354u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesPeerDialogs? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesPeerDialogs")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesPeerDialogs()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetPeerDialogs: TLObject() {
		@JvmField val peers = mutableListOf<InputDialogPeer>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesPeerDialogs? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesPeerDialogs.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(peers.size)
			peers.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xe470bcfdu.toInt()
		}
	}
	
	open class TLMessagesGetPinnedDialogs: TLObject() {
		@JvmField var folderId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesPeerDialogs? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesPeerDialogs.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(folderId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd6b94df2u.toInt()
		}
	}
	
	open class TLTopPeer: TLObject() {
		@JvmField var peer: Peer? = null
		@JvmField var rating = 0.0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			rating = stream.readDouble(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeDouble(rating)
		}
	
		companion object {
			val CONSTRUCTOR = 0xedcdc05bu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLTopPeer? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLTopPeer")
					}
					else {
						null
					}
				}
	
				val result = TLTopPeer()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class TopPeerCategory: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TopPeerCategory? {
				val result = when (constructor) {
					TLTopPeerCategoryBotsPM.CONSTRUCTOR -> TLTopPeerCategoryBotsPM()
					TLTopPeerCategoryBotsInline.CONSTRUCTOR -> TLTopPeerCategoryBotsInline()
					TLTopPeerCategoryCorrespondents.CONSTRUCTOR -> TLTopPeerCategoryCorrespondents()
					TLTopPeerCategoryGroups.CONSTRUCTOR -> TLTopPeerCategoryGroups()
					TLTopPeerCategoryChannels.CONSTRUCTOR -> TLTopPeerCategoryChannels()
					TLTopPeerCategoryPhoneCalls.CONSTRUCTOR -> TLTopPeerCategoryPhoneCalls()
					TLTopPeerCategoryForwardUsers.CONSTRUCTOR -> TLTopPeerCategoryForwardUsers()
					TLTopPeerCategoryForwardChats.CONSTRUCTOR -> TLTopPeerCategoryForwardChats()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in TopPeerCategory")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLTopPeerCategoryBotsPM: TopPeerCategory() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xab661b5bu.toInt()
		}
	}
	
	open class TLTopPeerCategoryBotsInline: TopPeerCategory() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x148677e2u.toInt()
		}
	}
	
	open class TLTopPeerCategoryCorrespondents: TopPeerCategory() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x637b7edu.toInt()
		}
	}
	
	open class TLTopPeerCategoryGroups: TopPeerCategory() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xbd17a14au.toInt()
		}
	}
	
	open class TLTopPeerCategoryChannels: TopPeerCategory() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x161d9628u.toInt()
		}
	}
	
	open class TLTopPeerCategoryPhoneCalls: TopPeerCategory() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1e76a78cu.toInt()
		}
	}
	
	open class TLTopPeerCategoryForwardUsers: TopPeerCategory() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa8406ca9u.toInt()
		}
	}
	
	open class TLTopPeerCategoryForwardChats: TopPeerCategory() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xfbeec0f0u.toInt()
		}
	}
	
	open class TLTopPeerCategoryPeers: TLObject() {
		@JvmField var category: TopPeerCategory? = null
		@JvmField var count = 0
		@JvmField val peers = mutableListOf<TLTopPeer>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			category = TopPeerCategory.deserialize(stream, stream.readInt32(exception), exception)
			count = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLTopPeer.deserialize(stream, stream.readInt32(exception), exception) ?: return
				peers.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			category?.serializeToStream(stream)
			stream.writeInt32(count)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(peers.size)
			peers.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xfb834291u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLTopPeerCategoryPeers? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLTopPeerCategoryPeers")
					}
					else {
						null
					}
				}
	
				val result = TLTopPeerCategoryPeers()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class ContactsTopPeers: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ContactsTopPeers? {
				val result = when (constructor) {
					TLContactsTopPeersNotModified.CONSTRUCTOR -> TLContactsTopPeersNotModified()
					TLContactsTopPeers.CONSTRUCTOR -> TLContactsTopPeers()
					TLContactsTopPeersDisabled.CONSTRUCTOR -> TLContactsTopPeersDisabled()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ContactsTopPeers")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLContactsTopPeersNotModified: ContactsTopPeers() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xde266ef5u.toInt()
		}
	}
	
	open class TLContactsTopPeers: ContactsTopPeers() {
		@JvmField val categories = mutableListOf<TLTopPeerCategoryPeers>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLTopPeerCategoryPeers.deserialize(stream, stream.readInt32(exception), exception) ?: return
				categories.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(categories.size)
			categories.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x70b772a8u.toInt()
		}
	}
	
	open class TLContactsTopPeersDisabled: ContactsTopPeers() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb52c939du.toInt()
		}
	}
	
	open class TLContactsGetTopPeers: TLObject() {
		@JvmField var flags = 0
		@JvmField var correspondents = false
		@JvmField var botsPm = false
		@JvmField var botsInline = false
		@JvmField var phoneCalls = false
		@JvmField var forwardUsers = false
		@JvmField var forwardChats = false
		@JvmField var groups = false
		@JvmField var channels = false
		@JvmField var offset = 0
		@JvmField var limit = 0
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ContactsTopPeers? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return ContactsTopPeers.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (correspondents) flags or 1 else flags and 1.inv()
			flags = if (botsPm) flags or 2 else flags and 2.inv()
			flags = if (botsInline) flags or 4 else flags and 4.inv()
			flags = if (phoneCalls) flags or 8 else flags and 8.inv()
			flags = if (forwardUsers) flags or 16 else flags and 16.inv()
			flags = if (forwardChats) flags or 32 else flags and 32.inv()
			flags = if (groups) flags or 1024 else flags and 1024.inv()
			flags = if (channels) flags or 32768 else flags and 32768.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(offset)
			stream.writeInt32(limit)
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x973478b6u.toInt()
		}
	}
	
	abstract class DraftMessage: TLObject() {
		@JvmField var flags = 0
		@JvmField var date = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): DraftMessage? {
				val result = when (constructor) {
					TLDraftMessageEmpty.CONSTRUCTOR -> TLDraftMessageEmpty()
					TLDraftMessage.CONSTRUCTOR -> TLDraftMessage()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in DraftMessage")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLDraftMessageEmpty: DraftMessage() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				date = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (date != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeInt32(date)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1b0c841au.toInt()
		}
	}
	
	open class TLDraftMessage: DraftMessage() {
			@JvmField var noWebpage = false
		@JvmField var replyToMsgId = 0
		@JvmField var message: String? = null
		@JvmField val entities = mutableListOf<MessageEntity>()
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			noWebpage = (flags and 2) != 0
		
			if ((flags and 1) != 0) {
				replyToMsgId = stream.readInt32(exception)
			}
			message = stream.readString(exception) ?: return
		
			if ((flags and 8) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
					entities.add(obj)
				}
			}
			date = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (noWebpage) flags or 2 else flags and 2.inv()
			flags = if (replyToMsgId != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeInt32(replyToMsgId)
			}
	
			stream.writeString(message)
			if ((flags and 8) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
			stream.writeInt32(date)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfd8e711fu.toInt()
		}
	}
	
	abstract class MessagesFeaturedStickers: TLObject() {
		@JvmField var count = 0
		@JvmField var hash = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesFeaturedStickers? {
				val result = when (constructor) {
					TLMessagesFeaturedStickersNotModified.CONSTRUCTOR -> TLMessagesFeaturedStickersNotModified()
					TLMessagesFeaturedStickers.CONSTRUCTOR -> TLMessagesFeaturedStickers()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesFeaturedStickers")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesFeaturedStickersNotModified: MessagesFeaturedStickers() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			count = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(count)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc6dc0c66u.toInt()
		}
	}
	
	open class TLMessagesFeaturedStickers: MessagesFeaturedStickers() {
		@JvmField var flags = 0
		@JvmField var premium = false
				@JvmField val sets = mutableListOf<StickerSetCovered>()
		@JvmField val unread = mutableListOf<Long>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			premium = (flags and 1) != 0
			hash = stream.readInt64(exception)
			count = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = StickerSetCovered.deserialize(stream, stream.readInt32(exception), exception) ?: return
				sets.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				unread.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (premium) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(hash)
			stream.writeInt32(count)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(sets.size)
			sets.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(unread.size)
			unread.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xbe382906u.toInt()
		}
	}
	
	open class TLMessagesGetFeaturedStickers: TLObject() {
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesFeaturedStickers? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesFeaturedStickers.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x64780b14u.toInt()
		}
	}
	
	open class TLMessagesGetOldFeaturedStickers: TLObject() {
		@JvmField var offset = 0
		@JvmField var limit = 0
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesFeaturedStickers? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesFeaturedStickers.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(offset)
			stream.writeInt32(limit)
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7ed094a1u.toInt()
		}
	}
	
	open class TLMessagesGetFeaturedEmojiStickers: TLObject() {
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesFeaturedStickers? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesFeaturedStickers.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xecf6736u.toInt()
		}
	}
	
	abstract class MessagesRecentStickers: TLObject() {
		@JvmField var hash = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesRecentStickers? {
				val result = when (constructor) {
					TLMessagesRecentStickersNotModified.CONSTRUCTOR -> TLMessagesRecentStickersNotModified()
					TLMessagesRecentStickers.CONSTRUCTOR -> TLMessagesRecentStickers()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesRecentStickers")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesRecentStickersNotModified: MessagesRecentStickers() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb17f890u.toInt()
		}
	}
	
	open class TLMessagesRecentStickers: MessagesRecentStickers() {
			@JvmField val packs = mutableListOf<TLStickerPack>()
		@JvmField val stickers = mutableListOf<Document>()
		@JvmField val dates = mutableListOf<Int>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			hash = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLStickerPack.deserialize(stream, stream.readInt32(exception), exception) ?: return
				packs.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Document.deserialize(stream, stream.readInt32(exception), exception) ?: return
				stickers.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt32(exception)
				dates.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(packs.size)
			packs.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(stickers.size)
			stickers.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(dates.size)
			dates.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x88d37c56u.toInt()
		}
	}
	
	open class TLMessagesGetRecentStickers: TLObject() {
		@JvmField var flags = 0
		@JvmField var attached = false
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesRecentStickers? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesRecentStickers.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (attached) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9da9403bu.toInt()
		}
	}
	
	open class TLMessagesArchivedStickers: TLObject() {
		@JvmField var count = 0
		@JvmField val sets = mutableListOf<StickerSetCovered>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			count = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = StickerSetCovered.deserialize(stream, stream.readInt32(exception), exception) ?: return
				sets.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(count)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(sets.size)
			sets.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x4fcba9c8u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesArchivedStickers? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesArchivedStickers")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesArchivedStickers()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetArchivedStickers: TLObject() {
		@JvmField var flags = 0
		@JvmField var masks = false
		@JvmField var emojis = false
		@JvmField var offsetId = 0L
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesArchivedStickers? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesArchivedStickers.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (masks) flags or 1 else flags and 1.inv()
			flags = if (emojis) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(offsetId)
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0x57f17692u.toInt()
		}
	}
	
	abstract class MessagesStickerSetInstallResult: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesStickerSetInstallResult? {
				val result = when (constructor) {
					TLMessagesStickerSetInstallResultSuccess.CONSTRUCTOR -> TLMessagesStickerSetInstallResultSuccess()
					TLMessagesStickerSetInstallResultArchive.CONSTRUCTOR -> TLMessagesStickerSetInstallResultArchive()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesStickerSetInstallResult")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesStickerSetInstallResultSuccess: MessagesStickerSetInstallResult() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x38641628u.toInt()
		}
	}
	
	open class TLMessagesStickerSetInstallResultArchive: MessagesStickerSetInstallResult() {
		@JvmField val sets = mutableListOf<StickerSetCovered>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = StickerSetCovered.deserialize(stream, stream.readInt32(exception), exception) ?: return
				sets.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(sets.size)
			sets.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x35e410a8u.toInt()
		}
	}
	
	open class TLMessagesInstallStickerSet: TLObject() {
		@JvmField var stickerset: InputStickerSet? = null
		@JvmField var archived = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesStickerSetInstallResult? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesStickerSetInstallResult.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stickerset?.serializeToStream(stream)
			stream.writeBool(archived)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc78fe460u.toInt()
		}
	}
	
	abstract class StickerSetCovered: TLObject() {
		@JvmField var set: TLStickerSet? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): StickerSetCovered? {
				val result = when (constructor) {
					TLStickerSetCovered.CONSTRUCTOR -> TLStickerSetCovered()
					TLStickerSetMultiCovered.CONSTRUCTOR -> TLStickerSetMultiCovered()
					TLStickerSetFullCovered.CONSTRUCTOR -> TLStickerSetFullCovered()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in StickerSetCovered")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLStickerSetCovered: StickerSetCovered() {
			@JvmField var cover: Document? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			set = TLStickerSet.deserialize(stream, stream.readInt32(exception), exception)
			cover = Document.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			set?.serializeToStream(stream)
			cover?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6410a5d2u.toInt()
		}
	}
	
	open class TLStickerSetMultiCovered: StickerSetCovered() {
			@JvmField val covers = mutableListOf<Document>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			set = TLStickerSet.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Document.deserialize(stream, stream.readInt32(exception), exception) ?: return
				covers.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			set?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(covers.size)
			covers.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x3407e51bu.toInt()
		}
	}
	
	open class TLStickerSetFullCovered: StickerSetCovered() {
			@JvmField val packs = mutableListOf<TLStickerPack>()
		@JvmField val keywords = mutableListOf<TLStickerKeyword>()
		@JvmField val documents = mutableListOf<Document>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			set = TLStickerSet.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLStickerPack.deserialize(stream, stream.readInt32(exception), exception) ?: return
				packs.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLStickerKeyword.deserialize(stream, stream.readInt32(exception), exception) ?: return
				keywords.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Document.deserialize(stream, stream.readInt32(exception), exception) ?: return
				documents.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			set?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(packs.size)
			packs.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(keywords.size)
			keywords.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(documents.size)
			documents.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x40d13c0eu.toInt()
		}
	}
	
	open class TLMaskCoords: TLObject() {
		@JvmField var n = 0
		@JvmField var x = 0.0
		@JvmField var y = 0.0
		@JvmField var zoom = 0.0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			n = stream.readInt32(exception)
			x = stream.readDouble(exception)
			y = stream.readDouble(exception)
			zoom = stream.readDouble(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(n)
			stream.writeDouble(x)
			stream.writeDouble(y)
			stream.writeDouble(zoom)
		}
	
		companion object {
			val CONSTRUCTOR = 0xaed6dbb2u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMaskCoords? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMaskCoords")
					}
					else {
						null
					}
				}
	
				val result = TLMaskCoords()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class InputStickeredMedia: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputStickeredMedia? {
				val result = when (constructor) {
					TLInputStickeredMediaPhoto.CONSTRUCTOR -> TLInputStickeredMediaPhoto()
					TLInputStickeredMediaDocument.CONSTRUCTOR -> TLInputStickeredMediaDocument()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputStickeredMedia")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputStickeredMediaPhoto: InputStickeredMedia() {
		@JvmField var id: InputPhoto? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = InputPhoto.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			id?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4a992157u.toInt()
		}
	}
	
	open class TLInputStickeredMediaDocument: InputStickeredMedia() {
		@JvmField var id: InputDocument? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = InputDocument.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			id?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x438865bu.toInt()
		}
	}
	
	open class TLGame: TLObject() {
		@JvmField var flags = 0
		@JvmField var id = 0L
		@JvmField var accessHash = 0L
		@JvmField var shortName: String? = null
		@JvmField var title: String? = null
		@JvmField var description: String? = null
		@JvmField var photo: Photo? = null
		@JvmField var document: Document? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			shortName = stream.readString(exception) ?: return
			title = stream.readString(exception) ?: return
			description = stream.readString(exception) ?: return
			photo = Photo.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				document = Document.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (document != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeString(shortName)
			stream.writeString(title)
			stream.writeString(description)
			photo?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				document?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xbdf9653bu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLGame? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLGame")
					}
					else {
						null
					}
				}
	
				val result = TLGame()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class InputGame: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputGame? {
				val result = when (constructor) {
					TLInputGameID.CONSTRUCTOR -> TLInputGameID()
					TLInputGameShortName.CONSTRUCTOR -> TLInputGameShortName()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputGame")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputGameID: InputGame() {
		@JvmField var id = 0L
		@JvmField var accessHash = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x32c3e77u.toInt()
		}
	}
	
	open class TLInputGameShortName: InputGame() {
		@JvmField var botId: InputUser? = null
		@JvmField var shortName: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			botId = InputUser.deserialize(stream, stream.readInt32(exception), exception)
			shortName = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			botId?.serializeToStream(stream)
			stream.writeString(shortName)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc331e80au.toInt()
		}
	}
	
	open class TLHighScore: TLObject() {
		@JvmField var pos = 0
		@JvmField var userId = 0L
		@JvmField var score = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			pos = stream.readInt32(exception)
			userId = stream.readInt64(exception)
			score = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(pos)
			stream.writeInt64(userId)
			stream.writeInt32(score)
		}
	
		companion object {
			val CONSTRUCTOR = 0x73a379ebu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLHighScore? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLHighScore")
					}
					else {
						null
					}
				}
	
				val result = TLHighScore()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesHighScores: TLObject() {
		@JvmField val scores = mutableListOf<TLHighScore>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLHighScore.deserialize(stream, stream.readInt32(exception), exception) ?: return
				scores.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(scores.size)
			scores.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x9a3bfd99u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesHighScores? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesHighScores")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesHighScores()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetGameHighScores: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var id = 0
		@JvmField var userId: InputUser? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesHighScores? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesHighScores.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(id)
			userId?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe822649du.toInt()
		}
	}
	
	open class TLMessagesGetInlineGameHighScores: TLObject() {
		@JvmField var id: InputBotInlineMessageID? = null
		@JvmField var userId: InputUser? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesHighScores? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesHighScores.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			id?.serializeToStream(stream)
			userId?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf635e1bu.toInt()
		}
	}
	
	abstract class RichText: TLObject() {
		@JvmField var parentRichText: RichText? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): RichText? {
				val result = when (constructor) {
					TLTextEmpty.CONSTRUCTOR -> TLTextEmpty()
					TLTextPlain.CONSTRUCTOR -> TLTextPlain()
					TLTextBold.CONSTRUCTOR -> TLTextBold()
					TLTextItalic.CONSTRUCTOR -> TLTextItalic()
					TLTextUnderline.CONSTRUCTOR -> TLTextUnderline()
					TLTextStrike.CONSTRUCTOR -> TLTextStrike()
					TLTextFixed.CONSTRUCTOR -> TLTextFixed()
					TLTextUrl.CONSTRUCTOR -> TLTextUrl()
					TLTextEmail.CONSTRUCTOR -> TLTextEmail()
					TLTextConcat.CONSTRUCTOR -> TLTextConcat()
					TLTextSubscript.CONSTRUCTOR -> TLTextSubscript()
					TLTextSuperscript.CONSTRUCTOR -> TLTextSuperscript()
					TLTextMarked.CONSTRUCTOR -> TLTextMarked()
					TLTextPhone.CONSTRUCTOR -> TLTextPhone()
					TLTextImage.CONSTRUCTOR -> TLTextImage()
					TLTextAnchor.CONSTRUCTOR -> TLTextAnchor()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in RichText")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLTextEmpty: RichText() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xdc3d824fu.toInt()
		}
	}
	
	open class TLTextPlain: RichText() {
		@JvmField var text: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0x744694e0u.toInt()
		}
	}
	
	open class TLTextBold: RichText() {
		@JvmField var text: RichText? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6724abc4u.toInt()
		}
	}
	
	open class TLTextItalic: RichText() {
		@JvmField var text: RichText? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd912a59cu.toInt()
		}
	}
	
	open class TLTextUnderline: RichText() {
		@JvmField var text: RichText? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc12622c4u.toInt()
		}
	}
	
	open class TLTextStrike: RichText() {
		@JvmField var text: RichText? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9bf8bb95u.toInt()
		}
	}
	
	open class TLTextFixed: RichText() {
		@JvmField var text: RichText? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6c3f19b9u.toInt()
		}
	}
	
	open class TLTextUrl: RichText() {
		@JvmField var text: RichText? = null
		@JvmField var url: String? = null
		@JvmField var webpageId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
			url = stream.readString(exception) ?: return
			webpageId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
			stream.writeString(url)
			stream.writeInt64(webpageId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3c2884c1u.toInt()
		}
	}
	
	open class TLTextEmail: RichText() {
		@JvmField var text: RichText? = null
		@JvmField var email: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
			email = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
			stream.writeString(email)
		}
	
		companion object {
			val CONSTRUCTOR = 0xde5a0dd6u.toInt()
		}
	}
	
	open class TLTextConcat: RichText() {
		@JvmField val texts = mutableListOf<RichText>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = RichText.deserialize(stream, stream.readInt32(exception), exception) ?: return
				texts.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(texts.size)
			texts.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x7e6260d7u.toInt()
		}
	}
	
	open class TLTextSubscript: RichText() {
		@JvmField var text: RichText? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xed6a8504u.toInt()
		}
	}
	
	open class TLTextSuperscript: RichText() {
		@JvmField var text: RichText? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc7fb5e01u.toInt()
		}
	}
	
	open class TLTextMarked: RichText() {
		@JvmField var text: RichText? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x34b8621u.toInt()
		}
	}
	
	open class TLTextPhone: RichText() {
		@JvmField var text: RichText? = null
		@JvmField var phone: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
			phone = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
			stream.writeString(phone)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1ccb966au.toInt()
		}
	}
	
	open class TLTextImage: RichText() {
		@JvmField var documentId = 0L
		@JvmField var w = 0
		@JvmField var h = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			documentId = stream.readInt64(exception)
			w = stream.readInt32(exception)
			h = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(documentId)
			stream.writeInt32(w)
			stream.writeInt32(h)
		}
	
		companion object {
			val CONSTRUCTOR = 0x81ccf4fu.toInt()
		}
	}
	
	open class TLTextAnchor: RichText() {
		@JvmField var text: RichText? = null
		@JvmField var name: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
			name = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
			stream.writeString(name)
		}
	
		companion object {
			val CONSTRUCTOR = 0x35553762u.toInt()
		}
	}
	
	abstract class PageBlock: TLObject() {
		@JvmField var text: RichText? = null
		@JvmField var url: String? = null
		@JvmField var flags = 0
		@JvmField val blocks = mutableListOf<PageBlock>()
		@JvmField var h = 0
		@JvmField var webpageId = 0L
		@JvmField var w = 0
		@JvmField var title: RichText? = null
		@JvmField var groupId: Int = 0
		@JvmField var thumb: PhotoSize? = null
		@JvmField var thumbObject: TLObject? = null
		@JvmField var first: Boolean = false
		@JvmField var mid: Int = 0
		@JvmField var level: Int = 0
		@JvmField var bottom: Boolean = false
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PageBlock? {
				val result = when (constructor) {
					TLPageBlockUnsupported.CONSTRUCTOR -> TLPageBlockUnsupported()
					TLPageBlockTitle.CONSTRUCTOR -> TLPageBlockTitle()
					TLPageBlockSubtitle.CONSTRUCTOR -> TLPageBlockSubtitle()
					TLPageBlockAuthorDate.CONSTRUCTOR -> TLPageBlockAuthorDate()
					TLPageBlockHeader.CONSTRUCTOR -> TLPageBlockHeader()
					TLPageBlockSubheader.CONSTRUCTOR -> TLPageBlockSubheader()
					TLPageBlockParagraph.CONSTRUCTOR -> TLPageBlockParagraph()
					TLPageBlockPreformatted.CONSTRUCTOR -> TLPageBlockPreformatted()
					TLPageBlockFooter.CONSTRUCTOR -> TLPageBlockFooter()
					TLPageBlockDivider.CONSTRUCTOR -> TLPageBlockDivider()
					TLPageBlockAnchor.CONSTRUCTOR -> TLPageBlockAnchor()
					TLPageBlockList.CONSTRUCTOR -> TLPageBlockList()
					TLPageBlockBlockquote.CONSTRUCTOR -> TLPageBlockBlockquote()
					TLPageBlockPullquote.CONSTRUCTOR -> TLPageBlockPullquote()
					TLPageBlockPhoto.CONSTRUCTOR -> TLPageBlockPhoto()
					TLPageBlockVideo.CONSTRUCTOR -> TLPageBlockVideo()
					TLPageBlockCover.CONSTRUCTOR -> TLPageBlockCover()
					TLPageBlockEmbed.CONSTRUCTOR -> TLPageBlockEmbed()
					TLPageBlockEmbedPost.CONSTRUCTOR -> TLPageBlockEmbedPost()
					TLPageBlockCollage.CONSTRUCTOR -> TLPageBlockCollage()
					TLPageBlockSlideshow.CONSTRUCTOR -> TLPageBlockSlideshow()
					TLPageBlockChannel.CONSTRUCTOR -> TLPageBlockChannel()
					TLPageBlockAudio.CONSTRUCTOR -> TLPageBlockAudio()
					TLPageBlockKicker.CONSTRUCTOR -> TLPageBlockKicker()
					TLPageBlockTable.CONSTRUCTOR -> TLPageBlockTable()
					TLPageBlockOrderedList.CONSTRUCTOR -> TLPageBlockOrderedList()
					TLPageBlockDetails.CONSTRUCTOR -> TLPageBlockDetails()
					TLPageBlockRelatedArticles.CONSTRUCTOR -> TLPageBlockRelatedArticles()
					TLPageBlockMap.CONSTRUCTOR -> TLPageBlockMap()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in PageBlock")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPageBlockUnsupported: PageBlock() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x13567e8au.toInt()
		}
	}
	
	open class TLPageBlockTitle: PageBlock() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x70abc3fdu.toInt()
		}
	}
	
	open class TLPageBlockSubtitle: PageBlock() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8ffa9a1fu.toInt()
		}
	}
	
	open class TLPageBlockAuthorDate: PageBlock() {
		@JvmField var author: RichText? = null
		@JvmField var publishedDate = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			author = RichText.deserialize(stream, stream.readInt32(exception), exception)
			publishedDate = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			author?.serializeToStream(stream)
			stream.writeInt32(publishedDate)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbaafe5e0u.toInt()
		}
	}
	
	open class TLPageBlockHeader: PageBlock() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbfd064ecu.toInt()
		}
	}
	
	open class TLPageBlockSubheader: PageBlock() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf12bb6e1u.toInt()
		}
	}
	
	open class TLPageBlockParagraph: PageBlock() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x467a0766u.toInt()
		}
	}
	
	open class TLPageBlockPreformatted: PageBlock() {
			@JvmField var language: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
			language = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
			stream.writeString(language)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc070d93eu.toInt()
		}
	}
	
	open class TLPageBlockFooter: PageBlock() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x48870999u.toInt()
		}
	}
	
	open class TLPageBlockDivider: PageBlock() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xdb20b188u.toInt()
		}
	}
	
	open class TLPageBlockAnchor: PageBlock() {
		@JvmField var name: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			name = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(name)
		}
	
		companion object {
			val CONSTRUCTOR = 0xce0d37b0u.toInt()
		}
	}
	
	open class TLPageBlockList: PageBlock() {
		@JvmField val items = mutableListOf<PageListItem>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = PageListItem.deserialize(stream, stream.readInt32(exception), exception) ?: return
				items.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(items.size)
			items.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xe4e88011u.toInt()
		}
	}
	
	open class TLPageBlockBlockquote: PageBlock() {
			@JvmField var caption: RichText? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
			caption = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
			caption?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x263d7c26u.toInt()
		}
	}
	
	open class TLPageBlockPullquote: PageBlock() {
			@JvmField var caption: RichText? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
			caption = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
			caption?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4f4456d3u.toInt()
		}
	}
	
	open class TLPageBlockPhoto: PageBlock() {
			@JvmField var photoId = 0L
		@JvmField var caption: TLPageCaption? = null
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			photoId = stream.readInt64(exception)
			caption = TLPageCaption.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				url = stream.readString(exception) ?: return
			}
		
			if ((flags and 1) != 0) {
				webpageId = stream.readInt64(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (url != null) flags or 1 else flags and 1.inv()
			flags = if (webpageId != 0L) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(photoId)
			caption?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeString(url)
			}
	
			if ((flags and 1) != 0) {
				stream.writeInt64(webpageId)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1759c560u.toInt()
		}
	}
	
	open class TLPageBlockVideo: PageBlock() {
			@JvmField var autoplay = false
		@JvmField var loop = false
		@JvmField var videoId = 0L
		@JvmField var caption: TLPageCaption? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			autoplay = (flags and 1) != 0
			loop = (flags and 2) != 0
			videoId = stream.readInt64(exception)
			caption = TLPageCaption.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (autoplay) flags or 1 else flags and 1.inv()
			flags = if (loop) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(videoId)
			caption?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7c8fe7b6u.toInt()
		}
	}
	
	open class TLPageBlockCover: PageBlock() {
		@JvmField var cover: PageBlock? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			cover = PageBlock.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			cover?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x39f23300u.toInt()
		}
	}
	
	open class TLPageBlockEmbed: PageBlock() {
			@JvmField var fullWidth = false
		@JvmField var allowScrolling = false
			@JvmField var html: String? = null
		@JvmField var posterPhotoId = 0L
				@JvmField var caption: TLPageCaption? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			fullWidth = (flags and 1) != 0
			allowScrolling = (flags and 8) != 0
		
			if ((flags and 2) != 0) {
				url = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				html = stream.readString(exception) ?: return
			}
		
			if ((flags and 16) != 0) {
				posterPhotoId = stream.readInt64(exception)
			}
		
			if ((flags and 32) != 0) {
				w = stream.readInt32(exception)
			}
		
			if ((flags and 32) != 0) {
				h = stream.readInt32(exception)
			}
			caption = TLPageCaption.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (fullWidth) flags or 1 else flags and 1.inv()
			flags = if (allowScrolling) flags or 8 else flags and 8.inv()
			flags = if (url != null) flags or 2 else flags and 2.inv()
			flags = if (html != null) flags or 4 else flags and 4.inv()
			flags = if (posterPhotoId != 0L) flags or 16 else flags and 16.inv()
			flags = if (w != 0) flags or 32 else flags and 32.inv()
			flags = if (h != 0) flags or 32 else flags and 32.inv()
	
			stream.writeInt32(flags)
			if ((flags and 2) != 0) {
				stream.writeString(url)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(html)
			}
	
			if ((flags and 16) != 0) {
				stream.writeInt64(posterPhotoId)
			}
	
			if ((flags and 32) != 0) {
				stream.writeInt32(w)
			}
	
			if ((flags and 32) != 0) {
				stream.writeInt32(h)
			}
	
			caption?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa8718dc5u.toInt()
		}
	}
	
	open class TLPageBlockEmbedPost: PageBlock() {
				@JvmField var authorPhotoId = 0L
		@JvmField var author: String? = null
		@JvmField var date = 0
			@JvmField var caption: TLPageCaption? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
			webpageId = stream.readInt64(exception)
			authorPhotoId = stream.readInt64(exception)
			author = stream.readString(exception) ?: return
			date = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = PageBlock.deserialize(stream, stream.readInt32(exception), exception) ?: return
				blocks.add(obj)
			}
			caption = TLPageCaption.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
			stream.writeInt64(webpageId)
			stream.writeInt64(authorPhotoId)
			stream.writeString(author)
			stream.writeInt32(date)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(blocks.size)
			blocks.forEach { it.serializeToStream(stream) }
			caption?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf259a80bu.toInt()
		}
	}
	
	open class TLPageBlockCollage: PageBlock() {
		@JvmField val items = mutableListOf<PageBlock>()
		@JvmField var caption: TLPageCaption? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = PageBlock.deserialize(stream, stream.readInt32(exception), exception) ?: return
				items.add(obj)
			}
			caption = TLPageCaption.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(items.size)
			items.forEach { it.serializeToStream(stream) }
			caption?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x65a0fa4du.toInt()
		}
	}
	
	open class TLPageBlockSlideshow: PageBlock() {
		@JvmField val items = mutableListOf<PageBlock>()
		@JvmField var caption: TLPageCaption? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = PageBlock.deserialize(stream, stream.readInt32(exception), exception) ?: return
				items.add(obj)
			}
			caption = TLPageCaption.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(items.size)
			items.forEach { it.serializeToStream(stream) }
			caption?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x31f9590u.toInt()
		}
	}
	
	open class TLPageBlockChannel: PageBlock() {
		@JvmField var channel: Chat? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			channel = Chat.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xef1751b5u.toInt()
		}
	}
	
	open class TLPageBlockAudio: PageBlock() {
		@JvmField var audioId = 0L
		@JvmField var caption: TLPageCaption? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			audioId = stream.readInt64(exception)
			caption = TLPageCaption.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(audioId)
			caption?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x804361eau.toInt()
		}
	}
	
	open class TLPageBlockKicker: PageBlock() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1e148390u.toInt()
		}
	}
	
	open class TLPageBlockTable: PageBlock() {
			@JvmField var bordered = false
		@JvmField var striped = false
			@JvmField val rows = mutableListOf<TLPageTableRow>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			bordered = (flags and 1) != 0
			striped = (flags and 2) != 0
			title = RichText.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLPageTableRow.deserialize(stream, stream.readInt32(exception), exception) ?: return
				rows.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (bordered) flags or 1 else flags and 1.inv()
			flags = if (striped) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			title?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(rows.size)
			rows.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xbf4dea82u.toInt()
		}
	}
	
	open class TLPageBlockOrderedList: PageBlock() {
		@JvmField val items = mutableListOf<PageListOrderedItem>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = PageListOrderedItem.deserialize(stream, stream.readInt32(exception), exception) ?: return
				items.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(items.size)
			items.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x9a8ae1e1u.toInt()
		}
	}
	
	open class TLPageBlockDetails: PageBlock() {
			@JvmField var open = false
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			open = (flags and 1) != 0
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = PageBlock.deserialize(stream, stream.readInt32(exception), exception) ?: return
				blocks.add(obj)
			}
			title = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (open) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(blocks.size)
			blocks.forEach { it.serializeToStream(stream) }
			title?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x76768bedu.toInt()
		}
	}
	
	open class TLPageBlockRelatedArticles: PageBlock() {
			@JvmField val articles = mutableListOf<TLPageRelatedArticle>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			title = RichText.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLPageRelatedArticle.deserialize(stream, stream.readInt32(exception), exception) ?: return
				articles.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			title?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(articles.size)
			articles.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x16115a96u.toInt()
		}
	}
	
	open class TLPageBlockMap: PageBlock() {
		@JvmField var geo: GeoPoint? = null
		@JvmField var zoom = 0
				@JvmField var caption: TLPageCaption? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			geo = GeoPoint.deserialize(stream, stream.readInt32(exception), exception)
			zoom = stream.readInt32(exception)
			w = stream.readInt32(exception)
			h = stream.readInt32(exception)
			caption = TLPageCaption.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			geo?.serializeToStream(stream)
			stream.writeInt32(zoom)
			stream.writeInt32(w)
			stream.writeInt32(h)
			caption?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa44f3ef6u.toInt()
		}
	}
	
	abstract class PhoneCallDiscardReason: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PhoneCallDiscardReason? {
				val result = when (constructor) {
					TLPhoneCallDiscardReasonMissed.CONSTRUCTOR -> TLPhoneCallDiscardReasonMissed()
					TLPhoneCallDiscardReasonDisconnect.CONSTRUCTOR -> TLPhoneCallDiscardReasonDisconnect()
					TLPhoneCallDiscardReasonHangup.CONSTRUCTOR -> TLPhoneCallDiscardReasonHangup()
					TLPhoneCallDiscardReasonBusy.CONSTRUCTOR -> TLPhoneCallDiscardReasonBusy()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in PhoneCallDiscardReason")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPhoneCallDiscardReasonMissed: PhoneCallDiscardReason() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x85e42301u.toInt()
		}
	}
	
	open class TLPhoneCallDiscardReasonDisconnect: PhoneCallDiscardReason() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe095c1a0u.toInt()
		}
	}
	
	open class TLPhoneCallDiscardReasonHangup: PhoneCallDiscardReason() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x57adc690u.toInt()
		}
	}
	
	open class TLPhoneCallDiscardReasonBusy: PhoneCallDiscardReason() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xfaf7e8c9u.toInt()
		}
	}
	
	open class TLDataJSON: TLObject() {
		@JvmField var data: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			data = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(data)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7d748d04u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLDataJSON? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLDataJSON")
					}
					else {
						null
					}
				}
	
				val result = TLDataJSON()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLBotsSendCustomRequest: TLObject() {
		@JvmField var customMethod: String? = null
		@JvmField var params: TLDataJSON? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLDataJSON? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLDataJSON.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(customMethod)
			params?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xaa2769edu.toInt()
		}
	}
	
	open class TLPhoneGetCallConfig: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLDataJSON? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLDataJSON.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x55451fa9u.toInt()
		}
	}
	
	open class TLLabeledPrice: TLObject() {
		@JvmField var label: String? = null
		@JvmField var amount = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			label = stream.readString(exception) ?: return
			amount = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(label)
			stream.writeInt64(amount)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcb296bf8u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLLabeledPrice? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLLabeledPrice")
					}
					else {
						null
					}
				}
	
				val result = TLLabeledPrice()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLInvoice: TLObject() {
		@JvmField var flags = 0
		@JvmField var test = false
		@JvmField var nameRequested = false
		@JvmField var phoneRequested = false
		@JvmField var emailRequested = false
		@JvmField var shippingAddressRequested = false
		@JvmField var flexible = false
		@JvmField var phoneToProvider = false
		@JvmField var emailToProvider = false
		@JvmField var recurring = false
		@JvmField var currency: String? = null
		@JvmField val prices = mutableListOf<TLLabeledPrice>()
		@JvmField var maxTipAmount = 0L
		@JvmField val suggestedTipAmounts = mutableListOf<Long>()
		@JvmField var recurringTermsUrl: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			test = (flags and 1) != 0
			nameRequested = (flags and 2) != 0
			phoneRequested = (flags and 4) != 0
			emailRequested = (flags and 8) != 0
			shippingAddressRequested = (flags and 16) != 0
			flexible = (flags and 32) != 0
			phoneToProvider = (flags and 64) != 0
			emailToProvider = (flags and 128) != 0
			recurring = (flags and 512) != 0
			currency = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLLabeledPrice.deserialize(stream, stream.readInt32(exception), exception) ?: return
				prices.add(obj)
			}
		
			if ((flags and 256) != 0) {
				maxTipAmount = stream.readInt64(exception)
			}
		
			if ((flags and 256) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = stream.readInt64(exception)
					suggestedTipAmounts.add(obj)
				}
			}
		
			if ((flags and 512) != 0) {
				recurringTermsUrl = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (test) flags or 1 else flags and 1.inv()
			flags = if (nameRequested) flags or 2 else flags and 2.inv()
			flags = if (phoneRequested) flags or 4 else flags and 4.inv()
			flags = if (emailRequested) flags or 8 else flags and 8.inv()
			flags = if (shippingAddressRequested) flags or 16 else flags and 16.inv()
			flags = if (flexible) flags or 32 else flags and 32.inv()
			flags = if (phoneToProvider) flags or 64 else flags and 64.inv()
			flags = if (emailToProvider) flags or 128 else flags and 128.inv()
			flags = if (recurring) flags or 512 else flags and 512.inv()
			flags = if (maxTipAmount != 0L) flags or 256 else flags and 256.inv()
			flags = if (recurringTermsUrl != null) flags or 512 else flags and 512.inv()
	
			stream.writeInt32(flags)
			stream.writeString(currency)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(prices.size)
			prices.forEach { it.serializeToStream(stream) }
			if ((flags and 256) != 0) {
				stream.writeInt64(maxTipAmount)
			}
	
			if ((flags and 256) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(suggestedTipAmounts.size)
			suggestedTipAmounts.forEach { stream.writeInt64(it) }
			}
	
			if ((flags and 512) != 0) {
				stream.writeString(recurringTermsUrl)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3e85a91bu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLInvoice? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLInvoice")
					}
					else {
						null
					}
				}
	
				val result = TLInvoice()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPaymentCharge: TLObject() {
		@JvmField var id: String? = null
		@JvmField var providerChargeId: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readString(exception) ?: return
			providerChargeId = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(id)
			stream.writeString(providerChargeId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xea02c27eu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPaymentCharge? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPaymentCharge")
					}
					else {
						null
					}
				}
	
				val result = TLPaymentCharge()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPostAddress: TLObject() {
		@JvmField var streetLine1: String? = null
		@JvmField var streetLine2: String? = null
		@JvmField var city: String? = null
		@JvmField var state: String? = null
		@JvmField var countryIso2: String? = null
		@JvmField var postCode: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			streetLine1 = stream.readString(exception) ?: return
			streetLine2 = stream.readString(exception) ?: return
			city = stream.readString(exception) ?: return
			state = stream.readString(exception) ?: return
			countryIso2 = stream.readString(exception) ?: return
			postCode = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(streetLine1)
			stream.writeString(streetLine2)
			stream.writeString(city)
			stream.writeString(state)
			stream.writeString(countryIso2)
			stream.writeString(postCode)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1e8caaebu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPostAddress? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPostAddress")
					}
					else {
						null
					}
				}
	
				val result = TLPostAddress()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPaymentRequestedInfo: TLObject() {
		@JvmField var flags = 0
		@JvmField var name: String? = null
		@JvmField var phone: String? = null
		@JvmField var email: String? = null
		@JvmField var shippingAddress: TLPostAddress? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				name = stream.readString(exception) ?: return
			}
		
			if ((flags and 2) != 0) {
				phone = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				email = stream.readString(exception) ?: return
			}
		
			if ((flags and 8) != 0) {
				shippingAddress = TLPostAddress.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (name != null) flags or 1 else flags and 1.inv()
			flags = if (phone != null) flags or 2 else flags and 2.inv()
			flags = if (email != null) flags or 4 else flags and 4.inv()
			flags = if (shippingAddress != null) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeString(name)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(phone)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(email)
			}
	
			if ((flags and 8) != 0) {
				shippingAddress?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x909c3f94u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPaymentRequestedInfo? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPaymentRequestedInfo")
					}
					else {
						null
					}
				}
	
				val result = TLPaymentRequestedInfo()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPaymentSavedCredentials: TLObject() {
		@JvmField var id: String? = null
		@JvmField var title: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readString(exception) ?: return
			title = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(id)
			stream.writeString(title)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcdc27a1fu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPaymentSavedCredentials? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPaymentSavedCredentials")
					}
					else {
						null
					}
				}
	
				val result = TLPaymentSavedCredentials()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class WebDocument: TLObject() {
		@JvmField var url: String? = null
		@JvmField val attributes = mutableListOf<DocumentAttribute>()
		@JvmField var size = 0
		@JvmField var mimeType: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): WebDocument? {
				val result = when (constructor) {
					TLWebDocument.CONSTRUCTOR -> TLWebDocument()
					TLWebDocumentNoProxy.CONSTRUCTOR -> TLWebDocumentNoProxy()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in WebDocument")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLWebDocument: WebDocument() {
			@JvmField var accessHash = 0L
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
			accessHash = stream.readInt64(exception)
			size = stream.readInt32(exception)
			mimeType = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = DocumentAttribute.deserialize(stream, stream.readInt32(exception), exception) ?: return
				attributes.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
			stream.writeInt64(accessHash)
			stream.writeInt32(size)
			stream.writeString(mimeType)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(attributes.size)
			attributes.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x1c570ed1u.toInt()
		}
	}
	
	open class TLWebDocumentNoProxy: WebDocument() {
					
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
			size = stream.readInt32(exception)
			mimeType = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = DocumentAttribute.deserialize(stream, stream.readInt32(exception), exception) ?: return
				attributes.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
			stream.writeInt32(size)
			stream.writeString(mimeType)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(attributes.size)
			attributes.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xf9c8bcc6u.toInt()
		}
	}
	
	open class TLInputWebDocument: TLObject() {
		@JvmField var url: String? = null
		@JvmField var size = 0
		@JvmField var mimeType: String? = null
		@JvmField val attributes = mutableListOf<DocumentAttribute>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
			size = stream.readInt32(exception)
			mimeType = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = DocumentAttribute.deserialize(stream, stream.readInt32(exception), exception) ?: return
				attributes.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
			stream.writeInt32(size)
			stream.writeString(mimeType)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(attributes.size)
			attributes.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x9bed434du.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLInputWebDocument? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLInputWebDocument")
					}
					else {
						null
					}
				}
	
				val result = TLInputWebDocument()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class InputWebFileLocation: TLObject() {
		@JvmField var accessHash = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputWebFileLocation? {
				val result = when (constructor) {
					TLInputWebFileLocation.CONSTRUCTOR -> TLInputWebFileLocation()
					TLInputWebFileGeoPointLocation.CONSTRUCTOR -> TLInputWebFileGeoPointLocation()
					TLInputWebFileAudioAlbumThumbLocation.CONSTRUCTOR -> TLInputWebFileAudioAlbumThumbLocation()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputWebFileLocation")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputWebFileLocation: InputWebFileLocation() {
		@JvmField var url: String? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc239d686u.toInt()
		}
	}
	
	open class TLInputWebFileGeoPointLocation: InputWebFileLocation() {
		@JvmField var geoPoint: InputGeoPoint? = null
			@JvmField var w = 0
		@JvmField var h = 0
		@JvmField var zoom = 0
		@JvmField var scale = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			geoPoint = InputGeoPoint.deserialize(stream, stream.readInt32(exception), exception)
			accessHash = stream.readInt64(exception)
			w = stream.readInt32(exception)
			h = stream.readInt32(exception)
			zoom = stream.readInt32(exception)
			scale = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			geoPoint?.serializeToStream(stream)
			stream.writeInt64(accessHash)
			stream.writeInt32(w)
			stream.writeInt32(h)
			stream.writeInt32(zoom)
			stream.writeInt32(scale)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9f2221c9u.toInt()
		}
	}
	
	open class TLInputWebFileAudioAlbumThumbLocation: InputWebFileLocation() {
		@JvmField var flags = 0
		@JvmField var small = false
		@JvmField var document: InputDocument? = null
		@JvmField var title: String? = null
		@JvmField var performer: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			small = (flags and 4) != 0
		
			if ((flags and 1) != 0) {
				document = InputDocument.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				title = stream.readString(exception) ?: return
			}
		
			if ((flags and 2) != 0) {
				performer = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (small) flags or 4 else flags and 4.inv()
			flags = if (document != null) flags or 1 else flags and 1.inv()
			flags = if (title != null) flags or 2 else flags and 2.inv()
			flags = if (performer != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				document?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(title)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(performer)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf46fe924u.toInt()
		}
	}
	
	open class TLUploadWebFile: TLObject() {
		@JvmField var size = 0
		@JvmField var mimeType: String? = null
		@JvmField var fileType: StorageFileType? = null
		@JvmField var mtime = 0
		@JvmField var bytes: NativeByteBuffer? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			size = stream.readInt32(exception)
			mimeType = stream.readString(exception) ?: return
			fileType = StorageFileType.deserialize(stream, stream.readInt32(exception), exception)
			mtime = stream.readInt32(exception)
			bytes = stream.readByteBuffer(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(size)
			stream.writeString(mimeType)
			fileType?.serializeToStream(stream)
			stream.writeInt32(mtime)
			stream.writeByteBuffer(bytes)
		}
	
		companion object {
			val CONSTRUCTOR = 0x21e753bcu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLUploadWebFile? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLUploadWebFile")
					}
					else {
						null
					}
				}
	
				val result = TLUploadWebFile()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLUploadGetWebFile: TLObject() {
		@JvmField var location: InputWebFileLocation? = null
		@JvmField var offset = 0
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLUploadWebFile? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLUploadWebFile.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			location?.serializeToStream(stream)
			stream.writeInt32(offset)
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0x24e6818du.toInt()
		}
	}
	
	open class TLPaymentsPaymentForm: TLObject() {
		@JvmField var flags = 0
		@JvmField var canSaveCredentials = false
		@JvmField var passwordMissing = false
		@JvmField var formId = 0L
		@JvmField var botId = 0L
		@JvmField var title: String? = null
		@JvmField var description: String? = null
		@JvmField var photo: WebDocument? = null
		@JvmField var invoice: TLInvoice? = null
		@JvmField var providerId = 0L
		@JvmField var url: String? = null
		@JvmField var nativeProvider: String? = null
		@JvmField var nativeParams: TLDataJSON? = null
		@JvmField val additionalMethods = mutableListOf<TLPaymentFormMethod>()
		@JvmField var savedInfo: TLPaymentRequestedInfo? = null
		@JvmField val savedCredentials = mutableListOf<TLPaymentSavedCredentials>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			canSaveCredentials = (flags and 4) != 0
			passwordMissing = (flags and 8) != 0
			formId = stream.readInt64(exception)
			botId = stream.readInt64(exception)
			title = stream.readString(exception) ?: return
			description = stream.readString(exception) ?: return
		
			if ((flags and 32) != 0) {
				photo = WebDocument.deserialize(stream, stream.readInt32(exception), exception)
			}
			invoice = TLInvoice.deserialize(stream, stream.readInt32(exception), exception)
			providerId = stream.readInt64(exception)
			url = stream.readString(exception) ?: return
		
			if ((flags and 16) != 0) {
				nativeProvider = stream.readString(exception) ?: return
			}
		
			if ((flags and 16) != 0) {
				nativeParams = TLDataJSON.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 64) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLPaymentFormMethod.deserialize(stream, stream.readInt32(exception), exception) ?: return
					additionalMethods.add(obj)
				}
			}
		
			if ((flags and 1) != 0) {
				savedInfo = TLPaymentRequestedInfo.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLPaymentSavedCredentials.deserialize(stream, stream.readInt32(exception), exception) ?: return
					savedCredentials.add(obj)
				}
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (canSaveCredentials) flags or 4 else flags and 4.inv()
			flags = if (passwordMissing) flags or 8 else flags and 8.inv()
			flags = if (photo != null) flags or 32 else flags and 32.inv()
			flags = if (nativeProvider != null) flags or 16 else flags and 16.inv()
			flags = if (nativeParams != null) flags or 16 else flags and 16.inv()
			flags = if (savedInfo != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(formId)
			stream.writeInt64(botId)
			stream.writeString(title)
			stream.writeString(description)
			if ((flags and 32) != 0) {
				photo?.serializeToStream(stream)
			}
	
			invoice?.serializeToStream(stream)
			stream.writeInt64(providerId)
			stream.writeString(url)
			if ((flags and 16) != 0) {
				stream.writeString(nativeProvider)
			}
	
			if ((flags and 16) != 0) {
				nativeParams?.serializeToStream(stream)
			}
	
			if ((flags and 64) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(additionalMethods.size)
			additionalMethods.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 1) != 0) {
				savedInfo?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(savedCredentials.size)
			savedCredentials.forEach { it.serializeToStream(stream) }
			}
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xa0058751u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPaymentsPaymentForm? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPaymentsPaymentForm")
					}
					else {
						null
					}
				}
	
				val result = TLPaymentsPaymentForm()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPaymentsValidatedRequestedInfo: TLObject() {
		@JvmField var flags = 0
		@JvmField var id: String? = null
		@JvmField val shippingOptions = mutableListOf<TLShippingOption>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				id = stream.readString(exception) ?: return
			}
		
			if ((flags and 2) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLShippingOption.deserialize(stream, stream.readInt32(exception), exception) ?: return
					shippingOptions.add(obj)
				}
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (id != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeString(id)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(shippingOptions.size)
			shippingOptions.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd1451883u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPaymentsValidatedRequestedInfo? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPaymentsValidatedRequestedInfo")
					}
					else {
						null
					}
				}
	
				val result = TLPaymentsValidatedRequestedInfo()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class PaymentsPaymentResult: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PaymentsPaymentResult? {
				val result = when (constructor) {
					TLPaymentsPaymentResult.CONSTRUCTOR -> TLPaymentsPaymentResult()
					TLPaymentsPaymentVerificationNeeded.CONSTRUCTOR -> TLPaymentsPaymentVerificationNeeded()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in PaymentsPaymentResult")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPaymentsPaymentResult: PaymentsPaymentResult() {
		@JvmField var updates: Updates? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			updates = Updates.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			updates?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4e5f810du.toInt()
		}
	}
	
	open class TLPaymentsPaymentVerificationNeeded: PaymentsPaymentResult() {
		@JvmField var url: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd8411139u.toInt()
		}
	}
	
	open class TLPaymentsPaymentReceipt: TLObject() {
		@JvmField var flags = 0
		@JvmField var date = 0
		@JvmField var botId = 0L
		@JvmField var providerId = 0L
		@JvmField var title: String? = null
		@JvmField var description: String? = null
		@JvmField var photo: WebDocument? = null
		@JvmField var invoice: TLInvoice? = null
		@JvmField var info: TLPaymentRequestedInfo? = null
		@JvmField var shipping: TLShippingOption? = null
		@JvmField var tipAmount = 0L
		@JvmField var currency: String? = null
		@JvmField var totalAmount = 0L
		@JvmField var credentialsTitle: String? = null
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			date = stream.readInt32(exception)
			botId = stream.readInt64(exception)
			providerId = stream.readInt64(exception)
			title = stream.readString(exception) ?: return
			description = stream.readString(exception) ?: return
		
			if ((flags and 4) != 0) {
				photo = WebDocument.deserialize(stream, stream.readInt32(exception), exception)
			}
			invoice = TLInvoice.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				info = TLPaymentRequestedInfo.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				shipping = TLShippingOption.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 8) != 0) {
				tipAmount = stream.readInt64(exception)
			}
			currency = stream.readString(exception) ?: return
			totalAmount = stream.readInt64(exception)
			credentialsTitle = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (photo != null) flags or 4 else flags and 4.inv()
			flags = if (info != null) flags or 1 else flags and 1.inv()
			flags = if (shipping != null) flags or 2 else flags and 2.inv()
			flags = if (tipAmount != 0L) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(date)
			stream.writeInt64(botId)
			stream.writeInt64(providerId)
			stream.writeString(title)
			stream.writeString(description)
			if ((flags and 4) != 0) {
				photo?.serializeToStream(stream)
			}
	
			invoice?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				info?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				shipping?.serializeToStream(stream)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt64(tipAmount)
			}
	
			stream.writeString(currency)
			stream.writeInt64(totalAmount)
			stream.writeString(credentialsTitle)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x70c4fe03u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPaymentsPaymentReceipt? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPaymentsPaymentReceipt")
					}
					else {
						null
					}
				}
	
				val result = TLPaymentsPaymentReceipt()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPaymentsSavedInfo: TLObject() {
		@JvmField var flags = 0
		@JvmField var hasSavedCredentials = false
		@JvmField var savedInfo: TLPaymentRequestedInfo? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			hasSavedCredentials = (flags and 2) != 0
		
			if ((flags and 1) != 0) {
				savedInfo = TLPaymentRequestedInfo.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (hasSavedCredentials) flags or 2 else flags and 2.inv()
			flags = if (savedInfo != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				savedInfo?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xfb8fe43cu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPaymentsSavedInfo? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPaymentsSavedInfo")
					}
					else {
						null
					}
				}
	
				val result = TLPaymentsSavedInfo()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class InputPaymentCredentials: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputPaymentCredentials? {
				val result = when (constructor) {
					TLInputPaymentCredentialsSaved.CONSTRUCTOR -> TLInputPaymentCredentialsSaved()
					TLInputPaymentCredentials.CONSTRUCTOR -> TLInputPaymentCredentials()
					TLInputPaymentCredentialsApplePay.CONSTRUCTOR -> TLInputPaymentCredentialsApplePay()
					TLInputPaymentCredentialsGooglePay.CONSTRUCTOR -> TLInputPaymentCredentialsGooglePay()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputPaymentCredentials")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputPaymentCredentialsSaved: InputPaymentCredentials() {
		@JvmField var id: String? = null
		@JvmField var tmpPassword: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readString(exception) ?: return
			tmpPassword = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(id)
			stream.writeByteArray(tmpPassword)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc10eb2cfu.toInt()
		}
	}
	
	open class TLInputPaymentCredentials: InputPaymentCredentials() {
		@JvmField var flags = 0
		@JvmField var save = false
		@JvmField var data: TLDataJSON? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			save = (flags and 1) != 0
			data = TLDataJSON.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (save) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			data?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3417d728u.toInt()
		}
	}
	
	open class TLInputPaymentCredentialsApplePay: InputPaymentCredentials() {
		@JvmField var paymentData: TLDataJSON? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			paymentData = TLDataJSON.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			paymentData?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xaa1c39fu.toInt()
		}
	}
	
	open class TLInputPaymentCredentialsGooglePay: InputPaymentCredentials() {
		@JvmField var paymentToken: TLDataJSON? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			paymentToken = TLDataJSON.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			paymentToken?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8ac32801u.toInt()
		}
	}
	
	open class TLAccountTmpPassword: TLObject() {
		@JvmField var tmpPassword: ByteArray? = null
		@JvmField var validUntil = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			tmpPassword = stream.readByteArray(exception) ?: return
			validUntil = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteArray(tmpPassword)
			stream.writeInt32(validUntil)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdb64fd34u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountTmpPassword? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAccountTmpPassword")
					}
					else {
						null
					}
				}
	
				val result = TLAccountTmpPassword()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountGetTmpPassword: TLObject() {
		@JvmField var password: InputCheckPasswordSRP? = null
		@JvmField var period = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountTmpPassword? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAccountTmpPassword.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			password?.serializeToStream(stream)
			stream.writeInt32(period)
		}
	
		companion object {
			val CONSTRUCTOR = 0x449e0b51u.toInt()
		}
	}
	
	open class TLShippingOption: TLObject() {
		@JvmField var id: String? = null
		@JvmField var title: String? = null
		@JvmField val prices = mutableListOf<TLLabeledPrice>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readString(exception) ?: return
			title = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLLabeledPrice.deserialize(stream, stream.readInt32(exception), exception) ?: return
				prices.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(id)
			stream.writeString(title)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(prices.size)
			prices.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xb6213cdfu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLShippingOption? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLShippingOption")
					}
					else {
						null
					}
				}
	
				val result = TLShippingOption()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLInputStickerSetItem: TLObject() {
		@JvmField var flags = 0
		@JvmField var document: InputDocument? = null
		@JvmField var emoji: String? = null
		@JvmField var maskCoords: TLMaskCoords? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			document = InputDocument.deserialize(stream, stream.readInt32(exception), exception)
			emoji = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				maskCoords = TLMaskCoords.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (maskCoords != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			document?.serializeToStream(stream)
			stream.writeString(emoji)
			if ((flags and 1) != 0) {
				maskCoords?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xffa0a496u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLInputStickerSetItem? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLInputStickerSetItem")
					}
					else {
						null
					}
				}
	
				val result = TLInputStickerSetItem()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLInputPhoneCall: TLObject() {
		@JvmField var id = 0L
		@JvmField var accessHash = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1e36fdedu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLInputPhoneCall? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLInputPhoneCall")
					}
					else {
						null
					}
				}
	
				val result = TLInputPhoneCall()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class PhoneCall: TLObject() {
		@JvmField var callProtocol: TLPhoneCallProtocol? = null
		@JvmField var flags = 0
		@JvmField var id = 0L
		@JvmField var date = 0
		@JvmField var adminId = 0L
		@JvmField var participantId = 0L
		@JvmField var accessHash = 0L
		@JvmField var video = false
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PhoneCall? {
				val result = when (constructor) {
					TLPhoneCallEmpty.CONSTRUCTOR -> TLPhoneCallEmpty()
					TLPhoneCallWaiting.CONSTRUCTOR -> TLPhoneCallWaiting()
					TLPhoneCallRequested.CONSTRUCTOR -> TLPhoneCallRequested()
					TLPhoneCallAccepted.CONSTRUCTOR -> TLPhoneCallAccepted()
					TLPhoneCall.CONSTRUCTOR -> TLPhoneCall()
					TLPhoneCallDiscarded.CONSTRUCTOR -> TLPhoneCallDiscarded()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in PhoneCall")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPhoneCallEmpty: PhoneCall() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5366c915u.toInt()
		}
	}
	
	open class TLPhoneCallWaiting: PhoneCall() {
										@JvmField var receiveDate = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			video = (flags and 64) != 0
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			date = stream.readInt32(exception)
			adminId = stream.readInt64(exception)
			participantId = stream.readInt64(exception)
			callProtocol = TLPhoneCallProtocol.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				receiveDate = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (video) flags or 64 else flags and 64.inv()
			flags = if (receiveDate != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeInt32(date)
			stream.writeInt64(adminId)
			stream.writeInt64(participantId)
			callProtocol?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(receiveDate)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc5226f17u.toInt()
		}
	}
	
	open class TLPhoneCallRequested: PhoneCall() {
									@JvmField var gAHash: ByteArray? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			video = (flags and 64) != 0
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			date = stream.readInt32(exception)
			adminId = stream.readInt64(exception)
			participantId = stream.readInt64(exception)
			gAHash = stream.readByteArray(exception) ?: return
			callProtocol = TLPhoneCallProtocol.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (video) flags or 64 else flags and 64.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeInt32(date)
			stream.writeInt64(adminId)
			stream.writeInt64(participantId)
			stream.writeByteArray(gAHash)
			callProtocol?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x14b0ed0cu.toInt()
		}
	}
	
	open class TLPhoneCallAccepted: PhoneCall() {
									@JvmField var gB: ByteArray? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			video = (flags and 64) != 0
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			date = stream.readInt32(exception)
			adminId = stream.readInt64(exception)
			participantId = stream.readInt64(exception)
			gB = stream.readByteArray(exception) ?: return
			callProtocol = TLPhoneCallProtocol.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (video) flags or 64 else flags and 64.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeInt32(date)
			stream.writeInt64(adminId)
			stream.writeInt64(participantId)
			stream.writeByteArray(gB)
			callProtocol?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3660c311u.toInt()
		}
	}
	
	open class TLPhoneCall: PhoneCall() {
			@JvmField var p2pAllowed = false
								@JvmField var gAOrB: ByteArray? = null
		@JvmField var keyFingerprint = 0L
			@JvmField val connections = mutableListOf<PhoneConnection>()
		@JvmField var startDate = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			p2pAllowed = (flags and 32) != 0
			video = (flags and 64) != 0
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			date = stream.readInt32(exception)
			adminId = stream.readInt64(exception)
			participantId = stream.readInt64(exception)
			gAOrB = stream.readByteArray(exception) ?: return
			keyFingerprint = stream.readInt64(exception)
			callProtocol = TLPhoneCallProtocol.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = PhoneConnection.deserialize(stream, stream.readInt32(exception), exception) ?: return
				connections.add(obj)
			}
			startDate = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (p2pAllowed) flags or 32 else flags and 32.inv()
			flags = if (video) flags or 64 else flags and 64.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeInt32(date)
			stream.writeInt64(adminId)
			stream.writeInt64(participantId)
			stream.writeByteArray(gAOrB)
			stream.writeInt64(keyFingerprint)
			callProtocol?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(connections.size)
			connections.forEach { it.serializeToStream(stream) }
			stream.writeInt32(startDate)
		}
	
		companion object {
			val CONSTRUCTOR = 0x967f7c67u.toInt()
		}
	}
	
	open class TLPhoneCallDiscarded: PhoneCall() {
			@JvmField var needRating = false
		@JvmField var needDebug = false
				@JvmField var reason: PhoneCallDiscardReason? = null
		@JvmField var duration = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			needRating = (flags and 4) != 0
			needDebug = (flags and 8) != 0
			video = (flags and 64) != 0
			id = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {
				reason = PhoneCallDiscardReason.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				duration = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (needRating) flags or 4 else flags and 4.inv()
			flags = if (needDebug) flags or 8 else flags and 8.inv()
			flags = if (video) flags or 64 else flags and 64.inv()
			flags = if (reason != null) flags or 1 else flags and 1.inv()
			flags = if (duration != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			if ((flags and 1) != 0) {
				reason?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(duration)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x50ca4de1u.toInt()
		}
	}
	
	abstract class PhoneConnection: TLObject() {
		@JvmField var port = 0
		@JvmField var flags = 0
		@JvmField var ipv6: String? = null
		@JvmField var id = 0L
		@JvmField var ip: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PhoneConnection? {
				val result = when (constructor) {
					TLPhoneConnection.CONSTRUCTOR -> TLPhoneConnection()
					TLPhoneConnectionWebrtc.CONSTRUCTOR -> TLPhoneConnectionWebrtc()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in PhoneConnection")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPhoneConnection: PhoneConnection() {
			@JvmField var tcp = false
						@JvmField var peerTag: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			tcp = (flags and 1) != 0
			id = stream.readInt64(exception)
			ip = stream.readString(exception) ?: return
			ipv6 = stream.readString(exception) ?: return
			port = stream.readInt32(exception)
			peerTag = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (tcp) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeString(ip)
			stream.writeString(ipv6)
			stream.writeInt32(port)
			stream.writeByteArray(peerTag)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9cc123c7u.toInt()
		}
	}
	
	open class TLPhoneConnectionWebrtc: PhoneConnection() {
			@JvmField var turn = false
		@JvmField var stun = false
						@JvmField var username: String? = null
		@JvmField var password: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			turn = (flags and 1) != 0
			stun = (flags and 2) != 0
			id = stream.readInt64(exception)
			ip = stream.readString(exception) ?: return
			ipv6 = stream.readString(exception) ?: return
			port = stream.readInt32(exception)
			username = stream.readString(exception) ?: return
			password = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (turn) flags or 1 else flags and 1.inv()
			flags = if (stun) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeString(ip)
			stream.writeString(ipv6)
			stream.writeInt32(port)
			stream.writeString(username)
			stream.writeString(password)
		}
	
		companion object {
			val CONSTRUCTOR = 0x635fe375u.toInt()
		}
	}
	
	open class TLPhoneCallProtocol: TLObject() {
		@JvmField var flags = 0
		@JvmField var udpP2p = false
		@JvmField var udpReflector = false
		@JvmField var minLayer = 0
		@JvmField var maxLayer = 0
		@JvmField val libraryVersions = mutableListOf<String>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			udpP2p = (flags and 1) != 0
			udpReflector = (flags and 2) != 0
			minLayer = stream.readInt32(exception)
			maxLayer = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readString(exception) ?: return
				libraryVersions.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (udpP2p) flags or 1 else flags and 1.inv()
			flags = if (udpReflector) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(minLayer)
			stream.writeInt32(maxLayer)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(libraryVersions.size)
			libraryVersions.forEach { stream.writeString(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xfc878fc8u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhoneCallProtocol? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPhoneCallProtocol")
					}
					else {
						null
					}
				}
	
				val result = TLPhoneCallProtocol()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPhonePhoneCall: TLObject() {
		@JvmField var phoneCall: PhoneCall? = null
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			phoneCall = PhoneCall.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			phoneCall?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xec82e140u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhonePhoneCall? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPhonePhoneCall")
					}
					else {
						null
					}
				}
	
				val result = TLPhonePhoneCall()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPhoneRequestCall: TLObject() {
		@JvmField var flags = 0
		@JvmField var video = false
		@JvmField var userId: InputUser? = null
		@JvmField var randomId = 0
		@JvmField var gAHash: ByteArray? = null
		@JvmField var callProtocol: TLPhoneCallProtocol? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhonePhoneCall? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPhonePhoneCall.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (video) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			userId?.serializeToStream(stream)
			stream.writeInt32(randomId)
			stream.writeByteArray(gAHash)
			callProtocol?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x42ff96edu.toInt()
		}
	}
	
	open class TLPhoneAcceptCall: TLObject() {
		@JvmField var peer: TLInputPhoneCall? = null
		@JvmField var gB: ByteArray? = null
		@JvmField var callProtocol: TLPhoneCallProtocol? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhonePhoneCall? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPhonePhoneCall.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeByteArray(gB)
			callProtocol?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3bd2b4a0u.toInt()
		}
	}
	
	open class TLPhoneConfirmCall: TLObject() {
		@JvmField var peer: TLInputPhoneCall? = null
		@JvmField var gA: ByteArray? = null
		@JvmField var keyFingerprint = 0L
		@JvmField var callProtocol: TLPhoneCallProtocol? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhonePhoneCall? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPhonePhoneCall.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeByteArray(gA)
			stream.writeInt64(keyFingerprint)
			callProtocol?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2efe1722u.toInt()
		}
	}
	
	abstract class UploadCdnFile: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): UploadCdnFile? {
				val result = when (constructor) {
					TLUploadCdnFileReuploadNeeded.CONSTRUCTOR -> TLUploadCdnFileReuploadNeeded()
					TLUploadCdnFile.CONSTRUCTOR -> TLUploadCdnFile()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in UploadCdnFile")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLUploadCdnFileReuploadNeeded: UploadCdnFile() {
		@JvmField var requestToken: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			requestToken = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteArray(requestToken)
		}
	
		companion object {
			val CONSTRUCTOR = 0xeea8e46eu.toInt()
		}
	}
	
	open class TLUploadCdnFile: UploadCdnFile() {
		@JvmField var bytes: NativeByteBuffer? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			bytes = stream.readByteBuffer(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteBuffer(bytes)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa99fca4fu.toInt()
		}
	}
	
	open class TLUploadGetCdnFile: TLObject() {
		@JvmField var fileToken: ByteArray? = null
		@JvmField var offset = 0L
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): UploadCdnFile? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return UploadCdnFile.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteArray(fileToken)
			stream.writeInt64(offset)
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0x395f69dau.toInt()
		}
	}
	
	open class TLCdnPublicKey: TLObject() {
		@JvmField var dcId = 0
		@JvmField var publicKey: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			dcId = stream.readInt32(exception)
			publicKey = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(dcId)
			stream.writeString(publicKey)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc982eabau.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLCdnPublicKey? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLCdnPublicKey")
					}
					else {
						null
					}
				}
	
				val result = TLCdnPublicKey()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLCdnConfig: TLObject() {
		@JvmField val publicKeys = mutableListOf<TLCdnPublicKey>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLCdnPublicKey.deserialize(stream, stream.readInt32(exception), exception) ?: return
				publicKeys.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(publicKeys.size)
			publicKeys.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x5725e40au.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLCdnConfig? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLCdnConfig")
					}
					else {
						null
					}
				}
	
				val result = TLCdnConfig()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLHelpGetCdnConfig: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLCdnConfig? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLCdnConfig.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x52029342u.toInt()
		}
	}
	
	abstract class LangPackString: TLObject() {
		@JvmField var key: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): LangPackString? {
				val result = when (constructor) {
					TLLangPackString.CONSTRUCTOR -> TLLangPackString()
					TLLangPackStringPluralized.CONSTRUCTOR -> TLLangPackStringPluralized()
					TLLangPackStringDeleted.CONSTRUCTOR -> TLLangPackStringDeleted()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in LangPackString")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLLangPackString: LangPackString() {
			@JvmField var value: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			key = stream.readString(exception) ?: return
			value = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(key)
			stream.writeString(value)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcad181f6u.toInt()
		}
	}
	
	open class TLLangPackStringPluralized: LangPackString() {
		@JvmField var flags = 0
			@JvmField var zeroValue: String? = null
		@JvmField var oneValue: String? = null
		@JvmField var twoValue: String? = null
		@JvmField var fewValue: String? = null
		@JvmField var manyValue: String? = null
		@JvmField var otherValue: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			key = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				zeroValue = stream.readString(exception) ?: return
			}
		
			if ((flags and 2) != 0) {
				oneValue = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				twoValue = stream.readString(exception) ?: return
			}
		
			if ((flags and 8) != 0) {
				fewValue = stream.readString(exception) ?: return
			}
		
			if ((flags and 16) != 0) {
				manyValue = stream.readString(exception) ?: return
			}
			otherValue = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (zeroValue != null) flags or 1 else flags and 1.inv()
			flags = if (oneValue != null) flags or 2 else flags and 2.inv()
			flags = if (twoValue != null) flags or 4 else flags and 4.inv()
			flags = if (fewValue != null) flags or 8 else flags and 8.inv()
			flags = if (manyValue != null) flags or 16 else flags and 16.inv()
	
			stream.writeInt32(flags)
			stream.writeString(key)
			if ((flags and 1) != 0) {
				stream.writeString(zeroValue)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(oneValue)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(twoValue)
			}
	
			if ((flags and 8) != 0) {
				stream.writeString(fewValue)
			}
	
			if ((flags and 16) != 0) {
				stream.writeString(manyValue)
			}
	
			stream.writeString(otherValue)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6c47ac9fu.toInt()
		}
	}
	
	open class TLLangPackStringDeleted: LangPackString() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			key = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(key)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2979eeb2u.toInt()
		}
	}
	
	open class TLLangPackDifference: TLObject() {
		@JvmField var langCode: String? = null
		@JvmField var fromVersion = 0
		@JvmField var version = 0
		@JvmField val strings = mutableListOf<LangPackString>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			langCode = stream.readString(exception) ?: return
			fromVersion = stream.readInt32(exception)
			version = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = LangPackString.deserialize(stream, stream.readInt32(exception), exception) ?: return
				strings.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(langCode)
			stream.writeInt32(fromVersion)
			stream.writeInt32(version)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(strings.size)
			strings.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xf385c1f6u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLLangPackDifference? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLLangPackDifference")
					}
					else {
						null
					}
				}
	
				val result = TLLangPackDifference()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLLangpackGetLangPack: TLObject() {
		@JvmField var langPack: String? = null
		@JvmField var langCode: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLLangPackDifference? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLLangPackDifference.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(langPack)
			stream.writeString(langCode)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf2f2330au.toInt()
		}
	}
	
	open class TLLangpackGetDifference: TLObject() {
		@JvmField var langPack: String? = null
		@JvmField var langCode: String? = null
		@JvmField var fromVersion = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLLangPackDifference? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLLangPackDifference.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(langPack)
			stream.writeString(langCode)
			stream.writeInt32(fromVersion)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcd984aa5u.toInt()
		}
	}
	
	open class TLLangPackLanguage: TLObject() {
		@JvmField var flags = 0
		@JvmField var official = false
		@JvmField var rtl = false
		@JvmField var beta = false
		@JvmField var name: String? = null
		@JvmField var nativeName: String? = null
		@JvmField var langCode: String? = null
		@JvmField var baseLangCode: String? = null
		@JvmField var pluralCode: String? = null
		@JvmField var stringsCount = 0
		@JvmField var translatedCount = 0
		@JvmField var translationsUrl: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			official = (flags and 1) != 0
			rtl = (flags and 4) != 0
			beta = (flags and 8) != 0
			name = stream.readString(exception) ?: return
			nativeName = stream.readString(exception) ?: return
			langCode = stream.readString(exception) ?: return
		
			if ((flags and 2) != 0) {
				baseLangCode = stream.readString(exception) ?: return
			}
			pluralCode = stream.readString(exception) ?: return
			stringsCount = stream.readInt32(exception)
			translatedCount = stream.readInt32(exception)
			translationsUrl = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (official) flags or 1 else flags and 1.inv()
			flags = if (rtl) flags or 4 else flags and 4.inv()
			flags = if (beta) flags or 8 else flags and 8.inv()
			flags = if (baseLangCode != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeString(name)
			stream.writeString(nativeName)
			stream.writeString(langCode)
			if ((flags and 2) != 0) {
				stream.writeString(baseLangCode)
			}
	
			stream.writeString(pluralCode)
			stream.writeInt32(stringsCount)
			stream.writeInt32(translatedCount)
			stream.writeString(translationsUrl)
		}
	
		companion object {
			val CONSTRUCTOR = 0xeeca5ce3u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLLangPackLanguage? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLLangPackLanguage")
					}
					else {
						null
					}
				}
	
				val result = TLLangPackLanguage()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLLangpackGetLanguage: TLObject() {
		@JvmField var langPack: String? = null
		@JvmField var langCode: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLLangPackLanguage? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLLangPackLanguage.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(langPack)
			stream.writeString(langCode)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6a596502u.toInt()
		}
	}
	
	abstract class ChannelAdminLogEventAction: TLObject() {
		@JvmField var message: Message? = null
		@JvmField var newParticipant: ChannelParticipant? = null
		@JvmField var invite: ExportedChatInvite? = null
		@JvmField var call: TLInputGroupCall? = null
		@JvmField var prevParticipant: ChannelParticipant? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChannelAdminLogEventAction? {
				val result = when (constructor) {
					TLChannelAdminLogEventActionChangeTitle.CONSTRUCTOR -> TLChannelAdminLogEventActionChangeTitle()
					TLChannelAdminLogEventActionChangeAbout.CONSTRUCTOR -> TLChannelAdminLogEventActionChangeAbout()
					TLChannelAdminLogEventActionChangeUsername.CONSTRUCTOR -> TLChannelAdminLogEventActionChangeUsername()
					TLChannelAdminLogEventActionChangePhoto.CONSTRUCTOR -> TLChannelAdminLogEventActionChangePhoto()
					TLChannelAdminLogEventActionToggleInvites.CONSTRUCTOR -> TLChannelAdminLogEventActionToggleInvites()
					TLChannelAdminLogEventActionToggleSignatures.CONSTRUCTOR -> TLChannelAdminLogEventActionToggleSignatures()
					TLChannelAdminLogEventActionUpdatePinned.CONSTRUCTOR -> TLChannelAdminLogEventActionUpdatePinned()
					TLChannelAdminLogEventActionEditMessage.CONSTRUCTOR -> TLChannelAdminLogEventActionEditMessage()
					TLChannelAdminLogEventActionDeleteMessage.CONSTRUCTOR -> TLChannelAdminLogEventActionDeleteMessage()
					TLChannelAdminLogEventActionParticipantJoin.CONSTRUCTOR -> TLChannelAdminLogEventActionParticipantJoin()
					TLChannelAdminLogEventActionParticipantLeave.CONSTRUCTOR -> TLChannelAdminLogEventActionParticipantLeave()
					TLChannelAdminLogEventActionParticipantInvite.CONSTRUCTOR -> TLChannelAdminLogEventActionParticipantInvite()
					TLChannelAdminLogEventActionParticipantToggleBan.CONSTRUCTOR -> TLChannelAdminLogEventActionParticipantToggleBan()
					TLChannelAdminLogEventActionParticipantToggleAdmin.CONSTRUCTOR -> TLChannelAdminLogEventActionParticipantToggleAdmin()
					TLChannelAdminLogEventActionChangeStickerSet.CONSTRUCTOR -> TLChannelAdminLogEventActionChangeStickerSet()
					TLChannelAdminLogEventActionTogglePreHistoryHidden.CONSTRUCTOR -> TLChannelAdminLogEventActionTogglePreHistoryHidden()
					TLChannelAdminLogEventActionDefaultBannedRights.CONSTRUCTOR -> TLChannelAdminLogEventActionDefaultBannedRights()
					TLChannelAdminLogEventActionStopPoll.CONSTRUCTOR -> TLChannelAdminLogEventActionStopPoll()
					TLChannelAdminLogEventActionChangeLinkedChat.CONSTRUCTOR -> TLChannelAdminLogEventActionChangeLinkedChat()
					TLChannelAdminLogEventActionChangeLocation.CONSTRUCTOR -> TLChannelAdminLogEventActionChangeLocation()
					TLChannelAdminLogEventActionToggleSlowMode.CONSTRUCTOR -> TLChannelAdminLogEventActionToggleSlowMode()
					TLChannelAdminLogEventActionStartGroupCall.CONSTRUCTOR -> TLChannelAdminLogEventActionStartGroupCall()
					TLChannelAdminLogEventActionDiscardGroupCall.CONSTRUCTOR -> TLChannelAdminLogEventActionDiscardGroupCall()
					TLChannelAdminLogEventActionParticipantMute.CONSTRUCTOR -> TLChannelAdminLogEventActionParticipantMute()
					TLChannelAdminLogEventActionParticipantUnmute.CONSTRUCTOR -> TLChannelAdminLogEventActionParticipantUnmute()
					TLChannelAdminLogEventActionToggleGroupCallSetting.CONSTRUCTOR -> TLChannelAdminLogEventActionToggleGroupCallSetting()
					TLChannelAdminLogEventActionParticipantJoinByInvite.CONSTRUCTOR -> TLChannelAdminLogEventActionParticipantJoinByInvite()
					TLChannelAdminLogEventActionExportedInviteDelete.CONSTRUCTOR -> TLChannelAdminLogEventActionExportedInviteDelete()
					TLChannelAdminLogEventActionExportedInviteRevoke.CONSTRUCTOR -> TLChannelAdminLogEventActionExportedInviteRevoke()
					TLChannelAdminLogEventActionExportedInviteEdit.CONSTRUCTOR -> TLChannelAdminLogEventActionExportedInviteEdit()
					TLChannelAdminLogEventActionParticipantVolume.CONSTRUCTOR -> TLChannelAdminLogEventActionParticipantVolume()
					TLChannelAdminLogEventActionChangeHistoryTTL.CONSTRUCTOR -> TLChannelAdminLogEventActionChangeHistoryTTL()
					TLChannelAdminLogEventActionParticipantJoinByRequest.CONSTRUCTOR -> TLChannelAdminLogEventActionParticipantJoinByRequest()
					TLChannelAdminLogEventActionToggleNoForwards.CONSTRUCTOR -> TLChannelAdminLogEventActionToggleNoForwards()
					TLChannelAdminLogEventActionSendMessage.CONSTRUCTOR -> TLChannelAdminLogEventActionSendMessage()
					TLChannelAdminLogEventActionChangeAvailableReactions.CONSTRUCTOR -> TLChannelAdminLogEventActionChangeAvailableReactions()
					TLChannelAdminLogEventActionToggleForum.CONSTRUCTOR -> TLChannelAdminLogEventActionToggleForum()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ChannelAdminLogEventAction")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChannelAdminLogEventActionChangeTitle: ChannelAdminLogEventAction() {
		@JvmField var prevValue: String? = null
		@JvmField var newValue: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			prevValue = stream.readString(exception) ?: return
			newValue = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(prevValue)
			stream.writeString(newValue)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe6dfb825u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionChangeAbout: ChannelAdminLogEventAction() {
		@JvmField var prevValue: String? = null
		@JvmField var newValue: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			prevValue = stream.readString(exception) ?: return
			newValue = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(prevValue)
			stream.writeString(newValue)
		}
	
		companion object {
			val CONSTRUCTOR = 0x55188a2eu.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionChangeUsername: ChannelAdminLogEventAction() {
		@JvmField var prevValue: String? = null
		@JvmField var newValue: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			prevValue = stream.readString(exception) ?: return
			newValue = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(prevValue)
			stream.writeString(newValue)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6a4afc38u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionChangePhoto: ChannelAdminLogEventAction() {
		@JvmField var prevPhoto: Photo? = null
		@JvmField var newPhoto: Photo? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			prevPhoto = Photo.deserialize(stream, stream.readInt32(exception), exception)
			newPhoto = Photo.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			prevPhoto?.serializeToStream(stream)
			newPhoto?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x434bd2afu.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionToggleInvites: ChannelAdminLogEventAction() {
		@JvmField var newValue = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			newValue = stream.readBool(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeBool(newValue)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1b7907aeu.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionToggleSignatures: ChannelAdminLogEventAction() {
		@JvmField var newValue = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			newValue = stream.readBool(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeBool(newValue)
		}
	
		companion object {
			val CONSTRUCTOR = 0x26ae0971u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionUpdatePinned: ChannelAdminLogEventAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			message = Message.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			message?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe9e82c18u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionEditMessage: ChannelAdminLogEventAction() {
		@JvmField var prevMessage: Message? = null
		@JvmField var newMessage: Message? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			prevMessage = Message.deserialize(stream, stream.readInt32(exception), exception)
			newMessage = Message.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			prevMessage?.serializeToStream(stream)
			newMessage?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x709b2405u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionDeleteMessage: ChannelAdminLogEventAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			message = Message.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			message?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x42e047bbu.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionParticipantJoin: ChannelAdminLogEventAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x183040d3u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionParticipantLeave: ChannelAdminLogEventAction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf89777f2u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionParticipantInvite: ChannelAdminLogEventAction() {
		@JvmField var participant: ChannelParticipant? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			participant = ChannelParticipant.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			participant?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe31c34d8u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionParticipantToggleBan: ChannelAdminLogEventAction() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			prevParticipant = ChannelParticipant.deserialize(stream, stream.readInt32(exception), exception)
			newParticipant = ChannelParticipant.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			prevParticipant?.serializeToStream(stream)
			newParticipant?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe6d83d7eu.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionParticipantToggleAdmin: ChannelAdminLogEventAction() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			prevParticipant = ChannelParticipant.deserialize(stream, stream.readInt32(exception), exception)
			newParticipant = ChannelParticipant.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			prevParticipant?.serializeToStream(stream)
			newParticipant?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd5676710u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionChangeStickerSet: ChannelAdminLogEventAction() {
		@JvmField var prevStickerset: InputStickerSet? = null
		@JvmField var newStickerset: InputStickerSet? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			prevStickerset = InputStickerSet.deserialize(stream, stream.readInt32(exception), exception)
			newStickerset = InputStickerSet.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			prevStickerset?.serializeToStream(stream)
			newStickerset?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb1c3caa7u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionTogglePreHistoryHidden: ChannelAdminLogEventAction() {
		@JvmField var newValue = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			newValue = stream.readBool(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeBool(newValue)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5f5c95f1u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionDefaultBannedRights: ChannelAdminLogEventAction() {
		@JvmField var prevBannedRights: TLChatBannedRights? = null
		@JvmField var newBannedRights: TLChatBannedRights? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			prevBannedRights = TLChatBannedRights.deserialize(stream, stream.readInt32(exception), exception)
			newBannedRights = TLChatBannedRights.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			prevBannedRights?.serializeToStream(stream)
			newBannedRights?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2df5fc0au.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionStopPoll: ChannelAdminLogEventAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			message = Message.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			message?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8f079643u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionChangeLinkedChat: ChannelAdminLogEventAction() {
		@JvmField var prevValue = 0L
		@JvmField var newValue = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			prevValue = stream.readInt64(exception)
			newValue = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(prevValue)
			stream.writeInt64(newValue)
		}
	
		companion object {
			val CONSTRUCTOR = 0x50c7ac8u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionChangeLocation: ChannelAdminLogEventAction() {
		@JvmField var prevValue: ChannelLocation? = null
		@JvmField var newValue: ChannelLocation? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			prevValue = ChannelLocation.deserialize(stream, stream.readInt32(exception), exception)
			newValue = ChannelLocation.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			prevValue?.serializeToStream(stream)
			newValue?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe6b76aeu.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionToggleSlowMode: ChannelAdminLogEventAction() {
		@JvmField var prevValue = 0
		@JvmField var newValue = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			prevValue = stream.readInt32(exception)
			newValue = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(prevValue)
			stream.writeInt32(newValue)
		}
	
		companion object {
			val CONSTRUCTOR = 0x53909779u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionStartGroupCall: ChannelAdminLogEventAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			call = TLInputGroupCall.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x23209745u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionDiscardGroupCall: ChannelAdminLogEventAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			call = TLInputGroupCall.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdb9f9140u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionParticipantMute: ChannelAdminLogEventAction() {
		@JvmField var participant: TLGroupCallParticipant? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			participant = TLGroupCallParticipant.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			participant?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf92424d2u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionParticipantUnmute: ChannelAdminLogEventAction() {
		@JvmField var participant: TLGroupCallParticipant? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			participant = TLGroupCallParticipant.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			participant?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe64429c0u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionToggleGroupCallSetting: ChannelAdminLogEventAction() {
		@JvmField var joinMuted = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			joinMuted = stream.readBool(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeBool(joinMuted)
		}
	
		companion object {
			val CONSTRUCTOR = 0x56d6a247u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionParticipantJoinByInvite: ChannelAdminLogEventAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			invite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			invite?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5cdada77u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionExportedInviteDelete: ChannelAdminLogEventAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			invite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			invite?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5a50fca4u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionExportedInviteRevoke: ChannelAdminLogEventAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			invite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			invite?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x410a134eu.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionExportedInviteEdit: ChannelAdminLogEventAction() {
		@JvmField var prevInvite: ExportedChatInvite? = null
		@JvmField var newInvite: ExportedChatInvite? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			prevInvite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
			newInvite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			prevInvite?.serializeToStream(stream)
			newInvite?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe90ebb59u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionParticipantVolume: ChannelAdminLogEventAction() {
		@JvmField var participant: TLGroupCallParticipant? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			participant = TLGroupCallParticipant.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			participant?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3e7f6847u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionChangeHistoryTTL: ChannelAdminLogEventAction() {
		@JvmField var prevValue = 0
		@JvmField var newValue = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			prevValue = stream.readInt32(exception)
			newValue = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(prevValue)
			stream.writeInt32(newValue)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6e941a38u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionParticipantJoinByRequest: ChannelAdminLogEventAction() {
			@JvmField var approvedBy = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			invite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
			approvedBy = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			invite?.serializeToStream(stream)
			stream.writeInt64(approvedBy)
		}
	
		companion object {
			val CONSTRUCTOR = 0xafb6144au.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionToggleNoForwards: ChannelAdminLogEventAction() {
		@JvmField var newValue = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			newValue = stream.readBool(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeBool(newValue)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcb2ac766u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionSendMessage: ChannelAdminLogEventAction() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			message = Message.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			message?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x278f2868u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionChangeAvailableReactions: ChannelAdminLogEventAction() {
		@JvmField var prevValue: ChatReactions? = null
		@JvmField var newValue: ChatReactions? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			prevValue = ChatReactions.deserialize(stream, stream.readInt32(exception), exception)
			newValue = ChatReactions.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			prevValue?.serializeToStream(stream)
			newValue?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbe4e0ef8u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventActionToggleForum: ChannelAdminLogEventAction() {
		@JvmField var newValue = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			newValue = stream.readBool(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeBool(newValue)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2cc6383u.toInt()
		}
	}
	
	open class TLChannelAdminLogEvent: TLObject() {
		@JvmField var id = 0L
		@JvmField var date = 0
		@JvmField var userId = 0L
		@JvmField var action: ChannelAdminLogEventAction? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			date = stream.readInt32(exception)
			userId = stream.readInt64(exception)
			action = ChannelAdminLogEventAction.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt32(date)
			stream.writeInt64(userId)
			action?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1fad68cdu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChannelAdminLogEvent? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLChannelAdminLogEvent")
					}
					else {
						null
					}
				}
	
				val result = TLChannelAdminLogEvent()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLChannelsAdminLogResults: TLObject() {
		@JvmField val events = mutableListOf<TLChannelAdminLogEvent>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLChannelAdminLogEvent.deserialize(stream, stream.readInt32(exception), exception) ?: return
				events.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(events.size)
			events.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xed8af74du.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChannelsAdminLogResults? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLChannelsAdminLogResults")
					}
					else {
						null
					}
				}
	
				val result = TLChannelsAdminLogResults()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLChannelsGetAdminLog: TLObject() {
		@JvmField var flags = 0
		@JvmField var channel: InputChannel? = null
		@JvmField var q: String? = null
		@JvmField var eventsFilter: TLChannelAdminLogEventsFilter? = null
		@JvmField val admins = mutableListOf<InputUser>()
		@JvmField var maxId = 0L
		@JvmField var minId = 0L
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChannelsAdminLogResults? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLChannelsAdminLogResults.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (eventsFilter != null) flags or 1 else flags and 1.inv()
			flags = if (admins.isNotEmpty()) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			channel?.serializeToStream(stream)
			stream.writeString(q)
			if ((flags and 1) != 0) {
				eventsFilter?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(admins.size)
			admins.forEach { it.serializeToStream(stream) }
			}
	
			stream.writeInt64(maxId)
			stream.writeInt64(minId)
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0x33ddf480u.toInt()
		}
	}
	
	open class TLChannelAdminLogEventsFilter: TLObject() {
		@JvmField var flags = 0
		@JvmField var join = false
		@JvmField var leave = false
		@JvmField var invite = false
		@JvmField var ban = false
		@JvmField var unban = false
		@JvmField var kick = false
		@JvmField var unkick = false
		@JvmField var promote = false
		@JvmField var demote = false
		@JvmField var info = false
		@JvmField var settings = false
		@JvmField var pinned = false
		@JvmField var edit = false
		@JvmField var delete = false
		@JvmField var groupCall = false
		@JvmField var invites = false
		@JvmField var send = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			join = (flags and 1) != 0
			leave = (flags and 2) != 0
			invite = (flags and 4) != 0
			ban = (flags and 8) != 0
			unban = (flags and 16) != 0
			kick = (flags and 32) != 0
			unkick = (flags and 64) != 0
			promote = (flags and 128) != 0
			demote = (flags and 256) != 0
			info = (flags and 512) != 0
			settings = (flags and 1024) != 0
			pinned = (flags and 2048) != 0
			edit = (flags and 4096) != 0
			delete = (flags and 8192) != 0
			groupCall = (flags and 16384) != 0
			invites = (flags and 32768) != 0
			send = (flags and 65536) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (join) flags or 1 else flags and 1.inv()
			flags = if (leave) flags or 2 else flags and 2.inv()
			flags = if (invite) flags or 4 else flags and 4.inv()
			flags = if (ban) flags or 8 else flags and 8.inv()
			flags = if (unban) flags or 16 else flags and 16.inv()
			flags = if (kick) flags or 32 else flags and 32.inv()
			flags = if (unkick) flags or 64 else flags and 64.inv()
			flags = if (promote) flags or 128 else flags and 128.inv()
			flags = if (demote) flags or 256 else flags and 256.inv()
			flags = if (info) flags or 512 else flags and 512.inv()
			flags = if (settings) flags or 1024 else flags and 1024.inv()
			flags = if (pinned) flags or 2048 else flags and 2048.inv()
			flags = if (edit) flags or 4096 else flags and 4096.inv()
			flags = if (delete) flags or 8192 else flags and 8192.inv()
			flags = if (groupCall) flags or 16384 else flags and 16384.inv()
			flags = if (invites) flags or 32768 else flags and 32768.inv()
			flags = if (send) flags or 65536 else flags and 65536.inv()
	
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0xea107ae4u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChannelAdminLogEventsFilter? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLChannelAdminLogEventsFilter")
					}
					else {
						null
					}
				}
	
				val result = TLChannelAdminLogEventsFilter()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPopularContact: TLObject() {
		@JvmField var clientId = 0L
		@JvmField var importers = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			clientId = stream.readInt64(exception)
			importers = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(clientId)
			stream.writeInt32(importers)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5ce14175u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPopularContact? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPopularContact")
					}
					else {
						null
					}
				}
	
				val result = TLPopularContact()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class MessagesFavedStickers: TLObject() {
		@JvmField var hash = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesFavedStickers? {
				val result = when (constructor) {
					TLMessagesFavedStickersNotModified.CONSTRUCTOR -> TLMessagesFavedStickersNotModified()
					TLMessagesFavedStickers.CONSTRUCTOR -> TLMessagesFavedStickers()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesFavedStickers")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesFavedStickersNotModified: MessagesFavedStickers() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9e8fa6d3u.toInt()
		}
	}
	
	open class TLMessagesFavedStickers: MessagesFavedStickers() {
			@JvmField val packs = mutableListOf<TLStickerPack>()
		@JvmField val stickers = mutableListOf<Document>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			hash = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLStickerPack.deserialize(stream, stream.readInt32(exception), exception) ?: return
				packs.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Document.deserialize(stream, stream.readInt32(exception), exception) ?: return
				stickers.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(packs.size)
			packs.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(stickers.size)
			stickers.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x2cb51097u.toInt()
		}
	}
	
	open class TLMessagesGetFavedStickers: TLObject() {
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesFavedStickers? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesFavedStickers.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4f1aaa9u.toInt()
		}
	}
	
	abstract class RecentMeUrl: TLObject() {
		@JvmField var url: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): RecentMeUrl? {
				val result = when (constructor) {
					TLRecentMeUrlUnknown.CONSTRUCTOR -> TLRecentMeUrlUnknown()
					TLRecentMeUrlUser.CONSTRUCTOR -> TLRecentMeUrlUser()
					TLRecentMeUrlChat.CONSTRUCTOR -> TLRecentMeUrlChat()
					TLRecentMeUrlChatInvite.CONSTRUCTOR -> TLRecentMeUrlChatInvite()
					TLRecentMeUrlStickerSet.CONSTRUCTOR -> TLRecentMeUrlStickerSet()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in RecentMeUrl")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLRecentMeUrlUnknown: RecentMeUrl() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
		}
	
		companion object {
			val CONSTRUCTOR = 0x46e1d13du.toInt()
		}
	}
	
	open class TLRecentMeUrlUser: RecentMeUrl() {
			@JvmField var userId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
			userId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
			stream.writeInt64(userId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb92c09e2u.toInt()
		}
	}
	
	open class TLRecentMeUrlChat: RecentMeUrl() {
			@JvmField var chatId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
			chatId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
			stream.writeInt64(chatId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb2da71d2u.toInt()
		}
	}
	
	open class TLRecentMeUrlChatInvite: RecentMeUrl() {
			@JvmField var chatInvite: ChatInvite? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
			chatInvite = ChatInvite.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
			chatInvite?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xeb49081du.toInt()
		}
	}
	
	open class TLRecentMeUrlStickerSet: RecentMeUrl() {
			@JvmField var set: StickerSetCovered? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
			set = StickerSetCovered.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
			set?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbc0a57dcu.toInt()
		}
	}
	
	open class TLHelpRecentMeUrls: TLObject() {
		@JvmField val urls = mutableListOf<RecentMeUrl>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = RecentMeUrl.deserialize(stream, stream.readInt32(exception), exception) ?: return
				urls.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(urls.size)
			urls.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xe0310d7u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLHelpRecentMeUrls? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLHelpRecentMeUrls")
					}
					else {
						null
					}
				}
	
				val result = TLHelpRecentMeUrls()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLHelpGetRecentMeUrls: TLObject() {
		@JvmField var referer: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLHelpRecentMeUrls? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLHelpRecentMeUrls.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(referer)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3dc0f114u.toInt()
		}
	}
	
	open class TLInputSingleMedia: TLObject() {
		@JvmField var flags = 0
		@JvmField var media: InputMedia? = null
		@JvmField var randomId = 0L
		@JvmField var message: String? = null
		@JvmField val entities = mutableListOf<MessageEntity>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			media = InputMedia.deserialize(stream, stream.readInt32(exception), exception)
			randomId = stream.readInt64(exception)
			message = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
					entities.add(obj)
				}
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(flags)
			media?.serializeToStream(stream)
			stream.writeInt64(randomId)
			stream.writeString(message)
			if ((flags and 1) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1cc6e91fu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLInputSingleMedia? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLInputSingleMedia")
					}
					else {
						null
					}
				}
	
				val result = TLInputSingleMedia()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLWebAuthorization: TLObject() {
		@JvmField var hash = 0L
		@JvmField var botId = 0L
		@JvmField var domain: String? = null
		@JvmField var browser: String? = null
		@JvmField var platform: String? = null
		@JvmField var dateCreated = 0
		@JvmField var dateActive = 0
		@JvmField var ip: String? = null
		@JvmField var region: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			hash = stream.readInt64(exception)
			botId = stream.readInt64(exception)
			domain = stream.readString(exception) ?: return
			browser = stream.readString(exception) ?: return
			platform = stream.readString(exception) ?: return
			dateCreated = stream.readInt32(exception)
			dateActive = stream.readInt32(exception)
			ip = stream.readString(exception) ?: return
			region = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
			stream.writeInt64(botId)
			stream.writeString(domain)
			stream.writeString(browser)
			stream.writeString(platform)
			stream.writeInt32(dateCreated)
			stream.writeInt32(dateActive)
			stream.writeString(ip)
			stream.writeString(region)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa6f8f452u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLWebAuthorization? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLWebAuthorization")
					}
					else {
						null
					}
				}
	
				val result = TLWebAuthorization()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountWebAuthorizations: TLObject() {
		@JvmField val authorizations = mutableListOf<TLWebAuthorization>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLWebAuthorization.deserialize(stream, stream.readInt32(exception), exception) ?: return
				authorizations.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(authorizations.size)
			authorizations.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xed56c9fcu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountWebAuthorizations? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAccountWebAuthorizations")
					}
					else {
						null
					}
				}
	
				val result = TLAccountWebAuthorizations()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountGetWebAuthorizations: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountWebAuthorizations? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAccountWebAuthorizations.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x182e6d6fu.toInt()
		}
	}
	
	abstract class InputMessage: TLObject() {
		@JvmField var id = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputMessage? {
				val result = when (constructor) {
					TLInputMessageID.CONSTRUCTOR -> TLInputMessageID()
					TLInputMessageReplyTo.CONSTRUCTOR -> TLInputMessageReplyTo()
					TLInputMessagePinned.CONSTRUCTOR -> TLInputMessagePinned()
					TLInputMessageCallbackQuery.CONSTRUCTOR -> TLInputMessageCallbackQuery()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputMessage")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputMessageID: InputMessage() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa676a322u.toInt()
		}
	}
	
	open class TLInputMessageReplyTo: InputMessage() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbad88395u.toInt()
		}
	}
	
	open class TLInputMessagePinned: InputMessage() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x86872538u.toInt()
		}
	}
	
	open class TLInputMessageCallbackQuery: InputMessage() {
			@JvmField var queryId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt32(exception)
			queryId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(id)
			stream.writeInt64(queryId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xacfa1a7eu.toInt()
		}
	}
	
	abstract class InputDialogPeer: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputDialogPeer? {
				val result = when (constructor) {
					TLInputDialogPeer.CONSTRUCTOR -> TLInputDialogPeer()
					TLInputDialogPeerFolder.CONSTRUCTOR -> TLInputDialogPeerFolder()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputDialogPeer")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputDialogPeer: InputDialogPeer() {
		@JvmField var peer: InputPeer? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = InputPeer.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfcaafeb7u.toInt()
		}
	}
	
	open class TLInputDialogPeerFolder: InputDialogPeer() {
		@JvmField var folderId = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			folderId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(folderId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x64600527u.toInt()
		}
	}
	
	abstract class DialogPeer: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): DialogPeer? {
				val result = when (constructor) {
					TLDialogPeer.CONSTRUCTOR -> TLDialogPeer()
					TLDialogPeerFolder.CONSTRUCTOR -> TLDialogPeerFolder()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in DialogPeer")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLDialogPeer: DialogPeer() {
		@JvmField var peer: Peer? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe56dbf05u.toInt()
		}
	}
	
	open class TLDialogPeerFolder: DialogPeer() {
		@JvmField var folderId = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			folderId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(folderId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x514519e2u.toInt()
		}
	}
	
	abstract class MessagesFoundStickerSets: TLObject() {
		@JvmField var hash = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesFoundStickerSets? {
				val result = when (constructor) {
					TLMessagesFoundStickerSetsNotModified.CONSTRUCTOR -> TLMessagesFoundStickerSetsNotModified()
					TLMessagesFoundStickerSets.CONSTRUCTOR -> TLMessagesFoundStickerSets()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesFoundStickerSets")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesFoundStickerSetsNotModified: MessagesFoundStickerSets() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd54b65du.toInt()
		}
	}
	
	open class TLMessagesFoundStickerSets: MessagesFoundStickerSets() {
			@JvmField val sets = mutableListOf<StickerSetCovered>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			hash = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = StickerSetCovered.deserialize(stream, stream.readInt32(exception), exception) ?: return
				sets.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(sets.size)
			sets.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x8af09dd2u.toInt()
		}
	}
	
	open class TLMessagesSearchStickerSets: TLObject() {
		@JvmField var flags = 0
		@JvmField var excludeFeatured = false
		@JvmField var q: String? = null
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesFoundStickerSets? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesFoundStickerSets.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (excludeFeatured) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeString(q)
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x35705b8au.toInt()
		}
	}
	
	open class TLFileHash: TLObject() {
		@JvmField var offset = 0L
		@JvmField var limit = 0
		@JvmField var hash: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			offset = stream.readInt64(exception)
			limit = stream.readInt32(exception)
			hash = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(offset)
			stream.writeInt32(limit)
			stream.writeByteArray(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf39b035cu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLFileHash? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLFileHash")
					}
					else {
						null
					}
				}
	
				val result = TLFileHash()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLInputClientProxy: TLObject() {
		@JvmField var address: String? = null
		@JvmField var port = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			address = stream.readString(exception) ?: return
			port = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(address)
			stream.writeInt32(port)
		}
	
		companion object {
			val CONSTRUCTOR = 0x75588b3fu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLInputClientProxy? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLInputClientProxy")
					}
					else {
						null
					}
				}
	
				val result = TLInputClientProxy()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class HelpTermsOfServiceUpdate: TLObject() {
		@JvmField var expires = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpTermsOfServiceUpdate? {
				val result = when (constructor) {
					TLHelpTermsOfServiceUpdateEmpty.CONSTRUCTOR -> TLHelpTermsOfServiceUpdateEmpty()
					TLHelpTermsOfServiceUpdate.CONSTRUCTOR -> TLHelpTermsOfServiceUpdate()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in HelpTermsOfServiceUpdate")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLHelpTermsOfServiceUpdateEmpty: HelpTermsOfServiceUpdate() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			expires = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(expires)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe3309f7fu.toInt()
		}
	}
	
	open class TLHelpTermsOfServiceUpdate: HelpTermsOfServiceUpdate() {
			@JvmField var termsOfService: TLHelpTermsOfService? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			expires = stream.readInt32(exception)
			termsOfService = TLHelpTermsOfService.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(expires)
			termsOfService?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x28ecf961u.toInt()
		}
	}
	
	open class TLHelpGetTermsOfServiceUpdate: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpTermsOfServiceUpdate? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return HelpTermsOfServiceUpdate.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x2ca51fd1u.toInt()
		}
	}
	
	abstract class InputSecureFile: TLObject() {
		@JvmField var id = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputSecureFile? {
				val result = when (constructor) {
					TLInputSecureFileUploaded.CONSTRUCTOR -> TLInputSecureFileUploaded()
					TLInputSecureFile.CONSTRUCTOR -> TLInputSecureFile()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputSecureFile")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputSecureFileUploaded: InputSecureFile() {
			@JvmField var parts = 0
		@JvmField var md5Checksum: String? = null
		@JvmField var fileHash: ByteArray? = null
		@JvmField var secret: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			parts = stream.readInt32(exception)
			md5Checksum = stream.readString(exception) ?: return
			fileHash = stream.readByteArray(exception) ?: return
			secret = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt32(parts)
			stream.writeString(md5Checksum)
			stream.writeByteArray(fileHash)
			stream.writeByteArray(secret)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3334b0f0u.toInt()
		}
	}
	
	open class TLInputSecureFile: InputSecureFile() {
			@JvmField var accessHash = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5367e5beu.toInt()
		}
	}
	
	abstract class SecureFile: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): SecureFile? {
				val result = when (constructor) {
					TLSecureFileEmpty.CONSTRUCTOR -> TLSecureFileEmpty()
					TLSecureFile.CONSTRUCTOR -> TLSecureFile()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in SecureFile")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLSecureFileEmpty: SecureFile() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x64199744u.toInt()
		}
	}
	
	open class TLSecureFile: SecureFile() {
		@JvmField var id = 0L
		@JvmField var accessHash = 0L
		@JvmField var size = 0L
		@JvmField var dcId = 0
		@JvmField var date = 0
		@JvmField var fileHash: ByteArray? = null
		@JvmField var secret: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			size = stream.readInt64(exception)
			dcId = stream.readInt32(exception)
			date = stream.readInt32(exception)
			fileHash = stream.readByteArray(exception) ?: return
			secret = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeInt64(size)
			stream.writeInt32(dcId)
			stream.writeInt32(date)
			stream.writeByteArray(fileHash)
			stream.writeByteArray(secret)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7d09c27eu.toInt()
		}
	}
	
	open class TLSecureData: TLObject() {
		@JvmField var data: ByteArray? = null
		@JvmField var dataHash: ByteArray? = null
		@JvmField var secret: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			data = stream.readByteArray(exception) ?: return
			dataHash = stream.readByteArray(exception) ?: return
			secret = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteArray(data)
			stream.writeByteArray(dataHash)
			stream.writeByteArray(secret)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8aeabec3u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLSecureData? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLSecureData")
					}
					else {
						null
					}
				}
	
				val result = TLSecureData()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class SecurePlainData: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): SecurePlainData? {
				val result = when (constructor) {
					TLSecurePlainPhone.CONSTRUCTOR -> TLSecurePlainPhone()
					TLSecurePlainEmail.CONSTRUCTOR -> TLSecurePlainEmail()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in SecurePlainData")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLSecurePlainPhone: SecurePlainData() {
		@JvmField var phone: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			phone = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phone)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7d6099ddu.toInt()
		}
	}
	
	open class TLSecurePlainEmail: SecurePlainData() {
		@JvmField var email: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			email = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(email)
		}
	
		companion object {
			val CONSTRUCTOR = 0x21ec5a5fu.toInt()
		}
	}
	
	abstract class SecureValueType: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): SecureValueType? {
				val result = when (constructor) {
					TLSecureValueTypePersonalDetails.CONSTRUCTOR -> TLSecureValueTypePersonalDetails()
					TLSecureValueTypePassport.CONSTRUCTOR -> TLSecureValueTypePassport()
					TLSecureValueTypeDriverLicense.CONSTRUCTOR -> TLSecureValueTypeDriverLicense()
					TLSecureValueTypeIdentityCard.CONSTRUCTOR -> TLSecureValueTypeIdentityCard()
					TLSecureValueTypeInternalPassport.CONSTRUCTOR -> TLSecureValueTypeInternalPassport()
					TLSecureValueTypeAddress.CONSTRUCTOR -> TLSecureValueTypeAddress()
					TLSecureValueTypeUtilityBill.CONSTRUCTOR -> TLSecureValueTypeUtilityBill()
					TLSecureValueTypeBankStatement.CONSTRUCTOR -> TLSecureValueTypeBankStatement()
					TLSecureValueTypeRentalAgreement.CONSTRUCTOR -> TLSecureValueTypeRentalAgreement()
					TLSecureValueTypePassportRegistration.CONSTRUCTOR -> TLSecureValueTypePassportRegistration()
					TLSecureValueTypeTemporaryRegistration.CONSTRUCTOR -> TLSecureValueTypeTemporaryRegistration()
					TLSecureValueTypePhone.CONSTRUCTOR -> TLSecureValueTypePhone()
					TLSecureValueTypeEmail.CONSTRUCTOR -> TLSecureValueTypeEmail()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in SecureValueType")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLSecureValueTypePersonalDetails: SecureValueType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9d2a81e3u.toInt()
		}
	}
	
	open class TLSecureValueTypePassport: SecureValueType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3dac6a00u.toInt()
		}
	}
	
	open class TLSecureValueTypeDriverLicense: SecureValueType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x6e425c4u.toInt()
		}
	}
	
	open class TLSecureValueTypeIdentityCard: SecureValueType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa0d0744bu.toInt()
		}
	}
	
	open class TLSecureValueTypeInternalPassport: SecureValueType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x99a48f23u.toInt()
		}
	}
	
	open class TLSecureValueTypeAddress: SecureValueType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xcbe31e26u.toInt()
		}
	}
	
	open class TLSecureValueTypeUtilityBill: SecureValueType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xfc36954eu.toInt()
		}
	}
	
	open class TLSecureValueTypeBankStatement: SecureValueType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x89137c0du.toInt()
		}
	}
	
	open class TLSecureValueTypeRentalAgreement: SecureValueType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8b883488u.toInt()
		}
	}
	
	open class TLSecureValueTypePassportRegistration: SecureValueType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x99e3806au.toInt()
		}
	}
	
	open class TLSecureValueTypeTemporaryRegistration: SecureValueType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xea02ec33u.toInt()
		}
	}
	
	open class TLSecureValueTypePhone: SecureValueType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb320aadbu.toInt()
		}
	}
	
	open class TLSecureValueTypeEmail: SecureValueType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8e3ca7eeu.toInt()
		}
	}
	
	open class TLSecureValue: TLObject() {
		@JvmField var flags = 0
		@JvmField var type: SecureValueType? = null
		@JvmField var data: TLSecureData? = null
		@JvmField var frontSide: SecureFile? = null
		@JvmField var reverseSide: SecureFile? = null
		@JvmField var selfie: SecureFile? = null
		@JvmField val translation = mutableListOf<SecureFile>()
		@JvmField val files = mutableListOf<SecureFile>()
		@JvmField var plainData: SecurePlainData? = null
		@JvmField var hash: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			type = SecureValueType.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				data = TLSecureData.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				frontSide = SecureFile.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 4) != 0) {
				reverseSide = SecureFile.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 8) != 0) {
				selfie = SecureFile.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 64) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = SecureFile.deserialize(stream, stream.readInt32(exception), exception) ?: return
					translation.add(obj)
				}
			}
		
			if ((flags and 16) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = SecureFile.deserialize(stream, stream.readInt32(exception), exception) ?: return
					files.add(obj)
				}
			}
		
			if ((flags and 32) != 0) {
				plainData = SecurePlainData.deserialize(stream, stream.readInt32(exception), exception)
			}
			hash = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (data != null) flags or 1 else flags and 1.inv()
			flags = if (frontSide != null) flags or 2 else flags and 2.inv()
			flags = if (reverseSide != null) flags or 4 else flags and 4.inv()
			flags = if (selfie != null) flags or 8 else flags and 8.inv()
			flags = if (plainData != null) flags or 32 else flags and 32.inv()
	
			stream.writeInt32(flags)
			type?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				data?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				frontSide?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				reverseSide?.serializeToStream(stream)
			}
	
			if ((flags and 8) != 0) {
				selfie?.serializeToStream(stream)
			}
	
			if ((flags and 64) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(translation.size)
			translation.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 16) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(files.size)
			files.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 32) != 0) {
				plainData?.serializeToStream(stream)
			}
	
			stream.writeByteArray(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x187fa0cau.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLSecureValue? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLSecureValue")
					}
					else {
						null
					}
				}
	
				val result = TLSecureValue()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountSaveSecureValue: TLObject() {
		@JvmField var value: TLInputSecureValue? = null
		@JvmField var secureSecretId = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLSecureValue? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLSecureValue.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			value?.serializeToStream(stream)
			stream.writeInt64(secureSecretId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x899fe31du.toInt()
		}
	}
	
	open class TLInputSecureValue: TLObject() {
		@JvmField var flags = 0
		@JvmField var type: SecureValueType? = null
		@JvmField var data: TLSecureData? = null
		@JvmField var frontSide: InputSecureFile? = null
		@JvmField var reverseSide: InputSecureFile? = null
		@JvmField var selfie: InputSecureFile? = null
		@JvmField val translation = mutableListOf<InputSecureFile>()
		@JvmField val files = mutableListOf<InputSecureFile>()
		@JvmField var plainData: SecurePlainData? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			type = SecureValueType.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				data = TLSecureData.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				frontSide = InputSecureFile.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 4) != 0) {
				reverseSide = InputSecureFile.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 8) != 0) {
				selfie = InputSecureFile.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 64) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = InputSecureFile.deserialize(stream, stream.readInt32(exception), exception) ?: return
					translation.add(obj)
				}
			}
		
			if ((flags and 16) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = InputSecureFile.deserialize(stream, stream.readInt32(exception), exception) ?: return
					files.add(obj)
				}
			}
		
			if ((flags and 32) != 0) {
				plainData = SecurePlainData.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (data != null) flags or 1 else flags and 1.inv()
			flags = if (frontSide != null) flags or 2 else flags and 2.inv()
			flags = if (reverseSide != null) flags or 4 else flags and 4.inv()
			flags = if (selfie != null) flags or 8 else flags and 8.inv()
			flags = if (plainData != null) flags or 32 else flags and 32.inv()
	
			stream.writeInt32(flags)
			type?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				data?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				frontSide?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				reverseSide?.serializeToStream(stream)
			}
	
			if ((flags and 8) != 0) {
				selfie?.serializeToStream(stream)
			}
	
			if ((flags and 64) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(translation.size)
			translation.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 16) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(files.size)
			files.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 32) != 0) {
				plainData?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xdb21d0a7u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLInputSecureValue? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLInputSecureValue")
					}
					else {
						null
					}
				}
	
				val result = TLInputSecureValue()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLSecureValueHash: TLObject() {
		@JvmField var type: SecureValueType? = null
		@JvmField var hash: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = SecureValueType.deserialize(stream, stream.readInt32(exception), exception)
			hash = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			type?.serializeToStream(stream)
			stream.writeByteArray(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xed1ecdb0u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLSecureValueHash? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLSecureValueHash")
					}
					else {
						null
					}
				}
	
				val result = TLSecureValueHash()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class SecureValueError: TLObject() {
		@JvmField var type: SecureValueType? = null
		@JvmField var text: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): SecureValueError? {
				val result = when (constructor) {
					TLSecureValueErrorData.CONSTRUCTOR -> TLSecureValueErrorData()
					TLSecureValueErrorFrontSide.CONSTRUCTOR -> TLSecureValueErrorFrontSide()
					TLSecureValueErrorReverseSide.CONSTRUCTOR -> TLSecureValueErrorReverseSide()
					TLSecureValueErrorSelfie.CONSTRUCTOR -> TLSecureValueErrorSelfie()
					TLSecureValueErrorFile.CONSTRUCTOR -> TLSecureValueErrorFile()
					TLSecureValueErrorFiles.CONSTRUCTOR -> TLSecureValueErrorFiles()
					TLSecureValueError.CONSTRUCTOR -> TLSecureValueError()
					TLSecureValueErrorTranslationFile.CONSTRUCTOR -> TLSecureValueErrorTranslationFile()
					TLSecureValueErrorTranslationFiles.CONSTRUCTOR -> TLSecureValueErrorTranslationFiles()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in SecureValueError")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLSecureValueErrorData: SecureValueError() {
			@JvmField var dataHash: ByteArray? = null
		@JvmField var field: String? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = SecureValueType.deserialize(stream, stream.readInt32(exception), exception)
			dataHash = stream.readByteArray(exception) ?: return
			field = stream.readString(exception) ?: return
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			type?.serializeToStream(stream)
			stream.writeByteArray(dataHash)
			stream.writeString(field)
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe8a40bd9u.toInt()
		}
	}
	
	open class TLSecureValueErrorFrontSide: SecureValueError() {
			@JvmField var fileHash: ByteArray? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = SecureValueType.deserialize(stream, stream.readInt32(exception), exception)
			fileHash = stream.readByteArray(exception) ?: return
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			type?.serializeToStream(stream)
			stream.writeByteArray(fileHash)
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbe3dfau.toInt()
		}
	}
	
	open class TLSecureValueErrorReverseSide: SecureValueError() {
			@JvmField var fileHash: ByteArray? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = SecureValueType.deserialize(stream, stream.readInt32(exception), exception)
			fileHash = stream.readByteArray(exception) ?: return
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			type?.serializeToStream(stream)
			stream.writeByteArray(fileHash)
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0x868a2aa5u.toInt()
		}
	}
	
	open class TLSecureValueErrorSelfie: SecureValueError() {
			@JvmField var fileHash: ByteArray? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = SecureValueType.deserialize(stream, stream.readInt32(exception), exception)
			fileHash = stream.readByteArray(exception) ?: return
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			type?.serializeToStream(stream)
			stream.writeByteArray(fileHash)
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe537ced6u.toInt()
		}
	}
	
	open class TLSecureValueErrorFile: SecureValueError() {
			@JvmField var fileHash: ByteArray? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = SecureValueType.deserialize(stream, stream.readInt32(exception), exception)
			fileHash = stream.readByteArray(exception) ?: return
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			type?.serializeToStream(stream)
			stream.writeByteArray(fileHash)
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7a700873u.toInt()
		}
	}
	
	open class TLSecureValueErrorFiles: SecureValueError() {
			@JvmField val fileHash = mutableListOf<ByteArray>()
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = SecureValueType.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readByteArray(exception) ?: return
				fileHash.add(obj)
			}
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			type?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(fileHash.size)
			fileHash.forEach { stream.writeByteArray(it) }
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0x666220e9u.toInt()
		}
	}
	
	open class TLSecureValueError: SecureValueError() {
			@JvmField var hash: ByteArray? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = SecureValueType.deserialize(stream, stream.readInt32(exception), exception)
			hash = stream.readByteArray(exception) ?: return
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			type?.serializeToStream(stream)
			stream.writeByteArray(hash)
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0x869d758fu.toInt()
		}
	}
	
	open class TLSecureValueErrorTranslationFile: SecureValueError() {
			@JvmField var fileHash: ByteArray? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = SecureValueType.deserialize(stream, stream.readInt32(exception), exception)
			fileHash = stream.readByteArray(exception) ?: return
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			type?.serializeToStream(stream)
			stream.writeByteArray(fileHash)
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa1144770u.toInt()
		}
	}
	
	open class TLSecureValueErrorTranslationFiles: SecureValueError() {
			@JvmField val fileHash = mutableListOf<ByteArray>()
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = SecureValueType.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readByteArray(exception) ?: return
				fileHash.add(obj)
			}
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			type?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(fileHash.size)
			fileHash.forEach { stream.writeByteArray(it) }
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0x34636dd8u.toInt()
		}
	}
	
	open class TLSecureCredentialsEncrypted: TLObject() {
		@JvmField var data: ByteArray? = null
		@JvmField var hash: ByteArray? = null
		@JvmField var secret: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			data = stream.readByteArray(exception) ?: return
			hash = stream.readByteArray(exception) ?: return
			secret = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteArray(data)
			stream.writeByteArray(hash)
			stream.writeByteArray(secret)
		}
	
		companion object {
			val CONSTRUCTOR = 0x33f0ea47u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLSecureCredentialsEncrypted? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLSecureCredentialsEncrypted")
					}
					else {
						null
					}
				}
	
				val result = TLSecureCredentialsEncrypted()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountAuthorizationForm: TLObject() {
		@JvmField var flags = 0
		@JvmField val requiredTypes = mutableListOf<SecureRequiredType>()
		@JvmField val values = mutableListOf<TLSecureValue>()
		@JvmField val errors = mutableListOf<SecureValueError>()
		@JvmField val users = mutableListOf<User>()
		@JvmField var privacyPolicyUrl: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = SecureRequiredType.deserialize(stream, stream.readInt32(exception), exception) ?: return
				requiredTypes.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLSecureValue.deserialize(stream, stream.readInt32(exception), exception) ?: return
				values.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = SecureValueError.deserialize(stream, stream.readInt32(exception), exception) ?: return
				errors.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		
			if ((flags and 1) != 0) {
				privacyPolicyUrl = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (privacyPolicyUrl != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(requiredTypes.size)
			requiredTypes.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(values.size)
			values.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(errors.size)
			errors.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
			if ((flags and 1) != 0) {
				stream.writeString(privacyPolicyUrl)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xad2e1cd8u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountAuthorizationForm? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAccountAuthorizationForm")
					}
					else {
						null
					}
				}
	
				val result = TLAccountAuthorizationForm()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountGetAuthorizationForm: TLObject() {
		@JvmField var botId = 0L
		@JvmField var scope: String? = null
		@JvmField var publicKey: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountAuthorizationForm? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAccountAuthorizationForm.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(botId)
			stream.writeString(scope)
			stream.writeString(publicKey)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa929597au.toInt()
		}
	}
	
	open class TLAccountSentEmailCode: TLObject() {
		@JvmField var emailPattern: String? = null
		@JvmField var length = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			emailPattern = stream.readString(exception) ?: return
			length = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(emailPattern)
			stream.writeInt32(length)
		}
	
		companion object {
			val CONSTRUCTOR = 0x811f854fu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountSentEmailCode? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAccountSentEmailCode")
					}
					else {
						null
					}
				}
	
				val result = TLAccountSentEmailCode()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountSendVerifyEmailCode: TLObject() {
		@JvmField var purpose: EmailVerifyPurpose? = null
		@JvmField var email: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountSentEmailCode? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAccountSentEmailCode.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			purpose?.serializeToStream(stream)
			stream.writeString(email)
		}
	
		companion object {
			val CONSTRUCTOR = 0x98e037bbu.toInt()
		}
	}
	
	abstract class HelpDeepLinkInfo: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpDeepLinkInfo? {
				val result = when (constructor) {
					TLHelpDeepLinkInfoEmpty.CONSTRUCTOR -> TLHelpDeepLinkInfoEmpty()
					TLHelpDeepLinkInfo.CONSTRUCTOR -> TLHelpDeepLinkInfo()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in HelpDeepLinkInfo")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLHelpDeepLinkInfoEmpty: HelpDeepLinkInfo() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x66afa166u.toInt()
		}
	}
	
	open class TLHelpDeepLinkInfo: HelpDeepLinkInfo() {
		@JvmField var flags = 0
		@JvmField var updateApp = false
		@JvmField var message: String? = null
		@JvmField val entities = mutableListOf<MessageEntity>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			updateApp = (flags and 1) != 0
			message = stream.readString(exception) ?: return
		
			if ((flags and 2) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
					entities.add(obj)
				}
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (updateApp) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeString(message)
			if ((flags and 2) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x6a4ee832u.toInt()
		}
	}
	
	open class TLHelpGetDeepLinkInfo: TLObject() {
		@JvmField var path: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpDeepLinkInfo? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return HelpDeepLinkInfo.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(path)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3fedc75fu.toInt()
		}
	}
	
	open class TLSavedContact: TLObject() {
		@JvmField var phone: String? = null
		@JvmField var firstName: String? = null
		@JvmField var lastName: String? = null
		@JvmField var date = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			phone = stream.readString(exception) ?: return
			firstName = stream.readString(exception) ?: return
			lastName = stream.readString(exception) ?: return
			date = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phone)
			stream.writeString(firstName)
			stream.writeString(lastName)
			stream.writeInt32(date)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1142bd56u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLSavedContact? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLSavedContact")
					}
					else {
						null
					}
				}
	
				val result = TLSavedContact()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountTakeout: TLObject() {
		@JvmField var id = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4dba4501u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountTakeout? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAccountTakeout")
					}
					else {
						null
					}
				}
	
				val result = TLAccountTakeout()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountInitTakeoutSession: TLObject() {
		@JvmField var flags = 0
		@JvmField var contacts = false
		@JvmField var messageUsers = false
		@JvmField var messageChats = false
		@JvmField var messageMegagroups = false
		@JvmField var messageChannels = false
		@JvmField var files = false
		@JvmField var fileMaxSize = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountTakeout? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAccountTakeout.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (contacts) flags or 1 else flags and 1.inv()
			flags = if (messageUsers) flags or 2 else flags and 2.inv()
			flags = if (messageChats) flags or 4 else flags and 4.inv()
			flags = if (messageMegagroups) flags or 8 else flags and 8.inv()
			flags = if (messageChannels) flags or 16 else flags and 16.inv()
			flags = if (files) flags or 32 else flags and 32.inv()
			flags = if (fileMaxSize != 0L) flags or 32 else flags and 32.inv()
	
			stream.writeInt32(flags)
			if ((flags and 32) != 0) {
				stream.writeInt64(fileMaxSize)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8ef3eab0u.toInt()
		}
	}
	
	abstract class PasswordKdfAlgo: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PasswordKdfAlgo? {
				val result = when (constructor) {
					TLPasswordKdfAlgoUnknown.CONSTRUCTOR -> TLPasswordKdfAlgoUnknown()
					TLPasswordKdfAlgoModPow.CONSTRUCTOR -> TLPasswordKdfAlgoModPow()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in PasswordKdfAlgo")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPasswordKdfAlgoUnknown: PasswordKdfAlgo() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd45ab096u.toInt()
		}
	}
	
	open class TLPasswordKdfAlgoModPow: PasswordKdfAlgo() {
		@JvmField var salt1: ByteArray? = null
		@JvmField var salt2: ByteArray? = null
		@JvmField var g = 0
		@JvmField var p: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			salt1 = stream.readByteArray(exception) ?: return
			salt2 = stream.readByteArray(exception) ?: return
			g = stream.readInt32(exception)
			p = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteArray(salt1)
			stream.writeByteArray(salt2)
			stream.writeInt32(g)
			stream.writeByteArray(p)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3a912d4au.toInt()
		}
	}
	
	abstract class SecurePasswordKdfAlgo: TLObject() {
		@JvmField var salt: ByteArray? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): SecurePasswordKdfAlgo? {
				val result = when (constructor) {
					TLSecurePasswordKdfAlgoUnknown.CONSTRUCTOR -> TLSecurePasswordKdfAlgoUnknown()
					TLSecurePasswordKdfAlgoPBKDF2.CONSTRUCTOR -> TLSecurePasswordKdfAlgoPBKDF2()
					TLSecurePasswordKdfAlgoSHA512.CONSTRUCTOR -> TLSecurePasswordKdfAlgoSHA512()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in SecurePasswordKdfAlgo")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLSecurePasswordKdfAlgoUnknown: SecurePasswordKdfAlgo() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x4a8537u.toInt()
		}
	}
	
	open class TLSecurePasswordKdfAlgoPBKDF2: SecurePasswordKdfAlgo() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			salt = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteArray(salt)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbbf2dda0u.toInt()
		}
	}
	
	open class TLSecurePasswordKdfAlgoSHA512: SecurePasswordKdfAlgo() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			salt = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteArray(salt)
		}
	
		companion object {
			val CONSTRUCTOR = 0x86471d92u.toInt()
		}
	}
	
	open class TLSecureSecretSettings: TLObject() {
		@JvmField var secureAlgo: SecurePasswordKdfAlgo? = null
		@JvmField var secureSecret: ByteArray? = null
		@JvmField var secureSecretId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			secureAlgo = SecurePasswordKdfAlgo.deserialize(stream, stream.readInt32(exception), exception)
			secureSecret = stream.readByteArray(exception) ?: return
			secureSecretId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			secureAlgo?.serializeToStream(stream)
			stream.writeByteArray(secureSecret)
			stream.writeInt64(secureSecretId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1527bcacu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLSecureSecretSettings? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLSecureSecretSettings")
					}
					else {
						null
					}
				}
	
				val result = TLSecureSecretSettings()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class InputCheckPasswordSRP: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputCheckPasswordSRP? {
				val result = when (constructor) {
					TLInputCheckPasswordEmpty.CONSTRUCTOR -> TLInputCheckPasswordEmpty()
					TLInputCheckPasswordSRP.CONSTRUCTOR -> TLInputCheckPasswordSRP()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputCheckPasswordSRP")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputCheckPasswordEmpty: InputCheckPasswordSRP() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9880f658u.toInt()
		}
	}
	
	open class TLInputCheckPasswordSRP: InputCheckPasswordSRP() {
		@JvmField var srpId = 0L
		@JvmField var a: ByteArray? = null
		@JvmField var m1: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			srpId = stream.readInt64(exception)
			a = stream.readByteArray(exception) ?: return
			m1 = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(srpId)
			stream.writeByteArray(a)
			stream.writeByteArray(m1)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd27ff082u.toInt()
		}
	}
	
	abstract class SecureRequiredType: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): SecureRequiredType? {
				val result = when (constructor) {
					TLSecureRequiredType.CONSTRUCTOR -> TLSecureRequiredType()
					TLSecureRequiredTypeOneOf.CONSTRUCTOR -> TLSecureRequiredTypeOneOf()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in SecureRequiredType")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLSecureRequiredType: SecureRequiredType() {
		@JvmField var flags = 0
		@JvmField var nativeNames = false
		@JvmField var selfieRequired = false
		@JvmField var translationRequired = false
		@JvmField var type: SecureValueType? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			nativeNames = (flags and 1) != 0
			selfieRequired = (flags and 2) != 0
			translationRequired = (flags and 4) != 0
			type = SecureValueType.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (nativeNames) flags or 1 else flags and 1.inv()
			flags = if (selfieRequired) flags or 2 else flags and 2.inv()
			flags = if (translationRequired) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			type?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x829d99dau.toInt()
		}
	}
	
	open class TLSecureRequiredTypeOneOf: SecureRequiredType() {
		@JvmField val types = mutableListOf<SecureRequiredType>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = SecureRequiredType.deserialize(stream, stream.readInt32(exception), exception) ?: return
				types.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(types.size)
			types.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x27477b4u.toInt()
		}
	}
	
	abstract class HelpPassportConfig: TLObject() {
		@JvmField var hash = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpPassportConfig? {
				val result = when (constructor) {
					TLHelpPassportConfigNotModified.CONSTRUCTOR -> TLHelpPassportConfigNotModified()
					TLHelpPassportConfig.CONSTRUCTOR -> TLHelpPassportConfig()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in HelpPassportConfig")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLHelpPassportConfigNotModified: HelpPassportConfig() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xbfb9f457u.toInt()
		}
	}
	
	open class TLHelpPassportConfig: HelpPassportConfig() {
			@JvmField var countriesLangs: TLDataJSON? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			hash = stream.readInt32(exception)
			countriesLangs = TLDataJSON.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(hash)
			countriesLangs?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa098d6afu.toInt()
		}
	}
	
	open class TLHelpGetPassportConfig: TLObject() {
		@JvmField var hash = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpPassportConfig? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return HelpPassportConfig.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc661ad08u.toInt()
		}
	}
	
	open class TLInputAppEvent: TLObject() {
		@JvmField var time = 0.0
		@JvmField var type: String? = null
		@JvmField var peer = 0L
		@JvmField var data: JSONValue? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			time = stream.readDouble(exception)
			type = stream.readString(exception) ?: return
			peer = stream.readInt64(exception)
			data = JSONValue.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeDouble(time)
			stream.writeString(type)
			stream.writeInt64(peer)
			data?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1d1b1245u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLInputAppEvent? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLInputAppEvent")
					}
					else {
						null
					}
				}
	
				val result = TLInputAppEvent()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLJsonObjectValue: TLObject() {
		@JvmField var key: String? = null
		@JvmField var value: JSONValue? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			key = stream.readString(exception) ?: return
			value = JSONValue.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(key)
			value?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc0de1bd9u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLJsonObjectValue? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLJsonObjectValue")
					}
					else {
						null
					}
				}
	
				val result = TLJsonObjectValue()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class JSONValue: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): JSONValue? {
				val result = when (constructor) {
					TLJsonNull.CONSTRUCTOR -> TLJsonNull()
					TLJsonBool.CONSTRUCTOR -> TLJsonBool()
					TLJsonNumber.CONSTRUCTOR -> TLJsonNumber()
					TLJsonString.CONSTRUCTOR -> TLJsonString()
					TLJsonArray.CONSTRUCTOR -> TLJsonArray()
					TLJsonObject.CONSTRUCTOR -> TLJsonObject()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in JSONValue")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLJsonNull: JSONValue() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3f6d7b68u.toInt()
		}
	}
	
	open class TLJsonBool: JSONValue() {
		@JvmField var value = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			value = stream.readBool(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeBool(value)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc7345e6au.toInt()
		}
	}
	
	open class TLJsonNumber: JSONValue() {
		@JvmField var value = 0.0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			value = stream.readDouble(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeDouble(value)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2be0dfa4u.toInt()
		}
	}
	
	open class TLJsonString: JSONValue() {
		@JvmField var value: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			value = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(value)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb71e767au.toInt()
		}
	}
	
	open class TLJsonArray: JSONValue() {
		@JvmField val value = mutableListOf<JSONValue>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = JSONValue.deserialize(stream, stream.readInt32(exception), exception) ?: return
				value.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(value.size)
			value.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xf7444763u.toInt()
		}
	}
	
	open class TLJsonObject: JSONValue() {
		@JvmField val value = mutableListOf<TLJsonObjectValue>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLJsonObjectValue.deserialize(stream, stream.readInt32(exception), exception) ?: return
				value.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(value.size)
			value.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x99c1d49du.toInt()
		}
	}
	
	open class TLHelpGetAppConfig: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): JSONValue? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return JSONValue.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x98914110u.toInt()
		}
	}
	
	open class TLPageTableCell: TLObject() {
		@JvmField var flags = 0
		@JvmField var header = false
		@JvmField var alignCenter = false
		@JvmField var alignRight = false
		@JvmField var valignMiddle = false
		@JvmField var valignBottom = false
		@JvmField var text: RichText? = null
		@JvmField var colspan = 0
		@JvmField var rowspan = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			header = (flags and 1) != 0
			alignCenter = (flags and 8) != 0
			alignRight = (flags and 16) != 0
			valignMiddle = (flags and 32) != 0
			valignBottom = (flags and 64) != 0
		
			if ((flags and 128) != 0) {
				text = RichText.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				colspan = stream.readInt32(exception)
			}
		
			if ((flags and 4) != 0) {
				rowspan = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (header) flags or 1 else flags and 1.inv()
			flags = if (alignCenter) flags or 8 else flags and 8.inv()
			flags = if (alignRight) flags or 16 else flags and 16.inv()
			flags = if (valignMiddle) flags or 32 else flags and 32.inv()
			flags = if (valignBottom) flags or 64 else flags and 64.inv()
			flags = if (text != null) flags or 128 else flags and 128.inv()
			flags = if (colspan != 0) flags or 2 else flags and 2.inv()
			flags = if (rowspan != 0) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			if ((flags and 128) != 0) {
				text?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(colspan)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(rowspan)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x34566b6au.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPageTableCell? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPageTableCell")
					}
					else {
						null
					}
				}
	
				val result = TLPageTableCell()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPageTableRow: TLObject() {
		@JvmField val cells = mutableListOf<TLPageTableCell>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLPageTableCell.deserialize(stream, stream.readInt32(exception), exception) ?: return
				cells.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(cells.size)
			cells.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xe0c0c5e5u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPageTableRow? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPageTableRow")
					}
					else {
						null
					}
				}
	
				val result = TLPageTableRow()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPageCaption: TLObject() {
		@JvmField var text: RichText? = null
		@JvmField var credit: RichText? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
			credit = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
			credit?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6f747657u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPageCaption? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPageCaption")
					}
					else {
						null
					}
				}
	
				val result = TLPageCaption()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class PageListItem: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PageListItem? {
				val result = when (constructor) {
					TLPageListItemText.CONSTRUCTOR -> TLPageListItemText()
					TLPageListItemBlocks.CONSTRUCTOR -> TLPageListItemBlocks()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in PageListItem")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPageListItemText: PageListItem() {
		@JvmField var text: RichText? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			text?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb92fb6cdu.toInt()
		}
	}
	
	open class TLPageListItemBlocks: PageListItem() {
		@JvmField val blocks = mutableListOf<PageBlock>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = PageBlock.deserialize(stream, stream.readInt32(exception), exception) ?: return
				blocks.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(blocks.size)
			blocks.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x25e073fcu.toInt()
		}
	}
	
	abstract class PageListOrderedItem: TLObject() {
		@JvmField var num: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PageListOrderedItem? {
				val result = when (constructor) {
					TLPageListOrderedItemText.CONSTRUCTOR -> TLPageListOrderedItemText()
					TLPageListOrderedItemBlocks.CONSTRUCTOR -> TLPageListOrderedItemBlocks()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in PageListOrderedItem")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPageListOrderedItemText: PageListOrderedItem() {
			@JvmField var text: RichText? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			num = stream.readString(exception) ?: return
			text = RichText.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(num)
			text?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5e068047u.toInt()
		}
	}
	
	open class TLPageListOrderedItemBlocks: PageListOrderedItem() {
			@JvmField val blocks = mutableListOf<PageBlock>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			num = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = PageBlock.deserialize(stream, stream.readInt32(exception), exception) ?: return
				blocks.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(num)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(blocks.size)
			blocks.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x98dd8936u.toInt()
		}
	}
	
	open class TLPageRelatedArticle: TLObject() {
		@JvmField var flags = 0
		@JvmField var url: String? = null
		@JvmField var webpageId = 0L
		@JvmField var title: String? = null
		@JvmField var description: String? = null
		@JvmField var photoId = 0L
		@JvmField var author: String? = null
		@JvmField var publishedDate = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			url = stream.readString(exception) ?: return
			webpageId = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {
				title = stream.readString(exception) ?: return
			}
		
			if ((flags and 2) != 0) {
				description = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				photoId = stream.readInt64(exception)
			}
		
			if ((flags and 8) != 0) {
				author = stream.readString(exception) ?: return
			}
		
			if ((flags and 16) != 0) {
				publishedDate = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (title != null) flags or 1 else flags and 1.inv()
			flags = if (description != null) flags or 2 else flags and 2.inv()
			flags = if (photoId != 0L) flags or 4 else flags and 4.inv()
			flags = if (author != null) flags or 8 else flags and 8.inv()
			flags = if (publishedDate != 0) flags or 16 else flags and 16.inv()
	
			stream.writeInt32(flags)
			stream.writeString(url)
			stream.writeInt64(webpageId)
			if ((flags and 1) != 0) {
				stream.writeString(title)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(description)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt64(photoId)
			}
	
			if ((flags and 8) != 0) {
				stream.writeString(author)
			}
	
			if ((flags and 16) != 0) {
				stream.writeInt32(publishedDate)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb390dc08u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPageRelatedArticle? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPageRelatedArticle")
					}
					else {
						null
					}
				}
	
				val result = TLPageRelatedArticle()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPage: TLObject() {
		@JvmField var flags = 0
		@JvmField var part = false
		@JvmField var rtl = false
		@JvmField var v2 = false
		@JvmField var url: String? = null
		@JvmField val blocks = mutableListOf<PageBlock>()
		@JvmField val photos = mutableListOf<Photo>()
		@JvmField val documents = mutableListOf<Document>()
		@JvmField var views = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			part = (flags and 1) != 0
			rtl = (flags and 2) != 0
			v2 = (flags and 4) != 0
			url = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = PageBlock.deserialize(stream, stream.readInt32(exception), exception) ?: return
				blocks.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Photo.deserialize(stream, stream.readInt32(exception), exception) ?: return
				photos.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Document.deserialize(stream, stream.readInt32(exception), exception) ?: return
				documents.add(obj)
			}
		
			if ((flags and 8) != 0) {
				views = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (part) flags or 1 else flags and 1.inv()
			flags = if (rtl) flags or 2 else flags and 2.inv()
			flags = if (v2) flags or 4 else flags and 4.inv()
			flags = if (views != 0) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			stream.writeString(url)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(blocks.size)
			blocks.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(photos.size)
			photos.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(documents.size)
			documents.forEach { it.serializeToStream(stream) }
			if ((flags and 8) != 0) {
				stream.writeInt32(views)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x98657f0du.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPage? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPage")
					}
					else {
						null
					}
				}
	
				val result = TLPage()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLHelpSupportName: TLObject() {
		@JvmField var name: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			name = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(name)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8c05f1c9u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLHelpSupportName? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLHelpSupportName")
					}
					else {
						null
					}
				}
	
				val result = TLHelpSupportName()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLHelpGetSupportName: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLHelpSupportName? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLHelpSupportName.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd360e72cu.toInt()
		}
	}
	
	abstract class HelpUserInfo: TLObject() {
		@JvmField var message: String? = null
		@JvmField val entities = mutableListOf<MessageEntity>()
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpUserInfo? {
				val result = when (constructor) {
					TLHelpUserInfoEmpty.CONSTRUCTOR -> TLHelpUserInfoEmpty()
					TLHelpUserInfo.CONSTRUCTOR -> TLHelpUserInfo()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in HelpUserInfo")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLHelpUserInfoEmpty: HelpUserInfo() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf3ae2eedu.toInt()
		}
	}
	
	open class TLHelpUserInfo: HelpUserInfo() {
				@JvmField var author: String? = null
		@JvmField var date = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			message = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
				entities.add(obj)
			}
			author = stream.readString(exception) ?: return
			date = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(message)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			stream.writeString(author)
			stream.writeInt32(date)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1eb3758u.toInt()
		}
	}
	
	open class TLHelpGetUserInfo: TLObject() {
		@JvmField var userId: InputUser? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpUserInfo? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return HelpUserInfo.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			userId?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x38a08d3u.toInt()
		}
	}
	
	open class TLHelpEditUserInfo: TLObject() {
		@JvmField var userId: InputUser? = null
		@JvmField var message: String? = null
		@JvmField val entities = mutableListOf<MessageEntity>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpUserInfo? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return HelpUserInfo.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			userId?.serializeToStream(stream)
			stream.writeString(message)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x66b91b70u.toInt()
		}
	}
	
	open class TLPollAnswer: TLObject() {
		@JvmField var text: String? = null
		@JvmField var option: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = stream.readString(exception) ?: return
			option = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(text)
			stream.writeByteArray(option)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6ca9c2e9u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPollAnswer? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPollAnswer")
					}
					else {
						null
					}
				}
	
				val result = TLPollAnswer()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPoll: TLObject() {
		@JvmField var id = 0L
		@JvmField var flags = 0
		@JvmField var closed = false
		@JvmField var publicVoters = false
		@JvmField var multipleChoice = false
		@JvmField var quiz = false
		@JvmField var question: String? = null
		@JvmField val answers = mutableListOf<TLPollAnswer>()
		@JvmField var closePeriod = 0
		@JvmField var closeDate = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			flags = stream.readInt32(exception)
			closed = (flags and 1) != 0
			publicVoters = (flags and 2) != 0
			multipleChoice = (flags and 4) != 0
			quiz = (flags and 8) != 0
			question = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLPollAnswer.deserialize(stream, stream.readInt32(exception), exception) ?: return
				answers.add(obj)
			}
		
			if ((flags and 16) != 0) {
				closePeriod = stream.readInt32(exception)
			}
		
			if ((flags and 32) != 0) {
				closeDate = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (closed) flags or 1 else flags and 1.inv()
			flags = if (publicVoters) flags or 2 else flags and 2.inv()
			flags = if (multipleChoice) flags or 4 else flags and 4.inv()
			flags = if (quiz) flags or 8 else flags and 8.inv()
			flags = if (closePeriod != 0) flags or 16 else flags and 16.inv()
			flags = if (closeDate != 0) flags or 32 else flags and 32.inv()
	
			stream.writeInt64(id)
			stream.writeInt32(flags)
			stream.writeString(question)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(answers.size)
			answers.forEach { it.serializeToStream(stream) }
			if ((flags and 16) != 0) {
				stream.writeInt32(closePeriod)
			}
	
			if ((flags and 32) != 0) {
				stream.writeInt32(closeDate)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x86e18161u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPoll? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPoll")
					}
					else {
						null
					}
				}
	
				val result = TLPoll()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPollAnswerVoters: TLObject() {
		@JvmField var flags = 0
		@JvmField var chosen = false
		@JvmField var correct = false
		@JvmField var option: ByteArray? = null
		@JvmField var voters = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			chosen = (flags and 1) != 0
			correct = (flags and 2) != 0
			option = stream.readByteArray(exception) ?: return
			voters = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (chosen) flags or 1 else flags and 1.inv()
			flags = if (correct) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeByteArray(option)
			stream.writeInt32(voters)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3b6ddad2u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPollAnswerVoters? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPollAnswerVoters")
					}
					else {
						null
					}
				}
	
				val result = TLPollAnswerVoters()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPollResults: TLObject() {
		@JvmField var flags = 0
		@JvmField var min = false
		@JvmField val results = mutableListOf<TLPollAnswerVoters>()
		@JvmField var totalVoters = 0
		@JvmField val recentVoters = mutableListOf<Long>()
		@JvmField var solution: String? = null
		@JvmField val solutionEntities = mutableListOf<MessageEntity>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			min = (flags and 1) != 0
		
			if ((flags and 2) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLPollAnswerVoters.deserialize(stream, stream.readInt32(exception), exception) ?: return
					results.add(obj)
				}
			}
		
			if ((flags and 4) != 0) {
				totalVoters = stream.readInt32(exception)
			}
		
			if ((flags and 8) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = stream.readInt64(exception)
					recentVoters.add(obj)
				}
			}
		
			if ((flags and 16) != 0) {
				solution = stream.readString(exception) ?: return
			}
		
			if ((flags and 16) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
					solutionEntities.add(obj)
				}
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (min) flags or 1 else flags and 1.inv()
			flags = if (totalVoters != 0) flags or 4 else flags and 4.inv()
			flags = if (solution != null) flags or 16 else flags and 16.inv()
	
			stream.writeInt32(flags)
			if ((flags and 2) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(results.size)
			results.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(totalVoters)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(recentVoters.size)
			recentVoters.forEach { stream.writeInt64(it) }
			}
	
			if ((flags and 16) != 0) {
				stream.writeString(solution)
			}
	
			if ((flags and 16) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(solutionEntities.size)
			solutionEntities.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xdcb82ea3u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPollResults? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPollResults")
					}
					else {
						null
					}
				}
	
				val result = TLPollResults()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLChatOnlines: TLObject() {
		@JvmField var onlines = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			onlines = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(onlines)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf041e250u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChatOnlines? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLChatOnlines")
					}
					else {
						null
					}
				}
	
				val result = TLChatOnlines()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetOnlines: TLObject() {
		@JvmField var peer: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChatOnlines? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLChatOnlines.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6e2be050u.toInt()
		}
	}
	
	open class TLStatsURL: TLObject() {
		@JvmField var url: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
		}
	
		companion object {
			val CONSTRUCTOR = 0x47a971e0u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStatsURL? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLStatsURL")
					}
					else {
						null
					}
				}
	
				val result = TLStatsURL()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLChatAdminRights: TLObject() {
		@JvmField var flags = 0
		@JvmField var changeInfo = false
		@JvmField var postMessages = false
		@JvmField var editMessages = false
		@JvmField var deleteMessages = false
		@JvmField var banUsers = false
		@JvmField var inviteUsers = false
		@JvmField var pinMessages = false
		@JvmField var addAdmins = false
		@JvmField var anonymous = false
		@JvmField var manageCall = false
		@JvmField var other = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			changeInfo = (flags and 1) != 0
			postMessages = (flags and 2) != 0
			editMessages = (flags and 4) != 0
			deleteMessages = (flags and 8) != 0
			banUsers = (flags and 16) != 0
			inviteUsers = (flags and 32) != 0
			pinMessages = (flags and 128) != 0
			addAdmins = (flags and 512) != 0
			anonymous = (flags and 1024) != 0
			manageCall = (flags and 2048) != 0
			other = (flags and 4096) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (changeInfo) flags or 1 else flags and 1.inv()
			flags = if (postMessages) flags or 2 else flags and 2.inv()
			flags = if (editMessages) flags or 4 else flags and 4.inv()
			flags = if (deleteMessages) flags or 8 else flags and 8.inv()
			flags = if (banUsers) flags or 16 else flags and 16.inv()
			flags = if (inviteUsers) flags or 32 else flags and 32.inv()
			flags = if (pinMessages) flags or 128 else flags and 128.inv()
			flags = if (addAdmins) flags or 512 else flags and 512.inv()
			flags = if (anonymous) flags or 1024 else flags and 1024.inv()
			flags = if (manageCall) flags or 2048 else flags and 2048.inv()
			flags = if (other) flags or 4096 else flags and 4096.inv()
	
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5fb224d5u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChatAdminRights? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLChatAdminRights")
					}
					else {
						null
					}
				}
	
				val result = TLChatAdminRights()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLChatBannedRights: TLObject() {
		@JvmField var flags = 0
		@JvmField var viewMessages = false
		@JvmField var sendMessages = false
		@JvmField var sendMedia = false
		@JvmField var sendStickers = false
		@JvmField var sendGifs = false
		@JvmField var sendGames = false
		@JvmField var sendInline = false
		@JvmField var embedLinks = false
		@JvmField var sendPolls = false
		@JvmField var changeInfo = false
		@JvmField var inviteUsers = false
		@JvmField var pinMessages = false
		@JvmField var untilDate = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			viewMessages = (flags and 1) != 0
			sendMessages = (flags and 2) != 0
			sendMedia = (flags and 4) != 0
			sendStickers = (flags and 8) != 0
			sendGifs = (flags and 16) != 0
			sendGames = (flags and 32) != 0
			sendInline = (flags and 64) != 0
			embedLinks = (flags and 128) != 0
			sendPolls = (flags and 256) != 0
			changeInfo = (flags and 1024) != 0
			inviteUsers = (flags and 32768) != 0
			pinMessages = (flags and 131072) != 0
			untilDate = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (viewMessages) flags or 1 else flags and 1.inv()
			flags = if (sendMessages) flags or 2 else flags and 2.inv()
			flags = if (sendMedia) flags or 4 else flags and 4.inv()
			flags = if (sendStickers) flags or 8 else flags and 8.inv()
			flags = if (sendGifs) flags or 16 else flags and 16.inv()
			flags = if (sendGames) flags or 32 else flags and 32.inv()
			flags = if (sendInline) flags or 64 else flags and 64.inv()
			flags = if (embedLinks) flags or 128 else flags and 128.inv()
			flags = if (sendPolls) flags or 256 else flags and 256.inv()
			flags = if (changeInfo) flags or 1024 else flags and 1024.inv()
			flags = if (inviteUsers) flags or 32768 else flags and 32768.inv()
			flags = if (pinMessages) flags or 131072 else flags and 131072.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(untilDate)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9f120418u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChatBannedRights? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLChatBannedRights")
					}
					else {
						null
					}
				}
	
				val result = TLChatBannedRights()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class InputWallPaper: TLObject() {
		@JvmField var id = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputWallPaper? {
				val result = when (constructor) {
					TLInputWallPaper.CONSTRUCTOR -> TLInputWallPaper()
					TLInputWallPaperSlug.CONSTRUCTOR -> TLInputWallPaperSlug()
					TLInputWallPaperNoFile.CONSTRUCTOR -> TLInputWallPaperNoFile()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputWallPaper")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputWallPaper: InputWallPaper() {
			@JvmField var accessHash = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe630b979u.toInt()
		}
	}
	
	open class TLInputWallPaperSlug: InputWallPaper() {
		@JvmField var slug: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			slug = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(slug)
		}
	
		companion object {
			val CONSTRUCTOR = 0x72091c80u.toInt()
		}
	}
	
	open class TLInputWallPaperNoFile: InputWallPaper() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0x967a462eu.toInt()
		}
	}
	
	abstract class AccountWallPapers: TLObject() {
		@JvmField var hash = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AccountWallPapers? {
				val result = when (constructor) {
					TLAccountWallPapersNotModified.CONSTRUCTOR -> TLAccountWallPapersNotModified()
					TLAccountWallPapers.CONSTRUCTOR -> TLAccountWallPapers()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in AccountWallPapers")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLAccountWallPapersNotModified: AccountWallPapers() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1c199183u.toInt()
		}
	}
	
	open class TLAccountWallPapers: AccountWallPapers() {
			@JvmField val wallpapers = mutableListOf<WallPaper>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			hash = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = WallPaper.deserialize(stream, stream.readInt32(exception), exception) ?: return
				wallpapers.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(wallpapers.size)
			wallpapers.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xcdc3858cu.toInt()
		}
	}
	
	open class TLAccountGetWallPapers: TLObject() {
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AccountWallPapers? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AccountWallPapers.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7967d36u.toInt()
		}
	}
	
	open class TLCodeSettings: TLObject() {
		@JvmField var flags = 0
		@JvmField var allowFlashcall = false
		@JvmField var currentNumber = false
		@JvmField var allowAppHash = false
		@JvmField var allowMissedCall = false
		@JvmField val logoutTokens = mutableListOf<ByteArray>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			allowFlashcall = (flags and 1) != 0
			currentNumber = (flags and 2) != 0
			allowAppHash = (flags and 16) != 0
			allowMissedCall = (flags and 32) != 0
		
			if ((flags and 64) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = stream.readByteArray(exception) ?: return
					logoutTokens.add(obj)
				}
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (allowFlashcall) flags or 1 else flags and 1.inv()
			flags = if (currentNumber) flags or 2 else flags and 2.inv()
			flags = if (allowAppHash) flags or 16 else flags and 16.inv()
			flags = if (allowMissedCall) flags or 32 else flags and 32.inv()
	
			stream.writeInt32(flags)
			if ((flags and 64) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(logoutTokens.size)
			logoutTokens.forEach { stream.writeByteArray(it) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8a6469c2u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLCodeSettings? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLCodeSettings")
					}
					else {
						null
					}
				}
	
				val result = TLCodeSettings()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLWallPaperSettings: TLObject() {
		@JvmField var flags = 0
		@JvmField var blur = false
		@JvmField var motion = false
		@JvmField var backgroundColor = 0
		@JvmField var secondBackgroundColor = 0
		@JvmField var thirdBackgroundColor = 0
		@JvmField var fourthBackgroundColor = 0
		@JvmField var intensity = 0
		@JvmField var rotation = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			blur = (flags and 2) != 0
			motion = (flags and 4) != 0
		
			if ((flags and 1) != 0) {
				backgroundColor = stream.readInt32(exception)
			}
		
			if ((flags and 16) != 0) {
				secondBackgroundColor = stream.readInt32(exception)
			}
		
			if ((flags and 32) != 0) {
				thirdBackgroundColor = stream.readInt32(exception)
			}
		
			if ((flags and 64) != 0) {
				fourthBackgroundColor = stream.readInt32(exception)
			}
		
			if ((flags and 8) != 0) {
				intensity = stream.readInt32(exception)
			}
		
			if ((flags and 16) != 0) {
				rotation = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (blur) flags or 2 else flags and 2.inv()
			flags = if (motion) flags or 4 else flags and 4.inv()
			flags = if (backgroundColor != 0) flags or 1 else flags and 1.inv()
			flags = if (secondBackgroundColor != 0) flags or 16 else flags and 16.inv()
			flags = if (thirdBackgroundColor != 0) flags or 32 else flags and 32.inv()
			flags = if (fourthBackgroundColor != 0) flags or 64 else flags and 64.inv()
			flags = if (intensity != 0) flags or 8 else flags and 8.inv()
			flags = if (rotation != 0) flags or 16 else flags and 16.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeInt32(backgroundColor)
			}
	
			if ((flags and 16) != 0) {
				stream.writeInt32(secondBackgroundColor)
			}
	
			if ((flags and 32) != 0) {
				stream.writeInt32(thirdBackgroundColor)
			}
	
			if ((flags and 64) != 0) {
				stream.writeInt32(fourthBackgroundColor)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt32(intensity)
			}
	
			if ((flags and 16) != 0) {
				stream.writeInt32(rotation)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1dc1bca4u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLWallPaperSettings? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLWallPaperSettings")
					}
					else {
						null
					}
				}
	
				val result = TLWallPaperSettings()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAutoDownloadSettings: TLObject() {
		@JvmField var flags = 0
		@JvmField var disabled = false
		@JvmField var videoPreloadLarge = false
		@JvmField var audioPreloadNext = false
		@JvmField var phonecallsLessData = false
		@JvmField var photoSizeMax = 0
		@JvmField var videoSizeMax = 0L
		@JvmField var fileSizeMax = 0L
		@JvmField var videoUploadMaxbitrate = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			disabled = (flags and 1) != 0
			videoPreloadLarge = (flags and 2) != 0
			audioPreloadNext = (flags and 4) != 0
			phonecallsLessData = (flags and 8) != 0
			photoSizeMax = stream.readInt32(exception)
			videoSizeMax = stream.readInt64(exception)
			fileSizeMax = stream.readInt64(exception)
			videoUploadMaxbitrate = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (disabled) flags or 1 else flags and 1.inv()
			flags = if (videoPreloadLarge) flags or 2 else flags and 2.inv()
			flags = if (audioPreloadNext) flags or 4 else flags and 4.inv()
			flags = if (phonecallsLessData) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(photoSizeMax)
			stream.writeInt64(videoSizeMax)
			stream.writeInt64(fileSizeMax)
			stream.writeInt32(videoUploadMaxbitrate)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8efab953u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAutoDownloadSettings? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAutoDownloadSettings")
					}
					else {
						null
					}
				}
	
				val result = TLAutoDownloadSettings()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountAutoDownloadSettings: TLObject() {
		@JvmField var low: TLAutoDownloadSettings? = null
		@JvmField var medium: TLAutoDownloadSettings? = null
		@JvmField var high: TLAutoDownloadSettings? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			low = TLAutoDownloadSettings.deserialize(stream, stream.readInt32(exception), exception)
			medium = TLAutoDownloadSettings.deserialize(stream, stream.readInt32(exception), exception)
			high = TLAutoDownloadSettings.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			low?.serializeToStream(stream)
			medium?.serializeToStream(stream)
			high?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x63cacf26u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountAutoDownloadSettings? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAccountAutoDownloadSettings")
					}
					else {
						null
					}
				}
	
				val result = TLAccountAutoDownloadSettings()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountGetAutoDownloadSettings: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountAutoDownloadSettings? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAccountAutoDownloadSettings.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x56da0b3fu.toInt()
		}
	}
	
	abstract class EmojiKeyword: TLObject() {
		@JvmField var keyword: String? = null
		@JvmField val emoticons = mutableListOf<String>()
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): EmojiKeyword? {
				val result = when (constructor) {
					TLEmojiKeyword.CONSTRUCTOR -> TLEmojiKeyword()
					TLEmojiKeywordDeleted.CONSTRUCTOR -> TLEmojiKeywordDeleted()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in EmojiKeyword")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLEmojiKeyword: EmojiKeyword() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			keyword = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readString(exception) ?: return
				emoticons.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(keyword)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(emoticons.size)
			emoticons.forEach { stream.writeString(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xd5b3b9f9u.toInt()
		}
	}
	
	open class TLEmojiKeywordDeleted: EmojiKeyword() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			keyword = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readString(exception) ?: return
				emoticons.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(keyword)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(emoticons.size)
			emoticons.forEach { stream.writeString(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x236df622u.toInt()
		}
	}
	
	open class TLEmojiKeywordsDifference: TLObject() {
		@JvmField var langCode: String? = null
		@JvmField var fromVersion = 0
		@JvmField var version = 0
		@JvmField val keywords = mutableListOf<EmojiKeyword>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			langCode = stream.readString(exception) ?: return
			fromVersion = stream.readInt32(exception)
			version = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = EmojiKeyword.deserialize(stream, stream.readInt32(exception), exception) ?: return
				keywords.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(langCode)
			stream.writeInt32(fromVersion)
			stream.writeInt32(version)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(keywords.size)
			keywords.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x5cc761bdu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLEmojiKeywordsDifference? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLEmojiKeywordsDifference")
					}
					else {
						null
					}
				}
	
				val result = TLEmojiKeywordsDifference()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetEmojiKeywords: TLObject() {
		@JvmField var langCode: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLEmojiKeywordsDifference? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLEmojiKeywordsDifference.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(langCode)
		}
	
		companion object {
			val CONSTRUCTOR = 0x35a0e062u.toInt()
		}
	}
	
	open class TLMessagesGetEmojiKeywordsDifference: TLObject() {
		@JvmField var langCode: String? = null
		@JvmField var fromVersion = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLEmojiKeywordsDifference? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLEmojiKeywordsDifference.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(langCode)
			stream.writeInt32(fromVersion)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1508b6afu.toInt()
		}
	}
	
	open class TLEmojiURL: TLObject() {
		@JvmField var url: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa575739du.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLEmojiURL? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLEmojiURL")
					}
					else {
						null
					}
				}
	
				val result = TLEmojiURL()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetEmojiURL: TLObject() {
		@JvmField var langCode: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLEmojiURL? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLEmojiURL.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(langCode)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd5b10c26u.toInt()
		}
	}
	
	open class TLEmojiLanguage: TLObject() {
		@JvmField var langCode: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			langCode = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(langCode)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb3fb5361u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLEmojiLanguage? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLEmojiLanguage")
					}
					else {
						null
					}
				}
	
				val result = TLEmojiLanguage()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLFolder: TLObject() {
		@JvmField var flags = 0
		@JvmField var autofillNewBroadcasts = false
		@JvmField var autofillPublicGroups = false
		@JvmField var autofillNewCorrespondents = false
		@JvmField var id = 0
		@JvmField var title: String? = null
		@JvmField var photo: ChatPhoto? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			autofillNewBroadcasts = (flags and 1) != 0
			autofillPublicGroups = (flags and 2) != 0
			autofillNewCorrespondents = (flags and 4) != 0
			id = stream.readInt32(exception)
			title = stream.readString(exception) ?: return
		
			if ((flags and 8) != 0) {
				photo = ChatPhoto.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (autofillNewBroadcasts) flags or 1 else flags and 1.inv()
			flags = if (autofillPublicGroups) flags or 2 else flags and 2.inv()
			flags = if (autofillNewCorrespondents) flags or 4 else flags and 4.inv()
			flags = if (photo != null) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(id)
			stream.writeString(title)
			if ((flags and 8) != 0) {
				photo?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xff544e65u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLFolder? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLFolder")
					}
					else {
						null
					}
				}
	
				val result = TLFolder()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLInputFolderPeer: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var folderId = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = InputPeer.deserialize(stream, stream.readInt32(exception), exception)
			folderId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(folderId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfbd2c296u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLInputFolderPeer? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLInputFolderPeer")
					}
					else {
						null
					}
				}
	
				val result = TLInputFolderPeer()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLFolderPeer: TLObject() {
		@JvmField var peer: Peer? = null
		@JvmField var folderId = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			folderId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(folderId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe9baa668u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLFolderPeer? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLFolderPeer")
					}
					else {
						null
					}
				}
	
				val result = TLFolderPeer()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesSearchCounter: TLObject() {
		@JvmField var flags = 0
		@JvmField var inexact = false
		@JvmField var filter: MessagesFilter? = null
		@JvmField var count = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			inexact = (flags and 2) != 0
			filter = MessagesFilter.deserialize(stream, stream.readInt32(exception), exception)
			count = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (inexact) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			filter?.serializeToStream(stream)
			stream.writeInt32(count)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe844ebffu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesSearchCounter? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesSearchCounter")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesSearchCounter()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class UrlAuthResult: TLObject() {
		@JvmField var url: String? = null
		@JvmField var flags = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): UrlAuthResult? {
				val result = when (constructor) {
					TLUrlAuthResultRequest.CONSTRUCTOR -> TLUrlAuthResultRequest()
					TLUrlAuthResultAccepted.CONSTRUCTOR -> TLUrlAuthResultAccepted()
					TLUrlAuthResultDefault.CONSTRUCTOR -> TLUrlAuthResultDefault()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in UrlAuthResult")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLUrlAuthResultRequest: UrlAuthResult() {
			@JvmField var requestWriteAccess = false
		@JvmField var bot: User? = null
		@JvmField var domain: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			requestWriteAccess = (flags and 1) != 0
			bot = User.deserialize(stream, stream.readInt32(exception), exception)
			domain = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (requestWriteAccess) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			bot?.serializeToStream(stream)
			stream.writeString(domain)
		}
	
		companion object {
			val CONSTRUCTOR = 0x92d33a0eu.toInt()
		}
	}
	
	open class TLUrlAuthResultAccepted: UrlAuthResult() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8f8c0e4eu.toInt()
		}
	}
	
	open class TLUrlAuthResultDefault: UrlAuthResult() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa9d6db1fu.toInt()
		}
	}
	
	open class TLMessagesRequestUrlAuth: TLObject() {
		@JvmField var flags = 0
		@JvmField var peer: InputPeer? = null
		@JvmField var msgId = 0
		@JvmField var buttonId = 0
		@JvmField var url: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): UrlAuthResult? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return UrlAuthResult.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (peer != null) flags or 2 else flags and 2.inv()
			flags = if (msgId != 0) flags or 2 else flags and 2.inv()
			flags = if (buttonId != 0) flags or 2 else flags and 2.inv()
			flags = if (url != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			if ((flags and 2) != 0) {
				peer?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(msgId)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(buttonId)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(url)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x198fb446u.toInt()
		}
	}
	
	open class TLMessagesAcceptUrlAuth: TLObject() {
		@JvmField var flags = 0
		@JvmField var writeAllowed = false
		@JvmField var peer: InputPeer? = null
		@JvmField var msgId = 0
		@JvmField var buttonId = 0
		@JvmField var url: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): UrlAuthResult? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return UrlAuthResult.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (writeAllowed) flags or 1 else flags and 1.inv()
			flags = if (peer != null) flags or 2 else flags and 2.inv()
			flags = if (msgId != 0) flags or 2 else flags and 2.inv()
			flags = if (buttonId != 0) flags or 2 else flags and 2.inv()
			flags = if (url != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			if ((flags and 2) != 0) {
				peer?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(msgId)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(buttonId)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(url)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb12c7125u.toInt()
		}
	}
	
	abstract class ChannelLocation: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChannelLocation? {
				val result = when (constructor) {
					TLChannelLocationEmpty.CONSTRUCTOR -> TLChannelLocationEmpty()
					TLChannelLocation.CONSTRUCTOR -> TLChannelLocation()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ChannelLocation")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChannelLocationEmpty: ChannelLocation() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xbfb5ad8bu.toInt()
		}
	}
	
	open class TLChannelLocation: ChannelLocation() {
		@JvmField var geoPoint: GeoPoint? = null
		@JvmField var address: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			geoPoint = GeoPoint.deserialize(stream, stream.readInt32(exception), exception)
			address = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			geoPoint?.serializeToStream(stream)
			stream.writeString(address)
		}
	
		companion object {
			val CONSTRUCTOR = 0x209b82dbu.toInt()
		}
	}
	
	abstract class PeerLocated: TLObject() {
		@JvmField var expires = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PeerLocated? {
				val result = when (constructor) {
					TLPeerLocated.CONSTRUCTOR -> TLPeerLocated()
					TLPeerSelfLocated.CONSTRUCTOR -> TLPeerSelfLocated()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in PeerLocated")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPeerLocated: PeerLocated() {
		@JvmField var peer: Peer? = null
			@JvmField var distance = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			expires = stream.readInt32(exception)
			distance = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(expires)
			stream.writeInt32(distance)
		}
	
		companion object {
			val CONSTRUCTOR = 0xca461b5du.toInt()
		}
	}
	
	open class TLPeerSelfLocated: PeerLocated() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			expires = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(expires)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf8ec284bu.toInt()
		}
	}
	
	open class TLRestrictionReason: TLObject() {
		@JvmField var platform: String? = null
		@JvmField var reason: String? = null
		@JvmField var text: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			platform = stream.readString(exception) ?: return
			reason = stream.readString(exception) ?: return
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(platform)
			stream.writeString(reason)
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd072acb4u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLRestrictionReason? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLRestrictionReason")
					}
					else {
						null
					}
				}
	
				val result = TLRestrictionReason()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class InputTheme: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputTheme? {
				val result = when (constructor) {
					TLInputTheme.CONSTRUCTOR -> TLInputTheme()
					TLInputThemeSlug.CONSTRUCTOR -> TLInputThemeSlug()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputTheme")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputTheme: InputTheme() {
		@JvmField var id = 0L
		@JvmField var accessHash = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3c5693e9u.toInt()
		}
	}
	
	open class TLInputThemeSlug: InputTheme() {
		@JvmField var slug: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			slug = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(slug)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf5890df1u.toInt()
		}
	}
	
	open class TLTheme: TLObject() {
		@JvmField var flags = 0
		@JvmField var creator = false
		@JvmField var isDefault = false
		@JvmField var forChat = false
		@JvmField var id = 0L
		@JvmField var accessHash = 0L
		@JvmField var slug: String? = null
		@JvmField var title: String? = null
		@JvmField var document: Document? = null
		@JvmField val settings = mutableListOf<TLThemeSettings>()
		@JvmField var emoticon: String? = null
		@JvmField var installsCount = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			creator = (flags and 1) != 0
			isDefault = (flags and 2) != 0
			forChat = (flags and 32) != 0
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			slug = stream.readString(exception) ?: return
			title = stream.readString(exception) ?: return
		
			if ((flags and 4) != 0) {
				document = Document.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 8) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLThemeSettings.deserialize(stream, stream.readInt32(exception), exception) ?: return
					settings.add(obj)
				}
			}
		
			if ((flags and 64) != 0) {
				emoticon = stream.readString(exception) ?: return
			}
		
			if ((flags and 16) != 0) {
				installsCount = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (creator) flags or 1 else flags and 1.inv()
			flags = if (isDefault) flags or 2 else flags and 2.inv()
			flags = if (forChat) flags or 32 else flags and 32.inv()
			flags = if (document != null) flags or 4 else flags and 4.inv()
			flags = if (emoticon != null) flags or 64 else flags and 64.inv()
			flags = if (installsCount != 0) flags or 16 else flags and 16.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeString(slug)
			stream.writeString(title)
			if ((flags and 4) != 0) {
				document?.serializeToStream(stream)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(settings.size)
			settings.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 64) != 0) {
				stream.writeString(emoticon)
			}
	
			if ((flags and 16) != 0) {
				stream.writeInt32(installsCount)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa00e67d6u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLTheme? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLTheme")
					}
					else {
						null
					}
				}
	
				val result = TLTheme()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountCreateTheme: TLObject() {
		@JvmField var flags = 0
		@JvmField var slug: String? = null
		@JvmField var title: String? = null
		@JvmField var document: InputDocument? = null
		@JvmField val settings = mutableListOf<TLInputThemeSettings>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLTheme? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLTheme.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (document != null) flags or 4 else flags and 4.inv()
			flags = if (settings.isNotEmpty()) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			stream.writeString(slug)
			stream.writeString(title)
			if ((flags and 4) != 0) {
				document?.serializeToStream(stream)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(settings.size)
			settings.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x652e4400u.toInt()
		}
	}
	
	open class TLAccountUpdateTheme: TLObject() {
		@JvmField var flags = 0
		@JvmField var format: String? = null
		@JvmField var theme: InputTheme? = null
		@JvmField var slug: String? = null
		@JvmField var title: String? = null
		@JvmField var document: InputDocument? = null
		@JvmField val settings = mutableListOf<TLInputThemeSettings>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLTheme? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLTheme.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (slug != null) flags or 1 else flags and 1.inv()
			flags = if (title != null) flags or 2 else flags and 2.inv()
			flags = if (document != null) flags or 4 else flags and 4.inv()
			flags = if (settings.isNotEmpty()) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			stream.writeString(format)
			theme?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeString(slug)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(title)
			}
	
			if ((flags and 4) != 0) {
				document?.serializeToStream(stream)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(settings.size)
			settings.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x2bf40cccu.toInt()
		}
	}
	
	open class TLAccountGetTheme: TLObject() {
		@JvmField var format: String? = null
		@JvmField var theme: InputTheme? = null
		@JvmField var documentId = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLTheme? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLTheme.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(format)
			theme?.serializeToStream(stream)
			stream.writeInt64(documentId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8d9d742bu.toInt()
		}
	}
	
	abstract class AccountThemes: TLObject() {
		@JvmField var hash = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AccountThemes? {
				val result = when (constructor) {
					TLAccountThemesNotModified.CONSTRUCTOR -> TLAccountThemesNotModified()
					TLAccountThemes.CONSTRUCTOR -> TLAccountThemes()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in AccountThemes")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLAccountThemesNotModified: AccountThemes() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf41eb622u.toInt()
		}
	}
	
	open class TLAccountThemes: AccountThemes() {
			@JvmField val themes = mutableListOf<TLTheme>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			hash = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLTheme.deserialize(stream, stream.readInt32(exception), exception) ?: return
				themes.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(themes.size)
			themes.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x9a3d8c6du.toInt()
		}
	}
	
	open class TLAccountGetThemes: TLObject() {
		@JvmField var format: String? = null
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AccountThemes? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AccountThemes.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(format)
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7206e458u.toInt()
		}
	}
	
	open class TLAccountGetChatThemes: TLObject() {
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AccountThemes? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AccountThemes.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd638de89u.toInt()
		}
	}
	
	abstract class AuthLoginToken: TLObject() {
		@JvmField var token: ByteArray? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthLoginToken? {
				val result = when (constructor) {
					TLAuthLoginToken.CONSTRUCTOR -> TLAuthLoginToken()
					TLAuthLoginTokenMigrateTo.CONSTRUCTOR -> TLAuthLoginTokenMigrateTo()
					TLAuthLoginTokenSuccess.CONSTRUCTOR -> TLAuthLoginTokenSuccess()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in AuthLoginToken")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLAuthLoginToken: AuthLoginToken() {
		@JvmField var expires = 0
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			expires = stream.readInt32(exception)
			token = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(expires)
			stream.writeByteArray(token)
		}
	
		companion object {
			val CONSTRUCTOR = 0x629f1980u.toInt()
		}
	}
	
	open class TLAuthLoginTokenMigrateTo: AuthLoginToken() {
		@JvmField var dcId = 0
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			dcId = stream.readInt32(exception)
			token = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(dcId)
			stream.writeByteArray(token)
		}
	
		companion object {
			val CONSTRUCTOR = 0x68e9916u.toInt()
		}
	}
	
	open class TLAuthLoginTokenSuccess: AuthLoginToken() {
		@JvmField var authorization: AuthAuthorization? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			authorization = AuthAuthorization.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			authorization?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x390d5c5eu.toInt()
		}
	}
	
	open class TLAuthExportLoginToken: TLObject() {
		@JvmField var apiId = 0
		@JvmField var apiHash: String? = null
		@JvmField val exceptIds = mutableListOf<Long>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthLoginToken? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AuthLoginToken.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(apiId)
			stream.writeString(apiHash)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(exceptIds.size)
			exceptIds.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xb7e085feu.toInt()
		}
	}
	
	open class TLAuthImportLoginToken: TLObject() {
		@JvmField var token: ByteArray? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthLoginToken? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AuthLoginToken.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteArray(token)
		}
	
		companion object {
			val CONSTRUCTOR = 0x95ac5ce4u.toInt()
		}
	}
	
	open class TLAccountContentSettings: TLObject() {
		@JvmField var flags = 0
		@JvmField var sensitiveEnabled = false
		@JvmField var sensitiveCanChange = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			sensitiveEnabled = (flags and 1) != 0
			sensitiveCanChange = (flags and 2) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (sensitiveEnabled) flags or 1 else flags and 1.inv()
			flags = if (sensitiveCanChange) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0x57e28221u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountContentSettings? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAccountContentSettings")
					}
					else {
						null
					}
				}
	
				val result = TLAccountContentSettings()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountGetContentSettings: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAccountContentSettings? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAccountContentSettings.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8b9b4daeu.toInt()
		}
	}
	
	open class TLMessagesInactiveChats: TLObject() {
		@JvmField val dates = mutableListOf<Int>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt32(exception)
				dates.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(dates.size)
			dates.forEach { stream.writeInt32(it) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xa927fec5u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesInactiveChats? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesInactiveChats")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesInactiveChats()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLChannelsGetInactiveChannels: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesInactiveChats? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesInactiveChats.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x11e831eeu.toInt()
		}
	}
	
	abstract class BaseTheme: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): BaseTheme? {
				val result = when (constructor) {
					TLBaseThemeClassic.CONSTRUCTOR -> TLBaseThemeClassic()
					TLBaseThemeDay.CONSTRUCTOR -> TLBaseThemeDay()
					TLBaseThemeNight.CONSTRUCTOR -> TLBaseThemeNight()
					TLBaseThemeTinted.CONSTRUCTOR -> TLBaseThemeTinted()
					TLBaseThemeArctic.CONSTRUCTOR -> TLBaseThemeArctic()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in BaseTheme")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLBaseThemeClassic: BaseTheme() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc3a12462u.toInt()
		}
	}
	
	open class TLBaseThemeDay: BaseTheme() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xfbd81688u.toInt()
		}
	}
	
	open class TLBaseThemeNight: BaseTheme() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb7b31ea8u.toInt()
		}
	}
	
	open class TLBaseThemeTinted: BaseTheme() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x6d5f77eeu.toInt()
		}
	}
	
	open class TLBaseThemeArctic: BaseTheme() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x5b11125au.toInt()
		}
	}
	
	open class TLInputThemeSettings: TLObject() {
		@JvmField var flags = 0
		@JvmField var messageColorsAnimated = false
		@JvmField var baseTheme: BaseTheme? = null
		@JvmField var accentColor = 0
		@JvmField var outboxAccentColor = 0
		@JvmField val messageColors = mutableListOf<Int>()
		@JvmField var wallpaper: InputWallPaper? = null
		@JvmField var wallpaperSettings: TLWallPaperSettings? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			messageColorsAnimated = (flags and 4) != 0
			baseTheme = BaseTheme.deserialize(stream, stream.readInt32(exception), exception)
			accentColor = stream.readInt32(exception)
		
			if ((flags and 8) != 0) {
				outboxAccentColor = stream.readInt32(exception)
			}
		
			if ((flags and 1) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = stream.readInt32(exception)
					messageColors.add(obj)
				}
			}
		
			if ((flags and 2) != 0) {
				wallpaper = InputWallPaper.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				wallpaperSettings = TLWallPaperSettings.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (messageColorsAnimated) flags or 4 else flags and 4.inv()
			flags = if (outboxAccentColor != 0) flags or 8 else flags and 8.inv()
			flags = if (wallpaper != null) flags or 2 else flags and 2.inv()
			flags = if (wallpaperSettings != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			baseTheme?.serializeToStream(stream)
			stream.writeInt32(accentColor)
			if ((flags and 8) != 0) {
				stream.writeInt32(outboxAccentColor)
			}
	
			if ((flags and 1) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messageColors.size)
			messageColors.forEach { stream.writeInt32(it) }
			}
	
			if ((flags and 2) != 0) {
				wallpaper?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				wallpaperSettings?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8fde504fu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLInputThemeSettings? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLInputThemeSettings")
					}
					else {
						null
					}
				}
	
				val result = TLInputThemeSettings()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLThemeSettings: TLObject() {
		@JvmField var flags = 0
		@JvmField var messageColorsAnimated = false
		@JvmField var baseTheme: BaseTheme? = null
		@JvmField var accentColor = 0
		@JvmField var outboxAccentColor = 0
		@JvmField val messageColors = mutableListOf<Int>()
		@JvmField var wallpaper: WallPaper? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			messageColorsAnimated = (flags and 4) != 0
			baseTheme = BaseTheme.deserialize(stream, stream.readInt32(exception), exception)
			accentColor = stream.readInt32(exception)
		
			if ((flags and 8) != 0) {
				outboxAccentColor = stream.readInt32(exception)
			}
		
			if ((flags and 1) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = stream.readInt32(exception)
					messageColors.add(obj)
				}
			}
		
			if ((flags and 2) != 0) {
				wallpaper = WallPaper.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (messageColorsAnimated) flags or 4 else flags and 4.inv()
			flags = if (outboxAccentColor != 0) flags or 8 else flags and 8.inv()
			flags = if (wallpaper != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			baseTheme?.serializeToStream(stream)
			stream.writeInt32(accentColor)
			if ((flags and 8) != 0) {
				stream.writeInt32(outboxAccentColor)
			}
	
			if ((flags and 1) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messageColors.size)
			messageColors.forEach { stream.writeInt32(it) }
			}
	
			if ((flags and 2) != 0) {
				wallpaper?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xfa58b6d4u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLThemeSettings? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLThemeSettings")
					}
					else {
						null
					}
				}
	
				val result = TLThemeSettings()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLWebPageAttribute: TLObject() {
		@JvmField var flags = 0
		@JvmField val documents = mutableListOf<Document>()
		@JvmField var settings: TLThemeSettings? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = Document.deserialize(stream, stream.readInt32(exception), exception) ?: return
					documents.add(obj)
				}
			}
		
			if ((flags and 2) != 0) {
				settings = TLThemeSettings.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (settings != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(documents.size)
			documents.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 2) != 0) {
				settings?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x54b56617u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLWebPageAttribute? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLWebPageAttribute")
					}
					else {
						null
					}
				}
	
				val result = TLWebPageAttribute()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class MessageUserVote: TLObject() {
		@JvmField var userId = 0L
		@JvmField var date = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessageUserVote? {
				val result = when (constructor) {
					TLMessageUserVote.CONSTRUCTOR -> TLMessageUserVote()
					TLMessageUserVoteInputOption.CONSTRUCTOR -> TLMessageUserVoteInputOption()
					TLMessageUserVoteMultiple.CONSTRUCTOR -> TLMessageUserVoteMultiple()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessageUserVote")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessageUserVote: MessageUserVote() {
			@JvmField var option: ByteArray? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			option = stream.readByteArray(exception) ?: return
			date = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeByteArray(option)
			stream.writeInt32(date)
		}
	
		companion object {
			val CONSTRUCTOR = 0x34d247b4u.toInt()
		}
	}
	
	open class TLMessageUserVoteInputOption: MessageUserVote() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			date = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeInt32(date)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3ca5b0ecu.toInt()
		}
	}
	
	open class TLMessageUserVoteMultiple: MessageUserVote() {
			@JvmField val options = mutableListOf<ByteArray>()
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readByteArray(exception) ?: return
				options.add(obj)
			}
			date = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(options.size)
			options.forEach { stream.writeByteArray(it) }
			stream.writeInt32(date)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8a65e557u.toInt()
		}
	}
	
	open class TLMessagesVotesList: TLObject() {
		@JvmField var flags = 0
		@JvmField var count = 0
		@JvmField val votes = mutableListOf<MessageUserVote>()
		@JvmField val users = mutableListOf<User>()
		@JvmField var nextOffset: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			count = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = MessageUserVote.deserialize(stream, stream.readInt32(exception), exception) ?: return
				votes.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		
			if ((flags and 1) != 0) {
				nextOffset = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (nextOffset != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(count)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(votes.size)
			votes.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
			if ((flags and 1) != 0) {
				stream.writeString(nextOffset)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x823f649u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesVotesList? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesVotesList")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesVotesList()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetPollVotes: TLObject() {
		@JvmField var flags = 0
		@JvmField var peer: InputPeer? = null
		@JvmField var id = 0
		@JvmField var option: ByteArray? = null
		@JvmField var offset: String? = null
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesVotesList? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesVotesList.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (option != null) flags or 1 else flags and 1.inv()
			flags = if (offset != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt32(id)
			if ((flags and 1) != 0) {
				stream.writeByteArray(option)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(offset)
			}
	
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb86e380eu.toInt()
		}
	}
	
	open class TLBankCardOpenUrl: TLObject() {
		@JvmField var url: String? = null
		@JvmField var name: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
			name = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
			stream.writeString(name)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf568028au.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLBankCardOpenUrl? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLBankCardOpenUrl")
					}
					else {
						null
					}
				}
	
				val result = TLBankCardOpenUrl()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPaymentsBankCardData: TLObject() {
		@JvmField var title: String? = null
		@JvmField val openUrls = mutableListOf<TLBankCardOpenUrl>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			title = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLBankCardOpenUrl.deserialize(stream, stream.readInt32(exception), exception) ?: return
				openUrls.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(title)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(openUrls.size)
			openUrls.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x3e24e573u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPaymentsBankCardData? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPaymentsBankCardData")
					}
					else {
						null
					}
				}
	
				val result = TLPaymentsBankCardData()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class DialogFilter: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): DialogFilter? {
				val result = when (constructor) {
					TLDialogFilter.CONSTRUCTOR -> TLDialogFilter()
					TLDialogFilterDefault.CONSTRUCTOR -> TLDialogFilterDefault()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in DialogFilter")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLDialogFilter: DialogFilter() {
		@JvmField var flags = 0
		@JvmField var contacts = false
		@JvmField var nonContacts = false
		@JvmField var groups = false
		@JvmField var broadcasts = false
		@JvmField var bots = false
		@JvmField var excludeMuted = false
		@JvmField var excludeRead = false
		@JvmField var excludeArchived = false
		@JvmField var id = 0
		@JvmField var title: String? = null
		@JvmField var emoticon: String? = null
		@JvmField val pinnedPeers = mutableListOf<InputPeer>()
		@JvmField val includePeers = mutableListOf<InputPeer>()
		@JvmField val excludePeers = mutableListOf<InputPeer>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			contacts = (flags and 1) != 0
			nonContacts = (flags and 2) != 0
			groups = (flags and 4) != 0
			broadcasts = (flags and 8) != 0
			bots = (flags and 16) != 0
			excludeMuted = (flags and 2048) != 0
			excludeRead = (flags and 4096) != 0
			excludeArchived = (flags and 8192) != 0
			id = stream.readInt32(exception)
			title = stream.readString(exception) ?: return
		
			if ((flags and 33554432) != 0) {
				emoticon = stream.readString(exception) ?: return
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = InputPeer.deserialize(stream, stream.readInt32(exception), exception) ?: return
				pinnedPeers.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = InputPeer.deserialize(stream, stream.readInt32(exception), exception) ?: return
				includePeers.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = InputPeer.deserialize(stream, stream.readInt32(exception), exception) ?: return
				excludePeers.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (contacts) flags or 1 else flags and 1.inv()
			flags = if (nonContacts) flags or 2 else flags and 2.inv()
			flags = if (groups) flags or 4 else flags and 4.inv()
			flags = if (broadcasts) flags or 8 else flags and 8.inv()
			flags = if (bots) flags or 16 else flags and 16.inv()
			flags = if (excludeMuted) flags or 2048 else flags and 2048.inv()
			flags = if (excludeRead) flags or 4096 else flags and 4096.inv()
			flags = if (excludeArchived) flags or 8192 else flags and 8192.inv()
			flags = if (emoticon != null) flags or 33554432 else flags and 33554432.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(id)
			stream.writeString(title)
			if ((flags and 33554432) != 0) {
				stream.writeString(emoticon)
			}
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(pinnedPeers.size)
			pinnedPeers.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(includePeers.size)
			includePeers.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(excludePeers.size)
			excludePeers.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x7438f7e8u.toInt()
		}
	}
	
	open class TLDialogFilterDefault: DialogFilter() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x363293aeu.toInt()
		}
	}
	
	open class TLDialogFilterSuggested: TLObject() {
		@JvmField var filter: DialogFilter? = null
		@JvmField var description: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			filter = DialogFilter.deserialize(stream, stream.readInt32(exception), exception)
			description = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			filter?.serializeToStream(stream)
			stream.writeString(description)
		}
	
		companion object {
			val CONSTRUCTOR = 0x77744d4au.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLDialogFilterSuggested? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLDialogFilterSuggested")
					}
					else {
						null
					}
				}
	
				val result = TLDialogFilterSuggested()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLStatsDateRangeDays: TLObject() {
		@JvmField var minDate = 0
		@JvmField var maxDate = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			minDate = stream.readInt32(exception)
			maxDate = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(minDate)
			stream.writeInt32(maxDate)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb637edafu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStatsDateRangeDays? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLStatsDateRangeDays")
					}
					else {
						null
					}
				}
	
				val result = TLStatsDateRangeDays()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLStatsAbsValueAndPrev: TLObject() {
		@JvmField var current = 0.0
		@JvmField var previous = 0.0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			current = stream.readDouble(exception)
			previous = stream.readDouble(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeDouble(current)
			stream.writeDouble(previous)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcb43acdeu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStatsAbsValueAndPrev? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLStatsAbsValueAndPrev")
					}
					else {
						null
					}
				}
	
				val result = TLStatsAbsValueAndPrev()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLStatsPercentValue: TLObject() {
		@JvmField var part = 0.0
		@JvmField var total = 0.0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			part = stream.readDouble(exception)
			total = stream.readDouble(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeDouble(part)
			stream.writeDouble(total)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcbce2fe0u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStatsPercentValue? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLStatsPercentValue")
					}
					else {
						null
					}
				}
	
				val result = TLStatsPercentValue()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class StatsGraph: TLObject() {
		@JvmField var token: String? = null
		@JvmField var flags = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): StatsGraph? {
				val result = when (constructor) {
					TLStatsGraphAsync.CONSTRUCTOR -> TLStatsGraphAsync()
					TLStatsGraphError.CONSTRUCTOR -> TLStatsGraphError()
					TLStatsGraph.CONSTRUCTOR -> TLStatsGraph()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in StatsGraph")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLStatsGraphAsync: StatsGraph() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			token = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(token)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4a27eb2du.toInt()
		}
	}
	
	open class TLStatsGraphError: StatsGraph() {
		@JvmField var error: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			error = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(error)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbedc9822u.toInt()
		}
	}
	
	open class TLStatsGraph: StatsGraph() {
			@JvmField var json: TLDataJSON? = null
		@JvmField var zoomToken: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			json = TLDataJSON.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {
				zoomToken = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (zoomToken != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			json?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeString(zoomToken)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8ea464b6u.toInt()
		}
	}
	
	open class TLStatsLoadAsyncGraph: TLObject() {
		@JvmField var flags = 0
		@JvmField var token: String? = null
		@JvmField var x = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): StatsGraph? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return StatsGraph.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (x != 0L) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeString(token)
			if ((flags and 1) != 0) {
				stream.writeInt64(x)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x621d5fa0u.toInt()
		}
	}
	
	open class TLMessageInteractionCounters: TLObject() {
		@JvmField var msgId = 0
		@JvmField var views = 0
		@JvmField var forwards = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			msgId = stream.readInt32(exception)
			views = stream.readInt32(exception)
			forwards = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(msgId)
			stream.writeInt32(views)
			stream.writeInt32(forwards)
		}
	
		companion object {
			val CONSTRUCTOR = 0xad4fc9bdu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessageInteractionCounters? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessageInteractionCounters")
					}
					else {
						null
					}
				}
	
				val result = TLMessageInteractionCounters()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLStatsBroadcastStats: TLObject() {
		@JvmField var period: TLStatsDateRangeDays? = null
		@JvmField var followers: TLStatsAbsValueAndPrev? = null
		@JvmField var viewsPerPost: TLStatsAbsValueAndPrev? = null
		@JvmField var sharesPerPost: TLStatsAbsValueAndPrev? = null
		@JvmField var enabledNotifications: TLStatsPercentValue? = null
		@JvmField var growthGraph: StatsGraph? = null
		@JvmField var followersGraph: StatsGraph? = null
		@JvmField var muteGraph: StatsGraph? = null
		@JvmField var topHoursGraph: StatsGraph? = null
		@JvmField var interactionsGraph: StatsGraph? = null
		@JvmField var ivInteractionsGraph: StatsGraph? = null
		@JvmField var viewsBySourceGraph: StatsGraph? = null
		@JvmField var newFollowersBySourceGraph: StatsGraph? = null
		@JvmField var languagesGraph: StatsGraph? = null
		@JvmField val recentMessageInteractions = mutableListOf<TLMessageInteractionCounters>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			period = TLStatsDateRangeDays.deserialize(stream, stream.readInt32(exception), exception)
			followers = TLStatsAbsValueAndPrev.deserialize(stream, stream.readInt32(exception), exception)
			viewsPerPost = TLStatsAbsValueAndPrev.deserialize(stream, stream.readInt32(exception), exception)
			sharesPerPost = TLStatsAbsValueAndPrev.deserialize(stream, stream.readInt32(exception), exception)
			enabledNotifications = TLStatsPercentValue.deserialize(stream, stream.readInt32(exception), exception)
			growthGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
			followersGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
			muteGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
			topHoursGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
			interactionsGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
			ivInteractionsGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
			viewsBySourceGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
			newFollowersBySourceGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
			languagesGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLMessageInteractionCounters.deserialize(stream, stream.readInt32(exception), exception) ?: return
				recentMessageInteractions.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			period?.serializeToStream(stream)
			followers?.serializeToStream(stream)
			viewsPerPost?.serializeToStream(stream)
			sharesPerPost?.serializeToStream(stream)
			enabledNotifications?.serializeToStream(stream)
			growthGraph?.serializeToStream(stream)
			followersGraph?.serializeToStream(stream)
			muteGraph?.serializeToStream(stream)
			topHoursGraph?.serializeToStream(stream)
			interactionsGraph?.serializeToStream(stream)
			ivInteractionsGraph?.serializeToStream(stream)
			viewsBySourceGraph?.serializeToStream(stream)
			newFollowersBySourceGraph?.serializeToStream(stream)
			languagesGraph?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(recentMessageInteractions.size)
			recentMessageInteractions.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xbdf78394u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStatsBroadcastStats? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLStatsBroadcastStats")
					}
					else {
						null
					}
				}
	
				val result = TLStatsBroadcastStats()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLStatsGetBroadcastStats: TLObject() {
		@JvmField var flags = 0
		@JvmField var dark = false
		@JvmField var channel: InputChannel? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStatsBroadcastStats? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLStatsBroadcastStats.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (dark) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			channel?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xab42441au.toInt()
		}
	}
	
	abstract class HelpPromoData: TLObject() {
		@JvmField var expires = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpPromoData? {
				val result = when (constructor) {
					TLHelpPromoDataEmpty.CONSTRUCTOR -> TLHelpPromoDataEmpty()
					TLHelpPromoData.CONSTRUCTOR -> TLHelpPromoData()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in HelpPromoData")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLHelpPromoDataEmpty: HelpPromoData() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			expires = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(expires)
		}
	
		companion object {
			val CONSTRUCTOR = 0x98f6ac75u.toInt()
		}
	}
	
	open class TLHelpPromoData: HelpPromoData() {
		@JvmField var flags = 0
		@JvmField var proxy = false
			@JvmField var peer: Peer? = null
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
		@JvmField var psaType: String? = null
		@JvmField var psaMessage: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			proxy = (flags and 1) != 0
			expires = stream.readInt32(exception)
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		
			if ((flags and 2) != 0) {
				psaType = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				psaMessage = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (proxy) flags or 1 else flags and 1.inv()
			flags = if (psaType != null) flags or 2 else flags and 2.inv()
			flags = if (psaMessage != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(expires)
			peer?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
			if ((flags and 2) != 0) {
				stream.writeString(psaType)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(psaMessage)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8c39793fu.toInt()
		}
	}
	
	open class TLHelpGetPromoData: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpPromoData? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return HelpPromoData.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc0977421u.toInt()
		}
	}
	
	abstract class VideoSize: TLObject() {
		@JvmField var location: FileLocation? = null
		@JvmField var flags = 0
		@JvmField var size = 0
		@JvmField var h = 0
		@JvmField var videoStartTs = 0.0
		@JvmField var type: String? = null
		@JvmField var w = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): VideoSize? {
				val result = when (constructor) {
					TLVideoSize.CONSTRUCTOR -> TLVideoSize()
					TLVideoSizeLayer127.CONSTRUCTOR -> TLVideoSizeLayer127()
					TLVideoSizeLayer115.CONSTRUCTOR -> TLVideoSizeLayer115()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in VideoSize")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLVideoSize: VideoSize() {
							
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			type = stream.readString(exception) ?: return
			w = stream.readInt32(exception)
			h = stream.readInt32(exception)
			size = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				videoStartTs = stream.readDouble(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (videoStartTs != 0.0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeString(type)
			stream.writeInt32(w)
			stream.writeInt32(h)
			stream.writeInt32(size)
			if ((flags and 1) != 0) {
				stream.writeDouble(videoStartTs)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xde33b094u.toInt()
		}
	}
	
	open class TLVideoSizeLayer127: TLVideoSize() {
								
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			type = stream.readString(exception) ?: return
			location = FileLocation.deserialize(stream, stream.readInt32(exception), exception)
			w = stream.readInt32(exception)
			h = stream.readInt32(exception)
			size = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				videoStartTs = stream.readDouble(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (videoStartTs != 0.0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeString(type)
			location?.serializeToStream(stream)
			stream.writeInt32(w)
			stream.writeInt32(h)
			stream.writeInt32(size)
			if ((flags and 1) != 0) {
				stream.writeDouble(videoStartTs)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe831c556u.toInt()
		}
	}
	
	open class TLVideoSizeLayer115: VideoSize() {
						
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			type = stream.readString(exception) ?: return
			location = FileLocation.deserialize(stream, stream.readInt32(exception), exception)
			w = stream.readInt32(exception)
			h = stream.readInt32(exception)
			size = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(type)
			location?.serializeToStream(stream)
			stream.writeInt32(w)
			stream.writeInt32(h)
			stream.writeInt32(size)
		}
	
		companion object {
			val CONSTRUCTOR = 0x435bb987u.toInt()
		}
	}
	
	open class TLStatsGroupTopPoster: TLObject() {
		@JvmField var userId = 0L
		@JvmField var messages = 0
		@JvmField var avgChars = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			messages = stream.readInt32(exception)
			avgChars = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeInt32(messages)
			stream.writeInt32(avgChars)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9d04af9bu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStatsGroupTopPoster? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLStatsGroupTopPoster")
					}
					else {
						null
					}
				}
	
				val result = TLStatsGroupTopPoster()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLStatsGroupTopAdmin: TLObject() {
		@JvmField var userId = 0L
		@JvmField var deleted = 0
		@JvmField var kicked = 0
		@JvmField var banned = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			deleted = stream.readInt32(exception)
			kicked = stream.readInt32(exception)
			banned = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeInt32(deleted)
			stream.writeInt32(kicked)
			stream.writeInt32(banned)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd7584c87u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStatsGroupTopAdmin? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLStatsGroupTopAdmin")
					}
					else {
						null
					}
				}
	
				val result = TLStatsGroupTopAdmin()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLStatsGroupTopInviter: TLObject() {
		@JvmField var userId = 0L
		@JvmField var invitations = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			invitations = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeInt32(invitations)
		}
	
		companion object {
			val CONSTRUCTOR = 0x535f779du.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStatsGroupTopInviter? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLStatsGroupTopInviter")
					}
					else {
						null
					}
				}
	
				val result = TLStatsGroupTopInviter()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLStatsMegagroupStats: TLObject() {
		@JvmField var period: TLStatsDateRangeDays? = null
		@JvmField var members: TLStatsAbsValueAndPrev? = null
		@JvmField var messages: TLStatsAbsValueAndPrev? = null
		@JvmField var viewers: TLStatsAbsValueAndPrev? = null
		@JvmField var posters: TLStatsAbsValueAndPrev? = null
		@JvmField var growthGraph: StatsGraph? = null
		@JvmField var membersGraph: StatsGraph? = null
		@JvmField var newMembersBySourceGraph: StatsGraph? = null
		@JvmField var languagesGraph: StatsGraph? = null
		@JvmField var messagesGraph: StatsGraph? = null
		@JvmField var actionsGraph: StatsGraph? = null
		@JvmField var topHoursGraph: StatsGraph? = null
		@JvmField var weekdaysGraph: StatsGraph? = null
		@JvmField val topPosters = mutableListOf<TLStatsGroupTopPoster>()
		@JvmField val topAdmins = mutableListOf<TLStatsGroupTopAdmin>()
		@JvmField val topInviters = mutableListOf<TLStatsGroupTopInviter>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			period = TLStatsDateRangeDays.deserialize(stream, stream.readInt32(exception), exception)
			members = TLStatsAbsValueAndPrev.deserialize(stream, stream.readInt32(exception), exception)
			messages = TLStatsAbsValueAndPrev.deserialize(stream, stream.readInt32(exception), exception)
			viewers = TLStatsAbsValueAndPrev.deserialize(stream, stream.readInt32(exception), exception)
			posters = TLStatsAbsValueAndPrev.deserialize(stream, stream.readInt32(exception), exception)
			growthGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
			membersGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
			newMembersBySourceGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
			languagesGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
			messagesGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
			actionsGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
			topHoursGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
			weekdaysGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLStatsGroupTopPoster.deserialize(stream, stream.readInt32(exception), exception) ?: return
				topPosters.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLStatsGroupTopAdmin.deserialize(stream, stream.readInt32(exception), exception) ?: return
				topAdmins.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLStatsGroupTopInviter.deserialize(stream, stream.readInt32(exception), exception) ?: return
				topInviters.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			period?.serializeToStream(stream)
			members?.serializeToStream(stream)
			messages?.serializeToStream(stream)
			viewers?.serializeToStream(stream)
			posters?.serializeToStream(stream)
			growthGraph?.serializeToStream(stream)
			membersGraph?.serializeToStream(stream)
			newMembersBySourceGraph?.serializeToStream(stream)
			languagesGraph?.serializeToStream(stream)
			messagesGraph?.serializeToStream(stream)
			actionsGraph?.serializeToStream(stream)
			topHoursGraph?.serializeToStream(stream)
			weekdaysGraph?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(topPosters.size)
			topPosters.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(topAdmins.size)
			topAdmins.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(topInviters.size)
			topInviters.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xef7ff916u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStatsMegagroupStats? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLStatsMegagroupStats")
					}
					else {
						null
					}
				}
	
				val result = TLStatsMegagroupStats()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLStatsGetMegagroupStats: TLObject() {
		@JvmField var flags = 0
		@JvmField var dark = false
		@JvmField var channel: InputChannel? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStatsMegagroupStats? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLStatsMegagroupStats.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (dark) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			channel?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdcdf8607u.toInt()
		}
	}
	
	open class TLGlobalPrivacySettings: TLObject() {
		@JvmField var flags = 0
		@JvmField var archiveAndMuteNewNoncontactPeers = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				archiveAndMuteNewNoncontactPeers = stream.readBool(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (archiveAndMuteNewNoncontactPeers) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeBool(archiveAndMuteNewNoncontactPeers)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xbea2f424u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLGlobalPrivacySettings? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLGlobalPrivacySettings")
					}
					else {
						null
					}
				}
	
				val result = TLGlobalPrivacySettings()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAccountGetGlobalPrivacySettings: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLGlobalPrivacySettings? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLGlobalPrivacySettings.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xeb2b4cf6u.toInt()
		}
	}
	
	open class TLAccountSetGlobalPrivacySettings: TLObject() {
		@JvmField var settings: TLGlobalPrivacySettings? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLGlobalPrivacySettings? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLGlobalPrivacySettings.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			settings?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1edaaac2u.toInt()
		}
	}
	
	open class TLHelpCountryCode: TLObject() {
		@JvmField var flags = 0
		@JvmField var countryCode: String? = null
		@JvmField val prefixes = mutableListOf<String>()
		@JvmField val patterns = mutableListOf<String>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			countryCode = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = stream.readString(exception) ?: return
					prefixes.add(obj)
				}
			}
		
			if ((flags and 2) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = stream.readString(exception) ?: return
					patterns.add(obj)
				}
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(flags)
			stream.writeString(countryCode)
			if ((flags and 1) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(prefixes.size)
			prefixes.forEach { stream.writeString(it) }
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(patterns.size)
			patterns.forEach { stream.writeString(it) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x4203c5efu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLHelpCountryCode? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLHelpCountryCode")
					}
					else {
						null
					}
				}
	
				val result = TLHelpCountryCode()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLHelpCountry: TLObject() {
		@JvmField var flags = 0
		@JvmField var hidden = false
		@JvmField var iso2: String? = null
		@JvmField var defaultName: String? = null
		@JvmField var name: String? = null
		@JvmField val countryCodes = mutableListOf<TLHelpCountryCode>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			hidden = (flags and 1) != 0
			iso2 = stream.readString(exception) ?: return
			defaultName = stream.readString(exception) ?: return
		
			if ((flags and 2) != 0) {
				name = stream.readString(exception) ?: return
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLHelpCountryCode.deserialize(stream, stream.readInt32(exception), exception) ?: return
				countryCodes.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (hidden) flags or 1 else flags and 1.inv()
			flags = if (name != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeString(iso2)
			stream.writeString(defaultName)
			if ((flags and 2) != 0) {
				stream.writeString(name)
			}
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(countryCodes.size)
			countryCodes.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xc3878e23u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLHelpCountry? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLHelpCountry")
					}
					else {
						null
					}
				}
	
				val result = TLHelpCountry()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class HelpCountriesList: TLObject() {
		@JvmField var hash = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpCountriesList? {
				val result = when (constructor) {
					TLHelpCountriesListNotModified.CONSTRUCTOR -> TLHelpCountriesListNotModified()
					TLHelpCountriesList.CONSTRUCTOR -> TLHelpCountriesList()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in HelpCountriesList")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLHelpCountriesListNotModified: HelpCountriesList() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x93cc1f32u.toInt()
		}
	}
	
	open class TLHelpCountriesList: HelpCountriesList() {
		@JvmField val countries = mutableListOf<TLHelpCountry>()
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLHelpCountry.deserialize(stream, stream.readInt32(exception), exception) ?: return
				countries.add(obj)
			}
			hash = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(countries.size)
			countries.forEach { it.serializeToStream(stream) }
			stream.writeInt32(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x87d0759eu.toInt()
		}
	}
	
	open class TLHelpGetCountriesList: TLObject() {
		@JvmField var langCode: String? = null
		@JvmField var hash = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): HelpCountriesList? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return HelpCountriesList.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(langCode)
			stream.writeInt32(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x735787a8u.toInt()
		}
	}
	
	open class TLMessageViews: TLObject() {
		@JvmField var flags = 0
		@JvmField var views = 0
		@JvmField var forwards = 0
		@JvmField var replies: TLMessageReplies? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				views = stream.readInt32(exception)
			}
		
			if ((flags and 2) != 0) {
				forwards = stream.readInt32(exception)
			}
		
			if ((flags and 4) != 0) {
				replies = TLMessageReplies.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (views != 0) flags or 1 else flags and 1.inv()
			flags = if (forwards != 0) flags or 2 else flags and 2.inv()
			flags = if (replies != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeInt32(views)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(forwards)
			}
	
			if ((flags and 4) != 0) {
				replies?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x455b853du.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessageViews? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessageViews")
					}
					else {
						null
					}
				}
	
				val result = TLMessageViews()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesMessageViews: TLObject() {
		@JvmField val views = mutableListOf<TLMessageViews>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLMessageViews.deserialize(stream, stream.readInt32(exception), exception) ?: return
				views.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(views.size)
			views.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xb6c4f543u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesMessageViews? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesMessageViews")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesMessageViews()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetMessagesViews: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField val id = mutableListOf<Int>()
		@JvmField var increment = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesMessageViews? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesMessageViews.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { stream.writeInt32(it) }
			stream.writeBool(increment)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5784d3e1u.toInt()
		}
	}
	
	open class TLMessagesDiscussionMessage: TLObject() {
		@JvmField var flags = 0
		@JvmField val messages = mutableListOf<Message>()
		@JvmField var maxId = 0
		@JvmField var readInboxMaxId = 0
		@JvmField var readOutboxMaxId = 0
		@JvmField var unreadCount = 0
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Message.deserialize(stream, stream.readInt32(exception), exception) ?: return
				messages.add(obj)
			}
		
			if ((flags and 1) != 0) {
				maxId = stream.readInt32(exception)
			}
		
			if ((flags and 2) != 0) {
				readInboxMaxId = stream.readInt32(exception)
			}
		
			if ((flags and 4) != 0) {
				readOutboxMaxId = stream.readInt32(exception)
			}
			unreadCount = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (maxId != 0) flags or 1 else flags and 1.inv()
			flags = if (readInboxMaxId != 0) flags or 2 else flags and 2.inv()
			flags = if (readOutboxMaxId != 0) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { it.serializeToStream(stream) }
			if ((flags and 1) != 0) {
				stream.writeInt32(maxId)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(readInboxMaxId)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(readOutboxMaxId)
			}
	
			stream.writeInt32(unreadCount)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xa6341782u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesDiscussionMessage? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesDiscussionMessage")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesDiscussionMessage()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetDiscussionMessage: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var msgId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesDiscussionMessage? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesDiscussionMessage.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x446972fdu.toInt()
		}
	}
	
	open class TLMessageReplyHeader: TLObject() {
		@JvmField var flags = 0
		@JvmField var replyToScheduled = false
		@JvmField var replyToMsgId = 0
		@JvmField var replyToPeerId: Peer? = null
		@JvmField var replyToTopId = 0
	
		@JvmField var replyToRandomId: Long = 0L
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			replyToScheduled = (flags and 4) != 0
			replyToMsgId = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				replyToPeerId = Peer.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				replyToTopId = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (replyToScheduled) flags or 4 else flags and 4.inv()
			flags = if (replyToPeerId != null) flags or 1 else flags and 1.inv()
			flags = if (replyToTopId != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(replyToMsgId)
			if ((flags and 1) != 0) {
				replyToPeerId?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(replyToTopId)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa6d57763u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessageReplyHeader? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessageReplyHeader")
					}
					else {
						null
					}
				}
	
				val result = TLMessageReplyHeader()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessageReplies: TLObject() {
		@JvmField var flags = 0
		@JvmField var comments = false
		@JvmField var replies = 0
		@JvmField var repliesPts = 0
		@JvmField val recentRepliers = mutableListOf<Peer>()
		@JvmField var channelId = 0L
		@JvmField var maxId = 0
		@JvmField var readMaxId = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			comments = (flags and 1) != 0
			replies = stream.readInt32(exception)
			repliesPts = stream.readInt32(exception)
		
			if ((flags and 2) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = Peer.deserialize(stream, stream.readInt32(exception), exception) ?: return
					recentRepliers.add(obj)
				}
			}
		
			if ((flags and 1) != 0) {
				channelId = stream.readInt64(exception)
			}
		
			if ((flags and 4) != 0) {
				maxId = stream.readInt32(exception)
			}
		
			if ((flags and 8) != 0) {
				readMaxId = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (comments) flags or 1 else flags and 1.inv()
			flags = if (channelId != 0L) flags or 1 else flags and 1.inv()
			flags = if (maxId != 0) flags or 4 else flags and 4.inv()
			flags = if (readMaxId != 0) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(replies)
			stream.writeInt32(repliesPts)
			if ((flags and 2) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(recentRepliers.size)
			recentRepliers.forEach { it.serializeToStream(stream) }
			}
	
			if ((flags and 1) != 0) {
				stream.writeInt64(channelId)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(maxId)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt32(readMaxId)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x83d60fc2u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessageReplies? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessageReplies")
					}
					else {
						null
					}
				}
	
				val result = TLMessageReplies()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPeerBlocked: TLObject() {
		@JvmField var peerId: Peer? = null
		@JvmField var date = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peerId = Peer.deserialize(stream, stream.readInt32(exception), exception)
			date = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peerId?.serializeToStream(stream)
			stream.writeInt32(date)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe8fd8014u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPeerBlocked? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPeerBlocked")
					}
					else {
						null
					}
				}
	
				val result = TLPeerBlocked()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLStatsMessageStats: TLObject() {
		@JvmField var viewsGraph: StatsGraph? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			viewsGraph = StatsGraph.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			viewsGraph?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8999f295u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStatsMessageStats? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLStatsMessageStats")
					}
					else {
						null
					}
				}
	
				val result = TLStatsMessageStats()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLStatsGetMessageStats: TLObject() {
		@JvmField var flags = 0
		@JvmField var dark = false
		@JvmField var channel: InputChannel? = null
		@JvmField var msgId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStatsMessageStats? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLStatsMessageStats.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (dark) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			channel?.serializeToStream(stream)
			stream.writeInt32(msgId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb6e0a3f5u.toInt()
		}
	}
	
	abstract class GroupCall: TLObject() {
		@JvmField var accessHash = 0L
		@JvmField var id = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): GroupCall? {
				val result = when (constructor) {
					TLGroupCallDiscarded.CONSTRUCTOR -> TLGroupCallDiscarded()
					TLGroupCall.CONSTRUCTOR -> TLGroupCall()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in GroupCall")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLGroupCallDiscarded: GroupCall() {
				@JvmField var duration = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			duration = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeInt32(duration)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7780bcb4u.toInt()
		}
	}
	
	open class TLGroupCall: GroupCall() {
		@JvmField var flags = 0
		@JvmField var joinMuted = false
		@JvmField var canChangeJoinMuted = false
		@JvmField var joinDateAsc = false
		@JvmField var scheduleStartSubscribed = false
		@JvmField var canStartVideo = false
		@JvmField var recordVideoActive = false
		@JvmField var rtmpStream = false
		@JvmField var listenersHidden = false
				@JvmField var participantsCount = 0
		@JvmField var title: String? = null
		@JvmField var streamDcId = 0
		@JvmField var recordStartDate = 0
		@JvmField var scheduleDate = 0
		@JvmField var unmutedVideoCount = 0
		@JvmField var unmutedVideoLimit = 0
		@JvmField var version = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			joinMuted = (flags and 2) != 0
			canChangeJoinMuted = (flags and 4) != 0
			joinDateAsc = (flags and 64) != 0
			scheduleStartSubscribed = (flags and 256) != 0
			canStartVideo = (flags and 512) != 0
			recordVideoActive = (flags and 2048) != 0
			rtmpStream = (flags and 4096) != 0
			listenersHidden = (flags and 8192) != 0
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			participantsCount = stream.readInt32(exception)
		
			if ((flags and 8) != 0) {
				title = stream.readString(exception) ?: return
			}
		
			if ((flags and 16) != 0) {
				streamDcId = stream.readInt32(exception)
			}
		
			if ((flags and 32) != 0) {
				recordStartDate = stream.readInt32(exception)
			}
		
			if ((flags and 128) != 0) {
				scheduleDate = stream.readInt32(exception)
			}
		
			if ((flags and 1024) != 0) {
				unmutedVideoCount = stream.readInt32(exception)
			}
			unmutedVideoLimit = stream.readInt32(exception)
			version = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (joinMuted) flags or 2 else flags and 2.inv()
			flags = if (canChangeJoinMuted) flags or 4 else flags and 4.inv()
			flags = if (joinDateAsc) flags or 64 else flags and 64.inv()
			flags = if (scheduleStartSubscribed) flags or 256 else flags and 256.inv()
			flags = if (canStartVideo) flags or 512 else flags and 512.inv()
			flags = if (recordVideoActive) flags or 2048 else flags and 2048.inv()
			flags = if (rtmpStream) flags or 4096 else flags and 4096.inv()
			flags = if (listenersHidden) flags or 8192 else flags and 8192.inv()
			flags = if (title != null) flags or 8 else flags and 8.inv()
			flags = if (streamDcId != 0) flags or 16 else flags and 16.inv()
			flags = if (recordStartDate != 0) flags or 32 else flags and 32.inv()
			flags = if (scheduleDate != 0) flags or 128 else flags and 128.inv()
			flags = if (unmutedVideoCount != 0) flags or 1024 else flags and 1024.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeInt32(participantsCount)
			if ((flags and 8) != 0) {
				stream.writeString(title)
			}
	
			if ((flags and 16) != 0) {
				stream.writeInt32(streamDcId)
			}
	
			if ((flags and 32) != 0) {
				stream.writeInt32(recordStartDate)
			}
	
			if ((flags and 128) != 0) {
				stream.writeInt32(scheduleDate)
			}
	
			if ((flags and 1024) != 0) {
				stream.writeInt32(unmutedVideoCount)
			}
	
			stream.writeInt32(unmutedVideoLimit)
			stream.writeInt32(version)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd597650cu.toInt()
		}
	}
	
	open class TLInputGroupCall: TLObject() {
		@JvmField var id = 0L
		@JvmField var accessHash = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd8aa840fu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLInputGroupCall? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLInputGroupCall")
					}
					else {
						null
					}
				}
	
				val result = TLInputGroupCall()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLGroupCallParticipant: TLObject() {
		@JvmField var flags = 0
		@JvmField var muted = false
		@JvmField var left = false
		@JvmField var canSelfUnmute = false
		@JvmField var justJoined = false
		@JvmField var versioned = false
		@JvmField var min = false
		@JvmField var mutedByYou = false
		@JvmField var volumeByAdmin = false
		@JvmField var isSelf = false
		@JvmField var videoJoined = false
		@JvmField var peer: Peer? = null
		@JvmField var date = 0
		@JvmField var activeDate = 0
		@JvmField var source = 0
		@JvmField var volume = 0
		@JvmField var about: String? = null
		@JvmField var raiseHandRating = 0L
		@JvmField var video: TLGroupCallParticipantVideo? = null
		@JvmField var presentation: TLGroupCallParticipantVideo? = null
	
		@JvmField var lastSpeakTime: Long = 0L
		@JvmField var amplitude: Float = 0.0f
		@JvmField var hasVoice: Boolean = false
		@JvmField var hasVoiceDelayed: Boolean = false
		@JvmField var lastVoiceUpdateTime: Long = 0L
		@JvmField var lastActiveDate: Long = 0L
		@JvmField var lastVisibleDate: Long = 0L
		@JvmField var lastTypingDate: Int = 0
		@JvmField var lastRaiseHandDate: Long = 0L
		@JvmField var videoEndpoint: String? = null
		@JvmField var presentationEndpoint: String? = null
		@JvmField var videoIndex: Int = 0
		@JvmField var hasPresentationFrame: Int = 0
		@JvmField var hasCameraFrame: Int = 0
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			muted = (flags and 1) != 0
			left = (flags and 2) != 0
			canSelfUnmute = (flags and 4) != 0
			justJoined = (flags and 16) != 0
			versioned = (flags and 32) != 0
			min = (flags and 256) != 0
			mutedByYou = (flags and 512) != 0
			volumeByAdmin = (flags and 1024) != 0
			isSelf = (flags and 4096) != 0
			videoJoined = (flags and 32768) != 0
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
			date = stream.readInt32(exception)
		
			if ((flags and 8) != 0) {
				activeDate = stream.readInt32(exception)
			}
			source = stream.readInt32(exception)
		
			if ((flags and 128) != 0) {
				volume = stream.readInt32(exception)
			}
		
			if ((flags and 2048) != 0) {
				about = stream.readString(exception) ?: return
			}
		
			if ((flags and 8192) != 0) {
				raiseHandRating = stream.readInt64(exception)
			}
		
			if ((flags and 64) != 0) {
				video = TLGroupCallParticipantVideo.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 16384) != 0) {
				presentation = TLGroupCallParticipantVideo.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (muted) flags or 1 else flags and 1.inv()
			flags = if (left) flags or 2 else flags and 2.inv()
			flags = if (canSelfUnmute) flags or 4 else flags and 4.inv()
			flags = if (justJoined) flags or 16 else flags and 16.inv()
			flags = if (versioned) flags or 32 else flags and 32.inv()
			flags = if (min) flags or 256 else flags and 256.inv()
			flags = if (mutedByYou) flags or 512 else flags and 512.inv()
			flags = if (volumeByAdmin) flags or 1024 else flags and 1024.inv()
			flags = if (isSelf) flags or 4096 else flags and 4096.inv()
			flags = if (videoJoined) flags or 32768 else flags and 32768.inv()
			flags = if (activeDate != 0) flags or 8 else flags and 8.inv()
			flags = if (volume != 0) flags or 128 else flags and 128.inv()
			flags = if (about != null) flags or 2048 else flags and 2048.inv()
			flags = if (raiseHandRating != 0L) flags or 8192 else flags and 8192.inv()
			flags = if (video != null) flags or 64 else flags and 64.inv()
			flags = if (presentation != null) flags or 16384 else flags and 16384.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt32(date)
			if ((flags and 8) != 0) {
				stream.writeInt32(activeDate)
			}
	
			stream.writeInt32(source)
			if ((flags and 128) != 0) {
				stream.writeInt32(volume)
			}
	
			if ((flags and 2048) != 0) {
				stream.writeString(about)
			}
	
			if ((flags and 8192) != 0) {
				stream.writeInt64(raiseHandRating)
			}
	
			if ((flags and 64) != 0) {
				video?.serializeToStream(stream)
			}
	
			if ((flags and 16384) != 0) {
				presentation?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xeba636feu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLGroupCallParticipant? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLGroupCallParticipant")
					}
					else {
						null
					}
				}
	
				val result = TLGroupCallParticipant()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPhoneGroupCall: TLObject() {
		@JvmField var call: GroupCall? = null
		@JvmField val participants = mutableListOf<TLGroupCallParticipant>()
		@JvmField var participantsNextOffset: String? = null
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			call = GroupCall.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLGroupCallParticipant.deserialize(stream, stream.readInt32(exception), exception) ?: return
				participants.add(obj)
			}
			participantsNextOffset = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(participants.size)
			participants.forEach { it.serializeToStream(stream) }
			stream.writeString(participantsNextOffset)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x9e727aadu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhoneGroupCall? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPhoneGroupCall")
					}
					else {
						null
					}
				}
	
				val result = TLPhoneGroupCall()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPhoneGetGroupCall: TLObject() {
		@JvmField var call: TLInputGroupCall? = null
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhoneGroupCall? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPhoneGroupCall.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0x41845dbu.toInt()
		}
	}
	
	open class TLPhoneGroupParticipants: TLObject() {
		@JvmField var count = 0
		@JvmField val participants = mutableListOf<TLGroupCallParticipant>()
		@JvmField var nextOffset: String? = null
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
		@JvmField var version = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			count = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLGroupCallParticipant.deserialize(stream, stream.readInt32(exception), exception) ?: return
				participants.add(obj)
			}
			nextOffset = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
			version = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(count)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(participants.size)
			participants.forEach { it.serializeToStream(stream) }
			stream.writeString(nextOffset)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
			stream.writeInt32(version)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf47751b6u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhoneGroupParticipants? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPhoneGroupParticipants")
					}
					else {
						null
					}
				}
	
				val result = TLPhoneGroupParticipants()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPhoneGetGroupParticipants: TLObject() {
		@JvmField var call: TLInputGroupCall? = null
		@JvmField val ids = mutableListOf<InputPeer>()
		@JvmField val sources = mutableListOf<Int>()
		@JvmField var offset: String? = null
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhoneGroupParticipants? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPhoneGroupParticipants.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(ids.size)
			ids.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(sources.size)
			sources.forEach { stream.writeInt32(it) }
			stream.writeString(offset)
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc558d8abu.toInt()
		}
	}
	
	abstract class InlineQueryPeerType: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InlineQueryPeerType? {
				val result = when (constructor) {
					TLInlineQueryPeerTypeSameBotPM.CONSTRUCTOR -> TLInlineQueryPeerTypeSameBotPM()
					TLInlineQueryPeerTypePM.CONSTRUCTOR -> TLInlineQueryPeerTypePM()
					TLInlineQueryPeerTypeChat.CONSTRUCTOR -> TLInlineQueryPeerTypeChat()
					TLInlineQueryPeerTypeMegagroup.CONSTRUCTOR -> TLInlineQueryPeerTypeMegagroup()
					TLInlineQueryPeerTypeBroadcast.CONSTRUCTOR -> TLInlineQueryPeerTypeBroadcast()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InlineQueryPeerType")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInlineQueryPeerTypeSameBotPM: InlineQueryPeerType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3081ed9du.toInt()
		}
	}
	
	open class TLInlineQueryPeerTypePM: InlineQueryPeerType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x833c0facu.toInt()
		}
	}
	
	open class TLInlineQueryPeerTypeChat: InlineQueryPeerType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd766c50au.toInt()
		}
	}
	
	open class TLInlineQueryPeerTypeMegagroup: InlineQueryPeerType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x5ec4be43u.toInt()
		}
	}
	
	open class TLInlineQueryPeerTypeBroadcast: InlineQueryPeerType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x6334ee9au.toInt()
		}
	}
	
	open class TLMessagesHistoryImport: TLObject() {
		@JvmField var id = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1662af0bu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesHistoryImport? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesHistoryImport")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesHistoryImport()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesInitHistoryImport: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var file: InputFile? = null
		@JvmField var mediaCount = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesHistoryImport? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesHistoryImport.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			file?.serializeToStream(stream)
			stream.writeInt32(mediaCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0x34090c3bu.toInt()
		}
	}
	
	open class TLMessagesHistoryImportParsed: TLObject() {
		@JvmField var flags = 0
		@JvmField var pm = false
		@JvmField var group = false
		@JvmField var title: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			pm = (flags and 1) != 0
			group = (flags and 2) != 0
		
			if ((flags and 4) != 0) {
				title = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (pm) flags or 1 else flags and 1.inv()
			flags = if (group) flags or 2 else flags and 2.inv()
			flags = if (title != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			if ((flags and 4) != 0) {
				stream.writeString(title)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x5e0fb7b9u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesHistoryImportParsed? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesHistoryImportParsed")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesHistoryImportParsed()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesCheckHistoryImport: TLObject() {
		@JvmField var importHead: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesHistoryImportParsed? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesHistoryImportParsed.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(importHead)
		}
	
		companion object {
			val CONSTRUCTOR = 0x43fe19f3u.toInt()
		}
	}
	
	open class TLMessagesAffectedFoundMessages: TLObject() {
		@JvmField var pts = 0
		@JvmField var ptsCount = 0
		@JvmField var offset = 0
		@JvmField val messages = mutableListOf<Int>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
			offset = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt32(exception)
				messages.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
			stream.writeInt32(offset)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xef8d3e6cu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesAffectedFoundMessages? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesAffectedFoundMessages")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesAffectedFoundMessages()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesDeletePhoneCallHistory: TLObject() {
		@JvmField var flags = 0
		@JvmField var revoke = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesAffectedFoundMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesAffectedFoundMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (revoke) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf9cbe409u.toInt()
		}
	}
	
	open class TLChatInviteImporter: TLObject() {
		@JvmField var flags = 0
		@JvmField var requested = false
		@JvmField var userId = 0L
		@JvmField var date = 0
		@JvmField var about: String? = null
		@JvmField var approvedBy = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			requested = (flags and 1) != 0
			userId = stream.readInt64(exception)
			date = stream.readInt32(exception)
		
			if ((flags and 4) != 0) {
				about = stream.readString(exception) ?: return
			}
		
			if ((flags and 2) != 0) {
				approvedBy = stream.readInt64(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (requested) flags or 1 else flags and 1.inv()
			flags = if (about != null) flags or 4 else flags and 4.inv()
			flags = if (approvedBy != 0L) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(userId)
			stream.writeInt32(date)
			if ((flags and 4) != 0) {
				stream.writeString(about)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt64(approvedBy)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x8c5adfd9u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChatInviteImporter? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLChatInviteImporter")
					}
					else {
						null
					}
				}
	
				val result = TLChatInviteImporter()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesExportedChatInvites: TLObject() {
		@JvmField var count = 0
		@JvmField val invites = mutableListOf<ExportedChatInvite>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			count = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception) ?: return
				invites.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(count)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(invites.size)
			invites.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xbdc62dccu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesExportedChatInvites? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesExportedChatInvites")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesExportedChatInvites()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetExportedChatInvites: TLObject() {
		@JvmField var flags = 0
		@JvmField var revoked = false
		@JvmField var peer: InputPeer? = null
		@JvmField var adminId: InputUser? = null
		@JvmField var offsetDate = 0
		@JvmField var offsetLink: String? = null
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesExportedChatInvites? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesExportedChatInvites.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (revoked) flags or 8 else flags and 8.inv()
			flags = if (offsetDate != 0) flags or 4 else flags and 4.inv()
			flags = if (offsetLink != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			adminId?.serializeToStream(stream)
			if ((flags and 4) != 0) {
				stream.writeInt32(offsetDate)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(offsetLink)
			}
	
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa2b5a3f6u.toInt()
		}
	}
	
	abstract class MessagesExportedChatInvite: TLObject() {
		@JvmField val users = mutableListOf<User>()
		@JvmField var invite: ExportedChatInvite? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesExportedChatInvite? {
				val result = when (constructor) {
					TLMessagesExportedChatInvite.CONSTRUCTOR -> TLMessagesExportedChatInvite()
					TLMessagesExportedChatInviteReplaced.CONSTRUCTOR -> TLMessagesExportedChatInviteReplaced()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesExportedChatInvite")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesExportedChatInvite: MessagesExportedChatInvite() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			invite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			invite?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x1871be50u.toInt()
		}
	}
	
	open class TLMessagesExportedChatInviteReplaced: MessagesExportedChatInvite() {
			@JvmField var newInvite: ExportedChatInvite? = null
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			invite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
			newInvite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			invite?.serializeToStream(stream)
			newInvite?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x222600efu.toInt()
		}
	}
	
	open class TLMessagesGetExportedChatInvite: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var link: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesExportedChatInvite? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesExportedChatInvite.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeString(link)
		}
	
		companion object {
			val CONSTRUCTOR = 0x73746f5cu.toInt()
		}
	}
	
	open class TLMessagesEditExportedChatInvite: TLObject() {
		@JvmField var flags = 0
		@JvmField var revoked = false
		@JvmField var peer: InputPeer? = null
		@JvmField var link: String? = null
		@JvmField var expireDate = 0
		@JvmField var usageLimit = 0
		@JvmField var requestNeeded = false
		@JvmField var title: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesExportedChatInvite? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesExportedChatInvite.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (revoked) flags or 4 else flags and 4.inv()
			flags = if (expireDate != 0) flags or 1 else flags and 1.inv()
			flags = if (usageLimit != 0) flags or 2 else flags and 2.inv()
			flags = if (requestNeeded) flags or 8 else flags and 8.inv()
			flags = if (title != null) flags or 16 else flags and 16.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeString(link)
			if ((flags and 1) != 0) {
				stream.writeInt32(expireDate)
			}
	
			if ((flags and 2) != 0) {
				stream.writeInt32(usageLimit)
			}
	
			if ((flags and 8) != 0) {
				stream.writeBool(requestNeeded)
			}
	
			if ((flags and 16) != 0) {
				stream.writeString(title)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xbdca2f75u.toInt()
		}
	}
	
	open class TLMessagesChatInviteImporters: TLObject() {
		@JvmField var count = 0
		@JvmField val importers = mutableListOf<TLChatInviteImporter>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			count = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLChatInviteImporter.deserialize(stream, stream.readInt32(exception), exception) ?: return
				importers.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(count)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(importers.size)
			importers.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x81b6b00au.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesChatInviteImporters? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesChatInviteImporters")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesChatInviteImporters()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetChatInviteImporters: TLObject() {
		@JvmField var flags = 0
		@JvmField var requested = false
		@JvmField var peer: InputPeer? = null
		@JvmField var link: String? = null
		@JvmField var q: String? = null
		@JvmField var offsetDate = 0
		@JvmField var offsetUser: InputUser? = null
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesChatInviteImporters? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesChatInviteImporters.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (requested) flags or 1 else flags and 1.inv()
			flags = if (link != null) flags or 2 else flags and 2.inv()
			flags = if (q != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			if ((flags and 2) != 0) {
				stream.writeString(link)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(q)
			}
	
			stream.writeInt32(offsetDate)
			offsetUser?.serializeToStream(stream)
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdf04dd4eu.toInt()
		}
	}
	
	open class TLChatAdminWithInvites: TLObject() {
		@JvmField var adminId = 0L
		@JvmField var invitesCount = 0
		@JvmField var revokedInvitesCount = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			adminId = stream.readInt64(exception)
			invitesCount = stream.readInt32(exception)
			revokedInvitesCount = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(adminId)
			stream.writeInt32(invitesCount)
			stream.writeInt32(revokedInvitesCount)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf2ecef23u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChatAdminWithInvites? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLChatAdminWithInvites")
					}
					else {
						null
					}
				}
	
				val result = TLChatAdminWithInvites()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesChatAdminsWithInvites: TLObject() {
		@JvmField val admins = mutableListOf<TLChatAdminWithInvites>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLChatAdminWithInvites.deserialize(stream, stream.readInt32(exception), exception) ?: return
				admins.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(admins.size)
			admins.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xb69b72d7u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesChatAdminsWithInvites? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesChatAdminsWithInvites")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesChatAdminsWithInvites()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetAdminsWithInvites: TLObject() {
		@JvmField var peer: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesChatAdminsWithInvites? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesChatAdminsWithInvites.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3920e6efu.toInt()
		}
	}
	
	open class TLMessagesCheckedHistoryImportPeer: TLObject() {
		@JvmField var confirmText: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			confirmText = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(confirmText)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa24de717u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesCheckedHistoryImportPeer? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesCheckedHistoryImportPeer")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesCheckedHistoryImportPeer()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesCheckHistoryImportPeer: TLObject() {
		@JvmField var peer: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesCheckedHistoryImportPeer? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesCheckedHistoryImportPeer.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5dc60f03u.toInt()
		}
	}
	
	open class TLPhoneJoinAsPeers: TLObject() {
		@JvmField val peers = mutableListOf<Peer>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Peer.deserialize(stream, stream.readInt32(exception), exception) ?: return
				peers.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(peers.size)
			peers.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xafe5623fu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhoneJoinAsPeers? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPhoneJoinAsPeers")
					}
					else {
						null
					}
				}
	
				val result = TLPhoneJoinAsPeers()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPhoneGetGroupCallJoinAs: TLObject() {
		@JvmField var peer: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhoneJoinAsPeers? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPhoneJoinAsPeers.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xef7c213au.toInt()
		}
	}
	
	open class TLPhoneExportedGroupCallInvite: TLObject() {
		@JvmField var link: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			link = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(link)
		}
	
		companion object {
			val CONSTRUCTOR = 0x204bd158u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhoneExportedGroupCallInvite? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPhoneExportedGroupCallInvite")
					}
					else {
						null
					}
				}
	
				val result = TLPhoneExportedGroupCallInvite()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPhoneExportGroupCallInvite: TLObject() {
		@JvmField var flags = 0
		@JvmField var canSelfUnmute = false
		@JvmField var call: TLInputGroupCall? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhoneExportedGroupCallInvite? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPhoneExportedGroupCallInvite.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (canSelfUnmute) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			call?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe6aa647fu.toInt()
		}
	}
	
	open class TLGroupCallParticipantVideoSourceGroup: TLObject() {
		@JvmField var semantics: String? = null
		@JvmField val sources = mutableListOf<Int>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			semantics = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt32(exception)
				sources.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(semantics)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(sources.size)
			sources.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xdcb118b7u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLGroupCallParticipantVideoSourceGroup? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLGroupCallParticipantVideoSourceGroup")
					}
					else {
						null
					}
				}
	
				val result = TLGroupCallParticipantVideoSourceGroup()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLGroupCallParticipantVideo: TLObject() {
		@JvmField var flags = 0
		@JvmField var paused = false
		@JvmField var endpoint: String? = null
		@JvmField val sourceGroups = mutableListOf<TLGroupCallParticipantVideoSourceGroup>()
		@JvmField var audioSource = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			paused = (flags and 1) != 0
			endpoint = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLGroupCallParticipantVideoSourceGroup.deserialize(stream, stream.readInt32(exception), exception) ?: return
				sourceGroups.add(obj)
			}
		
			if ((flags and 2) != 0) {
				audioSource = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (paused) flags or 1 else flags and 1.inv()
			flags = if (audioSource != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeString(endpoint)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(sourceGroups.size)
			sourceGroups.forEach { it.serializeToStream(stream) }
			if ((flags and 2) != 0) {
				stream.writeInt32(audioSource)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x67753ac8u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLGroupCallParticipantVideo? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLGroupCallParticipantVideo")
					}
					else {
						null
					}
				}
	
				val result = TLGroupCallParticipantVideo()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLStickersSuggestedShortName: TLObject() {
		@JvmField var shortName: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			shortName = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(shortName)
		}
	
		companion object {
			val CONSTRUCTOR = 0x85fea03fu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStickersSuggestedShortName? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLStickersSuggestedShortName")
					}
					else {
						null
					}
				}
	
				val result = TLStickersSuggestedShortName()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLStickersSuggestShortName: TLObject() {
		@JvmField var title: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStickersSuggestedShortName? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLStickersSuggestedShortName.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(title)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4dafc503u.toInt()
		}
	}
	
	abstract class BotCommandScope: TLObject() {
		@JvmField var peer: InputPeer? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): BotCommandScope? {
				val result = when (constructor) {
					TLBotCommandScopeDefault.CONSTRUCTOR -> TLBotCommandScopeDefault()
					TLBotCommandScopeUsers.CONSTRUCTOR -> TLBotCommandScopeUsers()
					TLBotCommandScopeChats.CONSTRUCTOR -> TLBotCommandScopeChats()
					TLBotCommandScopeChatAdmins.CONSTRUCTOR -> TLBotCommandScopeChatAdmins()
					TLBotCommandScopePeer.CONSTRUCTOR -> TLBotCommandScopePeer()
					TLBotCommandScopePeerAdmins.CONSTRUCTOR -> TLBotCommandScopePeerAdmins()
					TLBotCommandScopePeerUser.CONSTRUCTOR -> TLBotCommandScopePeerUser()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in BotCommandScope")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLBotCommandScopeDefault: BotCommandScope() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x2f6cb2abu.toInt()
		}
	}
	
	open class TLBotCommandScopeUsers: BotCommandScope() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3c4f04d8u.toInt()
		}
	}
	
	open class TLBotCommandScopeChats: BotCommandScope() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x6fe1a881u.toInt()
		}
	}
	
	open class TLBotCommandScopeChatAdmins: BotCommandScope() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb9aa606au.toInt()
		}
	}
	
	open class TLBotCommandScopePeer: BotCommandScope() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = InputPeer.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdb9d897du.toInt()
		}
	}
	
	open class TLBotCommandScopePeerAdmins: BotCommandScope() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = InputPeer.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3fd863d1u.toInt()
		}
	}
	
	open class TLBotCommandScopePeerUser: BotCommandScope() {
			@JvmField var userId: InputUser? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = InputPeer.deserialize(stream, stream.readInt32(exception), exception)
			userId = InputUser.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			userId?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa1321f3u.toInt()
		}
	}
	
	abstract class AccountResetPasswordResult: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AccountResetPasswordResult? {
				val result = when (constructor) {
					TLAccountResetPasswordFailedWait.CONSTRUCTOR -> TLAccountResetPasswordFailedWait()
					TLAccountResetPasswordRequestedWait.CONSTRUCTOR -> TLAccountResetPasswordRequestedWait()
					TLAccountResetPasswordOk.CONSTRUCTOR -> TLAccountResetPasswordOk()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in AccountResetPasswordResult")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLAccountResetPasswordFailedWait: AccountResetPasswordResult() {
		@JvmField var retryDate = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			retryDate = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(retryDate)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe3779861u.toInt()
		}
	}
	
	open class TLAccountResetPasswordRequestedWait: AccountResetPasswordResult() {
		@JvmField var untilDate = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			untilDate = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(untilDate)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe9effc7du.toInt()
		}
	}
	
	open class TLAccountResetPasswordOk: AccountResetPasswordResult() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xe926d63eu.toInt()
		}
	}
	
	open class TLAccountResetPassword: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AccountResetPasswordResult? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AccountResetPasswordResult.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9308ce1bu.toInt()
		}
	}
	
	open class TLSponsoredMessage: TLObject() {
		@JvmField var flags = 0
		@JvmField var recommended = false
		@JvmField var randomId: ByteArray? = null
		@JvmField var fromId: Peer? = null
		@JvmField var chatInvite: ChatInvite? = null
		@JvmField var chatInviteHash: String? = null
		@JvmField var channelPost = 0
		@JvmField var startParam: String? = null
		@JvmField var message: String? = null
		@JvmField val entities = mutableListOf<MessageEntity>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			recommended = (flags and 32) != 0
			randomId = stream.readByteArray(exception) ?: return
		
			if ((flags and 8) != 0) {
				fromId = Peer.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 16) != 0) {
				chatInvite = ChatInvite.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 16) != 0) {
				chatInviteHash = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				channelPost = stream.readInt32(exception)
			}
		
			if ((flags and 1) != 0) {
				startParam = stream.readString(exception) ?: return
			}
			message = stream.readString(exception) ?: return
		
			if ((flags and 2) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
					entities.add(obj)
				}
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (recommended) flags or 32 else flags and 32.inv()
			flags = if (fromId != null) flags or 8 else flags and 8.inv()
			flags = if (chatInvite != null) flags or 16 else flags and 16.inv()
			flags = if (chatInviteHash != null) flags or 16 else flags and 16.inv()
			flags = if (channelPost != 0) flags or 4 else flags and 4.inv()
			flags = if (startParam != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeByteArray(randomId)
			if ((flags and 8) != 0) {
				fromId?.serializeToStream(stream)
			}
	
			if ((flags and 16) != 0) {
				chatInvite?.serializeToStream(stream)
			}
	
			if ((flags and 16) != 0) {
				stream.writeString(chatInviteHash)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(channelPost)
			}
	
			if ((flags and 1) != 0) {
				stream.writeString(startParam)
			}
	
			stream.writeString(message)
			if ((flags and 2) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(entities.size)
			entities.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3a836df8u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLSponsoredMessage? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLSponsoredMessage")
					}
					else {
						null
					}
				}
	
				val result = TLSponsoredMessage()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesSponsoredMessages: TLObject() {
		@JvmField val messages = mutableListOf<TLSponsoredMessage>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLSponsoredMessage.deserialize(stream, stream.readInt32(exception), exception) ?: return
				messages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x65a4c7d5u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesSponsoredMessages? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesSponsoredMessages")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesSponsoredMessages()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLChannelsGetSponsoredMessages: TLObject() {
		@JvmField var channel: InputChannel? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesSponsoredMessages? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesSponsoredMessages.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			channel?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xec210fbfu.toInt()
		}
	}
	
	open class TLSearchResultsCalendarPeriod: TLObject() {
		@JvmField var date = 0
		@JvmField var minMsgId = 0
		@JvmField var maxMsgId = 0
		@JvmField var count = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			date = stream.readInt32(exception)
			minMsgId = stream.readInt32(exception)
			maxMsgId = stream.readInt32(exception)
			count = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(date)
			stream.writeInt32(minMsgId)
			stream.writeInt32(maxMsgId)
			stream.writeInt32(count)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc9b0539fu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLSearchResultsCalendarPeriod? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLSearchResultsCalendarPeriod")
					}
					else {
						null
					}
				}
	
				val result = TLSearchResultsCalendarPeriod()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesSearchResultsCalendar: TLObject() {
		@JvmField var flags = 0
		@JvmField var inexact = false
		@JvmField var count = 0
		@JvmField var minDate = 0
		@JvmField var minMsgId = 0
		@JvmField var offsetIdOffset = 0
		@JvmField val periods = mutableListOf<TLSearchResultsCalendarPeriod>()
		@JvmField val messages = mutableListOf<Message>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			inexact = (flags and 1) != 0
			count = stream.readInt32(exception)
			minDate = stream.readInt32(exception)
			minMsgId = stream.readInt32(exception)
		
			if ((flags and 2) != 0) {
				offsetIdOffset = stream.readInt32(exception)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLSearchResultsCalendarPeriod.deserialize(stream, stream.readInt32(exception), exception) ?: return
				periods.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Message.deserialize(stream, stream.readInt32(exception), exception) ?: return
				messages.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (inexact) flags or 1 else flags and 1.inv()
			flags = if (offsetIdOffset != 0) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(count)
			stream.writeInt32(minDate)
			stream.writeInt32(minMsgId)
			if ((flags and 2) != 0) {
				stream.writeInt32(offsetIdOffset)
			}
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(periods.size)
			periods.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(messages.size)
			messages.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x147ee23cu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesSearchResultsCalendar? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesSearchResultsCalendar")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesSearchResultsCalendar()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetSearchResultsCalendar: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var filter: MessagesFilter? = null
		@JvmField var offsetId = 0
		@JvmField var offsetDate = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesSearchResultsCalendar? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesSearchResultsCalendar.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			filter?.serializeToStream(stream)
			stream.writeInt32(offsetId)
			stream.writeInt32(offsetDate)
		}
	
		companion object {
			val CONSTRUCTOR = 0x49f0bde9u.toInt()
		}
	}
	
	open class TLSearchResultsPosition: TLObject() {
		@JvmField var msgId = 0
		@JvmField var date = 0
		@JvmField var offset = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			msgId = stream.readInt32(exception)
			date = stream.readInt32(exception)
			offset = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(msgId)
			stream.writeInt32(date)
			stream.writeInt32(offset)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7f648b67u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLSearchResultsPosition? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLSearchResultsPosition")
					}
					else {
						null
					}
				}
	
				val result = TLSearchResultsPosition()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesSearchResultsPositions: TLObject() {
		@JvmField var count = 0
		@JvmField val positions = mutableListOf<TLSearchResultsPosition>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			count = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLSearchResultsPosition.deserialize(stream, stream.readInt32(exception), exception) ?: return
				positions.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(count)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(positions.size)
			positions.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x53b22bafu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesSearchResultsPositions? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesSearchResultsPositions")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesSearchResultsPositions()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetSearchResultsPositions: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var filter: MessagesFilter? = null
		@JvmField var offsetId = 0
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesSearchResultsPositions? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesSearchResultsPositions.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			filter?.serializeToStream(stream)
			stream.writeInt32(offsetId)
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6e9583a3u.toInt()
		}
	}
	
	abstract class ChannelsSendAsPeers: TLObject() {
		@JvmField val users = mutableListOf<User>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val peers = mutableListOf<SendAsPeer>()
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChannelsSendAsPeers? {
				val result = when (constructor) {
					TLChannelsSendAsPeers.CONSTRUCTOR -> TLChannelsSendAsPeers()
					TLChannelsSendAsPeersLayer3.CONSTRUCTOR -> TLChannelsSendAsPeersLayer3()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ChannelsSendAsPeers")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChannelsSendAsPeers: ChannelsSendAsPeers() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = SendAsPeer.deserialize(stream, stream.readInt32(exception), exception) ?: return
				peers.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(peers.size)
			peers.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xf496b0c6u.toInt()
		}
	}
	
	open class TLChannelsSendAsPeersLayer3: ChannelsSendAsPeers() {
					@JvmField val peersVECTORPEER = mutableListOf<Peer>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = SendAsPeer.deserialize(stream, stream.readInt32(exception), exception) ?: return
				peers.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Peer.deserialize(stream, stream.readInt32(exception), exception) ?: return
				peersVECTORPEER.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(peers.size)
			peers.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(peersVECTORPEER.size)
			peersVECTORPEER.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x6d8d8645u.toInt()
		}
	}
	
	open class TLChannelsGetSendAs: TLObject() {
		@JvmField var peer: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChannelsSendAsPeers? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return ChannelsSendAsPeers.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdc770eeu.toInt()
		}
	}
	
	open class TLUsersUserFull: TLObject() {
		@JvmField var fullUser: TLUserFull? = null
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			fullUser = TLUserFull.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			fullUser?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x3b6d152eu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLUsersUserFull? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLUsersUserFull")
					}
					else {
						null
					}
				}
	
				val result = TLUsersUserFull()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLUsersGetFullUser: TLObject() {
		@JvmField var id: InputUser? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLUsersUserFull? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLUsersUserFull.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			id?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb60f5918u.toInt()
		}
	}
	
	open class TLMessagesPeerSettings: TLObject() {
		@JvmField var settings: TLPeerSettings? = null
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			settings = TLPeerSettings.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			settings?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x6880b94du.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesPeerSettings? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesPeerSettings")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesPeerSettings()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetPeerSettings: TLObject() {
		@JvmField var peer: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesPeerSettings? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesPeerSettings.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xefd9a6a2u.toInt()
		}
	}
	
	open class TLAuthLoggedOut: TLObject() {
		@JvmField var flags = 0
		@JvmField var futureAuthToken: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				futureAuthToken = stream.readByteArray(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (futureAuthToken != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeByteArray(futureAuthToken)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc3a2835fu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAuthLoggedOut? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAuthLoggedOut")
					}
					else {
						null
					}
				}
	
				val result = TLAuthLoggedOut()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAuthLogOut: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAuthLoggedOut? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAuthLoggedOut.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3e72ba19u.toInt()
		}
	}
	
	open class TLReactionCount: TLObject() {
		@JvmField var flags = 0
		@JvmField var chosenOrder = 0
		@JvmField var reaction: Reaction? = null
		@JvmField var count = 0
	
		@JvmField var lastDrawnPosition: Int = 0
		@JvmField var chosen: Boolean = false
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				chosenOrder = stream.readInt32(exception)
			}
			reaction = Reaction.deserialize(stream, stream.readInt32(exception), exception)
			count = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (chosenOrder != 0) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeInt32(chosenOrder)
			}
	
			reaction?.serializeToStream(stream)
			stream.writeInt32(count)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa3d1cb80u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLReactionCount? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLReactionCount")
					}
					else {
						null
					}
				}
	
				val result = TLReactionCount()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessageReactions: TLObject() {
		@JvmField var flags = 0
		@JvmField var min = false
		@JvmField var canSeeList = false
		@JvmField val results = mutableListOf<TLReactionCount>()
		@JvmField val recentReactions = mutableListOf<TLMessagePeerReaction>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			min = (flags and 1) != 0
			canSeeList = (flags and 4) != 0
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLReactionCount.deserialize(stream, stream.readInt32(exception), exception) ?: return
				results.add(obj)
			}
		
			if ((flags and 2) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLMessagePeerReaction.deserialize(stream, stream.readInt32(exception), exception) ?: return
					recentReactions.add(obj)
				}
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (min) flags or 1 else flags and 1.inv()
			flags = if (canSeeList) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(results.size)
			results.forEach { it.serializeToStream(stream) }
			if ((flags and 2) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(recentReactions.size)
			recentReactions.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x4f2b9479u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessageReactions? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessageReactions")
					}
					else {
						null
					}
				}
	
				val result = TLMessageReactions()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesMessageReactionsList: TLObject() {
		@JvmField var flags = 0
		@JvmField var count = 0
		@JvmField val reactions = mutableListOf<TLMessagePeerReaction>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
		@JvmField var nextOffset: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			count = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLMessagePeerReaction.deserialize(stream, stream.readInt32(exception), exception) ?: return
				reactions.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		
			if ((flags and 1) != 0) {
				nextOffset = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (nextOffset != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(count)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(reactions.size)
			reactions.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
			if ((flags and 1) != 0) {
				stream.writeString(nextOffset)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x31bd492du.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesMessageReactionsList? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesMessageReactionsList")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesMessageReactionsList()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetMessageReactionsList: TLObject() {
		@JvmField var flags = 0
		@JvmField var peer: InputPeer? = null
		@JvmField var id = 0
		@JvmField var reaction: Reaction? = null
		@JvmField var offset: String? = null
		@JvmField var limit = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesMessageReactionsList? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesMessageReactionsList.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (reaction != null) flags or 1 else flags and 1.inv()
			flags = if (offset != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			stream.writeInt32(id)
			if ((flags and 1) != 0) {
				reaction?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(offset)
			}
	
			stream.writeInt32(limit)
		}
	
		companion object {
			val CONSTRUCTOR = 0x461b3f48u.toInt()
		}
	}
	
	open class TLAvailableReaction: TLObject() {
		@JvmField var flags = 0
		@JvmField var inactive = false
		@JvmField var premium = false
		@JvmField var reaction: String? = null
		@JvmField var title: String? = null
		@JvmField var staticIcon: Document? = null
		@JvmField var appearAnimation: Document? = null
		@JvmField var selectAnimation: Document? = null
		@JvmField var activateAnimation: Document? = null
		@JvmField var effectAnimation: Document? = null
		@JvmField var aroundAnimation: Document? = null
		@JvmField var centerIcon: Document? = null
	
		@JvmField var positionInList: Int = 0
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			inactive = (flags and 1) != 0
			premium = (flags and 4) != 0
			reaction = stream.readString(exception) ?: return
			title = stream.readString(exception) ?: return
			staticIcon = Document.deserialize(stream, stream.readInt32(exception), exception)
			appearAnimation = Document.deserialize(stream, stream.readInt32(exception), exception)
			selectAnimation = Document.deserialize(stream, stream.readInt32(exception), exception)
			activateAnimation = Document.deserialize(stream, stream.readInt32(exception), exception)
			effectAnimation = Document.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 2) != 0) {
				aroundAnimation = Document.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 2) != 0) {
				centerIcon = Document.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (inactive) flags or 1 else flags and 1.inv()
			flags = if (premium) flags or 4 else flags and 4.inv()
			flags = if (aroundAnimation != null) flags or 2 else flags and 2.inv()
			flags = if (centerIcon != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeString(reaction)
			stream.writeString(title)
			staticIcon?.serializeToStream(stream)
			appearAnimation?.serializeToStream(stream)
			selectAnimation?.serializeToStream(stream)
			activateAnimation?.serializeToStream(stream)
			effectAnimation?.serializeToStream(stream)
			if ((flags and 2) != 0) {
				aroundAnimation?.serializeToStream(stream)
			}
	
			if ((flags and 2) != 0) {
				centerIcon?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc077ec01u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAvailableReaction? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAvailableReaction")
					}
					else {
						null
					}
				}
	
				val result = TLAvailableReaction()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class MessagesAvailableReactions: TLObject() {
		@JvmField var hash = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesAvailableReactions? {
				val result = when (constructor) {
					TLMessagesAvailableReactionsNotModified.CONSTRUCTOR -> TLMessagesAvailableReactionsNotModified()
					TLMessagesAvailableReactions.CONSTRUCTOR -> TLMessagesAvailableReactions()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesAvailableReactions")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesAvailableReactionsNotModified: MessagesAvailableReactions() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x9f071957u.toInt()
		}
	}
	
	open class TLMessagesAvailableReactions: MessagesAvailableReactions() {
			@JvmField val reactions = mutableListOf<TLAvailableReaction>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			hash = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLAvailableReaction.deserialize(stream, stream.readInt32(exception), exception) ?: return
				reactions.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(hash)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(reactions.size)
			reactions.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x768e3aadu.toInt()
		}
	}
	
	open class TLMessagesGetAvailableReactions: TLObject() {
		@JvmField var hash = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesAvailableReactions? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesAvailableReactions.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x18dea0acu.toInt()
		}
	}
	
	abstract class MessagesTranslatedText: TLObject() {
		@JvmField var text: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesTranslatedText? {
				val result = when (constructor) {
					TLMessagesTranslateNoResult.CONSTRUCTOR -> TLMessagesTranslateNoResult()
					TLMessagesTranslateResultText.CONSTRUCTOR -> TLMessagesTranslateResultText()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesTranslatedText")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesTranslateNoResult: MessagesTranslatedText() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x67ca4737u.toInt()
		}
	}
	
	open class TLMessagesTranslateResultText: MessagesTranslatedText() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa214f7d0u.toInt()
		}
	}
	
	open class TLMessagesTranslateText: TLObject() {
		@JvmField var flags = 0
		@JvmField var peer: InputPeer? = null
		@JvmField var msgId = 0
		@JvmField var text: String? = null
		@JvmField var fromLang: String? = null
		@JvmField var toLang: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesTranslatedText? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesTranslatedText.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (peer != null) flags or 1 else flags and 1.inv()
			flags = if (msgId != 0) flags or 1 else flags and 1.inv()
			flags = if (text != null) flags or 2 else flags and 2.inv()
			flags = if (fromLang != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				peer?.serializeToStream(stream)
			}
	
			if ((flags and 1) != 0) {
				stream.writeInt32(msgId)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(text)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(fromLang)
			}
	
			stream.writeString(toLang)
		}
	
		companion object {
			val CONSTRUCTOR = 0x24ce6deeu.toInt()
		}
	}
	
	open class TLMessagePeerReaction: TLObject() {
		@JvmField var flags = 0
		@JvmField var big = false
		@JvmField var unread = false
		@JvmField var peerId: Peer? = null
		@JvmField var reaction: Reaction? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			big = (flags and 1) != 0
			unread = (flags and 2) != 0
			peerId = Peer.deserialize(stream, stream.readInt32(exception), exception)
			reaction = Reaction.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (big) flags or 1 else flags and 1.inv()
			flags = if (unread) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			peerId?.serializeToStream(stream)
			reaction?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb156fe9cu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagePeerReaction? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagePeerReaction")
					}
					else {
						null
					}
				}
	
				val result = TLMessagePeerReaction()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLGroupCallStreamChannel: TLObject() {
		@JvmField var channel = 0
		@JvmField var scale = 0
		@JvmField var lastTimestampMs = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			channel = stream.readInt32(exception)
			scale = stream.readInt32(exception)
			lastTimestampMs = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(channel)
			stream.writeInt32(scale)
			stream.writeInt64(lastTimestampMs)
		}
	
		companion object {
			val CONSTRUCTOR = 0x80eb48afu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLGroupCallStreamChannel? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLGroupCallStreamChannel")
					}
					else {
						null
					}
				}
	
				val result = TLGroupCallStreamChannel()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPhoneGroupCallStreamChannels: TLObject() {
		@JvmField val channels = mutableListOf<TLGroupCallStreamChannel>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLGroupCallStreamChannel.deserialize(stream, stream.readInt32(exception), exception) ?: return
				channels.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(channels.size)
			channels.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xd0e482b2u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhoneGroupCallStreamChannels? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPhoneGroupCallStreamChannels")
					}
					else {
						null
					}
				}
	
				val result = TLPhoneGroupCallStreamChannels()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPhoneGetGroupCallStreamChannels: TLObject() {
		@JvmField var call: TLInputGroupCall? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhoneGroupCallStreamChannels? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPhoneGroupCallStreamChannels.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1ab21940u.toInt()
		}
	}
	
	open class TLPhoneGroupCallStreamRtmpUrl: TLObject() {
		@JvmField var url: String? = null
		@JvmField var key: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
			key = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
			stream.writeString(key)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2dbf3432u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhoneGroupCallStreamRtmpUrl? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPhoneGroupCallStreamRtmpUrl")
					}
					else {
						null
					}
				}
	
				val result = TLPhoneGroupCallStreamRtmpUrl()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPhoneGetGroupCallStreamRtmpUrl: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var revoke = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPhoneGroupCallStreamRtmpUrl? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPhoneGroupCallStreamRtmpUrl.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeBool(revoke)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdeb3abbfu.toInt()
		}
	}
	
	open class TLAttachMenuBotIconColor: TLObject() {
		@JvmField var name: String? = null
		@JvmField var color = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			name = stream.readString(exception) ?: return
			color = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(name)
			stream.writeInt32(color)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4576f3f0u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAttachMenuBotIconColor? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAttachMenuBotIconColor")
					}
					else {
						null
					}
				}
	
				val result = TLAttachMenuBotIconColor()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAttachMenuBotIcon: TLObject() {
		@JvmField var flags = 0
		@JvmField var name: String? = null
		@JvmField var icon: Document? = null
		@JvmField val colors = mutableListOf<TLAttachMenuBotIconColor>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			name = stream.readString(exception) ?: return
			icon = Document.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 1) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLAttachMenuBotIconColor.deserialize(stream, stream.readInt32(exception), exception) ?: return
					colors.add(obj)
				}
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(flags)
			stream.writeString(name)
			icon?.serializeToStream(stream)
			if ((flags and 1) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(colors.size)
			colors.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb2a7386bu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAttachMenuBotIcon? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAttachMenuBotIcon")
					}
					else {
						null
					}
				}
	
				val result = TLAttachMenuBotIcon()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLAttachMenuBot: TLObject() {
		@JvmField var flags = 0
		@JvmField var inactive = false
		@JvmField var hasSettings = false
		@JvmField var botId = 0L
		@JvmField var shortName: String? = null
		@JvmField val peerTypes = mutableListOf<AttachMenuPeerType>()
		@JvmField val icons = mutableListOf<TLAttachMenuBotIcon>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			inactive = (flags and 1) != 0
			hasSettings = (flags and 2) != 0
			botId = stream.readInt64(exception)
			shortName = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = AttachMenuPeerType.deserialize(stream, stream.readInt32(exception), exception) ?: return
				peerTypes.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLAttachMenuBotIcon.deserialize(stream, stream.readInt32(exception), exception) ?: return
				icons.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (inactive) flags or 1 else flags and 1.inv()
			flags = if (hasSettings) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(botId)
			stream.writeString(shortName)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(peerTypes.size)
			peerTypes.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(icons.size)
			icons.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xc8aa2cd2u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAttachMenuBot? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAttachMenuBot")
					}
					else {
						null
					}
				}
	
				val result = TLAttachMenuBot()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class AttachMenuBots: TLObject() {
		@JvmField var hash = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AttachMenuBots? {
				val result = when (constructor) {
					TLAttachMenuBotsNotModified.CONSTRUCTOR -> TLAttachMenuBotsNotModified()
					TLAttachMenuBots.CONSTRUCTOR -> TLAttachMenuBots()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in AttachMenuBots")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLAttachMenuBotsNotModified: AttachMenuBots() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf1d88a5cu.toInt()
		}
	}
	
	open class TLAttachMenuBots: AttachMenuBots() {
			@JvmField val bots = mutableListOf<TLAttachMenuBot>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			hash = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLAttachMenuBot.deserialize(stream, stream.readInt32(exception), exception) ?: return
				bots.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(bots.size)
			bots.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x3c4301c0u.toInt()
		}
	}
	
	open class TLMessagesGetAttachMenuBots: TLObject() {
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AttachMenuBots? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AttachMenuBots.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x16fcc2cbu.toInt()
		}
	}
	
	open class TLAttachMenuBotsBot: TLObject() {
		@JvmField var bot: TLAttachMenuBot? = null
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			bot = TLAttachMenuBot.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			bot?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x93bf667fu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAttachMenuBotsBot? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLAttachMenuBotsBot")
					}
					else {
						null
					}
				}
	
				val result = TLAttachMenuBotsBot()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesGetAttachMenuBot: TLObject() {
		@JvmField var bot: InputUser? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLAttachMenuBotsBot? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLAttachMenuBotsBot.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			bot?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x77216192u.toInt()
		}
	}
	
	open class TLWebViewResult: TLObject() {
		@JvmField var queryId = 0L
		@JvmField var url: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			queryId = stream.readInt64(exception)
			url = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(queryId)
			stream.writeString(url)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc14557cu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLWebViewResult? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLWebViewResult")
					}
					else {
						null
					}
				}
	
				val result = TLWebViewResult()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesRequestWebView: TLObject() {
		@JvmField var flags = 0
		@JvmField var fromBotMenu = false
		@JvmField var silent = false
		@JvmField var peer: InputPeer? = null
		@JvmField var bot: InputUser? = null
		@JvmField var url: String? = null
		@JvmField var startParam: String? = null
		@JvmField var themeParams: TLDataJSON? = null
		@JvmField var platform: String? = null
		@JvmField var replyToMsgId = 0
		@JvmField var sendAs: InputPeer? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLWebViewResult? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLWebViewResult.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (fromBotMenu) flags or 16 else flags and 16.inv()
			flags = if (silent) flags or 32 else flags and 32.inv()
			flags = if (url != null) flags or 2 else flags and 2.inv()
			flags = if (startParam != null) flags or 8 else flags and 8.inv()
			flags = if (themeParams != null) flags or 4 else flags and 4.inv()
			flags = if (replyToMsgId != 0) flags or 1 else flags and 1.inv()
			flags = if (sendAs != null) flags or 8192 else flags and 8192.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
			bot?.serializeToStream(stream)
			if ((flags and 2) != 0) {
				stream.writeString(url)
			}
	
			if ((flags and 8) != 0) {
				stream.writeString(startParam)
			}
	
			if ((flags and 4) != 0) {
				themeParams?.serializeToStream(stream)
			}
	
			stream.writeString(platform)
			if ((flags and 1) != 0) {
				stream.writeInt32(replyToMsgId)
			}
	
			if ((flags and 8192) != 0) {
				sendAs?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xfc87a53cu.toInt()
		}
	}
	
	open class TLSimpleWebViewResult: TLObject() {
		@JvmField var url: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
		}
	
		companion object {
			val CONSTRUCTOR = 0x882f76bbu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLSimpleWebViewResult? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLSimpleWebViewResult")
					}
					else {
						null
					}
				}
	
				val result = TLSimpleWebViewResult()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesRequestSimpleWebView: TLObject() {
		@JvmField var flags = 0
		@JvmField var bot: InputUser? = null
		@JvmField var url: String? = null
		@JvmField var themeParams: TLDataJSON? = null
		@JvmField var platform: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLSimpleWebViewResult? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLSimpleWebViewResult.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (themeParams != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			bot?.serializeToStream(stream)
			stream.writeString(url)
			if ((flags and 1) != 0) {
				themeParams?.serializeToStream(stream)
			}
	
			stream.writeString(platform)
		}
	
		companion object {
			val CONSTRUCTOR = 0x299bec8eu.toInt()
		}
	}
	
	open class TLWebViewMessageSent: TLObject() {
		@JvmField var flags = 0
		@JvmField var msgId: InputBotInlineMessageID? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				msgId = InputBotInlineMessageID.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (msgId != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				msgId?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc94511cu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLWebViewMessageSent? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLWebViewMessageSent")
					}
					else {
						null
					}
				}
	
				val result = TLWebViewMessageSent()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesSendWebViewResultMessage: TLObject() {
		@JvmField var botQueryId: String? = null
		@JvmField var result: InputBotInlineResult? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLWebViewMessageSent? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLWebViewMessageSent.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(botQueryId)
			result?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa4314f5u.toInt()
		}
	}
	
	abstract class BotMenuButton: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): BotMenuButton? {
				val result = when (constructor) {
					TLBotMenuButtonDefault.CONSTRUCTOR -> TLBotMenuButtonDefault()
					TLBotMenuButtonCommands.CONSTRUCTOR -> TLBotMenuButtonCommands()
					TLBotMenuButton.CONSTRUCTOR -> TLBotMenuButton()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in BotMenuButton")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLBotMenuButtonDefault: BotMenuButton() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x7533a588u.toInt()
		}
	}
	
	open class TLBotMenuButtonCommands: BotMenuButton() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x4258c205u.toInt()
		}
	}
	
	open class TLBotMenuButton: BotMenuButton() {
		@JvmField var text: String? = null
		@JvmField var url: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			text = stream.readString(exception) ?: return
			url = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(text)
			stream.writeString(url)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc7b57ce6u.toInt()
		}
	}
	
	open class TLBotsGetBotMenuButton: TLObject() {
		@JvmField var userId: InputUser? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): BotMenuButton? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return BotMenuButton.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			userId?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9c60eb28u.toInt()
		}
	}
	
	abstract class AccountSavedRingtones: TLObject() {
		@JvmField var hash = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AccountSavedRingtones? {
				val result = when (constructor) {
					TLAccountSavedRingtonesNotModified.CONSTRUCTOR -> TLAccountSavedRingtonesNotModified()
					TLAccountSavedRingtones.CONSTRUCTOR -> TLAccountSavedRingtones()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in AccountSavedRingtones")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLAccountSavedRingtonesNotModified: AccountSavedRingtones() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xfbf6e8b1u.toInt()
		}
	}
	
	open class TLAccountSavedRingtones: AccountSavedRingtones() {
			@JvmField val ringtones = mutableListOf<Document>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			hash = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Document.deserialize(stream, stream.readInt32(exception), exception) ?: return
				ringtones.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(ringtones.size)
			ringtones.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xc1e92cc5u.toInt()
		}
	}
	
	open class TLAccountGetSavedRingtones: TLObject() {
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AccountSavedRingtones? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AccountSavedRingtones.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe1902288u.toInt()
		}
	}
	
	abstract class NotificationSound: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): NotificationSound? {
				val result = when (constructor) {
					TLNotificationSoundDefault.CONSTRUCTOR -> TLNotificationSoundDefault()
					TLNotificationSoundNone.CONSTRUCTOR -> TLNotificationSoundNone()
					TLNotificationSoundLocal.CONSTRUCTOR -> TLNotificationSoundLocal()
					TLNotificationSoundRingtone.CONSTRUCTOR -> TLNotificationSoundRingtone()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in NotificationSound")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLNotificationSoundDefault: NotificationSound() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x97e8bebeu.toInt()
		}
	}
	
	open class TLNotificationSoundNone: NotificationSound() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x6f0c34dfu.toInt()
		}
	}
	
	open class TLNotificationSoundLocal: NotificationSound() {
		@JvmField var title: String? = null
		@JvmField var data: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			title = stream.readString(exception) ?: return
			data = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(title)
			stream.writeString(data)
		}
	
		companion object {
			val CONSTRUCTOR = 0x830b9ae4u.toInt()
		}
	}
	
	open class TLNotificationSoundRingtone: NotificationSound() {
		@JvmField var id = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
		}
	
		companion object {
			val CONSTRUCTOR = 0xff6c8049u.toInt()
		}
	}
	
	abstract class AccountSavedRingtone: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AccountSavedRingtone? {
				val result = when (constructor) {
					TLAccountSavedRingtone.CONSTRUCTOR -> TLAccountSavedRingtone()
					TLAccountSavedRingtoneConverted.CONSTRUCTOR -> TLAccountSavedRingtoneConverted()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in AccountSavedRingtone")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLAccountSavedRingtone: AccountSavedRingtone() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb7263f6du.toInt()
		}
	}
	
	open class TLAccountSavedRingtoneConverted: AccountSavedRingtone() {
		@JvmField var document: Document? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			document = Document.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			document?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1f307eb7u.toInt()
		}
	}
	
	open class TLAccountSaveRingtone: TLObject() {
		@JvmField var id: InputDocument? = null
		@JvmField var unsave = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AccountSavedRingtone? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AccountSavedRingtone.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			id?.serializeToStream(stream)
			stream.writeBool(unsave)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3dea5b03u.toInt()
		}
	}
	
	abstract class AttachMenuPeerType: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AttachMenuPeerType? {
				val result = when (constructor) {
					TLAttachMenuPeerTypeSameBotPM.CONSTRUCTOR -> TLAttachMenuPeerTypeSameBotPM()
					TLAttachMenuPeerTypeBotPM.CONSTRUCTOR -> TLAttachMenuPeerTypeBotPM()
					TLAttachMenuPeerTypePM.CONSTRUCTOR -> TLAttachMenuPeerTypePM()
					TLAttachMenuPeerTypeChat.CONSTRUCTOR -> TLAttachMenuPeerTypeChat()
					TLAttachMenuPeerTypeBroadcast.CONSTRUCTOR -> TLAttachMenuPeerTypeBroadcast()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in AttachMenuPeerType")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLAttachMenuPeerTypeSameBotPM: AttachMenuPeerType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x7d6be90eu.toInt()
		}
	}
	
	open class TLAttachMenuPeerTypeBotPM: AttachMenuPeerType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc32bfa1au.toInt()
		}
	}
	
	open class TLAttachMenuPeerTypePM: AttachMenuPeerType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf146d31fu.toInt()
		}
	}
	
	open class TLAttachMenuPeerTypeChat: AttachMenuPeerType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x509113fu.toInt()
		}
	}
	
	open class TLAttachMenuPeerTypeBroadcast: AttachMenuPeerType() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x7bfbdefcu.toInt()
		}
	}
	
	abstract class InputInvoice: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputInvoice? {
				val result = when (constructor) {
					TLInputInvoiceMessage.CONSTRUCTOR -> TLInputInvoiceMessage()
					TLInputInvoiceSlug.CONSTRUCTOR -> TLInputInvoiceSlug()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputInvoice")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputInvoiceMessage: InputInvoice() {
		@JvmField var peer: InputPeer? = null
		@JvmField var msgId = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			peer = InputPeer.deserialize(stream, stream.readInt32(exception), exception)
			msgId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc5b56859u.toInt()
		}
	}
	
	open class TLInputInvoiceSlug: InputInvoice() {
		@JvmField var slug: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			slug = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(slug)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc326caefu.toInt()
		}
	}
	
	open class TLPaymentsExportedInvoice: TLObject() {
		@JvmField var url: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
		}
	
		companion object {
			val CONSTRUCTOR = 0xaed0cbd9u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPaymentsExportedInvoice? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPaymentsExportedInvoice")
					}
					else {
						null
					}
				}
	
				val result = TLPaymentsExportedInvoice()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesTranscribedAudio: TLObject() {
		@JvmField var flags = 0
		@JvmField var pending = false
		@JvmField var transcriptionId = 0L
		@JvmField var text: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			pending = (flags and 1) != 0
			transcriptionId = stream.readInt64(exception)
			text = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (pending) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(transcriptionId)
			stream.writeString(text)
		}
	
		companion object {
			val CONSTRUCTOR = 0x93752c52u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesTranscribedAudio? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesTranscribedAudio")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesTranscribedAudio()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessagesTranscribeAudio: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var msgId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesTranscribedAudio? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLMessagesTranscribedAudio.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x269e9a49u.toInt()
		}
	}
	
	open class TLHelpPremiumPromo: TLObject() {
		@JvmField var statusText: String? = null
		@JvmField val statusEntities = mutableListOf<MessageEntity>()
		@JvmField val videoSections = mutableListOf<String>()
		@JvmField val videos = mutableListOf<Document>()
		@JvmField val periodOptions = mutableListOf<TLPremiumSubscriptionOption>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			statusText = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = MessageEntity.deserialize(stream, stream.readInt32(exception), exception) ?: return
				statusEntities.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readString(exception) ?: return
				videoSections.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Document.deserialize(stream, stream.readInt32(exception), exception) ?: return
				videos.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLPremiumSubscriptionOption.deserialize(stream, stream.readInt32(exception), exception) ?: return
				periodOptions.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(statusText)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(statusEntities.size)
			statusEntities.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(videoSections.size)
			videoSections.forEach { stream.writeString(it) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(videos.size)
			videos.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(periodOptions.size)
			periodOptions.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x5334759cu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLHelpPremiumPromo? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLHelpPremiumPromo")
					}
					else {
						null
					}
				}
	
				val result = TLHelpPremiumPromo()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLHelpGetPremiumPromo: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLHelpPremiumPromo? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLHelpPremiumPromo.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb81b93d4u.toInt()
		}
	}
	
	abstract class InputStorePaymentPurpose: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): InputStorePaymentPurpose? {
				val result = when (constructor) {
					TLInputStorePaymentPremiumSubscription.CONSTRUCTOR -> TLInputStorePaymentPremiumSubscription()
					TLInputStorePaymentGiftPremium.CONSTRUCTOR -> TLInputStorePaymentGiftPremium()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in InputStorePaymentPurpose")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLInputStorePaymentPremiumSubscription: InputStorePaymentPurpose() {
		@JvmField var flags = 0
		@JvmField var restore = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			restore = (flags and 1) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (restore) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa6751e66u.toInt()
		}
	}
	
	open class TLInputStorePaymentGiftPremium: InputStorePaymentPurpose() {
		@JvmField var userId: InputUser? = null
		@JvmField var currency: String? = null
		@JvmField var amount = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = InputUser.deserialize(stream, stream.readInt32(exception), exception)
			currency = stream.readString(exception) ?: return
			amount = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			userId?.serializeToStream(stream)
			stream.writeString(currency)
			stream.writeInt64(amount)
		}
	
		companion object {
			val CONSTRUCTOR = 0x616f7fe8u.toInt()
		}
	}
	
	open class TLPremiumGiftOption: TLObject() {
		@JvmField var flags = 0
		@JvmField var months = 0
		@JvmField var currency: String? = null
		@JvmField var amount = 0L
		@JvmField var botUrl: String? = null
		@JvmField var storeProduct: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			months = stream.readInt32(exception)
			currency = stream.readString(exception) ?: return
			amount = stream.readInt64(exception)
			botUrl = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				storeProduct = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (storeProduct != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(months)
			stream.writeString(currency)
			stream.writeInt64(amount)
			stream.writeString(botUrl)
			if ((flags and 1) != 0) {
				stream.writeString(storeProduct)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x74c34319u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPremiumGiftOption? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPremiumGiftOption")
					}
					else {
						null
					}
				}
	
				val result = TLPremiumGiftOption()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPaymentFormMethod: TLObject() {
		@JvmField var url: String? = null
		@JvmField var title: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			url = stream.readString(exception) ?: return
			title = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(url)
			stream.writeString(title)
		}
	
		companion object {
			val CONSTRUCTOR = 0x88f8f21bu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPaymentFormMethod? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPaymentFormMethod")
					}
					else {
						null
					}
				}
	
				val result = TLPaymentFormMethod()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class EmojiStatus: TLObject() {
		@JvmField var documentId = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): EmojiStatus? {
				val result = when (constructor) {
					TLEmojiStatusEmpty.CONSTRUCTOR -> TLEmojiStatusEmpty()
					TLEmojiStatus.CONSTRUCTOR -> TLEmojiStatus()
					TLEmojiStatusUntil.CONSTRUCTOR -> TLEmojiStatusUntil()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in EmojiStatus")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLEmojiStatusEmpty: EmojiStatus() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x2de11aaeu.toInt()
		}
	}
	
	open class TLEmojiStatus: EmojiStatus() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			documentId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(documentId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x929b619du.toInt()
		}
	}
	
	open class TLEmojiStatusUntil: EmojiStatus() {
			@JvmField var until = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			documentId = stream.readInt64(exception)
			until = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(documentId)
			stream.writeInt32(until)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfa30a8c7u.toInt()
		}
	}
	
	abstract class AccountEmojiStatuses: TLObject() {
		@JvmField var hash = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AccountEmojiStatuses? {
				val result = when (constructor) {
					TLAccountEmojiStatusesNotModified.CONSTRUCTOR -> TLAccountEmojiStatusesNotModified()
					TLAccountEmojiStatuses.CONSTRUCTOR -> TLAccountEmojiStatuses()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in AccountEmojiStatuses")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLAccountEmojiStatusesNotModified: AccountEmojiStatuses() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd08ce645u.toInt()
		}
	}
	
	open class TLAccountEmojiStatuses: AccountEmojiStatuses() {
			@JvmField val statuses = mutableListOf<EmojiStatus>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			hash = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = EmojiStatus.deserialize(stream, stream.readInt32(exception), exception) ?: return
				statuses.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(statuses.size)
			statuses.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x90c467d1u.toInt()
		}
	}
	
	open class TLAccountGetDefaultEmojiStatuses: TLObject() {
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AccountEmojiStatuses? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AccountEmojiStatuses.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd6753386u.toInt()
		}
	}
	
	open class TLAccountGetRecentEmojiStatuses: TLObject() {
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AccountEmojiStatuses? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AccountEmojiStatuses.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf578105u.toInt()
		}
	}
	
	abstract class Reaction: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Reaction? {
				val result = when (constructor) {
					TLReactionEmpty.CONSTRUCTOR -> TLReactionEmpty()
					TLReactionEmoji.CONSTRUCTOR -> TLReactionEmoji()
					TLReactionCustomEmoji.CONSTRUCTOR -> TLReactionCustomEmoji()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in Reaction")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLReactionEmpty: Reaction() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x79f5d419u.toInt()
		}
	}
	
	open class TLReactionEmoji: Reaction() {
		@JvmField var emoticon: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			emoticon = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(emoticon)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1b2286b8u.toInt()
		}
	}
	
	open class TLReactionCustomEmoji: Reaction() {
		@JvmField var documentId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			documentId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(documentId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8935fc73u.toInt()
		}
	}
	
	abstract class ChatReactions: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChatReactions? {
				val result = when (constructor) {
					TLChatReactionsNone.CONSTRUCTOR -> TLChatReactionsNone()
					TLChatReactionsAll.CONSTRUCTOR -> TLChatReactionsAll()
					TLChatReactionsSome.CONSTRUCTOR -> TLChatReactionsSome()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ChatReactions")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChatReactionsNone: ChatReactions() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xeafc32bcu.toInt()
		}
	}
	
	open class TLChatReactionsAll: ChatReactions() {
		@JvmField var flags = 0
		@JvmField var allowCustom = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			allowCustom = (flags and 1) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (allowCustom) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0x52928bcau.toInt()
		}
	}
	
	open class TLChatReactionsSome: ChatReactions() {
		@JvmField val reactions = mutableListOf<Reaction>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Reaction.deserialize(stream, stream.readInt32(exception), exception) ?: return
				reactions.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(reactions.size)
			reactions.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x661d4037u.toInt()
		}
	}
	
	abstract class MessagesReactions: TLObject() {
		@JvmField var hash = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesReactions? {
				val result = when (constructor) {
					TLMessagesReactionsNotModified.CONSTRUCTOR -> TLMessagesReactionsNotModified()
					TLMessagesReactions.CONSTRUCTOR -> TLMessagesReactions()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessagesReactions")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessagesReactionsNotModified: MessagesReactions() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb06fdbdfu.toInt()
		}
	}
	
	open class TLMessagesReactions: MessagesReactions() {
			@JvmField val reactions = mutableListOf<Reaction>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			hash = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Reaction.deserialize(stream, stream.readInt32(exception), exception) ?: return
				reactions.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(reactions.size)
			reactions.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xeafdf716u.toInt()
		}
	}
	
	open class TLMessagesGetTopReactions: TLObject() {
		@JvmField var limit = 0
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesReactions? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesReactions.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(limit)
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbb8125bau.toInt()
		}
	}
	
	open class TLMessagesGetRecentReactions: TLObject() {
		@JvmField var limit = 0
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessagesReactions? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return MessagesReactions.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(limit)
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x39461db2u.toInt()
		}
	}
	
	abstract class EmailVerifyPurpose: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): EmailVerifyPurpose? {
				val result = when (constructor) {
					TLEmailVerifyPurposeLoginSetup.CONSTRUCTOR -> TLEmailVerifyPurposeLoginSetup()
					TLEmailVerifyPurposeLoginChange.CONSTRUCTOR -> TLEmailVerifyPurposeLoginChange()
					TLEmailVerifyPurposePassport.CONSTRUCTOR -> TLEmailVerifyPurposePassport()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in EmailVerifyPurpose")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLEmailVerifyPurposeLoginSetup: EmailVerifyPurpose() {
		@JvmField var phoneNumber: String? = null
		@JvmField var phoneCodeHash: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			phoneNumber = stream.readString(exception) ?: return
			phoneCodeHash = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phoneNumber)
			stream.writeString(phoneCodeHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x4345be73u.toInt()
		}
	}
	
	open class TLEmailVerifyPurposeLoginChange: EmailVerifyPurpose() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x527d22ebu.toInt()
		}
	}
	
	open class TLEmailVerifyPurposePassport: EmailVerifyPurpose() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xbbf51685u.toInt()
		}
	}
	
	abstract class EmailVerification: TLObject() {
		@JvmField var token: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): EmailVerification? {
				val result = when (constructor) {
					TLEmailVerificationCode.CONSTRUCTOR -> TLEmailVerificationCode()
					TLEmailVerificationGoogle.CONSTRUCTOR -> TLEmailVerificationGoogle()
					TLEmailVerificationApple.CONSTRUCTOR -> TLEmailVerificationApple()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in EmailVerification")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLEmailVerificationCode: EmailVerification() {
		@JvmField var code: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			code = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(code)
		}
	
		companion object {
			val CONSTRUCTOR = 0x922e55a9u.toInt()
		}
	}
	
	open class TLEmailVerificationGoogle: EmailVerification() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			token = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(token)
		}
	
		companion object {
			val CONSTRUCTOR = 0xdb909ec2u.toInt()
		}
	}
	
	open class TLEmailVerificationApple: EmailVerification() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			token = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(token)
		}
	
		companion object {
			val CONSTRUCTOR = 0x96d074fdu.toInt()
		}
	}
	
	abstract class AccountEmailVerified: TLObject() {
		@JvmField var email: String? = null
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AccountEmailVerified? {
				val result = when (constructor) {
					TLAccountEmailVerified.CONSTRUCTOR -> TLAccountEmailVerified()
					TLAccountEmailVerifiedLogin.CONSTRUCTOR -> TLAccountEmailVerifiedLogin()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in AccountEmailVerified")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLAccountEmailVerified: AccountEmailVerified() {
		
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			email = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(email)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2b96cd1bu.toInt()
		}
	}
	
	open class TLAccountEmailVerifiedLogin: AccountEmailVerified() {
			@JvmField var sentCode: AuthSentCode? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			email = stream.readString(exception) ?: return
			sentCode = AuthSentCode.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(email)
			sentCode?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe1bb0d61u.toInt()
		}
	}
	
	open class TLAccountVerifyEmail: TLObject() {
		@JvmField var purpose: EmailVerifyPurpose? = null
		@JvmField var verification: EmailVerification? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AccountEmailVerified? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return AccountEmailVerified.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			purpose?.serializeToStream(stream)
			verification?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x32da4cfu.toInt()
		}
	}
	
	open class TLPremiumSubscriptionOption: TLObject() {
		@JvmField var flags = 0
		@JvmField var current = false
		@JvmField var canPurchaseUpgrade = false
		@JvmField var months = 0
		@JvmField var currency: String? = null
		@JvmField var amount = 0L
		@JvmField var botUrl: String? = null
		@JvmField var storeProduct: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			current = (flags and 2) != 0
			canPurchaseUpgrade = (flags and 4) != 0
			months = stream.readInt32(exception)
			currency = stream.readString(exception) ?: return
			amount = stream.readInt64(exception)
			botUrl = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				storeProduct = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (current) flags or 2 else flags and 2.inv()
			flags = if (canPurchaseUpgrade) flags or 4 else flags and 4.inv()
			flags = if (storeProduct != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(months)
			stream.writeString(currency)
			stream.writeInt64(amount)
			stream.writeString(botUrl)
			if ((flags and 1) != 0) {
				stream.writeString(storeProduct)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb6f11ebeu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPremiumSubscriptionOption? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPremiumSubscriptionOption")
					}
					else {
						null
					}
				}
	
				val result = TLPremiumSubscriptionOption()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class SendAsPeer: TLObject() {
		@JvmField var peer: Peer? = null
		@JvmField var flags = 0
		@JvmField var premiumRequired = false
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): SendAsPeer? {
				val result = when (constructor) {
					TLSendAsPeer.CONSTRUCTOR -> TLSendAsPeer()
					TLSendAsPeerLayer3.CONSTRUCTOR -> TLSendAsPeerLayer3()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in SendAsPeer")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLSendAsPeer: SendAsPeer() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			premiumRequired = (flags and 1) != 0
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (premiumRequired) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb81c7034u.toInt()
		}
	}
	
	open class TLSendAsPeerLayer3: SendAsPeer() {
				
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			premiumRequired = (flags and 1) != 0
			peer = Peer.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (premiumRequired) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			peer?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb81c7034u.toInt()
		}
	}
	
	abstract class MessageExtendedMedia: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): MessageExtendedMedia? {
				val result = when (constructor) {
					TLMessageExtendedMediaPreview.CONSTRUCTOR -> TLMessageExtendedMediaPreview()
					TLMessageExtendedMedia.CONSTRUCTOR -> TLMessageExtendedMedia()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in MessageExtendedMedia")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLMessageExtendedMediaPreview: MessageExtendedMedia() {
		@JvmField var flags = 0
		@JvmField var w = 0
		@JvmField var h = 0
		@JvmField var thumb: PhotoSize? = null
		@JvmField var videoDuration = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				w = stream.readInt32(exception)
			}
		
			if ((flags and 1) != 0) {
				h = stream.readInt32(exception)
			}
		
			if ((flags and 2) != 0) {
				thumb = PhotoSize.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 4) != 0) {
				videoDuration = stream.readInt32(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (w != 0) flags or 1 else flags and 1.inv()
			flags = if (h != 0) flags or 1 else flags and 1.inv()
			flags = if (thumb != null) flags or 2 else flags and 2.inv()
			flags = if (videoDuration != 0) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			if ((flags and 1) != 0) {
				stream.writeInt32(w)
			}
	
			if ((flags and 1) != 0) {
				stream.writeInt32(h)
			}
	
			if ((flags and 2) != 0) {
				thumb?.serializeToStream(stream)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(videoDuration)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xad628cc8u.toInt()
		}
	}
	
	open class TLMessageExtendedMedia: MessageExtendedMedia() {
		@JvmField var media: MessageMedia? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			media = MessageMedia.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			media?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xee479c64u.toInt()
		}
	}
	
	open class TLStickerKeyword: TLObject() {
		@JvmField var documentId = 0L
		@JvmField val keyword = mutableListOf<String>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			documentId = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readString(exception) ?: return
				keyword.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(documentId)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(keyword.size)
			keyword.forEach { stream.writeString(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xfcfeb29cu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLStickerKeyword? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLStickerKeyword")
					}
					else {
						null
					}
				}
	
				val result = TLStickerKeyword()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLForumTopic: TLObject() {
		@JvmField var flags = 0
		@JvmField var my = false
		@JvmField var closed = false
		@JvmField var pinned = false
		@JvmField var isShort = false
		@JvmField var hidden = false
		@JvmField var id = 0
		@JvmField var date = 0
		@JvmField var title: String? = null
		@JvmField var iconColor = 0
		@JvmField var iconEmojiId = 0L
		@JvmField var topMessage = 0
		@JvmField var readInboxMaxId = 0
		@JvmField var readOutboxMaxId = 0
		@JvmField var unreadCount = 0
		@JvmField var unreadMentionsCount = 0
		@JvmField var unreadReactionsCount = 0
		@JvmField var fromId: Peer? = null
		@JvmField var notifySettings: PeerNotifySettings? = null
		@JvmField var draft: DraftMessage? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			my = (flags and 2) != 0
			closed = (flags and 4) != 0
			pinned = (flags and 8) != 0
			isShort = (flags and 32) != 0
			hidden = (flags and 64) != 0
			id = stream.readInt32(exception)
			date = stream.readInt32(exception)
			title = stream.readString(exception) ?: return
			iconColor = stream.readInt32(exception)
		
			if ((flags and 1) != 0) {
				iconEmojiId = stream.readInt64(exception)
			}
			topMessage = stream.readInt32(exception)
			readInboxMaxId = stream.readInt32(exception)
			readOutboxMaxId = stream.readInt32(exception)
			unreadCount = stream.readInt32(exception)
			unreadMentionsCount = stream.readInt32(exception)
			unreadReactionsCount = stream.readInt32(exception)
			fromId = Peer.deserialize(stream, stream.readInt32(exception), exception)
			notifySettings = PeerNotifySettings.deserialize(stream, stream.readInt32(exception), exception)
		
			if ((flags and 16) != 0) {
				draft = DraftMessage.deserialize(stream, stream.readInt32(exception), exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (my) flags or 2 else flags and 2.inv()
			flags = if (closed) flags or 4 else flags and 4.inv()
			flags = if (pinned) flags or 8 else flags and 8.inv()
			flags = if (isShort) flags or 32 else flags and 32.inv()
			flags = if (hidden) flags or 64 else flags and 64.inv()
			flags = if (iconEmojiId != 0L) flags or 1 else flags and 1.inv()
			flags = if (draft != null) flags or 16 else flags and 16.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(id)
			stream.writeInt32(date)
			stream.writeString(title)
			stream.writeInt32(iconColor)
			if ((flags and 1) != 0) {
				stream.writeInt64(iconEmojiId)
			}
	
			stream.writeInt32(topMessage)
			stream.writeInt32(readInboxMaxId)
			stream.writeInt32(readOutboxMaxId)
			stream.writeInt32(unreadCount)
			stream.writeInt32(unreadMentionsCount)
			stream.writeInt32(unreadReactionsCount)
			fromId?.serializeToStream(stream)
			notifySettings?.serializeToStream(stream)
			if ((flags and 16) != 0) {
				draft?.serializeToStream(stream)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x71701da9u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLForumTopic? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLForumTopic")
					}
					else {
						null
					}
				}
	
				val result = TLForumTopic()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLInputChatlist: TLObject() {
		@JvmField var filterId = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			filterId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(filterId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf3e0da33u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLInputChatlist? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLInputChatlist")
					}
					else {
						null
					}
				}
	
				val result = TLInputChatlist()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLChatlistsExportedChatlistInvite: TLObject() {
		@JvmField var filter: DialogFilter? = null
		@JvmField var invite: TLExportedChatlistInvite? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			filter = DialogFilter.deserialize(stream, stream.readInt32(exception), exception)
			invite = TLExportedChatlistInvite.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			filter?.serializeToStream(stream)
			invite?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x10e6e3a6u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChatlistsExportedChatlistInvite? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLChatlistsExportedChatlistInvite")
					}
					else {
						null
					}
				}
	
				val result = TLChatlistsExportedChatlistInvite()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLChatlistsExportChatlistInvite: TLObject() {
		@JvmField var chatlist: TLInputChatlist? = null
		@JvmField var title: String? = null
		@JvmField val peers = mutableListOf<InputPeer>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChatlistsExportedChatlistInvite? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLChatlistsExportedChatlistInvite.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			chatlist?.serializeToStream(stream)
			stream.writeString(title)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(peers.size)
			peers.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x8472478eu.toInt()
		}
	}
	
	open class TLChatlistsExportedInvites: TLObject() {
		@JvmField val invites = mutableListOf<TLExportedChatlistInvite>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLExportedChatlistInvite.deserialize(stream, stream.readInt32(exception), exception) ?: return
				invites.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(invites.size)
			invites.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x10ab6dc7u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChatlistsExportedInvites? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLChatlistsExportedInvites")
					}
					else {
						null
					}
				}
	
				val result = TLChatlistsExportedInvites()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLChatlistsGetExportedInvites: TLObject() {
		@JvmField var chatlist: TLInputChatlist? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChatlistsExportedInvites? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLChatlistsExportedInvites.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			chatlist?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xce03da83u.toInt()
		}
	}
	
	abstract class ChatlistsChatlistInvite: TLObject() {
		@JvmField val users = mutableListOf<User>()
		@JvmField val chats = mutableListOf<Chat>()
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChatlistsChatlistInvite? {
				val result = when (constructor) {
					TLChatlistsChatlistInviteAlready.CONSTRUCTOR -> TLChatlistsChatlistInviteAlready()
					TLChatlistsChatlistInvite.CONSTRUCTOR -> TLChatlistsChatlistInvite()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ChatlistsChatlistInvite")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLChatlistsChatlistInviteAlready: ChatlistsChatlistInvite() {
		@JvmField var filterId = 0
		@JvmField val missingPeers = mutableListOf<Peer>()
		@JvmField val alreadyPeers = mutableListOf<Peer>()
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			filterId = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Peer.deserialize(stream, stream.readInt32(exception), exception) ?: return
				missingPeers.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Peer.deserialize(stream, stream.readInt32(exception), exception) ?: return
				alreadyPeers.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(filterId)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(missingPeers.size)
			missingPeers.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(alreadyPeers.size)
			alreadyPeers.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xfa87f659u.toInt()
		}
	}
	
	open class TLChatlistsChatlistInvite: ChatlistsChatlistInvite() {
		@JvmField var flags = 0
		@JvmField var title: String? = null
		@JvmField var emoticon: String? = null
		@JvmField val peers = mutableListOf<Peer>()
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			title = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				emoticon = stream.readString(exception) ?: return
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Peer.deserialize(stream, stream.readInt32(exception), exception) ?: return
				peers.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (emoticon != null) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeString(title)
			if ((flags and 1) != 0) {
				stream.writeString(emoticon)
			}
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(peers.size)
			peers.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x1dcd839du.toInt()
		}
	}
	
	open class TLChatlistsCheckChatlistInvite: TLObject() {
		@JvmField var slug: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ChatlistsChatlistInvite? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return ChatlistsChatlistInvite.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(slug)
		}
	
		companion object {
			val CONSTRUCTOR = 0x41c10fffu.toInt()
		}
	}
	
	open class TLChatlistsChatlistUpdates: TLObject() {
		@JvmField val missingPeers = mutableListOf<Peer>()
		@JvmField val chats = mutableListOf<Chat>()
		@JvmField val users = mutableListOf<User>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Peer.deserialize(stream, stream.readInt32(exception), exception) ?: return
				missingPeers.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Chat.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chats.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(missingPeers.size)
			missingPeers.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chats.size)
			chats.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x93bd878du.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChatlistsChatlistUpdates? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLChatlistsChatlistUpdates")
					}
					else {
						null
					}
				}
	
				val result = TLChatlistsChatlistUpdates()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLBizDataRaw: TLObject() {
		@JvmField var data: ByteArray? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			data = stream.readByteArray(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteArray(data)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6db3ac79u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLBizDataRaw? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLBizDataRaw")
					}
					else {
						null
					}
				}
	
				val result = TLBizDataRaw()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLBizInvokeBizDataRaw: TLObject() {
		@JvmField var bizData: TLBizDataRaw? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLBizDataRaw? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLBizDataRaw.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			bizData?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5a191146u.toInt()
		}
	}
	
	open class TLExportedChatlistInvite: TLObject() {
		@JvmField var flags = 0
		@JvmField var title: String? = null
		@JvmField var url: String? = null
		@JvmField val peers = mutableListOf<Peer>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			title = stream.readString(exception) ?: return
			url = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Peer.deserialize(stream, stream.readInt32(exception), exception) ?: return
				peers.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(flags)
			stream.writeString(title)
			stream.writeString(url)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(peers.size)
			peers.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xc5181acu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLExportedChatlistInvite? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLExportedChatlistInvite")
					}
					else {
						null
					}
				}
	
				val result = TLExportedChatlistInvite()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLChatlistsEditExportedInvite: TLObject() {
		@JvmField var flags = 0
		@JvmField var chatlist: TLInputChatlist? = null
		@JvmField var slug: String? = null
		@JvmField var title: String? = null
		@JvmField val peers = mutableListOf<InputPeer>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLExportedChatlistInvite? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLExportedChatlistInvite.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (title != null) flags or 2 else flags and 2.inv()
			flags = if (peers.isNotEmpty()) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			chatlist?.serializeToStream(stream)
			stream.writeString(slug)
			if ((flags and 2) != 0) {
				stream.writeString(title)
			}
	
			if ((flags and 4) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(peers.size)
			peers.forEach { it.serializeToStream(stream) }
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x653db63du.toInt()
		}
	}
	
	open class TLPredefinedUser: TLObject() {
		@JvmField var flags = 0
		@JvmField var phone: String? = null
		@JvmField var firstName: String? = null
		@JvmField var lastName: String? = null
		@JvmField var username: String? = null
		@JvmField var code: String? = null
		@JvmField var verified = false
		@JvmField var regiestedUserId = 0L
		@JvmField var lastSeenAt = 0
		@JvmField var banned = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			phone = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				firstName = stream.readString(exception) ?: return
			}
		
			if ((flags and 2) != 0) {
				lastName = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				username = stream.readString(exception) ?: return
			}
			code = stream.readString(exception) ?: return
			verified = (flags and 8) != 0
		
			if ((flags and 16) != 0) {
				regiestedUserId = stream.readInt64(exception)
			}
		
			if ((flags and 32) != 0) {
				lastSeenAt = stream.readInt32(exception)
			}
			banned = (flags and 64) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (firstName != null) flags or 1 else flags and 1.inv()
			flags = if (lastName != null) flags or 2 else flags and 2.inv()
			flags = if (username != null) flags or 4 else flags and 4.inv()
			flags = if (verified) flags or 8 else flags and 8.inv()
			flags = if (regiestedUserId != 0L) flags or 16 else flags and 16.inv()
			flags = if (lastSeenAt != 0) flags or 32 else flags and 32.inv()
			flags = if (banned) flags or 64 else flags and 64.inv()
	
			stream.writeInt32(flags)
			stream.writeString(phone)
			if ((flags and 1) != 0) {
				stream.writeString(firstName)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(lastName)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(username)
			}
	
			stream.writeString(code)
			if ((flags and 16) != 0) {
				stream.writeInt64(regiestedUserId)
			}
	
			if ((flags and 32) != 0) {
				stream.writeInt32(lastSeenAt)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x16d5ecc3u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPredefinedUser? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPredefinedUser")
					}
					else {
						null
					}
				}
	
				val result = TLPredefinedUser()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPredefinedusersCreatePredefinedUser: TLObject() {
		@JvmField var flags = 0
		@JvmField var phone: String? = null
		@JvmField var firstName: String? = null
		@JvmField var lastName: String? = null
		@JvmField var username: String? = null
		@JvmField var birthday = 0L
		@JvmField var gender = 0
		@JvmField var code: String? = null
		@JvmField var verified = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPredefinedUser? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPredefinedUser.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (firstName != null) flags or 1 else flags and 1.inv()
			flags = if (lastName != null) flags or 2 else flags and 2.inv()
			flags = if (username != null) flags or 4 else flags and 4.inv()
			flags = if (verified) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			stream.writeString(phone)
			if ((flags and 1) != 0) {
				stream.writeString(firstName)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(lastName)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(username)
			}
	
			stream.writeInt64(birthday)
			stream.writeInt32(gender)
			stream.writeString(code)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa87ba12au.toInt()
		}
	}
	
	open class TLPredefinedusersUpdatePredefinedUsername: TLObject() {
		@JvmField var phone: String? = null
		@JvmField var username: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPredefinedUser? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPredefinedUser.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phone)
			stream.writeString(username)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa8e111aeu.toInt()
		}
	}
	
	open class TLPredefinedusersUpdatePredefinedProfile: TLObject() {
		@JvmField var flags = 0
		@JvmField var phone: String? = null
		@JvmField var firstName: String? = null
		@JvmField var lastName: String? = null
		@JvmField var about: String? = null
		@JvmField var birthday = 0L
		@JvmField var gender = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPredefinedUser? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPredefinedUser.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (firstName != null) flags or 1 else flags and 1.inv()
			flags = if (lastName != null) flags or 2 else flags and 2.inv()
			flags = if (about != null) flags or 4 else flags and 4.inv()
			flags = if (birthday != 0L) flags or 8 else flags and 8.inv()
			flags = if (gender != 0) flags or 16 else flags and 16.inv()
	
			stream.writeInt32(flags)
			stream.writeString(phone)
			if ((flags and 1) != 0) {
				stream.writeString(firstName)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(lastName)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(about)
			}
	
			if ((flags and 8) != 0) {
				stream.writeInt64(birthday)
			}
	
			if ((flags and 16) != 0) {
				stream.writeInt32(gender)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x4059ab32u.toInt()
		}
	}
	
	open class TLPredefinedusersUpdatePredefinedVerified: TLObject() {
		@JvmField var flags = 0
		@JvmField var phone: String? = null
		@JvmField var verified = false
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPredefinedUser? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPredefinedUser.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (verified) flags or 1 else flags and 1.inv()
	
			stream.writeInt32(flags)
			stream.writeString(phone)
		}
	
		companion object {
			val CONSTRUCTOR = 0xed07d511u.toInt()
		}
	}
	
	open class TLPredefinedusersUpdatePredefinedCode: TLObject() {
		@JvmField var phone: String? = null
		@JvmField var code: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPredefinedUser? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPredefinedUser.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phone)
			stream.writeString(code)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3704e83fu.toInt()
		}
	}
	
	open class TLPredefinedusersGetPredefinedUser: TLObject() {
		@JvmField var phone: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPredefinedUser? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPredefinedUser.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phone)
		}
	
		companion object {
			val CONSTRUCTOR = 0x96435542u.toInt()
		}
	}
	
	open class TLAuthToggleBan: TLObject() {
		@JvmField var flags = 0
		@JvmField var phone: String? = null
		@JvmField var predefined = false
		@JvmField var expires = 0
		@JvmField var reason: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPredefinedUser? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPredefinedUser.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (predefined) flags or 1 else flags and 1.inv()
			flags = if (expires != 0) flags or 2 else flags and 2.inv()
			flags = if (reason != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeString(phone)
			if ((flags and 2) != 0) {
				stream.writeInt32(expires)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(reason)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x6163a390u.toInt()
		}
	}
	
	open class TLPredefinedAdministrator: TLObject() {
		@JvmField var flags = 0
		@JvmField var phone: String? = null
		@JvmField var email: String? = null
		@JvmField var firstName: String? = null
		@JvmField var lastName: String? = null
		@JvmField var code: String? = null
		@JvmField var regiestedUserId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			phone = stream.readString(exception) ?: return
			email = stream.readString(exception) ?: return
		
			if ((flags and 1) != 0) {
				firstName = stream.readString(exception) ?: return
			}
		
			if ((flags and 2) != 0) {
				lastName = stream.readString(exception) ?: return
			}
			code = stream.readString(exception) ?: return
		
			if ((flags and 4) != 0) {
				regiestedUserId = stream.readInt64(exception)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (firstName != null) flags or 1 else flags and 1.inv()
			flags = if (lastName != null) flags or 2 else flags and 2.inv()
			flags = if (regiestedUserId != 0L) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeString(phone)
			stream.writeString(email)
			if ((flags and 1) != 0) {
				stream.writeString(firstName)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(lastName)
			}
	
			stream.writeString(code)
			if ((flags and 4) != 0) {
				stream.writeInt64(regiestedUserId)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x3594a5c1u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPredefinedAdministrator? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPredefinedAdministrator")
					}
					else {
						null
					}
				}
	
				val result = TLPredefinedAdministrator()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPredefinedadminsCreatePredefinedAdministrator: TLObject() {
		@JvmField var flags = 0
		@JvmField var phone: String? = null
		@JvmField var email: String? = null
		@JvmField var firstName: String? = null
		@JvmField var lastName: String? = null
		@JvmField var code: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPredefinedAdministrator? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPredefinedAdministrator.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (firstName != null) flags or 1 else flags and 1.inv()
			flags = if (lastName != null) flags or 2 else flags and 2.inv()
	
			stream.writeInt32(flags)
			stream.writeString(phone)
			stream.writeString(email)
			if ((flags and 1) != 0) {
				stream.writeString(firstName)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(lastName)
			}
	
			stream.writeString(code)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb6a3d3beu.toInt()
		}
	}
	
	open class TLPredefinedadminsUpdatePredefinedEmail: TLObject() {
		@JvmField var phone: String? = null
		@JvmField var email: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPredefinedAdministrator? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPredefinedAdministrator.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phone)
			stream.writeString(email)
		}
	
		companion object {
			val CONSTRUCTOR = 0x53431e08u.toInt()
		}
	}
	
	open class TLPredefinedadminsUpdatePredefinedPhone: TLObject() {
		@JvmField var email: String? = null
		@JvmField var phone: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPredefinedAdministrator? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPredefinedAdministrator.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(email)
			stream.writeString(phone)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6a7af5a9u.toInt()
		}
	}
	
	open class TLPredefinedadminsUpdatePredefinedProfile: TLObject() {
		@JvmField var flags = 0
		@JvmField var phone: String? = null
		@JvmField var firstName: String? = null
		@JvmField var lastName: String? = null
		@JvmField var about: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPredefinedAdministrator? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPredefinedAdministrator.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (firstName != null) flags or 1 else flags and 1.inv()
			flags = if (lastName != null) flags or 2 else flags and 2.inv()
			flags = if (about != null) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeString(phone)
			if ((flags and 1) != 0) {
				stream.writeString(firstName)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(lastName)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(about)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xed205db3u.toInt()
		}
	}
	
	open class TLPredefinedadminsUpdatePredefinedCode: TLObject() {
		@JvmField var phone: String? = null
		@JvmField var code: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPredefinedAdministrator? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPredefinedAdministrator.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phone)
			stream.writeString(code)
		}
	
		companion object {
			val CONSTRUCTOR = 0x649a2349u.toInt()
		}
	}
	
	open class TLPredefinedadminsGetPredefinedAdministrator: TLObject() {
		@JvmField var phone: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPredefinedAdministrator? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLPredefinedAdministrator.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(phone)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbb35c30cu.toInt()
		}
	}
	
	abstract class AuthKeyInfo: TLObject() {
		@JvmField var authKeyId = 0L
		@JvmField var authKey: ByteArray? = null
		@JvmField var permAuthKeyId = 0L
		@JvmField var authKeyType = 0
		@JvmField var mediaTempAuthKeyId = 0L
		@JvmField var tempAuthKeyId = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): AuthKeyInfo? {
				val result = when (constructor) {
					TLAuthKeyInfo.CONSTRUCTOR -> TLAuthKeyInfo()
					TLAuthKeyInfoLayer3.CONSTRUCTOR -> TLAuthKeyInfoLayer3()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in AuthKeyInfo")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLAuthKeyInfo: AuthKeyInfo() {
							
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			authKeyId = stream.readInt64(exception)
			authKey = stream.readByteArray(exception) ?: return
			authKeyType = stream.readInt32(exception)
			permAuthKeyId = stream.readInt64(exception)
			tempAuthKeyId = stream.readInt64(exception)
			mediaTempAuthKeyId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(authKeyId)
			stream.writeByteArray(authKey)
			stream.writeInt32(authKeyType)
			stream.writeInt64(permAuthKeyId)
			stream.writeInt64(tempAuthKeyId)
			stream.writeInt64(mediaTempAuthKeyId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcceeefc0u.toInt()
		}
	}
	
	open class TLAuthKeyInfoLayer3: AuthKeyInfo() {
							
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			authKeyId = stream.readInt64(exception)
			authKey = stream.readByteArray(exception) ?: return
			authKeyType = stream.readInt32(exception)
			permAuthKeyId = stream.readInt64(exception)
			tempAuthKeyId = stream.readInt64(exception)
			mediaTempAuthKeyId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(authKeyId)
			stream.writeByteArray(authKey)
			stream.writeInt32(authKeyType)
			stream.writeInt64(permAuthKeyId)
			stream.writeInt64(tempAuthKeyId)
			stream.writeInt64(mediaTempAuthKeyId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd780e32au.toInt()
		}
	}
	
	abstract class ContactData: TLObject() {
		@JvmField var userId = 0L
		@JvmField var lastName: String? = null
		@JvmField var flags = 0
		@JvmField var contactUserId = 0L
		@JvmField var phone: String? = null
		@JvmField var firstName: String? = null
		@JvmField var mutualContact = false
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ContactData? {
				val result = when (constructor) {
					TLContactData.CONSTRUCTOR -> TLContactData()
					TLContactDataLayer3.CONSTRUCTOR -> TLContactDataLayer3()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ContactData")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLContactData: ContactData() {
								
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			userId = stream.readInt64(exception)
			contactUserId = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {
				firstName = stream.readString(exception) ?: return
			}
		
			if ((flags and 2) != 0) {
				lastName = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				phone = stream.readString(exception) ?: return
			}
			mutualContact = (flags and 8) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (firstName != null) flags or 1 else flags and 1.inv()
			flags = if (lastName != null) flags or 2 else flags and 2.inv()
			flags = if (phone != null) flags or 4 else flags and 4.inv()
			flags = if (mutualContact) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(userId)
			stream.writeInt64(contactUserId)
			if ((flags and 1) != 0) {
				stream.writeString(firstName)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(lastName)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(phone)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xdbf339dau.toInt()
		}
	}
	
	open class TLContactDataLayer3: ContactData() {
								
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			userId = stream.readInt64(exception)
			contactUserId = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {
				firstName = stream.readString(exception) ?: return
			}
		
			if ((flags and 2) != 0) {
				lastName = stream.readString(exception) ?: return
			}
		
			if ((flags and 4) != 0) {
				phone = stream.readString(exception) ?: return
			}
			mutualContact = (flags and 8) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (firstName != null) flags or 1 else flags and 1.inv()
			flags = if (lastName != null) flags or 2 else flags and 2.inv()
			flags = if (phone != null) flags or 4 else flags and 4.inv()
			flags = if (mutualContact) flags or 8 else flags and 8.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(userId)
			stream.writeInt64(contactUserId)
			if ((flags and 1) != 0) {
				stream.writeString(firstName)
			}
	
			if ((flags and 2) != 0) {
				stream.writeString(lastName)
			}
	
			if ((flags and 4) != 0) {
				stream.writeString(phone)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x4df3e844u.toInt()
		}
	}
	
	abstract class UserData: TLObject() {
		@JvmField var lastName: String? = null
		@JvmField var deleted = false
		@JvmField var birthday = 0L
		@JvmField var firstName: String? = null
		@JvmField var username: String? = null
		@JvmField var monthOfBirth = 0
		@JvmField var contactsVersion = 0
		@JvmField var yearOfBirth = 0
		@JvmField var phone: String? = null
		@JvmField var restricted = false
		@JvmField var about: String? = null
		@JvmField var scam = false
		@JvmField var sceretKeyId = 0L
		@JvmField var support = false
		@JvmField var countryCode: String? = null
		@JvmField var verified = false
		@JvmField var privaciesVersion = 0
		@JvmField var id = 0L
		@JvmField var userType = 0
		@JvmField var gender = 0
		@JvmField var bot: TLBotData? = null
		@JvmField val restrictionReason = mutableListOf<TLRestrictionReason>()
		@JvmField var flags = 0
		@JvmField var dayOfBirth = 0
		@JvmField var profilePhoto: Photo? = null
		@JvmField var fake = false
		@JvmField var accessHash = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): UserData? {
				val result = when (constructor) {
					TLUserData.CONSTRUCTOR -> TLUserData()
					TLUserDataLayer3.CONSTRUCTOR -> TLUserDataLayer3()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in UserData")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLUserData: UserData() {
																												
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			userType = stream.readInt32(exception)
			sceretKeyId = stream.readInt64(exception)
			firstName = stream.readString(exception) ?: return
			lastName = stream.readString(exception) ?: return
			username = stream.readString(exception) ?: return
			phone = stream.readString(exception) ?: return
		
			if ((flags and 1024) != 0) {
				birthday = stream.readInt64(exception)
			}
			yearOfBirth = stream.readInt32(exception)
			monthOfBirth = stream.readInt32(exception)
			dayOfBirth = stream.readInt32(exception)
		
			if ((flags and 2048) != 0) {
				gender = stream.readInt32(exception)
			}
		
			if ((flags and 1) != 0) {
				profilePhoto = Photo.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 256) != 0) {
				bot = TLBotData.deserialize(stream, stream.readInt32(exception), exception)
			}
			countryCode = stream.readString(exception) ?: return
			verified = (flags and 2) != 0
			support = (flags and 4) != 0
			scam = (flags and 8) != 0
			fake = (flags and 16) != 0
		
			if ((flags and 32) != 0) {
				about = stream.readString(exception) ?: return
			}
			restricted = (flags and 128) != 0
		
			if ((flags and 128) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLRestrictionReason.deserialize(stream, stream.readInt32(exception), exception) ?: return
					restrictionReason.add(obj)
				}
			}
			contactsVersion = stream.readInt32(exception)
			privaciesVersion = stream.readInt32(exception)
			deleted = (flags and 512) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (birthday != 0L) flags or 1024 else flags and 1024.inv()
			flags = if (gender != 0) flags or 2048 else flags and 2048.inv()
			flags = if (profilePhoto != null) flags or 1 else flags and 1.inv()
			flags = if (bot != null) flags or 256 else flags and 256.inv()
			flags = if (verified) flags or 2 else flags and 2.inv()
			flags = if (support) flags or 4 else flags and 4.inv()
			flags = if (scam) flags or 8 else flags and 8.inv()
			flags = if (fake) flags or 16 else flags and 16.inv()
			flags = if (about != null) flags or 32 else flags and 32.inv()
			flags = if (restricted) flags or 128 else flags and 128.inv()
			flags = if (deleted) flags or 512 else flags and 512.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeInt32(userType)
			stream.writeInt64(sceretKeyId)
			stream.writeString(firstName)
			stream.writeString(lastName)
			stream.writeString(username)
			stream.writeString(phone)
			if ((flags and 1024) != 0) {
				stream.writeInt64(birthday)
			}
	
			stream.writeInt32(yearOfBirth)
			stream.writeInt32(monthOfBirth)
			stream.writeInt32(dayOfBirth)
			if ((flags and 2048) != 0) {
				stream.writeInt32(gender)
			}
	
			if ((flags and 1) != 0) {
				profilePhoto?.serializeToStream(stream)
			}
	
			if ((flags and 256) != 0) {
				bot?.serializeToStream(stream)
			}
	
			stream.writeString(countryCode)
			if ((flags and 32) != 0) {
				stream.writeString(about)
			}
	
			if ((flags and 128) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(restrictionReason.size)
			restrictionReason.forEach { it.serializeToStream(stream) }
			}
	
			stream.writeInt32(contactsVersion)
			stream.writeInt32(privaciesVersion)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe1a7dc49u.toInt()
		}
	}
	
	open class TLUserDataLayer3: UserData() {
																												
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			id = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
			userType = stream.readInt32(exception)
			sceretKeyId = stream.readInt64(exception)
			firstName = stream.readString(exception) ?: return
			lastName = stream.readString(exception) ?: return
			username = stream.readString(exception) ?: return
			phone = stream.readString(exception) ?: return
		
			if ((flags and 1024) != 0) {
				birthday = stream.readInt64(exception)
			}
			yearOfBirth = stream.readInt32(exception)
			monthOfBirth = stream.readInt32(exception)
			dayOfBirth = stream.readInt32(exception)
		
			if ((flags and 2048) != 0) {
				gender = stream.readInt32(exception)
			}
		
			if ((flags and 1) != 0) {
				profilePhoto = Photo.deserialize(stream, stream.readInt32(exception), exception)
			}
		
			if ((flags and 256) != 0) {
				bot = TLBotData.deserialize(stream, stream.readInt32(exception), exception)
			}
			countryCode = stream.readString(exception) ?: return
			verified = (flags and 2) != 0
			support = (flags and 4) != 0
			scam = (flags and 8) != 0
			fake = (flags and 16) != 0
		
			if ((flags and 32) != 0) {
				about = stream.readString(exception) ?: return
			}
			restricted = (flags and 128) != 0
		
			if ((flags and 128) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = TLRestrictionReason.deserialize(stream, stream.readInt32(exception), exception) ?: return
					restrictionReason.add(obj)
				}
			}
			contactsVersion = stream.readInt32(exception)
			privaciesVersion = stream.readInt32(exception)
			deleted = (flags and 512) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (birthday != 0L) flags or 1024 else flags and 1024.inv()
			flags = if (gender != 0) flags or 2048 else flags and 2048.inv()
			flags = if (profilePhoto != null) flags or 1 else flags and 1.inv()
			flags = if (bot != null) flags or 256 else flags and 256.inv()
			flags = if (verified) flags or 2 else flags and 2.inv()
			flags = if (support) flags or 4 else flags and 4.inv()
			flags = if (scam) flags or 8 else flags and 8.inv()
			flags = if (fake) flags or 16 else flags and 16.inv()
			flags = if (about != null) flags or 32 else flags and 32.inv()
			flags = if (restricted) flags or 128 else flags and 128.inv()
			flags = if (deleted) flags or 512 else flags and 512.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeInt64(accessHash)
			stream.writeInt32(userType)
			stream.writeInt64(sceretKeyId)
			stream.writeString(firstName)
			stream.writeString(lastName)
			stream.writeString(username)
			stream.writeString(phone)
			if ((flags and 1024) != 0) {
				stream.writeInt64(birthday)
			}
	
			stream.writeInt32(yearOfBirth)
			stream.writeInt32(monthOfBirth)
			stream.writeInt32(dayOfBirth)
			if ((flags and 2048) != 0) {
				stream.writeInt32(gender)
			}
	
			if ((flags and 1) != 0) {
				profilePhoto?.serializeToStream(stream)
			}
	
			if ((flags and 256) != 0) {
				bot?.serializeToStream(stream)
			}
	
			stream.writeString(countryCode)
			if ((flags and 32) != 0) {
				stream.writeString(about)
			}
	
			if ((flags and 128) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(restrictionReason.size)
			restrictionReason.forEach { it.serializeToStream(stream) }
			}
	
			stream.writeInt32(contactsVersion)
			stream.writeInt32(privaciesVersion)
		}
	
		companion object {
			val CONSTRUCTOR = 0x0a202077u.toInt()
		}
	}
	
	abstract class PrivacyKeyRules: TLObject() {
		@JvmField var key = 0
		@JvmField val rules = mutableListOf<PrivacyRule>()
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PrivacyKeyRules? {
				val result = when (constructor) {
					TLPrivacyKeyRules.CONSTRUCTOR -> TLPrivacyKeyRules()
					TLPrivacyKeyRulesLayer3.CONSTRUCTOR -> TLPrivacyKeyRulesLayer3()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in PrivacyKeyRules")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPrivacyKeyRules: PrivacyKeyRules() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			key = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = PrivacyRule.deserialize(stream, stream.readInt32(exception), exception) ?: return
				rules.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(key)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(rules.size)
			rules.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x9412add6u.toInt()
		}
	}
	
	open class TLPrivacyKeyRulesLayer3: PrivacyKeyRules() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			key = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = PrivacyRule.deserialize(stream, stream.readInt32(exception), exception) ?: return
				rules.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(key)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(rules.size)
			rules.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xe1b1f134u.toInt()
		}
	}
	
	open class TLMutableUsers: TLObject() {
		@JvmField val users = mutableListOf<TLImmutableUser>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLImmutableUser.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xb2f3e7b1u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMutableUsers? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMutableUsers")
					}
					else {
						null
					}
				}
	
				val result = TLMutableUsers()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class FileLocation: TLObject() {
		@JvmField var localId = 0
		@JvmField var volumeId = 0L
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): FileLocation? {
				val result = when (constructor) {
					TLFileLocationUnavailable.CONSTRUCTOR -> TLFileLocationUnavailable()
					TLFileLocation.CONSTRUCTOR -> TLFileLocation()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in FileLocation")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLFileLocationUnavailable: FileLocation() {
				@JvmField var secret = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			volumeId = stream.readInt64(exception)
			localId = stream.readInt32(exception)
			secret = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(volumeId)
			stream.writeInt32(localId)
			stream.writeInt64(secret)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7c596b46u.toInt()
		}
	}
	
	open class TLFileLocation: FileLocation() {
			
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			volumeId = stream.readInt64(exception)
			localId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(volumeId)
			stream.writeInt32(localId)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbc7fc6cdu.toInt()
		}
	}
	
	open class TLPredefinedusersGetPredefinedUsers: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				TLPredefinedUser.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb81715fau.toInt()
		}
	}
	
	open class TLPredefinedadminsGetPredefinedAdministrators: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				TLPredefinedAdministrator.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x125fe1e1u.toInt()
		}
	}
	
	open class TLAccountGetAllSecureValues: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				TLSecureValue.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xb288bc7du.toInt()
		}
	}
	
	open class TLAccountGetSecureValue: TLObject() {
		@JvmField val types = mutableListOf<SecureValueType>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				TLSecureValue.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(types.size)
			types.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x73665bc2u.toInt()
		}
	}
	
	open class TLAccountGetMultiWallPapers: TLObject() {
		@JvmField val wallpapers = mutableListOf<InputWallPaper>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				WallPaper.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(wallpapers.size)
			wallpapers.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x65ad71dcu.toInt()
		}
	}
	
	open class TLUsersGetUsers: TLObject() {
		@JvmField val id = mutableListOf<InputUser>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				User.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xd91a548u.toInt()
		}
	}
	
	open class TLContactsGetContactIDs: TLObject() {
		@JvmField var hash = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				vector.objects.add(stream.readInt32(exception))
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(hash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7adc669du.toInt()
		}
	}
	
	open class TLPhoneCheckGroupCall: TLObject() {
		@JvmField var call: TLInputGroupCall? = null
		@JvmField val sources = mutableListOf<Int>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				vector.objects.add(stream.readInt32(exception))
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			call?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(sources.size)
			sources.forEach { stream.writeInt32(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xb59cf977u.toInt()
		}
	}
	
	open class TLContactsGetStatuses: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				TLContactStatus.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc4a353eeu.toInt()
		}
	}
	
	open class TLContactsGetSaved: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				TLSavedContact.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x82f1e39fu.toInt()
		}
	}
	
	open class TLMessagesReceivedMessages: TLObject() {
		@JvmField var maxId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				TLReceivedNotifyMessage.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(maxId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5a954c0u.toInt()
		}
	}
	
	open class TLMessagesReceivedQueue: TLObject() {
		@JvmField var maxQts = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				vector.objects.add(stream.readInt64(exception))
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(maxQts)
		}
	
		companion object {
			val CONSTRUCTOR = 0x55a5bb66u.toInt()
		}
	}
	
	open class TLMessagesGetMessageReadParticipants: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField var msgId = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				vector.objects.add(stream.readInt64(exception))
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(msgId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x2c6f97b7u.toInt()
		}
	}
	
	open class TLPhotosDeletePhotos: TLObject() {
		@JvmField val id = mutableListOf<InputPhoto>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				vector.objects.add(stream.readInt64(exception))
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(id.size)
			id.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x87cf7f2fu.toInt()
		}
	}
	
	open class TLMessagesGetAttachedStickers: TLObject() {
		@JvmField var media: InputStickeredMedia? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				StickerSetCovered.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			media?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcc5b67ccu.toInt()
		}
	}
	
	open class TLMessagesGetSplitRanges: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				TLMessageRange.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x1cff7e08u.toInt()
		}
	}
	
	open class TLMessagesGetDialogUnreadMarks: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				DialogPeer.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x22e24e22u.toInt()
		}
	}
	
	open class TLMessagesGetEmojiKeywordsLanguages: TLObject() {
		@JvmField val langCodes = mutableListOf<String>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				TLEmojiLanguage.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(langCodes.size)
			langCodes.forEach { stream.writeString(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x4e9963b2u.toInt()
		}
	}
	
	open class TLMessagesGetSearchCounters: TLObject() {
		@JvmField var peer: InputPeer? = null
		@JvmField val filters = mutableListOf<MessagesFilter>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				TLMessagesSearchCounter.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			peer?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(filters.size)
			filters.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x732eef00u.toInt()
		}
	}
	
	open class TLMessagesGetDialogFilters: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				DialogFilter.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf19ed96du.toInt()
		}
	}
	
	open class TLMessagesGetSuggestedDialogFilters: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				TLDialogFilterSuggested.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xa29cd42cu.toInt()
		}
	}
	
	open class TLMessagesGetCustomEmojiDocuments: TLObject() {
		@JvmField val documentId = mutableListOf<Long>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				Document.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(documentId.size)
			documentId.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xd9ab0f54u.toInt()
		}
	}
	
	open class TLUploadReuploadCdnFile: TLObject() {
		@JvmField var fileToken: ByteArray? = null
		@JvmField var requestToken: ByteArray? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				TLFileHash.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteArray(fileToken)
			stream.writeByteArray(requestToken)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9b2754a8u.toInt()
		}
	}
	
	open class TLUploadGetCdnFileHashes: TLObject() {
		@JvmField var fileToken: ByteArray? = null
		@JvmField var offset = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				TLFileHash.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeByteArray(fileToken)
			stream.writeInt64(offset)
		}
	
		companion object {
			val CONSTRUCTOR = 0x91dc3f31u.toInt()
		}
	}
	
	open class TLUploadGetFileHashes: TLObject() {
		@JvmField var location: InputFileLocation? = null
		@JvmField var offset = 0L
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				TLFileHash.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			location?.serializeToStream(stream)
			stream.writeInt64(offset)
		}
	
		companion object {
			val CONSTRUCTOR = 0x9156982au.toInt()
		}
	}
	
	open class TLBotsGetBotCommands: TLObject() {
		@JvmField var scope: BotCommandScope? = null
		@JvmField var langCode: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				TLBotCommand.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			scope?.serializeToStream(stream)
			stream.writeString(langCode)
		}
	
		companion object {
			val CONSTRUCTOR = 0xe34c0dd6u.toInt()
		}
	}
	
	open class TLLangpackGetStrings: TLObject() {
		@JvmField var langPack: String? = null
		@JvmField var langCode: String? = null
		@JvmField val keys = mutableListOf<String>()
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				LangPackString.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(langPack)
			stream.writeString(langCode)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(keys.size)
			keys.forEach { stream.writeString(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xefea3803u.toInt()
		}
	}
	
	open class TLLangpackGetLanguages: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				TLLangPackLanguage.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x800fd57du.toInt()
		}
	}
	
	open class TLLangpackGetLanguagesLayer3: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				TLLangPackLanguage.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x2eb46a24u.toInt()
		}
	}
	
	open class TLChatlistsGetLeaveChatlistSuggestions: TLObject() {
		@JvmField var chatlist: TLInputChatlist? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): Vector? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			val vector = Vector()
			val size = stream.readInt32(exception)
	
			for (i in 0 until size) {
				Peer.deserialize(stream, stream.readInt32(exception), exception)?.let {
					vector.objects.add(it)
				}
			}
	
			return vector
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			chatlist?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0xfdbcd714u.toInt()
		}
	}
	
	open class TLMessagesForwardReplyToTop: TLObject() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xc117c499u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessagesForwardReplyToTop? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessagesForwardReplyToTop")
					}
					else {
						null
					}
				}
	
				val result = TLMessagesForwardReplyToTop()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLPeerUtil: TLObject() {
		@JvmField var selfId = 0L
		@JvmField var peerType = 0
		@JvmField var peerId = 0L
		@JvmField var accessHash = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			selfId = stream.readInt64(exception)
			peerType = stream.readInt32(exception)
			peerId = stream.readInt64(exception)
			accessHash = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(selfId)
			stream.writeInt32(peerType)
			stream.writeInt64(peerId)
			stream.writeInt64(accessHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0xc596bee5u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLPeerUtil? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLPeerUtil")
					}
					else {
						null
					}
				}
	
				val result = TLPeerUtil()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMessageBox: TLObject() {
		@JvmField var flags = 0
		@JvmField var userId = 0L
		@JvmField var messageId = 0
		@JvmField var senderUserId = 0L
		@JvmField var peerType = 0
		@JvmField var peerId = 0L
		@JvmField var randomId = 0L
		@JvmField var dialogId1 = 0L
		@JvmField var dialogId2 = 0L
		@JvmField var dialogMessageId = 0L
		@JvmField var messageFilterType = 0
		@JvmField var message: Message? = null
		@JvmField var mentioned = false
		@JvmField var mediaUnread = false
		@JvmField var pinned = false
		@JvmField var pts = 0
		@JvmField var ptsCount = 0
		@JvmField var views = 0
		@JvmField var replyOwnerId = 0L
		@JvmField var forwards = 0
		@JvmField var reaction: String? = null
		@JvmField var commentGroupId = 0L
		@JvmField var replyChannelId = 0L
		@JvmField var replyChannelMessageId = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			userId = stream.readInt64(exception)
			messageId = stream.readInt32(exception)
			senderUserId = stream.readInt64(exception)
			peerType = stream.readInt32(exception)
			peerId = stream.readInt64(exception)
			randomId = stream.readInt64(exception)
			dialogId1 = stream.readInt64(exception)
			dialogId2 = stream.readInt64(exception)
			dialogMessageId = stream.readInt64(exception)
			messageFilterType = stream.readInt32(exception)
			message = Message.deserialize(stream, stream.readInt32(exception), exception)
			mentioned = (flags and 1) != 0
			mediaUnread = (flags and 2) != 0
			pinned = (flags and 4) != 0
			pts = stream.readInt32(exception)
			ptsCount = stream.readInt32(exception)
			views = stream.readInt32(exception)
			replyOwnerId = stream.readInt64(exception)
			forwards = stream.readInt32(exception)
			reaction = stream.readString(exception) ?: return
			commentGroupId = stream.readInt64(exception)
			replyChannelId = stream.readInt64(exception)
			replyChannelMessageId = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (mentioned) flags or 1 else flags and 1.inv()
			flags = if (mediaUnread) flags or 2 else flags and 2.inv()
			flags = if (pinned) flags or 4 else flags and 4.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(userId)
			stream.writeInt32(messageId)
			stream.writeInt64(senderUserId)
			stream.writeInt32(peerType)
			stream.writeInt64(peerId)
			stream.writeInt64(randomId)
			stream.writeInt64(dialogId1)
			stream.writeInt64(dialogId2)
			stream.writeInt64(dialogMessageId)
			stream.writeInt32(messageFilterType)
			message?.serializeToStream(stream)
			stream.writeInt32(pts)
			stream.writeInt32(ptsCount)
			stream.writeInt32(views)
			stream.writeInt64(replyOwnerId)
			stream.writeInt32(forwards)
			stream.writeString(reaction)
			stream.writeInt64(commentGroupId)
			stream.writeInt64(replyChannelId)
			stream.writeInt32(replyChannelMessageId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x5e999b7du.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMessageBox? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMessageBox")
					}
					else {
						null
					}
				}
	
				val result = TLMessageBox()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLUpdateList: TLObject() {
		@JvmField val updates = mutableListOf<Update>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = Update.deserialize(stream, stream.readInt32(exception), exception) ?: return
				updates.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(updates.size)
			updates.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xff6a143bu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLUpdateList? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLUpdateList")
					}
					else {
						null
					}
				}
	
				val result = TLUpdateList()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMData: TLObject() {
		@JvmField var serverId: String? = null
		@JvmField var clientAddr: String? = null
		@JvmField var authId = 0L
		@JvmField var sessionId = 0L
		@JvmField var receiveTime = 0L
		@JvmField var userId = 0L
		@JvmField var clientMsgId = 0L
		@JvmField var isBot = false
		@JvmField var layer = 0
		@JvmField var client: String? = null
		@JvmField var isAdmin = false
		@JvmField var langpack: String? = null
		@JvmField var permAuthKeyId = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			serverId = stream.readString(exception) ?: return
			clientAddr = stream.readString(exception) ?: return
			authId = stream.readInt64(exception)
			sessionId = stream.readInt64(exception)
			receiveTime = stream.readInt64(exception)
			userId = stream.readInt64(exception)
			clientMsgId = stream.readInt64(exception)
			isBot = stream.readBool(exception)
			layer = stream.readInt32(exception)
			client = stream.readString(exception) ?: return
			isAdmin = stream.readBool(exception)
			langpack = stream.readString(exception) ?: return
			permAuthKeyId = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(serverId)
			stream.writeString(clientAddr)
			stream.writeInt64(authId)
			stream.writeInt64(sessionId)
			stream.writeInt64(receiveTime)
			stream.writeInt64(userId)
			stream.writeInt64(clientMsgId)
			stream.writeBool(isBot)
			stream.writeInt32(layer)
			stream.writeString(client)
			stream.writeBool(isAdmin)
			stream.writeString(langpack)
			stream.writeInt64(permAuthKeyId)
		}
	
		companion object {
			val CONSTRUCTOR = 0x8cd0bc31u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMData? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMData")
					}
					else {
						null
					}
				}
	
				val result = TLMData()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLChannelAdminRights: TLObject() {
		@JvmField var flags = 0
		@JvmField var changeInfo = false
		@JvmField var postMessages = false
		@JvmField var editMessages = false
		@JvmField var deleteMessages = false
		@JvmField var banUsers = false
		@JvmField var inviteUsers = false
		@JvmField var inviteLink = false
		@JvmField var pinMessages = false
		@JvmField var addAdmins = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			changeInfo = (flags and 1) != 0
			postMessages = (flags and 2) != 0
			editMessages = (flags and 4) != 0
			deleteMessages = (flags and 8) != 0
			banUsers = (flags and 16) != 0
			inviteUsers = (flags and 32) != 0
			inviteLink = (flags and 64) != 0
			pinMessages = (flags and 128) != 0
			addAdmins = (flags and 512) != 0
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (changeInfo) flags or 1 else flags and 1.inv()
			flags = if (postMessages) flags or 2 else flags and 2.inv()
			flags = if (editMessages) flags or 4 else flags and 4.inv()
			flags = if (deleteMessages) flags or 8 else flags and 8.inv()
			flags = if (banUsers) flags or 16 else flags and 16.inv()
			flags = if (inviteUsers) flags or 32 else flags and 32.inv()
			flags = if (inviteLink) flags or 64 else flags and 64.inv()
			flags = if (pinMessages) flags or 128 else flags and 128.inv()
			flags = if (addAdmins) flags or 512 else flags and 512.inv()
	
			stream.writeInt32(flags)
		}
	
		companion object {
			val CONSTRUCTOR = 0xaafde8bbu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChannelAdminRights? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLChannelAdminRights")
					}
					else {
						null
					}
				}
	
				val result = TLChannelAdminRights()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLChannelBannedRights: TLObject() {
		@JvmField var flags = 0
		@JvmField var viewMessages = false
		@JvmField var sendMessages = false
		@JvmField var sendMedia = false
		@JvmField var sendStickers = false
		@JvmField var sendGifs = false
		@JvmField var sendGames = false
		@JvmField var sendInline = false
		@JvmField var embedLinks = false
		@JvmField var untilDate = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			viewMessages = (flags and 1) != 0
			sendMessages = (flags and 2) != 0
			sendMedia = (flags and 4) != 0
			sendStickers = (flags and 8) != 0
			sendGifs = (flags and 16) != 0
			sendGames = (flags and 32) != 0
			sendInline = (flags and 64) != 0
			embedLinks = (flags and 128) != 0
			untilDate = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (viewMessages) flags or 1 else flags and 1.inv()
			flags = if (sendMessages) flags or 2 else flags and 2.inv()
			flags = if (sendMedia) flags or 4 else flags and 4.inv()
			flags = if (sendStickers) flags or 8 else flags and 8.inv()
			flags = if (sendGifs) flags or 16 else flags and 16.inv()
			flags = if (sendGames) flags or 32 else flags and 32.inv()
			flags = if (sendInline) flags or 64 else flags and 64.inv()
			flags = if (embedLinks) flags or 128 else flags and 128.inv()
	
			stream.writeInt32(flags)
			stream.writeInt32(untilDate)
		}
	
		companion object {
			val CONSTRUCTOR = 0x1ab3bda7u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLChannelBannedRights? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLChannelBannedRights")
					}
					else {
						null
					}
				}
	
				val result = TLChannelBannedRights()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLBotData: TLObject() {
		@JvmField var flags = 0
		@JvmField var id = 0L
		@JvmField var botType = 0
		@JvmField var creator = 0L
		@JvmField var token: String? = null
		@JvmField var description: String? = null
		@JvmField var botChatHistory = false
		@JvmField var botNochats = false
		@JvmField var botInlineGeo = false
		@JvmField var botInfoVersion = 0
		@JvmField var botInlinePlaceholder: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			id = stream.readInt64(exception)
			botType = stream.readInt32(exception)
			creator = stream.readInt64(exception)
			token = stream.readString(exception) ?: return
			description = stream.readString(exception) ?: return
			botChatHistory = (flags and 2) != 0
			botNochats = (flags and 4) != 0
			botInlineGeo = (flags and 8) != 0
			botInfoVersion = stream.readInt32(exception)
		
			if ((flags and 16) != 0) {
				botInlinePlaceholder = stream.readString(exception) ?: return
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
			flags = if (botChatHistory) flags or 2 else flags and 2.inv()
			flags = if (botNochats) flags or 4 else flags and 4.inv()
			flags = if (botInlineGeo) flags or 8 else flags and 8.inv()
			flags = if (botInlinePlaceholder != null) flags or 16 else flags and 16.inv()
	
			stream.writeInt32(flags)
			stream.writeInt64(id)
			stream.writeInt32(botType)
			stream.writeInt64(creator)
			stream.writeString(token)
			stream.writeString(description)
			stream.writeInt32(botInfoVersion)
			if ((flags and 16) != 0) {
				stream.writeString(botInlinePlaceholder)
			}
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xcef4def7u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLBotData? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLBotData")
					}
					else {
						null
					}
				}
	
				val result = TLBotData()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLImmutableUser: TLObject() {
		@JvmField var flags = 0
		@JvmField var user: UserData? = null
		@JvmField var lastSeenAt = 0L
		@JvmField val contacts = mutableListOf<ContactData>()
		@JvmField val keysPrivacyRules = mutableListOf<PrivacyKeyRules>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			flags = stream.readInt32(exception)
			user = UserData.deserialize(stream, stream.readInt32(exception), exception)
			lastSeenAt = stream.readInt64(exception)
		
			if ((flags and 1) != 0) {	
				stream.readInt32(exception).let { magic ->
					if (magic != Vector.CONSTRUCTOR) {
						if (exception) {
							throw RuntimeException("wrong Vector magic, got $magic")
						}
		
						return
					}
				}
		
				for (i in 0 until stream.readInt32(exception)) {
					val obj = ContactData.deserialize(stream, stream.readInt32(exception), exception) ?: return
					contacts.add(obj)
				}
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = PrivacyKeyRules.deserialize(stream, stream.readInt32(exception), exception) ?: return
				keysPrivacyRules.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(flags)
			user?.serializeToStream(stream)
			stream.writeInt64(lastSeenAt)
			if ((flags and 1) != 0) {
				stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(contacts.size)
			contacts.forEach { it.serializeToStream(stream) }
			}
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(keysPrivacyRules.size)
			keysPrivacyRules.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xaf2aeafau.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLImmutableUser? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLImmutableUser")
					}
					else {
						null
					}
				}
	
				val result = TLImmutableUser()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLUserImportedContacts: TLObject() {
		@JvmField val imported = mutableListOf<TLImportedContact>()
		@JvmField val popularInvites = mutableListOf<TLPopularContact>()
		@JvmField val retryContacts = mutableListOf<Long>()
		@JvmField val users = mutableListOf<User>()
		@JvmField val updateIdList = mutableListOf<Long>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLImportedContact.deserialize(stream, stream.readInt32(exception), exception) ?: return
				imported.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLPopularContact.deserialize(stream, stream.readInt32(exception), exception) ?: return
				popularInvites.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				retryContacts.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = User.deserialize(stream, stream.readInt32(exception), exception) ?: return
				users.add(obj)
			}
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				updateIdList.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(imported.size)
			imported.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(popularInvites.size)
			popularInvites.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(retryContacts.size)
			retryContacts.forEach { stream.writeInt64(it) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(users.size)
			users.forEach { it.serializeToStream(stream) }
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(updateIdList.size)
			updateIdList.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x91e1d1c4u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLUserImportedContacts? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLUserImportedContacts")
					}
					else {
						null
					}
				}
	
				val result = TLUserImportedContacts()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLLastSeenData: TLObject() {
		@JvmField var userId = 0L
		@JvmField var lastSeenAt = 0L
		@JvmField var expries = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
			lastSeenAt = stream.readInt64(exception)
			expries = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeInt64(lastSeenAt)
			stream.writeInt32(expries)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf7806eb1u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLLastSeenData? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLLastSeenData")
					}
					else {
						null
					}
				}
	
				val result = TLLastSeenData()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLUserChatIdList: TLObject() {
		@JvmField var userId = 0L
		@JvmField val chatIdList = mutableListOf<Long>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			userId = stream.readInt64(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				chatIdList.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(userId)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chatIdList.size)
			chatIdList.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x6f3a2ad3u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLUserChatIdList? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLUserChatIdList")
					}
					else {
						null
					}
				}
	
				val result = TLUserChatIdList()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLImmutableChatParticipant: TLObject() {
		@JvmField var id = 0L
		@JvmField var chatId = 0L
		@JvmField var userId = 0L
		@JvmField var state = 0
		@JvmField var participantType = 0
		@JvmField var link: String? = null
		@JvmField var useage = 0
		@JvmField var inviterUserId = 0L
		@JvmField var invitedAt = 0L
		@JvmField var kickedAt = 0L
		@JvmField var leftAt = 0L
		@JvmField var adminRights: TLChatAdminRights? = null
		@JvmField var date = 0L
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			chatId = stream.readInt64(exception)
			userId = stream.readInt64(exception)
			state = stream.readInt32(exception)
			participantType = stream.readInt32(exception)
			link = stream.readString(exception) ?: return
			useage = stream.readInt32(exception)
			inviterUserId = stream.readInt64(exception)
			invitedAt = stream.readInt64(exception)
			kickedAt = stream.readInt64(exception)
			leftAt = stream.readInt64(exception)
			adminRights = TLChatAdminRights.deserialize(stream, stream.readInt32(exception), exception)
			date = stream.readInt64(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(chatId)
			stream.writeInt64(userId)
			stream.writeInt32(state)
			stream.writeInt32(participantType)
			stream.writeString(link)
			stream.writeInt32(useage)
			stream.writeInt64(inviterUserId)
			stream.writeInt64(invitedAt)
			stream.writeInt64(kickedAt)
			stream.writeInt64(leftAt)
			adminRights?.serializeToStream(stream)
			stream.writeInt64(date)
		}
	
		companion object {
			val CONSTRUCTOR = 0xcc25db43u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLImmutableChatParticipant? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLImmutableChatParticipant")
					}
					else {
						null
					}
				}
	
				val result = TLImmutableChatParticipant()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLImmutableChat: TLObject() {
		@JvmField var id = 0L
		@JvmField var creator = 0L
		@JvmField var title: String? = null
		@JvmField var photo: Photo? = null
		@JvmField var deactivated = false
		@JvmField var callActive = false
		@JvmField var callNotEmpty = false
		@JvmField var noforwards = false
		@JvmField var participantsCount = 0
		@JvmField var date = 0L
		@JvmField var version = 0
		@JvmField var migratedTo: InputChannel? = null
		@JvmField var defaultBannedRights: TLChatBannedRights? = null
		@JvmField var canSetUsername = false
		@JvmField var about: String? = null
		@JvmField var exportedInvite: ExportedChatInvite? = null
		@JvmField val botInfo = mutableListOf<TLBotInfo>()
		@JvmField var call: TLInputGroupCall? = null
		@JvmField var availableReactionsType = 0
		@JvmField val availableReactions = mutableListOf<String>()
		@JvmField var ttlPeriod = 0
		@JvmField var username: String? = null
		@JvmField var showHistory = false
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			id = stream.readInt64(exception)
			creator = stream.readInt64(exception)
			title = stream.readString(exception) ?: return
			photo = Photo.deserialize(stream, stream.readInt32(exception), exception)
			deactivated = stream.readBool(exception)
			callActive = stream.readBool(exception)
			callNotEmpty = stream.readBool(exception)
			noforwards = stream.readBool(exception)
			participantsCount = stream.readInt32(exception)
			date = stream.readInt64(exception)
			version = stream.readInt32(exception)
			migratedTo = InputChannel.deserialize(stream, stream.readInt32(exception), exception)
			defaultBannedRights = TLChatBannedRights.deserialize(stream, stream.readInt32(exception), exception)
			canSetUsername = stream.readBool(exception)
			about = stream.readString(exception) ?: return
			exportedInvite = ExportedChatInvite.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLBotInfo.deserialize(stream, stream.readInt32(exception), exception) ?: return
				botInfo.add(obj)
			}
			call = TLInputGroupCall.deserialize(stream, stream.readInt32(exception), exception)
			availableReactionsType = stream.readInt32(exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readString(exception) ?: return
				availableReactions.add(obj)
			}
			ttlPeriod = stream.readInt32(exception)
			username = stream.readString(exception) ?: return
			showHistory = stream.readBool(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(id)
			stream.writeInt64(creator)
			stream.writeString(title)
			photo?.serializeToStream(stream)
			stream.writeBool(deactivated)
			stream.writeBool(callActive)
			stream.writeBool(callNotEmpty)
			stream.writeBool(noforwards)
			stream.writeInt32(participantsCount)
			stream.writeInt64(date)
			stream.writeInt32(version)
			migratedTo?.serializeToStream(stream)
			defaultBannedRights?.serializeToStream(stream)
			stream.writeBool(canSetUsername)
			stream.writeString(about)
			exportedInvite?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(botInfo.size)
			botInfo.forEach { it.serializeToStream(stream) }
			call?.serializeToStream(stream)
			stream.writeInt32(availableReactionsType)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(availableReactions.size)
			availableReactions.forEach { stream.writeString(it) }
			stream.writeInt32(ttlPeriod)
			stream.writeString(username)
			stream.writeBool(showHistory)
		}
	
		companion object {
			val CONSTRUCTOR = 0xad386e06u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLImmutableChat? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLImmutableChat")
					}
					else {
						null
					}
				}
	
				val result = TLImmutableChat()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMutableChat: TLObject() {
		@JvmField var chat: TLImmutableChat? = null
		@JvmField val chatParticipants = mutableListOf<TLImmutableChatParticipant>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			chat = TLImmutableChat.deserialize(stream, stream.readInt32(exception), exception)
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = TLImmutableChatParticipant.deserialize(stream, stream.readInt32(exception), exception) ?: return
				chatParticipants.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			chat?.serializeToStream(stream)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(chatParticipants.size)
			chatParticipants.forEach { it.serializeToStream(stream) }
		}
	
		companion object {
			val CONSTRUCTOR = 0xc2f7c74bu.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMutableChat? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMutableChat")
					}
					else {
						null
					}
				}
	
				val result = TLMutableChat()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLMigratedChatChannel: TLObject() {
		@JvmField var chat: TLMutableChat? = null
		@JvmField var channel: TLMutableChat? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			chat = TLMutableChat.deserialize(stream, stream.readInt32(exception), exception)
			channel = TLMutableChat.deserialize(stream, stream.readInt32(exception), exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			chat?.serializeToStream(stream)
			channel?.serializeToStream(stream)
		}
	
		companion object {
			val CONSTRUCTOR = 0x7bf7d8dau.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLMigratedChatChannel? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLMigratedChatChannel")
					}
					else {
						null
					}
				}
	
				val result = TLMigratedChatChannel()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLResPQ: TLObject() {
		@JvmField var nonce = 0
		@JvmField var serverNonce = 0
		@JvmField var pq: String? = null
		@JvmField val serverPublicKeyFingerprints = mutableListOf<Long>()
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			nonce = stream.readInt32(exception)
			serverNonce = stream.readInt32(exception)
			pq = stream.readString(exception) ?: return
	
			stream.readInt32(exception).let { magic ->
				if (magic != Vector.CONSTRUCTOR) {
					if (exception) {
						throw RuntimeException("wrong Vector magic, got $magic")
					}
	
					return
				}
			}
	
			for (i in 0 until stream.readInt32(exception)) {
				val obj = stream.readInt64(exception)
				serverPublicKeyFingerprints.add(obj)
			}
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(nonce)
			stream.writeInt32(serverNonce)
			stream.writeString(pq)
			stream.writeInt32(Vector.CONSTRUCTOR)
			stream.writeInt32(serverPublicKeyFingerprints.size)
			serverPublicKeyFingerprints.forEach { stream.writeInt64(it) }
		}
	
		companion object {
			val CONSTRUCTOR = 0x05162463u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLResPQ? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLResPQ")
					}
					else {
						null
					}
				}
	
				val result = TLResPQ()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLReqPq: TLObject() {
		@JvmField var nonce = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLResPQ? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLResPQ.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(nonce)
		}
	
		companion object {
			val CONSTRUCTOR = 0x60469778u.toInt()
		}
	}
	
	open class TLReqPqMulti: TLObject() {
		@JvmField var nonce = 0
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLResPQ? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return TLResPQ.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(nonce)
		}
	
		companion object {
			val CONSTRUCTOR = 0xbe7e8ef1u.toInt()
		}
	}
	
	abstract class PQInnerData: TLObject() {
		@JvmField var q: String? = null
		@JvmField var newNonce = 0
		@JvmField var serverNonce = 0
		@JvmField var p: String? = null
		@JvmField var pq: String? = null
		@JvmField var dc = 0
		@JvmField var expiresIn = 0
		@JvmField var nonce = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): PQInnerData? {
				val result = when (constructor) {
					TLPQInnerData.CONSTRUCTOR -> TLPQInnerData()
					TLPQInnerDataDc.CONSTRUCTOR -> TLPQInnerDataDc()
					TLPQInnerDataTemp.CONSTRUCTOR -> TLPQInnerDataTemp()
					TLPQInnerDataTempDc.CONSTRUCTOR -> TLPQInnerDataTempDc()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in PQInnerData")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLPQInnerData: PQInnerData() {
							
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			pq = stream.readString(exception) ?: return
			p = stream.readString(exception) ?: return
			q = stream.readString(exception) ?: return
			nonce = stream.readInt32(exception)
			serverNonce = stream.readInt32(exception)
			newNonce = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(pq)
			stream.writeString(p)
			stream.writeString(q)
			stream.writeInt32(nonce)
			stream.writeInt32(serverNonce)
			stream.writeInt32(newNonce)
		}
	
		companion object {
			val CONSTRUCTOR = 0x83c95aecu.toInt()
		}
	}
	
	open class TLPQInnerDataDc: PQInnerData() {
								
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			pq = stream.readString(exception) ?: return
			p = stream.readString(exception) ?: return
			q = stream.readString(exception) ?: return
			nonce = stream.readInt32(exception)
			serverNonce = stream.readInt32(exception)
			newNonce = stream.readInt32(exception)
			dc = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(pq)
			stream.writeString(p)
			stream.writeString(q)
			stream.writeInt32(nonce)
			stream.writeInt32(serverNonce)
			stream.writeInt32(newNonce)
			stream.writeInt32(dc)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa9f55f95u.toInt()
		}
	}
	
	open class TLPQInnerDataTemp: PQInnerData() {
								
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			pq = stream.readString(exception) ?: return
			p = stream.readString(exception) ?: return
			q = stream.readString(exception) ?: return
			nonce = stream.readInt32(exception)
			serverNonce = stream.readInt32(exception)
			newNonce = stream.readInt32(exception)
			expiresIn = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(pq)
			stream.writeString(p)
			stream.writeString(q)
			stream.writeInt32(nonce)
			stream.writeInt32(serverNonce)
			stream.writeInt32(newNonce)
			stream.writeInt32(expiresIn)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3c6a84d4u.toInt()
		}
	}
	
	open class TLPQInnerDataTempDc: PQInnerData() {
									
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			pq = stream.readString(exception) ?: return
			p = stream.readString(exception) ?: return
			q = stream.readString(exception) ?: return
			nonce = stream.readInt32(exception)
			serverNonce = stream.readInt32(exception)
			newNonce = stream.readInt32(exception)
			dc = stream.readInt32(exception)
			expiresIn = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeString(pq)
			stream.writeString(p)
			stream.writeString(q)
			stream.writeInt32(nonce)
			stream.writeInt32(serverNonce)
			stream.writeInt32(newNonce)
			stream.writeInt32(dc)
			stream.writeInt32(expiresIn)
		}
	
		companion object {
			val CONSTRUCTOR = 0x56fddf88u.toInt()
		}
	}
	
	open class TLBindAuthKeyInner: TLObject() {
		@JvmField var nonce = 0L
		@JvmField var tempAuthKeyId = 0L
		@JvmField var permAuthKeyId = 0L
		@JvmField var tempSessionId = 0L
		@JvmField var expiresAt = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			nonce = stream.readInt64(exception)
			tempAuthKeyId = stream.readInt64(exception)
			permAuthKeyId = stream.readInt64(exception)
			tempSessionId = stream.readInt64(exception)
			expiresAt = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt64(nonce)
			stream.writeInt64(tempAuthKeyId)
			stream.writeInt64(permAuthKeyId)
			stream.writeInt64(tempSessionId)
			stream.writeInt32(expiresAt)
		}
	
		companion object {
			val CONSTRUCTOR = 0x75a3f765u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLBindAuthKeyInner? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLBindAuthKeyInner")
					}
					else {
						null
					}
				}
	
				val result = TLBindAuthKeyInner()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class ServerDHParams: TLObject() {
		@JvmField var nonce = 0
		@JvmField var serverNonce = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ServerDHParams? {
				val result = when (constructor) {
					TLServerDHParamsFail.CONSTRUCTOR -> TLServerDHParamsFail()
					TLServerDHParamsOk.CONSTRUCTOR -> TLServerDHParamsOk()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in ServerDHParams")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLServerDHParamsFail: ServerDHParams() {
				@JvmField var newNonceHash = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			nonce = stream.readInt32(exception)
			serverNonce = stream.readInt32(exception)
			newNonceHash = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(nonce)
			stream.writeInt32(serverNonce)
			stream.writeInt32(newNonceHash)
		}
	
		companion object {
			val CONSTRUCTOR = 0x79cb045du.toInt()
		}
	}
	
	open class TLServerDHParamsOk: ServerDHParams() {
				@JvmField var encryptedAnswer: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			nonce = stream.readInt32(exception)
			serverNonce = stream.readInt32(exception)
			encryptedAnswer = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(nonce)
			stream.writeInt32(serverNonce)
			stream.writeString(encryptedAnswer)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd0e8075cu.toInt()
		}
	}
	
	open class TLReqDHParams: TLObject() {
		@JvmField var nonce = 0
		@JvmField var serverNonce = 0
		@JvmField var p: String? = null
		@JvmField var q: String? = null
		@JvmField var publicKeyFingerprint = 0L
		@JvmField var encryptedData: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): ServerDHParams? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return ServerDHParams.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(nonce)
			stream.writeInt32(serverNonce)
			stream.writeString(p)
			stream.writeString(q)
			stream.writeInt64(publicKeyFingerprint)
			stream.writeString(encryptedData)
		}
	
		companion object {
			val CONSTRUCTOR = 0xd712e4beu.toInt()
		}
	}
	
	open class TLServerDHInnerData: TLObject() {
		@JvmField var nonce = 0
		@JvmField var serverNonce = 0
		@JvmField var g = 0
		@JvmField var dhPrime: String? = null
		@JvmField var gA: String? = null
		@JvmField var serverTime = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			nonce = stream.readInt32(exception)
			serverNonce = stream.readInt32(exception)
			g = stream.readInt32(exception)
			dhPrime = stream.readString(exception) ?: return
			gA = stream.readString(exception) ?: return
			serverTime = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(nonce)
			stream.writeInt32(serverNonce)
			stream.writeInt32(g)
			stream.writeString(dhPrime)
			stream.writeString(gA)
			stream.writeInt32(serverTime)
		}
	
		companion object {
			val CONSTRUCTOR = 0xb5890dbau.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLServerDHInnerData? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLServerDHInnerData")
					}
					else {
						null
					}
				}
	
				val result = TLServerDHInnerData()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	open class TLClientDHInnerData: TLObject() {
		@JvmField var nonce = 0
		@JvmField var serverNonce = 0
		@JvmField var retryId = 0L
		@JvmField var gB: String? = null
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			nonce = stream.readInt32(exception)
			serverNonce = stream.readInt32(exception)
			retryId = stream.readInt64(exception)
			gB = stream.readString(exception) ?: return
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(nonce)
			stream.writeInt32(serverNonce)
			stream.writeInt64(retryId)
			stream.writeString(gB)
		}
	
		companion object {
			val CONSTRUCTOR = 0x6643b654u.toInt()
	
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): TLClientDHInnerData? {
				if (CONSTRUCTOR != constructor) {
					return if (exception) {
						throw RuntimeException("can't parse magic $constructor in TLClientDHInnerData")
					}
					else {
						null
					}
				}
	
				val result = TLClientDHInnerData()
				result.readParams(stream, exception)
				return result
			}
	
		}
	}
	
	abstract class SetClientDHParamsAnswer: TLObject() {
		@JvmField var nonce = 0
		@JvmField var serverNonce = 0
	
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): SetClientDHParamsAnswer? {
				val result = when (constructor) {
					TLDhGenOk.CONSTRUCTOR -> TLDhGenOk()
					TLDhGenRetry.CONSTRUCTOR -> TLDhGenRetry()
					TLDhGenFail.CONSTRUCTOR -> TLDhGenFail()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in SetClientDHParamsAnswer")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLDhGenOk: SetClientDHParamsAnswer() {
				@JvmField var newNonceHash1 = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			nonce = stream.readInt32(exception)
			serverNonce = stream.readInt32(exception)
			newNonceHash1 = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(nonce)
			stream.writeInt32(serverNonce)
			stream.writeInt32(newNonceHash1)
		}
	
		companion object {
			val CONSTRUCTOR = 0x3bcbf734u.toInt()
		}
	}
	
	open class TLDhGenRetry: SetClientDHParamsAnswer() {
				@JvmField var newNonceHash2 = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			nonce = stream.readInt32(exception)
			serverNonce = stream.readInt32(exception)
			newNonceHash2 = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(nonce)
			stream.writeInt32(serverNonce)
			stream.writeInt32(newNonceHash2)
		}
	
		companion object {
			val CONSTRUCTOR = 0x46dc1fb9u.toInt()
		}
	}
	
	open class TLDhGenFail: SetClientDHParamsAnswer() {
				@JvmField var newNonceHash3 = 0
	
		override fun readParams(stream: AbstractSerializedData?, exception: Boolean) {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return
			}
	
			nonce = stream.readInt32(exception)
			serverNonce = stream.readInt32(exception)
			newNonceHash3 = stream.readInt32(exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(nonce)
			stream.writeInt32(serverNonce)
			stream.writeInt32(newNonceHash3)
		}
	
		companion object {
			val CONSTRUCTOR = 0xa69dae02u.toInt()
		}
	}
	
	open class TLSetClientDHParams: TLObject() {
		@JvmField var nonce = 0
		@JvmField var serverNonce = 0
		@JvmField var encryptedData: String? = null
	
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): SetClientDHParamsAnswer? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return SetClientDHParamsAnswer.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
			stream.writeInt32(nonce)
			stream.writeInt32(serverNonce)
			stream.writeString(encryptedData)
		}
	
		companion object {
			val CONSTRUCTOR = 0xf5045f1fu.toInt()
		}
	}
	
	abstract class DestroyAuthKeyRes: TLObject() {
		companion object {
			@JvmStatic
			fun deserialize(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): DestroyAuthKeyRes? {
				val result = when (constructor) {
					TLDestroyAuthKeyOk.CONSTRUCTOR -> TLDestroyAuthKeyOk()
					TLDestroyAuthKeyNone.CONSTRUCTOR -> TLDestroyAuthKeyNone()
					TLDestroyAuthKeyFail.CONSTRUCTOR -> TLDestroyAuthKeyFail()
					else -> null
				}
	
				if (result == null && exception) {
					throw RuntimeException("can't parse magic $constructor in DestroyAuthKeyRes")
				}
	
				result?.readParams(stream, exception)
				result?.postDeserialize()
	
				return result
			}
		}
	}
	
	open class TLDestroyAuthKeyOk: DestroyAuthKeyRes() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xf660e1d4u.toInt()
		}
	}
	
	open class TLDestroyAuthKeyNone: DestroyAuthKeyRes() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0x0a9f2259u.toInt()
		}
	}
	
	open class TLDestroyAuthKeyFail: DestroyAuthKeyRes() {
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xea109b13u.toInt()
		}
	}
	
	open class TLDestroyAuthKey: TLObject() {
		override fun deserializeResponse(stream: AbstractSerializedData?, constructor: Int, exception: Boolean): DestroyAuthKeyRes? {
			if (stream == null) {
				if (exception) {
					throw RuntimeException("Input stream is null")
				}
				else {
					FileLog.e("Input stream is null")
				}
	
				return null
			}
			return DestroyAuthKeyRes.deserialize(stream, constructor, exception)
		}
	
		override fun serializeToStream(stream: AbstractSerializedData?) {
			if (stream == null) {
				throw RuntimeException("Input stream is null")
			}
	
			stream.writeInt32(CONSTRUCTOR)
	
	
		}
	
		companion object {
			val CONSTRUCTOR = 0xd1435160u.toInt()
		}
	}
	
}
